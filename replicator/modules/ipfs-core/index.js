var __defProp = Object.defineProperty;
var __markAsModule = (target) => __defProp(target, "__esModule", {value: true});
var __commonJS = (callback, module2) => () => {
  if (!module2) {
    module2 = {exports: {}};
    callback(module2.exports, module2);
  }
  return module2.exports;
};
var __export = (target, all) => {
  __markAsModule(target);
  for (var name in all)
    __defProp(target, name, {get: all[name], enumerable: true});
};

// node_modules/base64-js/index.js
var require_base64_js = __commonJS((exports2) => {
  "use strict";
  exports2.byteLength = byteLength;
  exports2.toByteArray = toByteArray;
  exports2.fromByteArray = fromByteArray;
  var lookup = [];
  var revLookup = [];
  var Arr = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
  var code = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
  for (var i = 0, len = code.length; i < len; ++i) {
    lookup[i] = code[i];
    revLookup[code.charCodeAt(i)] = i;
  }
  revLookup["-".charCodeAt(0)] = 62;
  revLookup["_".charCodeAt(0)] = 63;
  function getLens(b64) {
    var len2 = b64.length;
    if (len2 % 4 > 0) {
      throw new Error("Invalid string. Length must be a multiple of 4");
    }
    var validLen = b64.indexOf("=");
    if (validLen === -1)
      validLen = len2;
    var placeHoldersLen = validLen === len2 ? 0 : 4 - validLen % 4;
    return [validLen, placeHoldersLen];
  }
  function byteLength(b64) {
    var lens = getLens(b64);
    var validLen = lens[0];
    var placeHoldersLen = lens[1];
    return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
  }
  function _byteLength(b64, validLen, placeHoldersLen) {
    return (validLen + placeHoldersLen) * 3 / 4 - placeHoldersLen;
  }
  function toByteArray(b64) {
    var tmp;
    var lens = getLens(b64);
    var validLen = lens[0];
    var placeHoldersLen = lens[1];
    var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen));
    var curByte = 0;
    var len2 = placeHoldersLen > 0 ? validLen - 4 : validLen;
    var i2;
    for (i2 = 0; i2 < len2; i2 += 4) {
      tmp = revLookup[b64.charCodeAt(i2)] << 18 | revLookup[b64.charCodeAt(i2 + 1)] << 12 | revLookup[b64.charCodeAt(i2 + 2)] << 6 | revLookup[b64.charCodeAt(i2 + 3)];
      arr[curByte++] = tmp >> 16 & 255;
      arr[curByte++] = tmp >> 8 & 255;
      arr[curByte++] = tmp & 255;
    }
    if (placeHoldersLen === 2) {
      tmp = revLookup[b64.charCodeAt(i2)] << 2 | revLookup[b64.charCodeAt(i2 + 1)] >> 4;
      arr[curByte++] = tmp & 255;
    }
    if (placeHoldersLen === 1) {
      tmp = revLookup[b64.charCodeAt(i2)] << 10 | revLookup[b64.charCodeAt(i2 + 1)] << 4 | revLookup[b64.charCodeAt(i2 + 2)] >> 2;
      arr[curByte++] = tmp >> 8 & 255;
      arr[curByte++] = tmp & 255;
    }
    return arr;
  }
  function tripletToBase64(num) {
    return lookup[num >> 18 & 63] + lookup[num >> 12 & 63] + lookup[num >> 6 & 63] + lookup[num & 63];
  }
  function encodeChunk(uint8, start, end) {
    var tmp;
    var output = [];
    for (var i2 = start; i2 < end; i2 += 3) {
      tmp = (uint8[i2] << 16 & 16711680) + (uint8[i2 + 1] << 8 & 65280) + (uint8[i2 + 2] & 255);
      output.push(tripletToBase64(tmp));
    }
    return output.join("");
  }
  function fromByteArray(uint8) {
    var tmp;
    var len2 = uint8.length;
    var extraBytes = len2 % 3;
    var parts = [];
    var maxChunkLength = 16383;
    for (var i2 = 0, len22 = len2 - extraBytes; i2 < len22; i2 += maxChunkLength) {
      parts.push(encodeChunk(uint8, i2, i2 + maxChunkLength > len22 ? len22 : i2 + maxChunkLength));
    }
    if (extraBytes === 1) {
      tmp = uint8[len2 - 1];
      parts.push(lookup[tmp >> 2] + lookup[tmp << 4 & 63] + "==");
    } else if (extraBytes === 2) {
      tmp = (uint8[len2 - 2] << 8) + uint8[len2 - 1];
      parts.push(lookup[tmp >> 10] + lookup[tmp >> 4 & 63] + lookup[tmp << 2 & 63] + "=");
    }
    return parts.join("");
  }
});

// node_modules/ieee754/index.js
var require_ieee754 = __commonJS((exports2) => {
  /*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
  exports2.read = function(buffer, offset, isLE, mLen, nBytes) {
    var e, m;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var nBits = -7;
    var i = isLE ? nBytes - 1 : 0;
    var d = isLE ? -1 : 1;
    var s = buffer[offset + i];
    i += d;
    e = s & (1 << -nBits) - 1;
    s >>= -nBits;
    nBits += eLen;
    for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {
    }
    m = e & (1 << -nBits) - 1;
    e >>= -nBits;
    nBits += mLen;
    for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {
    }
    if (e === 0) {
      e = 1 - eBias;
    } else if (e === eMax) {
      return m ? NaN : (s ? -1 : 1) * Infinity;
    } else {
      m = m + Math.pow(2, mLen);
      e = e - eBias;
    }
    return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
  };
  exports2.write = function(buffer, value, offset, isLE, mLen, nBytes) {
    var e, m, c;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
    var i = isLE ? 0 : nBytes - 1;
    var d = isLE ? 1 : -1;
    var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
    value = Math.abs(value);
    if (isNaN(value) || value === Infinity) {
      m = isNaN(value) ? 1 : 0;
      e = eMax;
    } else {
      e = Math.floor(Math.log(value) / Math.LN2);
      if (value * (c = Math.pow(2, -e)) < 1) {
        e--;
        c *= 2;
      }
      if (e + eBias >= 1) {
        value += rt / c;
      } else {
        value += rt * Math.pow(2, 1 - eBias);
      }
      if (value * c >= 2) {
        e++;
        c /= 2;
      }
      if (e + eBias >= eMax) {
        m = 0;
        e = eMax;
      } else if (e + eBias >= 1) {
        m = (value * c - 1) * Math.pow(2, mLen);
        e = e + eBias;
      } else {
        m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
        e = 0;
      }
    }
    for (; mLen >= 8; buffer[offset + i] = m & 255, i += d, m /= 256, mLen -= 8) {
    }
    e = e << mLen | m;
    eLen += mLen;
    for (; eLen > 0; buffer[offset + i] = e & 255, i += d, e /= 256, eLen -= 8) {
    }
    buffer[offset + i - d] |= s * 128;
  };
});

// node_modules/buffer/index.js
var require_buffer = __commonJS((exports2) => {
  /*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <https://feross.org>
   * @license  MIT
   */
  "use strict";
  var base64 = require_base64_js();
  var ieee754 = require_ieee754();
  var customInspectSymbol = typeof Symbol === "function" && typeof Symbol["for"] === "function" ? Symbol["for"]("nodejs.util.inspect.custom") : null;
  exports2.Buffer = Buffer2;
  exports2.SlowBuffer = SlowBuffer;
  exports2.INSPECT_MAX_BYTES = 50;
  var K_MAX_LENGTH = 2147483647;
  exports2.kMaxLength = K_MAX_LENGTH;
  Buffer2.TYPED_ARRAY_SUPPORT = typedArraySupport();
  if (!Buffer2.TYPED_ARRAY_SUPPORT && typeof console !== "undefined" && typeof console.error === "function") {
    console.error("This browser lacks typed array (Uint8Array) support which is required by `buffer` v5.x. Use `buffer` v4.x if you require old browser support.");
  }
  function typedArraySupport() {
    try {
      var arr = new Uint8Array(1);
      var proto = {foo: function() {
        return 42;
      }};
      Object.setPrototypeOf(proto, Uint8Array.prototype);
      Object.setPrototypeOf(arr, proto);
      return arr.foo() === 42;
    } catch (e) {
      return false;
    }
  }
  Object.defineProperty(Buffer2.prototype, "parent", {
    enumerable: true,
    get: function() {
      if (!Buffer2.isBuffer(this))
        return void 0;
      return this.buffer;
    }
  });
  Object.defineProperty(Buffer2.prototype, "offset", {
    enumerable: true,
    get: function() {
      if (!Buffer2.isBuffer(this))
        return void 0;
      return this.byteOffset;
    }
  });
  function createBuffer(length) {
    if (length > K_MAX_LENGTH) {
      throw new RangeError('The value "' + length + '" is invalid for option "size"');
    }
    var buf = new Uint8Array(length);
    Object.setPrototypeOf(buf, Buffer2.prototype);
    return buf;
  }
  function Buffer2(arg, encodingOrOffset, length) {
    if (typeof arg === "number") {
      if (typeof encodingOrOffset === "string") {
        throw new TypeError('The "string" argument must be of type string. Received type number');
      }
      return allocUnsafe(arg);
    }
    return from(arg, encodingOrOffset, length);
  }
  Buffer2.poolSize = 8192;
  function from(value, encodingOrOffset, length) {
    if (typeof value === "string") {
      return fromString(value, encodingOrOffset);
    }
    if (ArrayBuffer.isView(value)) {
      return fromArrayView(value);
    }
    if (value == null) {
      throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
    }
    if (isInstance(value, ArrayBuffer) || value && isInstance(value.buffer, ArrayBuffer)) {
      return fromArrayBuffer(value, encodingOrOffset, length);
    }
    if (typeof SharedArrayBuffer !== "undefined" && (isInstance(value, SharedArrayBuffer) || value && isInstance(value.buffer, SharedArrayBuffer))) {
      return fromArrayBuffer(value, encodingOrOffset, length);
    }
    if (typeof value === "number") {
      throw new TypeError('The "value" argument must not be of type number. Received type number');
    }
    var valueOf = value.valueOf && value.valueOf();
    if (valueOf != null && valueOf !== value) {
      return Buffer2.from(valueOf, encodingOrOffset, length);
    }
    var b = fromObject(value);
    if (b)
      return b;
    if (typeof Symbol !== "undefined" && Symbol.toPrimitive != null && typeof value[Symbol.toPrimitive] === "function") {
      return Buffer2.from(value[Symbol.toPrimitive]("string"), encodingOrOffset, length);
    }
    throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
  }
  Buffer2.from = function(value, encodingOrOffset, length) {
    return from(value, encodingOrOffset, length);
  };
  Object.setPrototypeOf(Buffer2.prototype, Uint8Array.prototype);
  Object.setPrototypeOf(Buffer2, Uint8Array);
  function assertSize(size) {
    if (typeof size !== "number") {
      throw new TypeError('"size" argument must be of type number');
    } else if (size < 0) {
      throw new RangeError('The value "' + size + '" is invalid for option "size"');
    }
  }
  function alloc(size, fill, encoding) {
    assertSize(size);
    if (size <= 0) {
      return createBuffer(size);
    }
    if (fill !== void 0) {
      return typeof encoding === "string" ? createBuffer(size).fill(fill, encoding) : createBuffer(size).fill(fill);
    }
    return createBuffer(size);
  }
  Buffer2.alloc = function(size, fill, encoding) {
    return alloc(size, fill, encoding);
  };
  function allocUnsafe(size) {
    assertSize(size);
    return createBuffer(size < 0 ? 0 : checked(size) | 0);
  }
  Buffer2.allocUnsafe = function(size) {
    return allocUnsafe(size);
  };
  Buffer2.allocUnsafeSlow = function(size) {
    return allocUnsafe(size);
  };
  function fromString(string, encoding) {
    if (typeof encoding !== "string" || encoding === "") {
      encoding = "utf8";
    }
    if (!Buffer2.isEncoding(encoding)) {
      throw new TypeError("Unknown encoding: " + encoding);
    }
    var length = byteLength(string, encoding) | 0;
    var buf = createBuffer(length);
    var actual = buf.write(string, encoding);
    if (actual !== length) {
      buf = buf.slice(0, actual);
    }
    return buf;
  }
  function fromArrayLike(array) {
    var length = array.length < 0 ? 0 : checked(array.length) | 0;
    var buf = createBuffer(length);
    for (var i = 0; i < length; i += 1) {
      buf[i] = array[i] & 255;
    }
    return buf;
  }
  function fromArrayView(arrayView) {
    if (isInstance(arrayView, Uint8Array)) {
      var copy = new Uint8Array(arrayView);
      return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength);
    }
    return fromArrayLike(arrayView);
  }
  function fromArrayBuffer(array, byteOffset, length) {
    if (byteOffset < 0 || array.byteLength < byteOffset) {
      throw new RangeError('"offset" is outside of buffer bounds');
    }
    if (array.byteLength < byteOffset + (length || 0)) {
      throw new RangeError('"length" is outside of buffer bounds');
    }
    var buf;
    if (byteOffset === void 0 && length === void 0) {
      buf = new Uint8Array(array);
    } else if (length === void 0) {
      buf = new Uint8Array(array, byteOffset);
    } else {
      buf = new Uint8Array(array, byteOffset, length);
    }
    Object.setPrototypeOf(buf, Buffer2.prototype);
    return buf;
  }
  function fromObject(obj) {
    if (Buffer2.isBuffer(obj)) {
      var len = checked(obj.length) | 0;
      var buf = createBuffer(len);
      if (buf.length === 0) {
        return buf;
      }
      obj.copy(buf, 0, 0, len);
      return buf;
    }
    if (obj.length !== void 0) {
      if (typeof obj.length !== "number" || numberIsNaN(obj.length)) {
        return createBuffer(0);
      }
      return fromArrayLike(obj);
    }
    if (obj.type === "Buffer" && Array.isArray(obj.data)) {
      return fromArrayLike(obj.data);
    }
  }
  function checked(length) {
    if (length >= K_MAX_LENGTH) {
      throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x" + K_MAX_LENGTH.toString(16) + " bytes");
    }
    return length | 0;
  }
  function SlowBuffer(length) {
    if (+length != length) {
      length = 0;
    }
    return Buffer2.alloc(+length);
  }
  Buffer2.isBuffer = function isBuffer(b) {
    return b != null && b._isBuffer === true && b !== Buffer2.prototype;
  };
  Buffer2.compare = function compare(a, b) {
    if (isInstance(a, Uint8Array))
      a = Buffer2.from(a, a.offset, a.byteLength);
    if (isInstance(b, Uint8Array))
      b = Buffer2.from(b, b.offset, b.byteLength);
    if (!Buffer2.isBuffer(a) || !Buffer2.isBuffer(b)) {
      throw new TypeError('The "buf1", "buf2" arguments must be one of type Buffer or Uint8Array');
    }
    if (a === b)
      return 0;
    var x = a.length;
    var y = b.length;
    for (var i = 0, len = Math.min(x, y); i < len; ++i) {
      if (a[i] !== b[i]) {
        x = a[i];
        y = b[i];
        break;
      }
    }
    if (x < y)
      return -1;
    if (y < x)
      return 1;
    return 0;
  };
  Buffer2.isEncoding = function isEncoding(encoding) {
    switch (String(encoding).toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "latin1":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
        return true;
      default:
        return false;
    }
  };
  Buffer2.concat = function concat(list, length) {
    if (!Array.isArray(list)) {
      throw new TypeError('"list" argument must be an Array of Buffers');
    }
    if (list.length === 0) {
      return Buffer2.alloc(0);
    }
    var i;
    if (length === void 0) {
      length = 0;
      for (i = 0; i < list.length; ++i) {
        length += list[i].length;
      }
    }
    var buffer = Buffer2.allocUnsafe(length);
    var pos = 0;
    for (i = 0; i < list.length; ++i) {
      var buf = list[i];
      if (isInstance(buf, Uint8Array)) {
        if (pos + buf.length > buffer.length) {
          Buffer2.from(buf).copy(buffer, pos);
        } else {
          Uint8Array.prototype.set.call(buffer, buf, pos);
        }
      } else if (!Buffer2.isBuffer(buf)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
      } else {
        buf.copy(buffer, pos);
      }
      pos += buf.length;
    }
    return buffer;
  };
  function byteLength(string, encoding) {
    if (Buffer2.isBuffer(string)) {
      return string.length;
    }
    if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {
      return string.byteLength;
    }
    if (typeof string !== "string") {
      throw new TypeError('The "string" argument must be one of type string, Buffer, or ArrayBuffer. Received type ' + typeof string);
    }
    var len = string.length;
    var mustMatch = arguments.length > 2 && arguments[2] === true;
    if (!mustMatch && len === 0)
      return 0;
    var loweredCase = false;
    for (; ; ) {
      switch (encoding) {
        case "ascii":
        case "latin1":
        case "binary":
          return len;
        case "utf8":
        case "utf-8":
          return utf8ToBytes(string).length;
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return len * 2;
        case "hex":
          return len >>> 1;
        case "base64":
          return base64ToBytes(string).length;
        default:
          if (loweredCase) {
            return mustMatch ? -1 : utf8ToBytes(string).length;
          }
          encoding = ("" + encoding).toLowerCase();
          loweredCase = true;
      }
    }
  }
  Buffer2.byteLength = byteLength;
  function slowToString(encoding, start, end) {
    var loweredCase = false;
    if (start === void 0 || start < 0) {
      start = 0;
    }
    if (start > this.length) {
      return "";
    }
    if (end === void 0 || end > this.length) {
      end = this.length;
    }
    if (end <= 0) {
      return "";
    }
    end >>>= 0;
    start >>>= 0;
    if (end <= start) {
      return "";
    }
    if (!encoding)
      encoding = "utf8";
    while (true) {
      switch (encoding) {
        case "hex":
          return hexSlice(this, start, end);
        case "utf8":
        case "utf-8":
          return utf8Slice(this, start, end);
        case "ascii":
          return asciiSlice(this, start, end);
        case "latin1":
        case "binary":
          return latin1Slice(this, start, end);
        case "base64":
          return base64Slice(this, start, end);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return utf16leSlice(this, start, end);
        default:
          if (loweredCase)
            throw new TypeError("Unknown encoding: " + encoding);
          encoding = (encoding + "").toLowerCase();
          loweredCase = true;
      }
    }
  }
  Buffer2.prototype._isBuffer = true;
  function swap(b, n, m) {
    var i = b[n];
    b[n] = b[m];
    b[m] = i;
  }
  Buffer2.prototype.swap16 = function swap16() {
    var len = this.length;
    if (len % 2 !== 0) {
      throw new RangeError("Buffer size must be a multiple of 16-bits");
    }
    for (var i = 0; i < len; i += 2) {
      swap(this, i, i + 1);
    }
    return this;
  };
  Buffer2.prototype.swap32 = function swap32() {
    var len = this.length;
    if (len % 4 !== 0) {
      throw new RangeError("Buffer size must be a multiple of 32-bits");
    }
    for (var i = 0; i < len; i += 4) {
      swap(this, i, i + 3);
      swap(this, i + 1, i + 2);
    }
    return this;
  };
  Buffer2.prototype.swap64 = function swap64() {
    var len = this.length;
    if (len % 8 !== 0) {
      throw new RangeError("Buffer size must be a multiple of 64-bits");
    }
    for (var i = 0; i < len; i += 8) {
      swap(this, i, i + 7);
      swap(this, i + 1, i + 6);
      swap(this, i + 2, i + 5);
      swap(this, i + 3, i + 4);
    }
    return this;
  };
  Buffer2.prototype.toString = function toString() {
    var length = this.length;
    if (length === 0)
      return "";
    if (arguments.length === 0)
      return utf8Slice(this, 0, length);
    return slowToString.apply(this, arguments);
  };
  Buffer2.prototype.toLocaleString = Buffer2.prototype.toString;
  Buffer2.prototype.equals = function equals(b) {
    if (!Buffer2.isBuffer(b))
      throw new TypeError("Argument must be a Buffer");
    if (this === b)
      return true;
    return Buffer2.compare(this, b) === 0;
  };
  Buffer2.prototype.inspect = function inspect() {
    var str = "";
    var max = exports2.INSPECT_MAX_BYTES;
    str = this.toString("hex", 0, max).replace(/(.{2})/g, "$1 ").trim();
    if (this.length > max)
      str += " ... ";
    return "<Buffer " + str + ">";
  };
  if (customInspectSymbol) {
    Buffer2.prototype[customInspectSymbol] = Buffer2.prototype.inspect;
  }
  Buffer2.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
    if (isInstance(target, Uint8Array)) {
      target = Buffer2.from(target, target.offset, target.byteLength);
    }
    if (!Buffer2.isBuffer(target)) {
      throw new TypeError('The "target" argument must be one of type Buffer or Uint8Array. Received type ' + typeof target);
    }
    if (start === void 0) {
      start = 0;
    }
    if (end === void 0) {
      end = target ? target.length : 0;
    }
    if (thisStart === void 0) {
      thisStart = 0;
    }
    if (thisEnd === void 0) {
      thisEnd = this.length;
    }
    if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
      throw new RangeError("out of range index");
    }
    if (thisStart >= thisEnd && start >= end) {
      return 0;
    }
    if (thisStart >= thisEnd) {
      return -1;
    }
    if (start >= end) {
      return 1;
    }
    start >>>= 0;
    end >>>= 0;
    thisStart >>>= 0;
    thisEnd >>>= 0;
    if (this === target)
      return 0;
    var x = thisEnd - thisStart;
    var y = end - start;
    var len = Math.min(x, y);
    var thisCopy = this.slice(thisStart, thisEnd);
    var targetCopy = target.slice(start, end);
    for (var i = 0; i < len; ++i) {
      if (thisCopy[i] !== targetCopy[i]) {
        x = thisCopy[i];
        y = targetCopy[i];
        break;
      }
    }
    if (x < y)
      return -1;
    if (y < x)
      return 1;
    return 0;
  };
  function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
    if (buffer.length === 0)
      return -1;
    if (typeof byteOffset === "string") {
      encoding = byteOffset;
      byteOffset = 0;
    } else if (byteOffset > 2147483647) {
      byteOffset = 2147483647;
    } else if (byteOffset < -2147483648) {
      byteOffset = -2147483648;
    }
    byteOffset = +byteOffset;
    if (numberIsNaN(byteOffset)) {
      byteOffset = dir ? 0 : buffer.length - 1;
    }
    if (byteOffset < 0)
      byteOffset = buffer.length + byteOffset;
    if (byteOffset >= buffer.length) {
      if (dir)
        return -1;
      else
        byteOffset = buffer.length - 1;
    } else if (byteOffset < 0) {
      if (dir)
        byteOffset = 0;
      else
        return -1;
    }
    if (typeof val === "string") {
      val = Buffer2.from(val, encoding);
    }
    if (Buffer2.isBuffer(val)) {
      if (val.length === 0) {
        return -1;
      }
      return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
    } else if (typeof val === "number") {
      val = val & 255;
      if (typeof Uint8Array.prototype.indexOf === "function") {
        if (dir) {
          return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
        } else {
          return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
        }
      }
      return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
    }
    throw new TypeError("val must be string, number or Buffer");
  }
  function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
    var indexSize = 1;
    var arrLength = arr.length;
    var valLength = val.length;
    if (encoding !== void 0) {
      encoding = String(encoding).toLowerCase();
      if (encoding === "ucs2" || encoding === "ucs-2" || encoding === "utf16le" || encoding === "utf-16le") {
        if (arr.length < 2 || val.length < 2) {
          return -1;
        }
        indexSize = 2;
        arrLength /= 2;
        valLength /= 2;
        byteOffset /= 2;
      }
    }
    function read(buf, i2) {
      if (indexSize === 1) {
        return buf[i2];
      } else {
        return buf.readUInt16BE(i2 * indexSize);
      }
    }
    var i;
    if (dir) {
      var foundIndex = -1;
      for (i = byteOffset; i < arrLength; i++) {
        if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
          if (foundIndex === -1)
            foundIndex = i;
          if (i - foundIndex + 1 === valLength)
            return foundIndex * indexSize;
        } else {
          if (foundIndex !== -1)
            i -= i - foundIndex;
          foundIndex = -1;
        }
      }
    } else {
      if (byteOffset + valLength > arrLength)
        byteOffset = arrLength - valLength;
      for (i = byteOffset; i >= 0; i--) {
        var found = true;
        for (var j = 0; j < valLength; j++) {
          if (read(arr, i + j) !== read(val, j)) {
            found = false;
            break;
          }
        }
        if (found)
          return i;
      }
    }
    return -1;
  }
  Buffer2.prototype.includes = function includes(val, byteOffset, encoding) {
    return this.indexOf(val, byteOffset, encoding) !== -1;
  };
  Buffer2.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
  };
  Buffer2.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
  };
  function hexWrite(buf, string, offset, length) {
    offset = Number(offset) || 0;
    var remaining = buf.length - offset;
    if (!length) {
      length = remaining;
    } else {
      length = Number(length);
      if (length > remaining) {
        length = remaining;
      }
    }
    var strLen = string.length;
    if (length > strLen / 2) {
      length = strLen / 2;
    }
    for (var i = 0; i < length; ++i) {
      var parsed = parseInt(string.substr(i * 2, 2), 16);
      if (numberIsNaN(parsed))
        return i;
      buf[offset + i] = parsed;
    }
    return i;
  }
  function utf8Write(buf, string, offset, length) {
    return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
  }
  function asciiWrite(buf, string, offset, length) {
    return blitBuffer(asciiToBytes(string), buf, offset, length);
  }
  function base64Write(buf, string, offset, length) {
    return blitBuffer(base64ToBytes(string), buf, offset, length);
  }
  function ucs2Write(buf, string, offset, length) {
    return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
  }
  Buffer2.prototype.write = function write(string, offset, length, encoding) {
    if (offset === void 0) {
      encoding = "utf8";
      length = this.length;
      offset = 0;
    } else if (length === void 0 && typeof offset === "string") {
      encoding = offset;
      length = this.length;
      offset = 0;
    } else if (isFinite(offset)) {
      offset = offset >>> 0;
      if (isFinite(length)) {
        length = length >>> 0;
        if (encoding === void 0)
          encoding = "utf8";
      } else {
        encoding = length;
        length = void 0;
      }
    } else {
      throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");
    }
    var remaining = this.length - offset;
    if (length === void 0 || length > remaining)
      length = remaining;
    if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
      throw new RangeError("Attempt to write outside buffer bounds");
    }
    if (!encoding)
      encoding = "utf8";
    var loweredCase = false;
    for (; ; ) {
      switch (encoding) {
        case "hex":
          return hexWrite(this, string, offset, length);
        case "utf8":
        case "utf-8":
          return utf8Write(this, string, offset, length);
        case "ascii":
        case "latin1":
        case "binary":
          return asciiWrite(this, string, offset, length);
        case "base64":
          return base64Write(this, string, offset, length);
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return ucs2Write(this, string, offset, length);
        default:
          if (loweredCase)
            throw new TypeError("Unknown encoding: " + encoding);
          encoding = ("" + encoding).toLowerCase();
          loweredCase = true;
      }
    }
  };
  Buffer2.prototype.toJSON = function toJSON() {
    return {
      type: "Buffer",
      data: Array.prototype.slice.call(this._arr || this, 0)
    };
  };
  function base64Slice(buf, start, end) {
    if (start === 0 && end === buf.length) {
      return base64.fromByteArray(buf);
    } else {
      return base64.fromByteArray(buf.slice(start, end));
    }
  }
  function utf8Slice(buf, start, end) {
    end = Math.min(buf.length, end);
    var res = [];
    var i = start;
    while (i < end) {
      var firstByte = buf[i];
      var codePoint = null;
      var bytesPerSequence = firstByte > 239 ? 4 : firstByte > 223 ? 3 : firstByte > 191 ? 2 : 1;
      if (i + bytesPerSequence <= end) {
        var secondByte, thirdByte, fourthByte, tempCodePoint;
        switch (bytesPerSequence) {
          case 1:
            if (firstByte < 128) {
              codePoint = firstByte;
            }
            break;
          case 2:
            secondByte = buf[i + 1];
            if ((secondByte & 192) === 128) {
              tempCodePoint = (firstByte & 31) << 6 | secondByte & 63;
              if (tempCodePoint > 127) {
                codePoint = tempCodePoint;
              }
            }
            break;
          case 3:
            secondByte = buf[i + 1];
            thirdByte = buf[i + 2];
            if ((secondByte & 192) === 128 && (thirdByte & 192) === 128) {
              tempCodePoint = (firstByte & 15) << 12 | (secondByte & 63) << 6 | thirdByte & 63;
              if (tempCodePoint > 2047 && (tempCodePoint < 55296 || tempCodePoint > 57343)) {
                codePoint = tempCodePoint;
              }
            }
            break;
          case 4:
            secondByte = buf[i + 1];
            thirdByte = buf[i + 2];
            fourthByte = buf[i + 3];
            if ((secondByte & 192) === 128 && (thirdByte & 192) === 128 && (fourthByte & 192) === 128) {
              tempCodePoint = (firstByte & 15) << 18 | (secondByte & 63) << 12 | (thirdByte & 63) << 6 | fourthByte & 63;
              if (tempCodePoint > 65535 && tempCodePoint < 1114112) {
                codePoint = tempCodePoint;
              }
            }
        }
      }
      if (codePoint === null) {
        codePoint = 65533;
        bytesPerSequence = 1;
      } else if (codePoint > 65535) {
        codePoint -= 65536;
        res.push(codePoint >>> 10 & 1023 | 55296);
        codePoint = 56320 | codePoint & 1023;
      }
      res.push(codePoint);
      i += bytesPerSequence;
    }
    return decodeCodePointsArray(res);
  }
  var MAX_ARGUMENTS_LENGTH = 4096;
  function decodeCodePointsArray(codePoints) {
    var len = codePoints.length;
    if (len <= MAX_ARGUMENTS_LENGTH) {
      return String.fromCharCode.apply(String, codePoints);
    }
    var res = "";
    var i = 0;
    while (i < len) {
      res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));
    }
    return res;
  }
  function asciiSlice(buf, start, end) {
    var ret = "";
    end = Math.min(buf.length, end);
    for (var i = start; i < end; ++i) {
      ret += String.fromCharCode(buf[i] & 127);
    }
    return ret;
  }
  function latin1Slice(buf, start, end) {
    var ret = "";
    end = Math.min(buf.length, end);
    for (var i = start; i < end; ++i) {
      ret += String.fromCharCode(buf[i]);
    }
    return ret;
  }
  function hexSlice(buf, start, end) {
    var len = buf.length;
    if (!start || start < 0)
      start = 0;
    if (!end || end < 0 || end > len)
      end = len;
    var out = "";
    for (var i = start; i < end; ++i) {
      out += hexSliceLookupTable[buf[i]];
    }
    return out;
  }
  function utf16leSlice(buf, start, end) {
    var bytes = buf.slice(start, end);
    var res = "";
    for (var i = 0; i < bytes.length - 1; i += 2) {
      res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
    }
    return res;
  }
  Buffer2.prototype.slice = function slice(start, end) {
    var len = this.length;
    start = ~~start;
    end = end === void 0 ? len : ~~end;
    if (start < 0) {
      start += len;
      if (start < 0)
        start = 0;
    } else if (start > len) {
      start = len;
    }
    if (end < 0) {
      end += len;
      if (end < 0)
        end = 0;
    } else if (end > len) {
      end = len;
    }
    if (end < start)
      end = start;
    var newBuf = this.subarray(start, end);
    Object.setPrototypeOf(newBuf, Buffer2.prototype);
    return newBuf;
  };
  function checkOffset(offset, ext, length) {
    if (offset % 1 !== 0 || offset < 0)
      throw new RangeError("offset is not uint");
    if (offset + ext > length)
      throw new RangeError("Trying to access beyond buffer length");
  }
  Buffer2.prototype.readUintLE = Buffer2.prototype.readUIntLE = function readUIntLE(offset, byteLength2, noAssert) {
    offset = offset >>> 0;
    byteLength2 = byteLength2 >>> 0;
    if (!noAssert)
      checkOffset(offset, byteLength2, this.length);
    var val = this[offset];
    var mul = 1;
    var i = 0;
    while (++i < byteLength2 && (mul *= 256)) {
      val += this[offset + i] * mul;
    }
    return val;
  };
  Buffer2.prototype.readUintBE = Buffer2.prototype.readUIntBE = function readUIntBE(offset, byteLength2, noAssert) {
    offset = offset >>> 0;
    byteLength2 = byteLength2 >>> 0;
    if (!noAssert) {
      checkOffset(offset, byteLength2, this.length);
    }
    var val = this[offset + --byteLength2];
    var mul = 1;
    while (byteLength2 > 0 && (mul *= 256)) {
      val += this[offset + --byteLength2] * mul;
    }
    return val;
  };
  Buffer2.prototype.readUint8 = Buffer2.prototype.readUInt8 = function readUInt8(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 1, this.length);
    return this[offset];
  };
  Buffer2.prototype.readUint16LE = Buffer2.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 2, this.length);
    return this[offset] | this[offset + 1] << 8;
  };
  Buffer2.prototype.readUint16BE = Buffer2.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 2, this.length);
    return this[offset] << 8 | this[offset + 1];
  };
  Buffer2.prototype.readUint32LE = Buffer2.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 16777216;
  };
  Buffer2.prototype.readUint32BE = Buffer2.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return this[offset] * 16777216 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
  };
  Buffer2.prototype.readIntLE = function readIntLE(offset, byteLength2, noAssert) {
    offset = offset >>> 0;
    byteLength2 = byteLength2 >>> 0;
    if (!noAssert)
      checkOffset(offset, byteLength2, this.length);
    var val = this[offset];
    var mul = 1;
    var i = 0;
    while (++i < byteLength2 && (mul *= 256)) {
      val += this[offset + i] * mul;
    }
    mul *= 128;
    if (val >= mul)
      val -= Math.pow(2, 8 * byteLength2);
    return val;
  };
  Buffer2.prototype.readIntBE = function readIntBE(offset, byteLength2, noAssert) {
    offset = offset >>> 0;
    byteLength2 = byteLength2 >>> 0;
    if (!noAssert)
      checkOffset(offset, byteLength2, this.length);
    var i = byteLength2;
    var mul = 1;
    var val = this[offset + --i];
    while (i > 0 && (mul *= 256)) {
      val += this[offset + --i] * mul;
    }
    mul *= 128;
    if (val >= mul)
      val -= Math.pow(2, 8 * byteLength2);
    return val;
  };
  Buffer2.prototype.readInt8 = function readInt8(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 1, this.length);
    if (!(this[offset] & 128))
      return this[offset];
    return (255 - this[offset] + 1) * -1;
  };
  Buffer2.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 2, this.length);
    var val = this[offset] | this[offset + 1] << 8;
    return val & 32768 ? val | 4294901760 : val;
  };
  Buffer2.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 2, this.length);
    var val = this[offset + 1] | this[offset] << 8;
    return val & 32768 ? val | 4294901760 : val;
  };
  Buffer2.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
  };
  Buffer2.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
  };
  Buffer2.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return ieee754.read(this, offset, true, 23, 4);
  };
  Buffer2.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 4, this.length);
    return ieee754.read(this, offset, false, 23, 4);
  };
  Buffer2.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 8, this.length);
    return ieee754.read(this, offset, true, 52, 8);
  };
  Buffer2.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
    offset = offset >>> 0;
    if (!noAssert)
      checkOffset(offset, 8, this.length);
    return ieee754.read(this, offset, false, 52, 8);
  };
  function checkInt(buf, value, offset, ext, max, min) {
    if (!Buffer2.isBuffer(buf))
      throw new TypeError('"buffer" argument must be a Buffer instance');
    if (value > max || value < min)
      throw new RangeError('"value" argument is out of bounds');
    if (offset + ext > buf.length)
      throw new RangeError("Index out of range");
  }
  Buffer2.prototype.writeUintLE = Buffer2.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength2, noAssert) {
    value = +value;
    offset = offset >>> 0;
    byteLength2 = byteLength2 >>> 0;
    if (!noAssert) {
      var maxBytes = Math.pow(2, 8 * byteLength2) - 1;
      checkInt(this, value, offset, byteLength2, maxBytes, 0);
    }
    var mul = 1;
    var i = 0;
    this[offset] = value & 255;
    while (++i < byteLength2 && (mul *= 256)) {
      this[offset + i] = value / mul & 255;
    }
    return offset + byteLength2;
  };
  Buffer2.prototype.writeUintBE = Buffer2.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength2, noAssert) {
    value = +value;
    offset = offset >>> 0;
    byteLength2 = byteLength2 >>> 0;
    if (!noAssert) {
      var maxBytes = Math.pow(2, 8 * byteLength2) - 1;
      checkInt(this, value, offset, byteLength2, maxBytes, 0);
    }
    var i = byteLength2 - 1;
    var mul = 1;
    this[offset + i] = value & 255;
    while (--i >= 0 && (mul *= 256)) {
      this[offset + i] = value / mul & 255;
    }
    return offset + byteLength2;
  };
  Buffer2.prototype.writeUint8 = Buffer2.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 1, 255, 0);
    this[offset] = value & 255;
    return offset + 1;
  };
  Buffer2.prototype.writeUint16LE = Buffer2.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 2, 65535, 0);
    this[offset] = value & 255;
    this[offset + 1] = value >>> 8;
    return offset + 2;
  };
  Buffer2.prototype.writeUint16BE = Buffer2.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 2, 65535, 0);
    this[offset] = value >>> 8;
    this[offset + 1] = value & 255;
    return offset + 2;
  };
  Buffer2.prototype.writeUint32LE = Buffer2.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 4, 4294967295, 0);
    this[offset + 3] = value >>> 24;
    this[offset + 2] = value >>> 16;
    this[offset + 1] = value >>> 8;
    this[offset] = value & 255;
    return offset + 4;
  };
  Buffer2.prototype.writeUint32BE = Buffer2.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 4, 4294967295, 0);
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 255;
    return offset + 4;
  };
  Buffer2.prototype.writeIntLE = function writeIntLE(value, offset, byteLength2, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
      var limit = Math.pow(2, 8 * byteLength2 - 1);
      checkInt(this, value, offset, byteLength2, limit - 1, -limit);
    }
    var i = 0;
    var mul = 1;
    var sub = 0;
    this[offset] = value & 255;
    while (++i < byteLength2 && (mul *= 256)) {
      if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
        sub = 1;
      }
      this[offset + i] = (value / mul >> 0) - sub & 255;
    }
    return offset + byteLength2;
  };
  Buffer2.prototype.writeIntBE = function writeIntBE(value, offset, byteLength2, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
      var limit = Math.pow(2, 8 * byteLength2 - 1);
      checkInt(this, value, offset, byteLength2, limit - 1, -limit);
    }
    var i = byteLength2 - 1;
    var mul = 1;
    var sub = 0;
    this[offset + i] = value & 255;
    while (--i >= 0 && (mul *= 256)) {
      if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
        sub = 1;
      }
      this[offset + i] = (value / mul >> 0) - sub & 255;
    }
    return offset + byteLength2;
  };
  Buffer2.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 1, 127, -128);
    if (value < 0)
      value = 255 + value + 1;
    this[offset] = value & 255;
    return offset + 1;
  };
  Buffer2.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 2, 32767, -32768);
    this[offset] = value & 255;
    this[offset + 1] = value >>> 8;
    return offset + 2;
  };
  Buffer2.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 2, 32767, -32768);
    this[offset] = value >>> 8;
    this[offset + 1] = value & 255;
    return offset + 2;
  };
  Buffer2.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 4, 2147483647, -2147483648);
    this[offset] = value & 255;
    this[offset + 1] = value >>> 8;
    this[offset + 2] = value >>> 16;
    this[offset + 3] = value >>> 24;
    return offset + 4;
  };
  Buffer2.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert)
      checkInt(this, value, offset, 4, 2147483647, -2147483648);
    if (value < 0)
      value = 4294967295 + value + 1;
    this[offset] = value >>> 24;
    this[offset + 1] = value >>> 16;
    this[offset + 2] = value >>> 8;
    this[offset + 3] = value & 255;
    return offset + 4;
  };
  function checkIEEE754(buf, value, offset, ext, max, min) {
    if (offset + ext > buf.length)
      throw new RangeError("Index out of range");
    if (offset < 0)
      throw new RangeError("Index out of range");
  }
  function writeFloat(buf, value, offset, littleEndian, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
      checkIEEE754(buf, value, offset, 4, 34028234663852886e22, -34028234663852886e22);
    }
    ieee754.write(buf, value, offset, littleEndian, 23, 4);
    return offset + 4;
  }
  Buffer2.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
    return writeFloat(this, value, offset, true, noAssert);
  };
  Buffer2.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
    return writeFloat(this, value, offset, false, noAssert);
  };
  function writeDouble(buf, value, offset, littleEndian, noAssert) {
    value = +value;
    offset = offset >>> 0;
    if (!noAssert) {
      checkIEEE754(buf, value, offset, 8, 17976931348623157e292, -17976931348623157e292);
    }
    ieee754.write(buf, value, offset, littleEndian, 52, 8);
    return offset + 8;
  }
  Buffer2.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
    return writeDouble(this, value, offset, true, noAssert);
  };
  Buffer2.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
    return writeDouble(this, value, offset, false, noAssert);
  };
  Buffer2.prototype.copy = function copy(target, targetStart, start, end) {
    if (!Buffer2.isBuffer(target))
      throw new TypeError("argument should be a Buffer");
    if (!start)
      start = 0;
    if (!end && end !== 0)
      end = this.length;
    if (targetStart >= target.length)
      targetStart = target.length;
    if (!targetStart)
      targetStart = 0;
    if (end > 0 && end < start)
      end = start;
    if (end === start)
      return 0;
    if (target.length === 0 || this.length === 0)
      return 0;
    if (targetStart < 0) {
      throw new RangeError("targetStart out of bounds");
    }
    if (start < 0 || start >= this.length)
      throw new RangeError("Index out of range");
    if (end < 0)
      throw new RangeError("sourceEnd out of bounds");
    if (end > this.length)
      end = this.length;
    if (target.length - targetStart < end - start) {
      end = target.length - targetStart + start;
    }
    var len = end - start;
    if (this === target && typeof Uint8Array.prototype.copyWithin === "function") {
      this.copyWithin(targetStart, start, end);
    } else {
      Uint8Array.prototype.set.call(target, this.subarray(start, end), targetStart);
    }
    return len;
  };
  Buffer2.prototype.fill = function fill(val, start, end, encoding) {
    if (typeof val === "string") {
      if (typeof start === "string") {
        encoding = start;
        start = 0;
        end = this.length;
      } else if (typeof end === "string") {
        encoding = end;
        end = this.length;
      }
      if (encoding !== void 0 && typeof encoding !== "string") {
        throw new TypeError("encoding must be a string");
      }
      if (typeof encoding === "string" && !Buffer2.isEncoding(encoding)) {
        throw new TypeError("Unknown encoding: " + encoding);
      }
      if (val.length === 1) {
        var code = val.charCodeAt(0);
        if (encoding === "utf8" && code < 128 || encoding === "latin1") {
          val = code;
        }
      }
    } else if (typeof val === "number") {
      val = val & 255;
    } else if (typeof val === "boolean") {
      val = Number(val);
    }
    if (start < 0 || this.length < start || this.length < end) {
      throw new RangeError("Out of range index");
    }
    if (end <= start) {
      return this;
    }
    start = start >>> 0;
    end = end === void 0 ? this.length : end >>> 0;
    if (!val)
      val = 0;
    var i;
    if (typeof val === "number") {
      for (i = start; i < end; ++i) {
        this[i] = val;
      }
    } else {
      var bytes = Buffer2.isBuffer(val) ? val : Buffer2.from(val, encoding);
      var len = bytes.length;
      if (len === 0) {
        throw new TypeError('The value "' + val + '" is invalid for argument "value"');
      }
      for (i = 0; i < end - start; ++i) {
        this[i + start] = bytes[i % len];
      }
    }
    return this;
  };
  var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g;
  function base64clean(str) {
    str = str.split("=")[0];
    str = str.trim().replace(INVALID_BASE64_RE, "");
    if (str.length < 2)
      return "";
    while (str.length % 4 !== 0) {
      str = str + "=";
    }
    return str;
  }
  function utf8ToBytes(string, units) {
    units = units || Infinity;
    var codePoint;
    var length = string.length;
    var leadSurrogate = null;
    var bytes = [];
    for (var i = 0; i < length; ++i) {
      codePoint = string.charCodeAt(i);
      if (codePoint > 55295 && codePoint < 57344) {
        if (!leadSurrogate) {
          if (codePoint > 56319) {
            if ((units -= 3) > -1)
              bytes.push(239, 191, 189);
            continue;
          } else if (i + 1 === length) {
            if ((units -= 3) > -1)
              bytes.push(239, 191, 189);
            continue;
          }
          leadSurrogate = codePoint;
          continue;
        }
        if (codePoint < 56320) {
          if ((units -= 3) > -1)
            bytes.push(239, 191, 189);
          leadSurrogate = codePoint;
          continue;
        }
        codePoint = (leadSurrogate - 55296 << 10 | codePoint - 56320) + 65536;
      } else if (leadSurrogate) {
        if ((units -= 3) > -1)
          bytes.push(239, 191, 189);
      }
      leadSurrogate = null;
      if (codePoint < 128) {
        if ((units -= 1) < 0)
          break;
        bytes.push(codePoint);
      } else if (codePoint < 2048) {
        if ((units -= 2) < 0)
          break;
        bytes.push(codePoint >> 6 | 192, codePoint & 63 | 128);
      } else if (codePoint < 65536) {
        if ((units -= 3) < 0)
          break;
        bytes.push(codePoint >> 12 | 224, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
      } else if (codePoint < 1114112) {
        if ((units -= 4) < 0)
          break;
        bytes.push(codePoint >> 18 | 240, codePoint >> 12 & 63 | 128, codePoint >> 6 & 63 | 128, codePoint & 63 | 128);
      } else {
        throw new Error("Invalid code point");
      }
    }
    return bytes;
  }
  function asciiToBytes(str) {
    var byteArray = [];
    for (var i = 0; i < str.length; ++i) {
      byteArray.push(str.charCodeAt(i) & 255);
    }
    return byteArray;
  }
  function utf16leToBytes(str, units) {
    var c, hi, lo;
    var byteArray = [];
    for (var i = 0; i < str.length; ++i) {
      if ((units -= 2) < 0)
        break;
      c = str.charCodeAt(i);
      hi = c >> 8;
      lo = c % 256;
      byteArray.push(lo);
      byteArray.push(hi);
    }
    return byteArray;
  }
  function base64ToBytes(str) {
    return base64.toByteArray(base64clean(str));
  }
  function blitBuffer(src, dst, offset, length) {
    for (var i = 0; i < length; ++i) {
      if (i + offset >= dst.length || i >= src.length)
        break;
      dst[i + offset] = src[i];
    }
    return i;
  }
  function isInstance(obj, type) {
    return obj instanceof type || obj != null && obj.constructor != null && obj.constructor.name != null && obj.constructor.name === type.name;
  }
  function numberIsNaN(obj) {
    return obj !== obj;
  }
  var hexSliceLookupTable = function() {
    var alphabet = "0123456789abcdef";
    var table = new Array(256);
    for (var i = 0; i < 16; ++i) {
      var i16 = i * 16;
      for (var j = 0; j < 16; ++j) {
        table[i16 + j] = alphabet[i] + alphabet[j];
      }
    }
    return table;
  }();
});

// node_modules/process/browser.js
var require_browser = __commonJS((exports2, module2) => {
  var process2 = module2.exports = {};
  var cachedSetTimeout;
  var cachedClearTimeout;
  function defaultSetTimout() {
    throw new Error("setTimeout has not been defined");
  }
  function defaultClearTimeout() {
    throw new Error("clearTimeout has not been defined");
  }
  (function() {
    try {
      if (typeof setTimeout === "function") {
        cachedSetTimeout = setTimeout;
      } else {
        cachedSetTimeout = defaultSetTimout;
      }
    } catch (e) {
      cachedSetTimeout = defaultSetTimout;
    }
    try {
      if (typeof clearTimeout === "function") {
        cachedClearTimeout = clearTimeout;
      } else {
        cachedClearTimeout = defaultClearTimeout;
      }
    } catch (e) {
      cachedClearTimeout = defaultClearTimeout;
    }
  })();
  function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
      return setTimeout(fun, 0);
    }
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
      cachedSetTimeout = setTimeout;
      return setTimeout(fun, 0);
    }
    try {
      return cachedSetTimeout(fun, 0);
    } catch (e) {
      try {
        return cachedSetTimeout.call(null, fun, 0);
      } catch (e2) {
        return cachedSetTimeout.call(this, fun, 0);
      }
    }
  }
  function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
      return clearTimeout(marker);
    }
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
      cachedClearTimeout = clearTimeout;
      return clearTimeout(marker);
    }
    try {
      return cachedClearTimeout(marker);
    } catch (e) {
      try {
        return cachedClearTimeout.call(null, marker);
      } catch (e2) {
        return cachedClearTimeout.call(this, marker);
      }
    }
  }
  var queue = [];
  var draining = false;
  var currentQueue;
  var queueIndex = -1;
  function cleanUpNextTick() {
    if (!draining || !currentQueue) {
      return;
    }
    draining = false;
    if (currentQueue.length) {
      queue = currentQueue.concat(queue);
    } else {
      queueIndex = -1;
    }
    if (queue.length) {
      drainQueue();
    }
  }
  function drainQueue() {
    if (draining) {
      return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;
    var len = queue.length;
    while (len) {
      currentQueue = queue;
      queue = [];
      while (++queueIndex < len) {
        if (currentQueue) {
          currentQueue[queueIndex].run();
        }
      }
      queueIndex = -1;
      len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
  }
  process2.nextTick = function(fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
      for (var i = 1; i < arguments.length; i++) {
        args[i - 1] = arguments[i];
      }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
      runTimeout(drainQueue);
    }
  };
  function Item(fun, array) {
    this.fun = fun;
    this.array = array;
  }
  Item.prototype.run = function() {
    this.fun.apply(null, this.array);
  };
  process2.title = "browser";
  process2.browser = true;
  process2.env = {};
  process2.argv = [];
  process2.version = "";
  process2.versions = {};
  function noop() {
  }
  process2.on = noop;
  process2.addListener = noop;
  process2.once = noop;
  process2.off = noop;
  process2.removeListener = noop;
  process2.removeAllListeners = noop;
  process2.emit = noop;
  process2.prependListener = noop;
  process2.prependOnceListener = noop;
  process2.listeners = function(name) {
    return [];
  };
  process2.binding = function(name) {
    throw new Error("process.binding is not supported");
  };
  process2.cwd = function() {
    return "/";
  };
  process2.chdir = function(dir) {
    throw new Error("process.chdir is not supported");
  };
  process2.umask = function() {
    return 0;
  };
});

// empty:/Users/gozala/Projects/replicator/node_modules/ipfs-utils/src/files/glob-source.js
var require_glob_source = __commonJS(() => {
});

// node_modules/ipfs-utils/src/http/error.js
var require_error = __commonJS((exports2) => {
  "use strict";
  var TimeoutError = class extends Error {
    constructor(message = "Request timed out") {
      super(message);
      this.name = "TimeoutError";
    }
  };
  exports2.TimeoutError = TimeoutError;
  var AbortError = class extends Error {
    constructor(message = "The operation was aborted.") {
      super(message);
      this.name = "AbortError";
    }
  };
  exports2.AbortError = AbortError;
  var HTTPError = class extends Error {
    constructor(response) {
      super(response.statusText);
      this.name = "HTTPError";
      this.response = response;
    }
  };
  exports2.HTTPError = HTTPError;
});

// node_modules/is-electron/index.js
var require_is_electron = __commonJS((exports2, module2) => {
  function isElectron() {
    if (typeof window !== "undefined" && typeof window.process === "object" && window.process.type === "renderer") {
      return true;
    }
    if (typeof process !== "undefined" && typeof process.versions === "object" && !!process.versions.electron) {
      return true;
    }
    if (typeof navigator === "object" && typeof navigator.userAgent === "string" && navigator.userAgent.indexOf("Electron") >= 0) {
      return true;
    }
    return false;
  }
  module2.exports = isElectron;
});

// node_modules/ipfs-utils/src/env.js
var require_env = __commonJS((exports2, module2) => {
  "use strict";
  var isElectron = require_is_electron();
  var IS_ENV_WITH_DOM = typeof window === "object" && typeof document === "object" && document.nodeType === 9;
  var IS_ELECTRON = isElectron();
  var IS_BROWSER = IS_ENV_WITH_DOM && !IS_ELECTRON;
  var IS_ELECTRON_MAIN = IS_ELECTRON && !IS_ENV_WITH_DOM;
  var IS_ELECTRON_RENDERER = IS_ELECTRON && IS_ENV_WITH_DOM;
  var IS_NODE = typeof process !== "undefined" && typeof process.release !== "undefined" && process.release.name === "node" && !IS_ELECTRON;
  var IS_WEBWORKER = typeof importScripts === "function" && typeof self !== "undefined" && typeof WorkerGlobalScope !== "undefined" && self instanceof WorkerGlobalScope;
  var IS_TEST = typeof process !== "undefined" && typeof process.env !== "undefined" && process.env.NODE_ENV === "test";
  module2.exports = {
    isTest: IS_TEST,
    isElectron: IS_ELECTRON,
    isElectronMain: IS_ELECTRON_MAIN,
    isElectronRenderer: IS_ELECTRON_RENDERER,
    isNode: IS_NODE,
    isBrowser: IS_BROWSER,
    isWebWorker: IS_WEBWORKER,
    isEnvWithDom: IS_ENV_WITH_DOM
  };
});

// empty:/Users/gozala/Projects/replicator/node_modules/electron-fetch/lib/index.es.js
var require_index_es = __commonJS(() => {
});

// node_modules/object-keys/isArguments.js
var require_isArguments = __commonJS((exports2, module2) => {
  "use strict";
  var toStr = Object.prototype.toString;
  module2.exports = function isArguments(value) {
    var str = toStr.call(value);
    var isArgs = str === "[object Arguments]";
    if (!isArgs) {
      isArgs = str !== "[object Array]" && value !== null && typeof value === "object" && typeof value.length === "number" && value.length >= 0 && toStr.call(value.callee) === "[object Function]";
    }
    return isArgs;
  };
});

// node_modules/object-keys/implementation.js
var require_implementation = __commonJS((exports2, module2) => {
  "use strict";
  var keysShim;
  if (!Object.keys) {
    has = Object.prototype.hasOwnProperty;
    toStr = Object.prototype.toString;
    isArgs = require_isArguments();
    isEnumerable = Object.prototype.propertyIsEnumerable;
    hasDontEnumBug = !isEnumerable.call({toString: null}, "toString");
    hasProtoEnumBug = isEnumerable.call(function() {
    }, "prototype");
    dontEnums = [
      "toString",
      "toLocaleString",
      "valueOf",
      "hasOwnProperty",
      "isPrototypeOf",
      "propertyIsEnumerable",
      "constructor"
    ];
    equalsConstructorPrototype = function(o) {
      var ctor = o.constructor;
      return ctor && ctor.prototype === o;
    };
    excludedKeys = {
      $applicationCache: true,
      $console: true,
      $external: true,
      $frame: true,
      $frameElement: true,
      $frames: true,
      $innerHeight: true,
      $innerWidth: true,
      $onmozfullscreenchange: true,
      $onmozfullscreenerror: true,
      $outerHeight: true,
      $outerWidth: true,
      $pageXOffset: true,
      $pageYOffset: true,
      $parent: true,
      $scrollLeft: true,
      $scrollTop: true,
      $scrollX: true,
      $scrollY: true,
      $self: true,
      $webkitIndexedDB: true,
      $webkitStorageInfo: true,
      $window: true
    };
    hasAutomationEqualityBug = function() {
      if (typeof window === "undefined") {
        return false;
      }
      for (var k in window) {
        try {
          if (!excludedKeys["$" + k] && has.call(window, k) && window[k] !== null && typeof window[k] === "object") {
            try {
              equalsConstructorPrototype(window[k]);
            } catch (e) {
              return true;
            }
          }
        } catch (e) {
          return true;
        }
      }
      return false;
    }();
    equalsConstructorPrototypeIfNotBuggy = function(o) {
      if (typeof window === "undefined" || !hasAutomationEqualityBug) {
        return equalsConstructorPrototype(o);
      }
      try {
        return equalsConstructorPrototype(o);
      } catch (e) {
        return false;
      }
    };
    keysShim = function keys(object) {
      var isObject = object !== null && typeof object === "object";
      var isFunction = toStr.call(object) === "[object Function]";
      var isArguments = isArgs(object);
      var isString = isObject && toStr.call(object) === "[object String]";
      var theKeys = [];
      if (!isObject && !isFunction && !isArguments) {
        throw new TypeError("Object.keys called on a non-object");
      }
      var skipProto = hasProtoEnumBug && isFunction;
      if (isString && object.length > 0 && !has.call(object, 0)) {
        for (var i = 0; i < object.length; ++i) {
          theKeys.push(String(i));
        }
      }
      if (isArguments && object.length > 0) {
        for (var j = 0; j < object.length; ++j) {
          theKeys.push(String(j));
        }
      } else {
        for (var name in object) {
          if (!(skipProto && name === "prototype") && has.call(object, name)) {
            theKeys.push(String(name));
          }
        }
      }
      if (hasDontEnumBug) {
        var skipConstructor = equalsConstructorPrototypeIfNotBuggy(object);
        for (var k = 0; k < dontEnums.length; ++k) {
          if (!(skipConstructor && dontEnums[k] === "constructor") && has.call(object, dontEnums[k])) {
            theKeys.push(dontEnums[k]);
          }
        }
      }
      return theKeys;
    };
  }
  var has;
  var toStr;
  var isArgs;
  var isEnumerable;
  var hasDontEnumBug;
  var hasProtoEnumBug;
  var dontEnums;
  var equalsConstructorPrototype;
  var excludedKeys;
  var hasAutomationEqualityBug;
  var equalsConstructorPrototypeIfNotBuggy;
  module2.exports = keysShim;
});

// node_modules/object-keys/index.js
var require_object_keys = __commonJS((exports2, module2) => {
  "use strict";
  var slice = Array.prototype.slice;
  var isArgs = require_isArguments();
  var origKeys = Object.keys;
  var keysShim = origKeys ? function keys(o) {
    return origKeys(o);
  } : require_implementation();
  var originalKeys = Object.keys;
  keysShim.shim = function shimObjectKeys() {
    if (Object.keys) {
      var keysWorksWithArguments = function() {
        var args = Object.keys(arguments);
        return args && args.length === arguments.length;
      }(1, 2);
      if (!keysWorksWithArguments) {
        Object.keys = function keys(object) {
          if (isArgs(object)) {
            return originalKeys(slice.call(object));
          }
          return originalKeys(object);
        };
      }
    } else {
      Object.keys = keysShim;
    }
    return Object.keys || keysShim;
  };
  module2.exports = keysShim;
});

// node_modules/define-properties/index.js
var require_define_properties = __commonJS((exports2, module2) => {
  "use strict";
  var keys = require_object_keys();
  var hasSymbols = typeof Symbol === "function" && typeof Symbol("foo") === "symbol";
  var toStr = Object.prototype.toString;
  var concat = Array.prototype.concat;
  var origDefineProperty = Object.defineProperty;
  var isFunction = function(fn) {
    return typeof fn === "function" && toStr.call(fn) === "[object Function]";
  };
  var arePropertyDescriptorsSupported = function() {
    var obj = {};
    try {
      origDefineProperty(obj, "x", {enumerable: false, value: obj});
      for (var _ in obj) {
        return false;
      }
      return obj.x === obj;
    } catch (e) {
      return false;
    }
  };
  var supportsDescriptors = origDefineProperty && arePropertyDescriptorsSupported();
  var defineProperty = function(object, name, value, predicate) {
    if (name in object && (!isFunction(predicate) || !predicate())) {
      return;
    }
    if (supportsDescriptors) {
      origDefineProperty(object, name, {
        configurable: true,
        enumerable: false,
        value,
        writable: true
      });
    } else {
      object[name] = value;
    }
  };
  var defineProperties = function(object, map) {
    var predicates = arguments.length > 2 ? arguments[2] : {};
    var props = keys(map);
    if (hasSymbols) {
      props = concat.call(props, Object.getOwnPropertySymbols(map));
    }
    for (var i = 0; i < props.length; i += 1) {
      defineProperty(object, props[i], map[props[i]], predicates[props[i]]);
    }
  };
  defineProperties.supportsDescriptors = !!supportsDescriptors;
  module2.exports = defineProperties;
});

// node_modules/globalthis/implementation.browser.js
var require_implementation_browser = __commonJS((exports2, module2) => {
  "use strict";
  if (typeof self !== "undefined") {
    module2.exports = self;
  } else if (typeof window !== "undefined") {
    module2.exports = window;
  } else {
    module2.exports = Function("return this")();
  }
});

// node_modules/globalthis/polyfill.js
var require_polyfill = __commonJS((exports2, module2) => {
  "use strict";
  var implementation = require_implementation_browser();
  module2.exports = function getPolyfill() {
    if (typeof global !== "object" || !global || global.Math !== Math || global.Array !== Array) {
      return implementation;
    }
    return global;
  };
});

// node_modules/globalthis/shim.js
var require_shim = __commonJS((exports2, module2) => {
  "use strict";
  var define2 = require_define_properties();
  var getPolyfill = require_polyfill();
  module2.exports = function shimGlobal() {
    var polyfill = getPolyfill();
    if (define2.supportsDescriptors) {
      var descriptor = Object.getOwnPropertyDescriptor(polyfill, "globalThis");
      if (!descriptor || descriptor.configurable && (descriptor.enumerable || descriptor.writable || globalThis !== polyfill)) {
        Object.defineProperty(polyfill, "globalThis", {
          configurable: true,
          enumerable: false,
          value: polyfill,
          writable: false
        });
      }
    } else if (typeof globalThis !== "object" || globalThis !== polyfill) {
      polyfill.globalThis = polyfill;
    }
    return polyfill;
  };
});

// node_modules/globalthis/index.js
var require_globalthis = __commonJS((exports2, module2) => {
  "use strict";
  var defineProperties = require_define_properties();
  var implementation = require_implementation_browser();
  var getPolyfill = require_polyfill();
  var shim = require_shim();
  var polyfill = getPolyfill();
  var getGlobal = function() {
    return polyfill;
  };
  defineProperties(getGlobal, {
    getPolyfill,
    implementation,
    shim
  });
  module2.exports = getGlobal;
});

// node_modules/node-fetch/browser.js
var require_browser2 = __commonJS((exports2, module2) => {
  "use strict";
  var getGlobal = function() {
    if (typeof self !== "undefined") {
      return self;
    }
    if (typeof window !== "undefined") {
      return window;
    }
    if (typeof global2 !== "undefined") {
      return global2;
    }
    throw new Error("unable to locate global object");
  };
  var global2 = getGlobal();
  module2.exports = exports2 = global2.fetch;
  if (global2.fetch) {
    exports2.default = global2.fetch.bind(global2);
  }
  exports2.Headers = global2.Headers;
  exports2.Request = global2.Request;
  exports2.Response = global2.Response;
});

// node_modules/native-fetch/src/index.js
var require_src = __commonJS((exports2, module2) => {
  "use strict";
  var globalThis2 = require_globalthis()();
  if (globalThis2.fetch && globalThis2.Headers && globalThis2.Request && globalThis2.Response) {
    module2.exports = function fetch(...args) {
      return globalThis2.fetch(...args);
    };
    module2.exports.Headers = globalThis2.Headers;
    module2.exports.Request = globalThis2.Request;
    module2.exports.Response = globalThis2.Response;
    module2.exports.default = module2.exports;
  } else {
    module2.exports = require_browser2();
  }
});

// node_modules/ipfs-utils/src/fetch.js
var require_fetch = __commonJS((exports2, module2) => {
  "use strict";
  var {isElectronMain} = require_env();
  if (isElectronMain) {
    module2.exports = require_index_es();
  } else {
    module2.exports = require_src();
  }
});

// node_modules/ipfs-utils/src/http/fetch.browser.js
var require_fetch_browser = __commonJS((exports2, module2) => {
  "use strict";
  var {TimeoutError, AbortError} = require_error();
  var {Response: Response2, Request, Headers, default: fetch} = require_fetch();
  var fetchWithProgress = (url, options = {}) => {
    const request = new XMLHttpRequest();
    request.open(options.method || "GET", url.toString(), true);
    const {timeout, headers} = options;
    if (timeout && timeout > 0 && timeout < Infinity) {
      request.timeout = timeout;
    }
    if (options.overrideMimeType != null) {
      request.overrideMimeType(options.overrideMimeType);
    }
    if (headers) {
      for (const [name, value] of new Headers(headers)) {
        request.setRequestHeader(name, value);
      }
    }
    if (options.signal) {
      options.signal.onabort = () => request.abort();
    }
    if (options.onUploadProgress) {
      request.upload.onprogress = options.onUploadProgress;
    }
    request.responseType = "arraybuffer";
    return new Promise((resolve, reject) => {
      const handleEvent = (event) => {
        switch (event.type) {
          case "error": {
            resolve(Response2.error());
            break;
          }
          case "load": {
            resolve(new ResponseWithURL(request.responseURL, request.response, {
              status: request.status,
              statusText: request.statusText,
              headers: parseHeaders(request.getAllResponseHeaders())
            }));
            break;
          }
          case "timeout": {
            reject(new TimeoutError());
            break;
          }
          case "abort": {
            reject(new AbortError());
            break;
          }
          default: {
            break;
          }
        }
      };
      request.onerror = handleEvent;
      request.onload = handleEvent;
      request.ontimeout = handleEvent;
      request.onabort = handleEvent;
      request.send(options.body);
    });
  };
  var fetchWithStreaming = fetch;
  var fetchWith = (url, options = {}) => options.onUploadProgress != null ? fetchWithProgress(url, options) : fetchWithStreaming(url, options);
  var parseHeaders = (input) => {
    const headers = new Headers();
    for (const line of input.trim().split(/[\r\n]+/)) {
      const index = line.indexOf(": ");
      if (index > 0) {
        headers.set(line.slice(0, index), line.slice(index + 1));
      }
    }
    return headers;
  };
  var ResponseWithURL = class extends Response2 {
    constructor(url, body, options) {
      super(body, options);
      Object.defineProperty(this, "url", {value: url});
    }
  };
  module2.exports = {
    fetch: fetchWith,
    Request,
    Headers,
    ResponseWithURL
  };
});

// node_modules/is-plain-obj/index.js
var require_is_plain_obj = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = (value) => {
    if (Object.prototype.toString.call(value) !== "[object Object]") {
      return false;
    }
    const prototype = Object.getPrototypeOf(value);
    return prototype === null || prototype === Object.prototype;
  };
});

// node_modules/merge-options/index.js
var require_merge_options = __commonJS((exports2, module2) => {
  "use strict";
  var isOptionObject = require_is_plain_obj();
  var {hasOwnProperty} = Object.prototype;
  var {propertyIsEnumerable} = Object;
  var defineProperty = (object, name, value) => Object.defineProperty(object, name, {
    value,
    writable: true,
    enumerable: true,
    configurable: true
  });
  var globalThis2 = exports2;
  var defaultMergeOptions = {
    concatArrays: false,
    ignoreUndefined: false
  };
  var getEnumerableOwnPropertyKeys = (value) => {
    const keys = [];
    for (const key in value) {
      if (hasOwnProperty.call(value, key)) {
        keys.push(key);
      }
    }
    if (Object.getOwnPropertySymbols) {
      const symbols = Object.getOwnPropertySymbols(value);
      for (const symbol of symbols) {
        if (propertyIsEnumerable.call(value, symbol)) {
          keys.push(symbol);
        }
      }
    }
    return keys;
  };
  function clone(value) {
    if (Array.isArray(value)) {
      return cloneArray(value);
    }
    if (isOptionObject(value)) {
      return cloneOptionObject(value);
    }
    return value;
  }
  function cloneArray(array) {
    const result = array.slice(0, 0);
    getEnumerableOwnPropertyKeys(array).forEach((key) => {
      defineProperty(result, key, clone(array[key]));
    });
    return result;
  }
  function cloneOptionObject(object) {
    const result = Object.getPrototypeOf(object) === null ? Object.create(null) : {};
    getEnumerableOwnPropertyKeys(object).forEach((key) => {
      defineProperty(result, key, clone(object[key]));
    });
    return result;
  }
  var mergeKeys = (merged, source, keys, config) => {
    keys.forEach((key) => {
      if (typeof source[key] === "undefined" && config.ignoreUndefined) {
        return;
      }
      if (key in merged && merged[key] !== Object.getPrototypeOf(merged)) {
        defineProperty(merged, key, merge(merged[key], source[key], config));
      } else {
        defineProperty(merged, key, clone(source[key]));
      }
    });
    return merged;
  };
  var concatArrays = (merged, source, config) => {
    let result = merged.slice(0, 0);
    let resultIndex = 0;
    [merged, source].forEach((array) => {
      const indices = [];
      for (let k = 0; k < array.length; k++) {
        if (!hasOwnProperty.call(array, k)) {
          continue;
        }
        indices.push(String(k));
        if (array === merged) {
          defineProperty(result, resultIndex++, array[k]);
        } else {
          defineProperty(result, resultIndex++, clone(array[k]));
        }
      }
      result = mergeKeys(result, array, getEnumerableOwnPropertyKeys(array).filter((key) => !indices.includes(key)), config);
    });
    return result;
  };
  function merge(merged, source, config) {
    if (config.concatArrays && Array.isArray(merged) && Array.isArray(source)) {
      return concatArrays(merged, source, config);
    }
    if (!isOptionObject(source) || !isOptionObject(merged)) {
      return clone(source);
    }
    return mergeKeys(merged, source, getEnumerableOwnPropertyKeys(source), config);
  }
  module2.exports = function(...options) {
    const config = merge(clone(defaultMergeOptions), this !== globalThis2 && this || {}, defaultMergeOptions);
    let merged = {_: {}};
    for (const option of options) {
      if (option === void 0) {
        continue;
      }
      if (!isOptionObject(option)) {
        throw new TypeError("`" + option + "` is not an Option Object");
      }
      merged = merge(merged, {_: option}, config);
    }
    return merged._;
  };
});

// node_modules/iso-url/src/url-browser.js
var require_url_browser = __commonJS((exports2, module2) => {
  "use strict";
  var defaultBase = self.location && self.location.protocol + "//" + self.location.host;
  var URL2 = self.URL;
  var URLWithLegacySupport = class {
    constructor(url = "", base = defaultBase) {
      this.super = new URL2(url, base);
      this.path = this.pathname + this.search;
      this.auth = this.username && this.password ? this.username + ":" + this.password : null;
      this.query = this.search && this.search.startsWith("?") ? this.search.slice(1) : null;
    }
    get hash() {
      return this.super.hash;
    }
    get host() {
      return this.super.host;
    }
    get hostname() {
      return this.super.hostname;
    }
    get href() {
      return this.super.href;
    }
    get origin() {
      return this.super.origin;
    }
    get password() {
      return this.super.password;
    }
    get pathname() {
      return this.super.pathname;
    }
    get port() {
      return this.super.port;
    }
    get protocol() {
      return this.super.protocol;
    }
    get search() {
      return this.super.search;
    }
    get searchParams() {
      return this.super.searchParams;
    }
    get username() {
      return this.super.username;
    }
    set hash(hash) {
      this.super.hash = hash;
    }
    set host(host) {
      this.super.host = host;
    }
    set hostname(hostname) {
      this.super.hostname = hostname;
    }
    set href(href) {
      this.super.href = href;
    }
    set origin(origin) {
      this.super.origin = origin;
    }
    set password(password) {
      this.super.password = password;
    }
    set pathname(pathname) {
      this.super.pathname = pathname;
    }
    set port(port) {
      this.super.port = port;
    }
    set protocol(protocol) {
      this.super.protocol = protocol;
    }
    set search(search) {
      this.super.search = search;
    }
    set searchParams(searchParams) {
      this.super.searchParams = searchParams;
    }
    set username(username) {
      this.super.username = username;
    }
    createObjectURL(o) {
      return this.super.createObjectURL(o);
    }
    revokeObjectURL(o) {
      this.super.revokeObjectURL(o);
    }
    toJSON() {
      return this.super.toJSON();
    }
    toString() {
      return this.super.toString();
    }
    format() {
      return this.toString();
    }
  };
  function format(obj) {
    if (typeof obj === "string") {
      const url = new URL2(obj);
      return url.toString();
    }
    if (!(obj instanceof URL2)) {
      const userPass = obj.username && obj.password ? `${obj.username}:${obj.password}@` : "";
      const auth = obj.auth ? obj.auth + "@" : "";
      const port = obj.port ? ":" + obj.port : "";
      const protocol = obj.protocol ? obj.protocol + "//" : "";
      const host = obj.host || "";
      const hostname = obj.hostname || "";
      const search = obj.search || (obj.query ? "?" + obj.query : "");
      const hash = obj.hash || "";
      const pathname = obj.pathname || "";
      const path = obj.path || pathname + search;
      return `${protocol}${userPass || auth}${host || hostname + port}${path}${hash}`;
    }
  }
  module2.exports = {
    URLWithLegacySupport,
    URLSearchParams: self.URLSearchParams,
    defaultBase,
    format
  };
});

// node_modules/iso-url/src/relative.js
var require_relative = __commonJS((exports2, module2) => {
  "use strict";
  var {URLWithLegacySupport, format} = require_url_browser();
  module2.exports = (url, location2 = {}, protocolMap = {}, defaultProtocol) => {
    let protocol = location2.protocol ? location2.protocol.replace(":", "") : "http";
    protocol = (protocolMap[protocol] || defaultProtocol || protocol) + ":";
    let urlParsed;
    try {
      urlParsed = new URLWithLegacySupport(url);
    } catch (err) {
      urlParsed = {};
    }
    const base = Object.assign({}, location2, {
      protocol: protocol || urlParsed.protocol,
      host: location2.host || urlParsed.host
    });
    return new URLWithLegacySupport(url, format(base)).toString();
  };
});

// node_modules/iso-url/index.js
var require_iso_url = __commonJS((exports2, module2) => {
  "use strict";
  var {
    URLWithLegacySupport,
    format,
    URLSearchParams: URLSearchParams2,
    defaultBase
  } = require_url_browser();
  var relative = require_relative();
  module2.exports = {
    URL: URLWithLegacySupport,
    URLSearchParams: URLSearchParams2,
    format,
    relative,
    defaultBase
  };
});

// node_modules/web-encoding/src/lib.browser.js
var require_lib_browser = __commonJS((exports2) => {
  "use strict";
  exports2.TextEncoder = TextEncoder;
  exports2.TextDecoder = TextDecoder;
});

// node_modules/ipfs-utils/src/text-decoder.js
var require_text_decoder = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = require_lib_browser().TextDecoder;
});

// node_modules/abort-controller/browser.js
var require_browser3 = __commonJS((exports2, module2) => {
  "use strict";
  var {AbortController, AbortSignal} = typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : void 0;
  module2.exports = AbortController;
  module2.exports.AbortSignal = AbortSignal;
  module2.exports.default = AbortController;
});

// node_modules/native-abort-controller/src/index.js
var require_src2 = __commonJS((exports2, module2) => {
  "use strict";
  var globalThis2 = require_globalthis()();
  if (globalThis2.AbortController && globalThis2.AbortSignal) {
    module2.exports = class AbortController extends globalThis2.AbortController {
    };
    module2.exports.AbortSignal = globalThis2.AbortSignal;
    module2.exports.default = module2.exports;
  } else {
    module2.exports = require_browser3();
  }
});

// node_modules/any-signal/index.js
var require_any_signal = __commonJS((exports2, module2) => {
  var AbortController = require_src2();
  function anySignal(signals) {
    const controller = new AbortController();
    function onAbort() {
      controller.abort();
      for (const signal of signals) {
        if (!signal || !signal.removeEventListener)
          continue;
        signal.removeEventListener("abort", onAbort);
      }
    }
    for (const signal of signals) {
      if (!signal || !signal.addEventListener)
        continue;
      if (signal.aborted) {
        onAbort();
        break;
      }
      signal.addEventListener("abort", onAbort);
    }
    return controller.signal;
  }
  module2.exports = anySignal;
  module2.exports.anySignal = anySignal;
});

// node_modules/ipfs-utils/src/http.js
var require_http = __commonJS((exports2, module2) => {
  "use strict";
  var {fetch, Request, Headers} = require_fetch_browser();
  var {TimeoutError, HTTPError} = require_error();
  var merge = require_merge_options().bind({ignoreUndefined: true});
  var {URL: URL2, URLSearchParams: URLSearchParams2} = require_iso_url();
  var TextDecoder2 = require_text_decoder();
  var AbortController = require_src2();
  var anySignal = require_any_signal();
  var timeout = (promise, ms, abortController) => {
    if (ms === void 0) {
      return promise;
    }
    const start = Date.now();
    const timedOut = () => {
      const time = Date.now() - start;
      return time >= ms;
    };
    return new Promise((resolve, reject) => {
      const timeoutID = setTimeout(() => {
        if (timedOut()) {
          reject(new TimeoutError());
          abortController.abort();
        }
      }, ms);
      const after = (next) => {
        const fn = (res) => {
          clearTimeout(timeoutID);
          if (timedOut()) {
            reject(new TimeoutError());
            return;
          }
          next(res);
        };
        return fn;
      };
      promise.then(after(resolve), after(reject));
    });
  };
  var defaults = {
    throwHttpErrors: true,
    credentials: "same-origin"
  };
  var HTTP = class {
    constructor(options = {}) {
      this.opts = merge(defaults, options);
    }
    async fetch(resource, options = {}) {
      const opts = merge(this.opts, options);
      const headers = new Headers(opts.headers);
      if (typeof resource !== "string" && !(resource instanceof URL2 || resource instanceof Request)) {
        throw new TypeError("`resource` must be a string, URL, or Request");
      }
      const url = new URL2(resource.toString(), opts.base);
      const {
        searchParams,
        transformSearchParams,
        json
      } = opts;
      if (searchParams) {
        if (typeof transformSearchParams === "function") {
          url.search = transformSearchParams(new URLSearchParams2(opts.searchParams));
        } else {
          url.search = new URLSearchParams2(opts.searchParams);
        }
      }
      if (json) {
        opts.body = JSON.stringify(opts.json);
        headers.set("content-type", "application/json");
      }
      const abortController = new AbortController();
      const signal = anySignal([abortController.signal, opts.signal]);
      const response = await timeout(fetch(url.toString(), {
        ...opts,
        signal,
        timeout: void 0,
        headers
      }), opts.timeout, abortController);
      if (!response.ok && opts.throwHttpErrors) {
        if (opts.handleError) {
          await opts.handleError(response);
        }
        throw new HTTPError(response);
      }
      response.iterator = function() {
        return fromStream(response.body);
      };
      response.ndjson = async function* () {
        for await (const chunk of ndjson(response.iterator())) {
          if (options.transform) {
            yield options.transform(chunk);
          } else {
            yield chunk;
          }
        }
      };
      return response;
    }
    post(resource, options = {}) {
      return this.fetch(resource, {...options, method: "POST"});
    }
    get(resource, options = {}) {
      return this.fetch(resource, {...options, method: "GET"});
    }
    put(resource, options = {}) {
      return this.fetch(resource, {...options, method: "PUT"});
    }
    delete(resource, options = {}) {
      return this.fetch(resource, {...options, method: "DELETE"});
    }
    options(resource, options = {}) {
      return this.fetch(resource, {...options, method: "OPTIONS"});
    }
  };
  var ndjson = async function* (source) {
    const decoder = new TextDecoder2();
    let buf = "";
    for await (const chunk of source) {
      buf += decoder.decode(chunk, {stream: true});
      const lines = buf.split(/\r?\n/);
      for (let i = 0; i < lines.length - 1; i++) {
        const l = lines[i].trim();
        if (l.length > 0) {
          yield JSON.parse(l);
        }
      }
      buf = lines[lines.length - 1];
    }
    buf += decoder.decode();
    buf = buf.trim();
    if (buf.length !== 0) {
      yield JSON.parse(buf);
    }
  };
  var fromStream = (source) => {
    if (isNodeReadableStream(source)) {
      const iter = source[Symbol.asyncIterator]();
      return {
        [Symbol.asyncIterator]() {
          return {
            next: iter.next.bind(iter),
            return(value) {
              source.destroy();
              if (typeof iter.return === "function") {
                return iter.return();
              }
              return Promise.resolve({done: true, value});
            }
          };
        }
      };
    }
    if (isWebReadableStream(source)) {
      const reader = source.getReader();
      return async function* () {
        try {
          while (true) {
            const {done, value} = await reader.read();
            if (done)
              return;
            if (value) {
              yield value;
            }
          }
        } finally {
          reader.releaseLock();
        }
      }();
    }
    if (isAsyncIterable(source)) {
      return source;
    }
    throw new TypeError("Body can't be converted to AsyncIterable");
  };
  var isAsyncIterable = (value) => {
    return typeof value === "object" && value !== null && typeof value[Symbol.asyncIterator] === "function";
  };
  var isWebReadableStream = (value) => {
    return value && typeof value.getReader === "function";
  };
  var isNodeReadableStream = (value) => Object.prototype.hasOwnProperty.call(value, "readable") && Object.prototype.hasOwnProperty.call(value, "writable");
  HTTP.HTTPError = HTTPError;
  HTTP.TimeoutError = TimeoutError;
  HTTP.streamToAsyncIterator = fromStream;
  HTTP.post = (resource, options) => new HTTP(options).post(resource, options);
  HTTP.get = (resource, options) => new HTTP(options).get(resource, options);
  HTTP.put = (resource, options) => new HTTP(options).put(resource, options);
  HTTP.delete = (resource, options) => new HTTP(options).delete(resource, options);
  HTTP.options = (resource, options) => new HTTP(options).options(resource, options);
  module2.exports = HTTP;
});

// node_modules/ipfs-utils/src/files/url-source.js
var require_url_source = __commonJS((exports2, module2) => {
  "use strict";
  var HTTP = require_http();
  var urlSource = (url, options) => {
    return {
      path: decodeURIComponent(new URL(url).pathname.split("/").pop() || ""),
      content: readURLContent(url, options)
    };
  };
  async function* readURLContent(url, options) {
    const http = new HTTP();
    const response = await http.get(url, options);
    yield* response.iterator();
  }
  module2.exports = urlSource;
});

// node_modules/@multiformats/base-x/src/index.js
var require_src3 = __commonJS((exports2, module2) => {
  "use strict";
  function base(ALPHABET) {
    if (ALPHABET.length >= 255) {
      throw new TypeError("Alphabet too long");
    }
    var BASE_MAP = new Uint8Array(256);
    for (var j = 0; j < BASE_MAP.length; j++) {
      BASE_MAP[j] = 255;
    }
    for (var i = 0; i < ALPHABET.length; i++) {
      var x = ALPHABET.charAt(i);
      var xc = x.charCodeAt(0);
      if (BASE_MAP[xc] !== 255) {
        throw new TypeError(x + " is ambiguous");
      }
      BASE_MAP[xc] = i;
    }
    var BASE = ALPHABET.length;
    var LEADER = ALPHABET.charAt(0);
    var FACTOR = Math.log(BASE) / Math.log(256);
    var iFACTOR = Math.log(256) / Math.log(BASE);
    function encode(source) {
      if (source instanceof Uint8Array) {
      } else if (ArrayBuffer.isView(source)) {
        source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength);
      } else if (Array.isArray(source)) {
        source = Uint8Array.from(source);
      }
      if (!(source instanceof Uint8Array)) {
        throw new TypeError("Expected Uint8Array");
      }
      if (source.length === 0) {
        return "";
      }
      var zeroes = 0;
      var length = 0;
      var pbegin = 0;
      var pend = source.length;
      while (pbegin !== pend && source[pbegin] === 0) {
        pbegin++;
        zeroes++;
      }
      var size = (pend - pbegin) * iFACTOR + 1 >>> 0;
      var b58 = new Uint8Array(size);
      while (pbegin !== pend) {
        var carry = source[pbegin];
        var i2 = 0;
        for (var it1 = size - 1; (carry !== 0 || i2 < length) && it1 !== -1; it1--, i2++) {
          carry += 256 * b58[it1] >>> 0;
          b58[it1] = carry % BASE >>> 0;
          carry = carry / BASE >>> 0;
        }
        if (carry !== 0) {
          throw new Error("Non-zero carry");
        }
        length = i2;
        pbegin++;
      }
      var it2 = size - length;
      while (it2 !== size && b58[it2] === 0) {
        it2++;
      }
      var str = LEADER.repeat(zeroes);
      for (; it2 < size; ++it2) {
        str += ALPHABET.charAt(b58[it2]);
      }
      return str;
    }
    function decodeUnsafe(source) {
      if (typeof source !== "string") {
        throw new TypeError("Expected String");
      }
      if (source.length === 0) {
        return new Uint8Array();
      }
      var psz = 0;
      if (source[psz] === " ") {
        return;
      }
      var zeroes = 0;
      var length = 0;
      while (source[psz] === LEADER) {
        zeroes++;
        psz++;
      }
      var size = (source.length - psz) * FACTOR + 1 >>> 0;
      var b256 = new Uint8Array(size);
      while (source[psz]) {
        var carry = BASE_MAP[source.charCodeAt(psz)];
        if (carry === 255) {
          return;
        }
        var i2 = 0;
        for (var it3 = size - 1; (carry !== 0 || i2 < length) && it3 !== -1; it3--, i2++) {
          carry += BASE * b256[it3] >>> 0;
          b256[it3] = carry % 256 >>> 0;
          carry = carry / 256 >>> 0;
        }
        if (carry !== 0) {
          throw new Error("Non-zero carry");
        }
        length = i2;
        psz++;
      }
      if (source[psz] === " ") {
        return;
      }
      var it4 = size - length;
      while (it4 !== size && b256[it4] === 0) {
        it4++;
      }
      var vch = new Uint8Array(zeroes + (size - it4));
      var j2 = zeroes;
      while (it4 !== size) {
        vch[j2++] = b256[it4++];
      }
      return vch;
    }
    function decode(string) {
      var buffer = decodeUnsafe(string);
      if (buffer) {
        return buffer;
      }
      throw new Error("Non-base" + BASE + " character");
    }
    return {
      encode,
      decodeUnsafe,
      decode
    };
  }
  module2.exports = base;
});

// node_modules/multibase/src/util.js
var require_util = __commonJS((exports2, module2) => {
  "use strict";
  var {TextEncoder: TextEncoder2, TextDecoder: TextDecoder2} = require_lib_browser();
  var textDecoder = new TextDecoder2();
  var decodeText = (bytes) => textDecoder.decode(bytes);
  var textEncoder = new TextEncoder2();
  var encodeText = (text) => textEncoder.encode(text);
  function concat(arrs, length) {
    const output = new Uint8Array(length);
    let offset = 0;
    for (const arr of arrs) {
      output.set(arr, offset);
      offset += arr.length;
    }
    return output;
  }
  module2.exports = {decodeText, encodeText, concat};
});

// node_modules/multibase/src/base.js
var require_base = __commonJS((exports2, module2) => {
  "use strict";
  var {encodeText} = require_util();
  var Base = class {
    constructor(name, code, factory, alphabet) {
      this.name = name;
      this.code = code;
      this.codeBuf = encodeText(this.code);
      this.alphabet = alphabet;
      this.codec = factory(alphabet);
    }
    encode(buf) {
      return this.codec.encode(buf);
    }
    decode(string) {
      for (const char of string) {
        if (this.alphabet && this.alphabet.indexOf(char) < 0) {
          throw new Error(`invalid character '${char}' in '${string}'`);
        }
      }
      return this.codec.decode(string);
    }
  };
  module2.exports = Base;
});

// node_modules/multibase/src/rfc4648.js
var require_rfc4648 = __commonJS((exports2, module2) => {
  "use strict";
  var decode = (string, alphabet, bitsPerChar) => {
    const codes = {};
    for (let i = 0; i < alphabet.length; ++i) {
      codes[alphabet[i]] = i;
    }
    let end = string.length;
    while (string[end - 1] === "=") {
      --end;
    }
    const out = new Uint8Array(end * bitsPerChar / 8 | 0);
    let bits = 0;
    let buffer = 0;
    let written = 0;
    for (let i = 0; i < end; ++i) {
      const value = codes[string[i]];
      if (value === void 0) {
        throw new SyntaxError("Invalid character " + string[i]);
      }
      buffer = buffer << bitsPerChar | value;
      bits += bitsPerChar;
      if (bits >= 8) {
        bits -= 8;
        out[written++] = 255 & buffer >> bits;
      }
    }
    if (bits >= bitsPerChar || 255 & buffer << 8 - bits) {
      throw new SyntaxError("Unexpected end of data");
    }
    return out;
  };
  var encode = (data, alphabet, bitsPerChar) => {
    const pad = alphabet[alphabet.length - 1] === "=";
    const mask = (1 << bitsPerChar) - 1;
    let out = "";
    let bits = 0;
    let buffer = 0;
    for (let i = 0; i < data.length; ++i) {
      buffer = buffer << 8 | data[i];
      bits += 8;
      while (bits > bitsPerChar) {
        bits -= bitsPerChar;
        out += alphabet[mask & buffer >> bits];
      }
    }
    if (bits) {
      out += alphabet[mask & buffer << bitsPerChar - bits];
    }
    if (pad) {
      while (out.length * bitsPerChar & 7) {
        out += "=";
      }
    }
    return out;
  };
  var rfc4648 = (bitsPerChar) => (alphabet) => {
    return {
      encode(input) {
        return encode(input, alphabet, bitsPerChar);
      },
      decode(input) {
        return decode(input, alphabet, bitsPerChar);
      }
    };
  };
  module2.exports = {rfc4648};
});

// node_modules/multibase/src/constants.js
var require_constants = __commonJS((exports2, module2) => {
  "use strict";
  var baseX = require_src3();
  var Base = require_base();
  var {rfc4648} = require_rfc4648();
  var {decodeText, encodeText} = require_util();
  var identity = () => {
    return {
      encode: decodeText,
      decode: encodeText
    };
  };
  var constants = [
    ["identity", "\0", identity, ""],
    ["base2", "0", rfc4648(1), "01"],
    ["base8", "7", rfc4648(3), "01234567"],
    ["base10", "9", baseX, "0123456789"],
    ["base16", "f", rfc4648(4), "0123456789abcdef"],
    ["base16upper", "F", rfc4648(4), "0123456789ABCDEF"],
    ["base32hex", "v", rfc4648(5), "0123456789abcdefghijklmnopqrstuv"],
    ["base32hexupper", "V", rfc4648(5), "0123456789ABCDEFGHIJKLMNOPQRSTUV"],
    ["base32hexpad", "t", rfc4648(5), "0123456789abcdefghijklmnopqrstuv="],
    ["base32hexpadupper", "T", rfc4648(5), "0123456789ABCDEFGHIJKLMNOPQRSTUV="],
    ["base32", "b", rfc4648(5), "abcdefghijklmnopqrstuvwxyz234567"],
    ["base32upper", "B", rfc4648(5), "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567"],
    ["base32pad", "c", rfc4648(5), "abcdefghijklmnopqrstuvwxyz234567="],
    ["base32padupper", "C", rfc4648(5), "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567="],
    ["base32z", "h", rfc4648(5), "ybndrfg8ejkmcpqxot1uwisza345h769"],
    ["base36", "k", baseX, "0123456789abcdefghijklmnopqrstuvwxyz"],
    ["base36upper", "K", baseX, "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"],
    ["base58btc", "z", baseX, "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"],
    ["base58flickr", "Z", baseX, "123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ"],
    ["base64", "m", rfc4648(6), "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"],
    ["base64pad", "M", rfc4648(6), "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/="],
    ["base64url", "u", rfc4648(6), "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"],
    ["base64urlpad", "U", rfc4648(6), "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_="]
  ];
  var names = constants.reduce((prev, tupple) => {
    prev[tupple[0]] = new Base(tupple[0], tupple[1], tupple[2], tupple[3]);
    return prev;
  }, {});
  var codes = constants.reduce((prev, tupple) => {
    prev[tupple[1]] = names[tupple[0]];
    return prev;
  }, {});
  module2.exports = {
    names,
    codes
  };
});

// node_modules/multibase/src/index.js
var require_src4 = __commonJS((exports2, module2) => {
  "use strict";
  var constants = require_constants();
  var {encodeText, decodeText, concat} = require_util();
  function multibase(nameOrCode, buf) {
    if (!buf) {
      throw new Error("requires an encoded Uint8Array");
    }
    const {name, codeBuf} = encoding(nameOrCode);
    validEncode(name, buf);
    return concat([codeBuf, buf], codeBuf.length + buf.length);
  }
  function encode(nameOrCode, buf) {
    const enc = encoding(nameOrCode);
    const data = encodeText(enc.encode(buf));
    return concat([enc.codeBuf, data], enc.codeBuf.length + data.length);
  }
  function decode(data) {
    if (data instanceof Uint8Array) {
      data = decodeText(data);
    }
    const prefix = data[0];
    if (["f", "F", "v", "V", "t", "T", "b", "B", "c", "C", "h", "k", "K"].includes(prefix)) {
      data = data.toLowerCase();
    }
    const enc = encoding(data[0]);
    return enc.decode(data.substring(1));
  }
  function isEncoded(data) {
    if (data instanceof Uint8Array) {
      data = decodeText(data);
    }
    if (Object.prototype.toString.call(data) !== "[object String]") {
      return false;
    }
    try {
      const enc = encoding(data[0]);
      return enc.name;
    } catch (err) {
      return false;
    }
  }
  function validEncode(name, buf) {
    const enc = encoding(name);
    enc.decode(decodeText(buf));
  }
  function encoding(nameOrCode) {
    if (constants.names[nameOrCode]) {
      return constants.names[nameOrCode];
    } else if (constants.codes[nameOrCode]) {
      return constants.codes[nameOrCode];
    } else {
      throw new Error(`Unsupported encoding: ${nameOrCode}`);
    }
  }
  function encodingFromData(data) {
    if (data instanceof Uint8Array) {
      data = decodeText(data);
    }
    return encoding(data[0]);
  }
  exports2 = module2.exports = multibase;
  exports2.encode = encode;
  exports2.decode = decode;
  exports2.isEncoded = isEncoded;
  exports2.encoding = encoding;
  exports2.encodingFromData = encodingFromData;
  exports2.names = Object.freeze(constants.names);
  exports2.codes = Object.freeze(constants.codes);
});

// node_modules/multihashes/node_modules/varint/encode.js
var require_encode = __commonJS((exports2, module2) => {
  module2.exports = encode;
  var MSB = 128;
  var REST = 127;
  var MSBALL = ~REST;
  var INT = Math.pow(2, 31);
  function encode(num, out, offset) {
    if (Number.MAX_SAFE_INTEGER && num > Number.MAX_SAFE_INTEGER) {
      encode.bytes = 0;
      throw new RangeError("Could not encode varint");
    }
    out = out || [];
    offset = offset || 0;
    var oldOffset = offset;
    while (num >= INT) {
      out[offset++] = num & 255 | MSB;
      num /= 128;
    }
    while (num & MSBALL) {
      out[offset++] = num & 255 | MSB;
      num >>>= 7;
    }
    out[offset] = num | 0;
    encode.bytes = offset - oldOffset + 1;
    return out;
  }
});

// node_modules/multihashes/node_modules/varint/decode.js
var require_decode = __commonJS((exports2, module2) => {
  module2.exports = read;
  var MSB = 128;
  var REST = 127;
  function read(buf, offset) {
    var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf.length;
    do {
      if (counter >= l || shift > 49) {
        read.bytes = 0;
        throw new RangeError("Could not decode varint");
      }
      b = buf[counter++];
      res += shift < 28 ? (b & REST) << shift : (b & REST) * Math.pow(2, shift);
      shift += 7;
    } while (b >= MSB);
    read.bytes = counter - offset;
    return res;
  }
});

// node_modules/multihashes/node_modules/varint/length.js
var require_length = __commonJS((exports2, module2) => {
  var N1 = Math.pow(2, 7);
  var N2 = Math.pow(2, 14);
  var N3 = Math.pow(2, 21);
  var N4 = Math.pow(2, 28);
  var N5 = Math.pow(2, 35);
  var N6 = Math.pow(2, 42);
  var N7 = Math.pow(2, 49);
  var N8 = Math.pow(2, 56);
  var N9 = Math.pow(2, 63);
  module2.exports = function(value) {
    return value < N1 ? 1 : value < N2 ? 2 : value < N3 ? 3 : value < N4 ? 4 : value < N5 ? 5 : value < N6 ? 6 : value < N7 ? 7 : value < N8 ? 8 : value < N9 ? 9 : 10;
  };
});

// node_modules/multihashes/node_modules/varint/index.js
var require_varint = __commonJS((exports2, module2) => {
  module2.exports = {
    encode: require_encode(),
    decode: require_decode(),
    encodingLength: require_length()
  };
});

// node_modules/multihashes/src/constants.js
var require_constants2 = __commonJS((exports2, module2) => {
  "use strict";
  var names = Object.freeze({
    identity: 0,
    sha1: 17,
    "sha2-256": 18,
    "sha2-512": 19,
    "sha3-512": 20,
    "sha3-384": 21,
    "sha3-256": 22,
    "sha3-224": 23,
    "shake-128": 24,
    "shake-256": 25,
    "keccak-224": 26,
    "keccak-256": 27,
    "keccak-384": 28,
    "keccak-512": 29,
    blake3: 30,
    "murmur3-128": 34,
    "murmur3-32": 35,
    "dbl-sha2-256": 86,
    md4: 212,
    md5: 213,
    bmt: 214,
    "sha2-256-trunc254-padded": 4114,
    "ripemd-128": 4178,
    "ripemd-160": 4179,
    "ripemd-256": 4180,
    "ripemd-320": 4181,
    x11: 4352,
    kangarootwelve: 7425,
    "sm3-256": 21325,
    "blake2b-8": 45569,
    "blake2b-16": 45570,
    "blake2b-24": 45571,
    "blake2b-32": 45572,
    "blake2b-40": 45573,
    "blake2b-48": 45574,
    "blake2b-56": 45575,
    "blake2b-64": 45576,
    "blake2b-72": 45577,
    "blake2b-80": 45578,
    "blake2b-88": 45579,
    "blake2b-96": 45580,
    "blake2b-104": 45581,
    "blake2b-112": 45582,
    "blake2b-120": 45583,
    "blake2b-128": 45584,
    "blake2b-136": 45585,
    "blake2b-144": 45586,
    "blake2b-152": 45587,
    "blake2b-160": 45588,
    "blake2b-168": 45589,
    "blake2b-176": 45590,
    "blake2b-184": 45591,
    "blake2b-192": 45592,
    "blake2b-200": 45593,
    "blake2b-208": 45594,
    "blake2b-216": 45595,
    "blake2b-224": 45596,
    "blake2b-232": 45597,
    "blake2b-240": 45598,
    "blake2b-248": 45599,
    "blake2b-256": 45600,
    "blake2b-264": 45601,
    "blake2b-272": 45602,
    "blake2b-280": 45603,
    "blake2b-288": 45604,
    "blake2b-296": 45605,
    "blake2b-304": 45606,
    "blake2b-312": 45607,
    "blake2b-320": 45608,
    "blake2b-328": 45609,
    "blake2b-336": 45610,
    "blake2b-344": 45611,
    "blake2b-352": 45612,
    "blake2b-360": 45613,
    "blake2b-368": 45614,
    "blake2b-376": 45615,
    "blake2b-384": 45616,
    "blake2b-392": 45617,
    "blake2b-400": 45618,
    "blake2b-408": 45619,
    "blake2b-416": 45620,
    "blake2b-424": 45621,
    "blake2b-432": 45622,
    "blake2b-440": 45623,
    "blake2b-448": 45624,
    "blake2b-456": 45625,
    "blake2b-464": 45626,
    "blake2b-472": 45627,
    "blake2b-480": 45628,
    "blake2b-488": 45629,
    "blake2b-496": 45630,
    "blake2b-504": 45631,
    "blake2b-512": 45632,
    "blake2s-8": 45633,
    "blake2s-16": 45634,
    "blake2s-24": 45635,
    "blake2s-32": 45636,
    "blake2s-40": 45637,
    "blake2s-48": 45638,
    "blake2s-56": 45639,
    "blake2s-64": 45640,
    "blake2s-72": 45641,
    "blake2s-80": 45642,
    "blake2s-88": 45643,
    "blake2s-96": 45644,
    "blake2s-104": 45645,
    "blake2s-112": 45646,
    "blake2s-120": 45647,
    "blake2s-128": 45648,
    "blake2s-136": 45649,
    "blake2s-144": 45650,
    "blake2s-152": 45651,
    "blake2s-160": 45652,
    "blake2s-168": 45653,
    "blake2s-176": 45654,
    "blake2s-184": 45655,
    "blake2s-192": 45656,
    "blake2s-200": 45657,
    "blake2s-208": 45658,
    "blake2s-216": 45659,
    "blake2s-224": 45660,
    "blake2s-232": 45661,
    "blake2s-240": 45662,
    "blake2s-248": 45663,
    "blake2s-256": 45664,
    "skein256-8": 45825,
    "skein256-16": 45826,
    "skein256-24": 45827,
    "skein256-32": 45828,
    "skein256-40": 45829,
    "skein256-48": 45830,
    "skein256-56": 45831,
    "skein256-64": 45832,
    "skein256-72": 45833,
    "skein256-80": 45834,
    "skein256-88": 45835,
    "skein256-96": 45836,
    "skein256-104": 45837,
    "skein256-112": 45838,
    "skein256-120": 45839,
    "skein256-128": 45840,
    "skein256-136": 45841,
    "skein256-144": 45842,
    "skein256-152": 45843,
    "skein256-160": 45844,
    "skein256-168": 45845,
    "skein256-176": 45846,
    "skein256-184": 45847,
    "skein256-192": 45848,
    "skein256-200": 45849,
    "skein256-208": 45850,
    "skein256-216": 45851,
    "skein256-224": 45852,
    "skein256-232": 45853,
    "skein256-240": 45854,
    "skein256-248": 45855,
    "skein256-256": 45856,
    "skein512-8": 45857,
    "skein512-16": 45858,
    "skein512-24": 45859,
    "skein512-32": 45860,
    "skein512-40": 45861,
    "skein512-48": 45862,
    "skein512-56": 45863,
    "skein512-64": 45864,
    "skein512-72": 45865,
    "skein512-80": 45866,
    "skein512-88": 45867,
    "skein512-96": 45868,
    "skein512-104": 45869,
    "skein512-112": 45870,
    "skein512-120": 45871,
    "skein512-128": 45872,
    "skein512-136": 45873,
    "skein512-144": 45874,
    "skein512-152": 45875,
    "skein512-160": 45876,
    "skein512-168": 45877,
    "skein512-176": 45878,
    "skein512-184": 45879,
    "skein512-192": 45880,
    "skein512-200": 45881,
    "skein512-208": 45882,
    "skein512-216": 45883,
    "skein512-224": 45884,
    "skein512-232": 45885,
    "skein512-240": 45886,
    "skein512-248": 45887,
    "skein512-256": 45888,
    "skein512-264": 45889,
    "skein512-272": 45890,
    "skein512-280": 45891,
    "skein512-288": 45892,
    "skein512-296": 45893,
    "skein512-304": 45894,
    "skein512-312": 45895,
    "skein512-320": 45896,
    "skein512-328": 45897,
    "skein512-336": 45898,
    "skein512-344": 45899,
    "skein512-352": 45900,
    "skein512-360": 45901,
    "skein512-368": 45902,
    "skein512-376": 45903,
    "skein512-384": 45904,
    "skein512-392": 45905,
    "skein512-400": 45906,
    "skein512-408": 45907,
    "skein512-416": 45908,
    "skein512-424": 45909,
    "skein512-432": 45910,
    "skein512-440": 45911,
    "skein512-448": 45912,
    "skein512-456": 45913,
    "skein512-464": 45914,
    "skein512-472": 45915,
    "skein512-480": 45916,
    "skein512-488": 45917,
    "skein512-496": 45918,
    "skein512-504": 45919,
    "skein512-512": 45920,
    "skein1024-8": 45921,
    "skein1024-16": 45922,
    "skein1024-24": 45923,
    "skein1024-32": 45924,
    "skein1024-40": 45925,
    "skein1024-48": 45926,
    "skein1024-56": 45927,
    "skein1024-64": 45928,
    "skein1024-72": 45929,
    "skein1024-80": 45930,
    "skein1024-88": 45931,
    "skein1024-96": 45932,
    "skein1024-104": 45933,
    "skein1024-112": 45934,
    "skein1024-120": 45935,
    "skein1024-128": 45936,
    "skein1024-136": 45937,
    "skein1024-144": 45938,
    "skein1024-152": 45939,
    "skein1024-160": 45940,
    "skein1024-168": 45941,
    "skein1024-176": 45942,
    "skein1024-184": 45943,
    "skein1024-192": 45944,
    "skein1024-200": 45945,
    "skein1024-208": 45946,
    "skein1024-216": 45947,
    "skein1024-224": 45948,
    "skein1024-232": 45949,
    "skein1024-240": 45950,
    "skein1024-248": 45951,
    "skein1024-256": 45952,
    "skein1024-264": 45953,
    "skein1024-272": 45954,
    "skein1024-280": 45955,
    "skein1024-288": 45956,
    "skein1024-296": 45957,
    "skein1024-304": 45958,
    "skein1024-312": 45959,
    "skein1024-320": 45960,
    "skein1024-328": 45961,
    "skein1024-336": 45962,
    "skein1024-344": 45963,
    "skein1024-352": 45964,
    "skein1024-360": 45965,
    "skein1024-368": 45966,
    "skein1024-376": 45967,
    "skein1024-384": 45968,
    "skein1024-392": 45969,
    "skein1024-400": 45970,
    "skein1024-408": 45971,
    "skein1024-416": 45972,
    "skein1024-424": 45973,
    "skein1024-432": 45974,
    "skein1024-440": 45975,
    "skein1024-448": 45976,
    "skein1024-456": 45977,
    "skein1024-464": 45978,
    "skein1024-472": 45979,
    "skein1024-480": 45980,
    "skein1024-488": 45981,
    "skein1024-496": 45982,
    "skein1024-504": 45983,
    "skein1024-512": 45984,
    "skein1024-520": 45985,
    "skein1024-528": 45986,
    "skein1024-536": 45987,
    "skein1024-544": 45988,
    "skein1024-552": 45989,
    "skein1024-560": 45990,
    "skein1024-568": 45991,
    "skein1024-576": 45992,
    "skein1024-584": 45993,
    "skein1024-592": 45994,
    "skein1024-600": 45995,
    "skein1024-608": 45996,
    "skein1024-616": 45997,
    "skein1024-624": 45998,
    "skein1024-632": 45999,
    "skein1024-640": 46e3,
    "skein1024-648": 46001,
    "skein1024-656": 46002,
    "skein1024-664": 46003,
    "skein1024-672": 46004,
    "skein1024-680": 46005,
    "skein1024-688": 46006,
    "skein1024-696": 46007,
    "skein1024-704": 46008,
    "skein1024-712": 46009,
    "skein1024-720": 46010,
    "skein1024-728": 46011,
    "skein1024-736": 46012,
    "skein1024-744": 46013,
    "skein1024-752": 46014,
    "skein1024-760": 46015,
    "skein1024-768": 46016,
    "skein1024-776": 46017,
    "skein1024-784": 46018,
    "skein1024-792": 46019,
    "skein1024-800": 46020,
    "skein1024-808": 46021,
    "skein1024-816": 46022,
    "skein1024-824": 46023,
    "skein1024-832": 46024,
    "skein1024-840": 46025,
    "skein1024-848": 46026,
    "skein1024-856": 46027,
    "skein1024-864": 46028,
    "skein1024-872": 46029,
    "skein1024-880": 46030,
    "skein1024-888": 46031,
    "skein1024-896": 46032,
    "skein1024-904": 46033,
    "skein1024-912": 46034,
    "skein1024-920": 46035,
    "skein1024-928": 46036,
    "skein1024-936": 46037,
    "skein1024-944": 46038,
    "skein1024-952": 46039,
    "skein1024-960": 46040,
    "skein1024-968": 46041,
    "skein1024-976": 46042,
    "skein1024-984": 46043,
    "skein1024-992": 46044,
    "skein1024-1000": 46045,
    "skein1024-1008": 46046,
    "skein1024-1016": 46047,
    "skein1024-1024": 46048,
    "poseidon-bls12_381-a2-fc1": 46081,
    "poseidon-bls12_381-a2-fc1-sc": 46082
  });
  module2.exports = {names};
});

// node_modules/multihashes/node_modules/uint8arrays/to-string.js
var require_to_string = __commonJS((exports2, module2) => {
  "use strict";
  var {encoding: getCodec} = require_src4();
  var {TextDecoder: TextDecoder2} = require_lib_browser();
  var utf8Decoder = new TextDecoder2("utf8");
  function uint8ArrayToAsciiString(array) {
    let string = "";
    for (let i = 0; i < array.length; i++) {
      string += String.fromCharCode(array[i]);
    }
    return string;
  }
  function toString(array, encoding = "utf8") {
    if (encoding === "utf8" || encoding === "utf-8") {
      return utf8Decoder.decode(array);
    }
    if (encoding === "ascii") {
      return uint8ArrayToAsciiString(array);
    }
    return getCodec(encoding).encode(array);
  }
  module2.exports = toString;
});

// node_modules/multihashes/node_modules/uint8arrays/from-string.js
var require_from_string = __commonJS((exports2, module2) => {
  "use strict";
  var {encoding: getCodec} = require_src4();
  var {TextEncoder: TextEncoder2} = require_lib_browser();
  var utf8Encoder = new TextEncoder2();
  function asciiStringToUint8Array(string) {
    const array = new Uint8Array(string.length);
    for (let i = 0; i < string.length; i++) {
      array[i] = string.charCodeAt(i);
    }
    return array;
  }
  function fromString(string, encoding = "utf8") {
    if (encoding === "utf8" || encoding === "utf-8") {
      return utf8Encoder.encode(string);
    }
    if (encoding === "ascii") {
      return asciiStringToUint8Array(string);
    }
    return getCodec(encoding).decode(string);
  }
  module2.exports = fromString;
});

// node_modules/multihashes/node_modules/uint8arrays/concat.js
var require_concat = __commonJS((exports2, module2) => {
  "use strict";
  function concat(arrays, length) {
    if (!length) {
      length = arrays.reduce((acc, curr) => acc + curr.length, 0);
    }
    const output = new Uint8Array(length);
    let offset = 0;
    for (const arr of arrays) {
      output.set(arr, offset);
      offset += arr.length;
    }
    return output;
  }
  module2.exports = concat;
});

// node_modules/multihashes/src/index.js
var require_src5 = __commonJS((exports2, module2) => {
  "use strict";
  var multibase = require_src4();
  var varint = require_varint();
  var {names} = require_constants2();
  var uint8ArrayToString = require_to_string();
  var uint8ArrayFromString = require_from_string();
  var uint8ArrayConcat = require_concat();
  var codes = {};
  for (const key in names) {
    const name = key;
    codes[names[name]] = name;
  }
  function toHexString(hash) {
    if (!(hash instanceof Uint8Array)) {
      throw new Error("must be passed a Uint8Array");
    }
    return uint8ArrayToString(hash, "base16");
  }
  function fromHexString(hash) {
    return uint8ArrayFromString(hash, "base16");
  }
  function toB58String(hash) {
    if (!(hash instanceof Uint8Array)) {
      throw new Error("must be passed a Uint8Array");
    }
    return uint8ArrayToString(multibase.encode("base58btc", hash)).slice(1);
  }
  function fromB58String(hash) {
    const encoded = hash instanceof Uint8Array ? uint8ArrayToString(hash) : hash;
    return multibase.decode("z" + encoded);
  }
  function decode(bytes) {
    if (!(bytes instanceof Uint8Array)) {
      throw new Error("multihash must be a Uint8Array");
    }
    if (bytes.length < 2) {
      throw new Error("multihash too short. must be > 2 bytes.");
    }
    const code = varint.decode(bytes);
    if (!isValidCode(code)) {
      throw new Error(`multihash unknown function code: 0x${code.toString(16)}`);
    }
    bytes = bytes.slice(varint.decode.bytes);
    const len = varint.decode(bytes);
    if (len < 0) {
      throw new Error(`multihash invalid length: ${len}`);
    }
    bytes = bytes.slice(varint.decode.bytes);
    if (bytes.length !== len) {
      throw new Error(`multihash length inconsistent: 0x${uint8ArrayToString(bytes, "base16")}`);
    }
    return {
      code,
      name: codes[code],
      length: len,
      digest: bytes
    };
  }
  function encode(digest, code, length) {
    if (!digest || code === void 0) {
      throw new Error("multihash encode requires at least two args: digest, code");
    }
    const hashfn = coerceCode(code);
    if (!(digest instanceof Uint8Array)) {
      throw new Error("digest should be a Uint8Array");
    }
    if (length == null) {
      length = digest.length;
    }
    if (length && digest.length !== length) {
      throw new Error("digest length should be equal to specified length.");
    }
    const hash = varint.encode(hashfn);
    const len = varint.encode(length);
    return uint8ArrayConcat([hash, len, digest], hash.length + len.length + digest.length);
  }
  function coerceCode(name) {
    let code = name;
    if (typeof name === "string") {
      if (names[name] === void 0) {
        throw new Error(`Unrecognized hash function named: ${name}`);
      }
      code = names[name];
    }
    if (typeof code !== "number") {
      throw new Error(`Hash function code should be a number. Got: ${code}`);
    }
    if (codes[code] === void 0 && !isAppCode(code)) {
      throw new Error(`Unrecognized function code: ${code}`);
    }
    return code;
  }
  function isAppCode(code) {
    return code > 0 && code < 16;
  }
  function isValidCode(code) {
    if (isAppCode(code)) {
      return true;
    }
    if (codes[code]) {
      return true;
    }
    return false;
  }
  function validate(multihash) {
    decode(multihash);
  }
  function prefix(multihash) {
    validate(multihash);
    return multihash.subarray(0, 2);
  }
  module2.exports = {
    names,
    codes: Object.freeze(codes),
    toHexString,
    fromHexString,
    toB58String,
    fromB58String,
    decode,
    encode,
    coerceCode,
    isAppCode,
    validate,
    prefix,
    isValidCode
  };
});

// node_modules/multicodec/node_modules/varint/encode.js
var require_encode2 = __commonJS((exports2, module2) => {
  module2.exports = encode;
  var MSB = 128;
  var REST = 127;
  var MSBALL = ~REST;
  var INT = Math.pow(2, 31);
  function encode(num, out, offset) {
    if (Number.MAX_SAFE_INTEGER && num > Number.MAX_SAFE_INTEGER) {
      encode.bytes = 0;
      throw new RangeError("Could not encode varint");
    }
    out = out || [];
    offset = offset || 0;
    var oldOffset = offset;
    while (num >= INT) {
      out[offset++] = num & 255 | MSB;
      num /= 128;
    }
    while (num & MSBALL) {
      out[offset++] = num & 255 | MSB;
      num >>>= 7;
    }
    out[offset] = num | 0;
    encode.bytes = offset - oldOffset + 1;
    return out;
  }
});

// node_modules/multicodec/node_modules/varint/decode.js
var require_decode2 = __commonJS((exports2, module2) => {
  module2.exports = read;
  var MSB = 128;
  var REST = 127;
  function read(buf, offset) {
    var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf.length;
    do {
      if (counter >= l || shift > 49) {
        read.bytes = 0;
        throw new RangeError("Could not decode varint");
      }
      b = buf[counter++];
      res += shift < 28 ? (b & REST) << shift : (b & REST) * Math.pow(2, shift);
      shift += 7;
    } while (b >= MSB);
    read.bytes = counter - offset;
    return res;
  }
});

// node_modules/multicodec/node_modules/varint/length.js
var require_length2 = __commonJS((exports2, module2) => {
  var N1 = Math.pow(2, 7);
  var N2 = Math.pow(2, 14);
  var N3 = Math.pow(2, 21);
  var N4 = Math.pow(2, 28);
  var N5 = Math.pow(2, 35);
  var N6 = Math.pow(2, 42);
  var N7 = Math.pow(2, 49);
  var N8 = Math.pow(2, 56);
  var N9 = Math.pow(2, 63);
  module2.exports = function(value) {
    return value < N1 ? 1 : value < N2 ? 2 : value < N3 ? 3 : value < N4 ? 4 : value < N5 ? 5 : value < N6 ? 6 : value < N7 ? 7 : value < N8 ? 8 : value < N9 ? 9 : 10;
  };
});

// node_modules/multicodec/node_modules/varint/index.js
var require_varint2 = __commonJS((exports2, module2) => {
  module2.exports = {
    encode: require_encode2(),
    decode: require_decode2(),
    encodingLength: require_length2()
  };
});

// node_modules/multicodec/src/base-table.js
var require_base_table = __commonJS((exports2, module2) => {
  "use strict";
  var baseTable = Object.freeze({
    identity: 0,
    cidv1: 1,
    cidv2: 2,
    cidv3: 3,
    ip4: 4,
    tcp: 6,
    sha1: 17,
    "sha2-256": 18,
    "sha2-512": 19,
    "sha3-512": 20,
    "sha3-384": 21,
    "sha3-256": 22,
    "sha3-224": 23,
    "shake-128": 24,
    "shake-256": 25,
    "keccak-224": 26,
    "keccak-256": 27,
    "keccak-384": 28,
    "keccak-512": 29,
    blake3: 30,
    dccp: 33,
    "murmur3-128": 34,
    "murmur3-32": 35,
    ip6: 41,
    ip6zone: 42,
    path: 47,
    multicodec: 48,
    multihash: 49,
    multiaddr: 50,
    multibase: 51,
    dns: 53,
    dns4: 54,
    dns6: 55,
    dnsaddr: 56,
    protobuf: 80,
    cbor: 81,
    raw: 85,
    "dbl-sha2-256": 86,
    rlp: 96,
    bencode: 99,
    "dag-pb": 112,
    "dag-cbor": 113,
    "libp2p-key": 114,
    "git-raw": 120,
    "torrent-info": 123,
    "torrent-file": 124,
    "leofcoin-block": 129,
    "leofcoin-tx": 130,
    "leofcoin-pr": 131,
    sctp: 132,
    "dag-jose": 133,
    "dag-cose": 134,
    "eth-block": 144,
    "eth-block-list": 145,
    "eth-tx-trie": 146,
    "eth-tx": 147,
    "eth-tx-receipt-trie": 148,
    "eth-tx-receipt": 149,
    "eth-state-trie": 150,
    "eth-account-snapshot": 151,
    "eth-storage-trie": 152,
    "bitcoin-block": 176,
    "bitcoin-tx": 177,
    "bitcoin-witness-commitment": 178,
    "zcash-block": 192,
    "zcash-tx": 193,
    docid: 206,
    "stellar-block": 208,
    "stellar-tx": 209,
    md4: 212,
    md5: 213,
    bmt: 214,
    "decred-block": 224,
    "decred-tx": 225,
    "ipld-ns": 226,
    "ipfs-ns": 227,
    "swarm-ns": 228,
    "ipns-ns": 229,
    zeronet: 230,
    "secp256k1-pub": 231,
    "bls12_381-g1-pub": 234,
    "bls12_381-g2-pub": 235,
    "x25519-pub": 236,
    "ed25519-pub": 237,
    "bls12_381-g1g2-pub": 238,
    "dash-block": 240,
    "dash-tx": 241,
    "swarm-manifest": 250,
    "swarm-feed": 251,
    udp: 273,
    "p2p-webrtc-star": 275,
    "p2p-webrtc-direct": 276,
    "p2p-stardust": 277,
    "p2p-circuit": 290,
    "dag-json": 297,
    udt: 301,
    utp: 302,
    unix: 400,
    p2p: 421,
    ipfs: 421,
    https: 443,
    onion: 444,
    onion3: 445,
    garlic64: 446,
    garlic32: 447,
    tls: 448,
    quic: 460,
    ws: 477,
    wss: 478,
    "p2p-websocket-star": 479,
    http: 480,
    json: 512,
    messagepack: 513,
    "libp2p-peer-record": 769,
    "sha2-256-trunc254-padded": 4114,
    "ripemd-128": 4178,
    "ripemd-160": 4179,
    "ripemd-256": 4180,
    "ripemd-320": 4181,
    x11: 4352,
    "p256-pub": 4608,
    "p384-pub": 4609,
    "p521-pub": 4610,
    "ed448-pub": 4611,
    "x448-pub": 4612,
    "ed25519-priv": 4864,
    kangarootwelve: 7425,
    "sm3-256": 21325,
    "blake2b-8": 45569,
    "blake2b-16": 45570,
    "blake2b-24": 45571,
    "blake2b-32": 45572,
    "blake2b-40": 45573,
    "blake2b-48": 45574,
    "blake2b-56": 45575,
    "blake2b-64": 45576,
    "blake2b-72": 45577,
    "blake2b-80": 45578,
    "blake2b-88": 45579,
    "blake2b-96": 45580,
    "blake2b-104": 45581,
    "blake2b-112": 45582,
    "blake2b-120": 45583,
    "blake2b-128": 45584,
    "blake2b-136": 45585,
    "blake2b-144": 45586,
    "blake2b-152": 45587,
    "blake2b-160": 45588,
    "blake2b-168": 45589,
    "blake2b-176": 45590,
    "blake2b-184": 45591,
    "blake2b-192": 45592,
    "blake2b-200": 45593,
    "blake2b-208": 45594,
    "blake2b-216": 45595,
    "blake2b-224": 45596,
    "blake2b-232": 45597,
    "blake2b-240": 45598,
    "blake2b-248": 45599,
    "blake2b-256": 45600,
    "blake2b-264": 45601,
    "blake2b-272": 45602,
    "blake2b-280": 45603,
    "blake2b-288": 45604,
    "blake2b-296": 45605,
    "blake2b-304": 45606,
    "blake2b-312": 45607,
    "blake2b-320": 45608,
    "blake2b-328": 45609,
    "blake2b-336": 45610,
    "blake2b-344": 45611,
    "blake2b-352": 45612,
    "blake2b-360": 45613,
    "blake2b-368": 45614,
    "blake2b-376": 45615,
    "blake2b-384": 45616,
    "blake2b-392": 45617,
    "blake2b-400": 45618,
    "blake2b-408": 45619,
    "blake2b-416": 45620,
    "blake2b-424": 45621,
    "blake2b-432": 45622,
    "blake2b-440": 45623,
    "blake2b-448": 45624,
    "blake2b-456": 45625,
    "blake2b-464": 45626,
    "blake2b-472": 45627,
    "blake2b-480": 45628,
    "blake2b-488": 45629,
    "blake2b-496": 45630,
    "blake2b-504": 45631,
    "blake2b-512": 45632,
    "blake2s-8": 45633,
    "blake2s-16": 45634,
    "blake2s-24": 45635,
    "blake2s-32": 45636,
    "blake2s-40": 45637,
    "blake2s-48": 45638,
    "blake2s-56": 45639,
    "blake2s-64": 45640,
    "blake2s-72": 45641,
    "blake2s-80": 45642,
    "blake2s-88": 45643,
    "blake2s-96": 45644,
    "blake2s-104": 45645,
    "blake2s-112": 45646,
    "blake2s-120": 45647,
    "blake2s-128": 45648,
    "blake2s-136": 45649,
    "blake2s-144": 45650,
    "blake2s-152": 45651,
    "blake2s-160": 45652,
    "blake2s-168": 45653,
    "blake2s-176": 45654,
    "blake2s-184": 45655,
    "blake2s-192": 45656,
    "blake2s-200": 45657,
    "blake2s-208": 45658,
    "blake2s-216": 45659,
    "blake2s-224": 45660,
    "blake2s-232": 45661,
    "blake2s-240": 45662,
    "blake2s-248": 45663,
    "blake2s-256": 45664,
    "skein256-8": 45825,
    "skein256-16": 45826,
    "skein256-24": 45827,
    "skein256-32": 45828,
    "skein256-40": 45829,
    "skein256-48": 45830,
    "skein256-56": 45831,
    "skein256-64": 45832,
    "skein256-72": 45833,
    "skein256-80": 45834,
    "skein256-88": 45835,
    "skein256-96": 45836,
    "skein256-104": 45837,
    "skein256-112": 45838,
    "skein256-120": 45839,
    "skein256-128": 45840,
    "skein256-136": 45841,
    "skein256-144": 45842,
    "skein256-152": 45843,
    "skein256-160": 45844,
    "skein256-168": 45845,
    "skein256-176": 45846,
    "skein256-184": 45847,
    "skein256-192": 45848,
    "skein256-200": 45849,
    "skein256-208": 45850,
    "skein256-216": 45851,
    "skein256-224": 45852,
    "skein256-232": 45853,
    "skein256-240": 45854,
    "skein256-248": 45855,
    "skein256-256": 45856,
    "skein512-8": 45857,
    "skein512-16": 45858,
    "skein512-24": 45859,
    "skein512-32": 45860,
    "skein512-40": 45861,
    "skein512-48": 45862,
    "skein512-56": 45863,
    "skein512-64": 45864,
    "skein512-72": 45865,
    "skein512-80": 45866,
    "skein512-88": 45867,
    "skein512-96": 45868,
    "skein512-104": 45869,
    "skein512-112": 45870,
    "skein512-120": 45871,
    "skein512-128": 45872,
    "skein512-136": 45873,
    "skein512-144": 45874,
    "skein512-152": 45875,
    "skein512-160": 45876,
    "skein512-168": 45877,
    "skein512-176": 45878,
    "skein512-184": 45879,
    "skein512-192": 45880,
    "skein512-200": 45881,
    "skein512-208": 45882,
    "skein512-216": 45883,
    "skein512-224": 45884,
    "skein512-232": 45885,
    "skein512-240": 45886,
    "skein512-248": 45887,
    "skein512-256": 45888,
    "skein512-264": 45889,
    "skein512-272": 45890,
    "skein512-280": 45891,
    "skein512-288": 45892,
    "skein512-296": 45893,
    "skein512-304": 45894,
    "skein512-312": 45895,
    "skein512-320": 45896,
    "skein512-328": 45897,
    "skein512-336": 45898,
    "skein512-344": 45899,
    "skein512-352": 45900,
    "skein512-360": 45901,
    "skein512-368": 45902,
    "skein512-376": 45903,
    "skein512-384": 45904,
    "skein512-392": 45905,
    "skein512-400": 45906,
    "skein512-408": 45907,
    "skein512-416": 45908,
    "skein512-424": 45909,
    "skein512-432": 45910,
    "skein512-440": 45911,
    "skein512-448": 45912,
    "skein512-456": 45913,
    "skein512-464": 45914,
    "skein512-472": 45915,
    "skein512-480": 45916,
    "skein512-488": 45917,
    "skein512-496": 45918,
    "skein512-504": 45919,
    "skein512-512": 45920,
    "skein1024-8": 45921,
    "skein1024-16": 45922,
    "skein1024-24": 45923,
    "skein1024-32": 45924,
    "skein1024-40": 45925,
    "skein1024-48": 45926,
    "skein1024-56": 45927,
    "skein1024-64": 45928,
    "skein1024-72": 45929,
    "skein1024-80": 45930,
    "skein1024-88": 45931,
    "skein1024-96": 45932,
    "skein1024-104": 45933,
    "skein1024-112": 45934,
    "skein1024-120": 45935,
    "skein1024-128": 45936,
    "skein1024-136": 45937,
    "skein1024-144": 45938,
    "skein1024-152": 45939,
    "skein1024-160": 45940,
    "skein1024-168": 45941,
    "skein1024-176": 45942,
    "skein1024-184": 45943,
    "skein1024-192": 45944,
    "skein1024-200": 45945,
    "skein1024-208": 45946,
    "skein1024-216": 45947,
    "skein1024-224": 45948,
    "skein1024-232": 45949,
    "skein1024-240": 45950,
    "skein1024-248": 45951,
    "skein1024-256": 45952,
    "skein1024-264": 45953,
    "skein1024-272": 45954,
    "skein1024-280": 45955,
    "skein1024-288": 45956,
    "skein1024-296": 45957,
    "skein1024-304": 45958,
    "skein1024-312": 45959,
    "skein1024-320": 45960,
    "skein1024-328": 45961,
    "skein1024-336": 45962,
    "skein1024-344": 45963,
    "skein1024-352": 45964,
    "skein1024-360": 45965,
    "skein1024-368": 45966,
    "skein1024-376": 45967,
    "skein1024-384": 45968,
    "skein1024-392": 45969,
    "skein1024-400": 45970,
    "skein1024-408": 45971,
    "skein1024-416": 45972,
    "skein1024-424": 45973,
    "skein1024-432": 45974,
    "skein1024-440": 45975,
    "skein1024-448": 45976,
    "skein1024-456": 45977,
    "skein1024-464": 45978,
    "skein1024-472": 45979,
    "skein1024-480": 45980,
    "skein1024-488": 45981,
    "skein1024-496": 45982,
    "skein1024-504": 45983,
    "skein1024-512": 45984,
    "skein1024-520": 45985,
    "skein1024-528": 45986,
    "skein1024-536": 45987,
    "skein1024-544": 45988,
    "skein1024-552": 45989,
    "skein1024-560": 45990,
    "skein1024-568": 45991,
    "skein1024-576": 45992,
    "skein1024-584": 45993,
    "skein1024-592": 45994,
    "skein1024-600": 45995,
    "skein1024-608": 45996,
    "skein1024-616": 45997,
    "skein1024-624": 45998,
    "skein1024-632": 45999,
    "skein1024-640": 46e3,
    "skein1024-648": 46001,
    "skein1024-656": 46002,
    "skein1024-664": 46003,
    "skein1024-672": 46004,
    "skein1024-680": 46005,
    "skein1024-688": 46006,
    "skein1024-696": 46007,
    "skein1024-704": 46008,
    "skein1024-712": 46009,
    "skein1024-720": 46010,
    "skein1024-728": 46011,
    "skein1024-736": 46012,
    "skein1024-744": 46013,
    "skein1024-752": 46014,
    "skein1024-760": 46015,
    "skein1024-768": 46016,
    "skein1024-776": 46017,
    "skein1024-784": 46018,
    "skein1024-792": 46019,
    "skein1024-800": 46020,
    "skein1024-808": 46021,
    "skein1024-816": 46022,
    "skein1024-824": 46023,
    "skein1024-832": 46024,
    "skein1024-840": 46025,
    "skein1024-848": 46026,
    "skein1024-856": 46027,
    "skein1024-864": 46028,
    "skein1024-872": 46029,
    "skein1024-880": 46030,
    "skein1024-888": 46031,
    "skein1024-896": 46032,
    "skein1024-904": 46033,
    "skein1024-912": 46034,
    "skein1024-920": 46035,
    "skein1024-928": 46036,
    "skein1024-936": 46037,
    "skein1024-944": 46038,
    "skein1024-952": 46039,
    "skein1024-960": 46040,
    "skein1024-968": 46041,
    "skein1024-976": 46042,
    "skein1024-984": 46043,
    "skein1024-992": 46044,
    "skein1024-1000": 46045,
    "skein1024-1008": 46046,
    "skein1024-1016": 46047,
    "skein1024-1024": 46048,
    "poseidon-bls12_381-a2-fc1": 46081,
    "poseidon-bls12_381-a2-fc1-sc": 46082,
    "zeroxcert-imprint-256": 52753,
    "fil-commitment-unsealed": 61697,
    "fil-commitment-sealed": 61698,
    "holochain-adr-v0": 8417572,
    "holochain-adr-v1": 8483108,
    "holochain-key-v0": 9728292,
    "holochain-key-v1": 9793828,
    "holochain-sig-v0": 10645796,
    "holochain-sig-v1": 10711332,
    "skynet-ns": 11639056
  });
  module2.exports = {baseTable};
});

// node_modules/multicodec/src/int-table.js
var require_int_table = __commonJS((exports2, module2) => {
  "use strict";
  var {baseTable} = require_base_table();
  var nameTable = new Map();
  for (const encodingName in baseTable) {
    const code = baseTable[encodingName];
    nameTable.set(code, encodingName);
  }
  module2.exports = Object.freeze(nameTable);
});

// node_modules/uint8arrays/to-string.js
var require_to_string2 = __commonJS((exports2, module2) => {
  "use strict";
  var {names} = require_constants();
  var {TextDecoder: TextDecoder2} = require_lib_browser();
  var utf8Decoder = new TextDecoder2("utf8");
  function uint8ArrayToAsciiString(array) {
    let string = "";
    for (let i = 0; i < array.length; i++) {
      string += String.fromCharCode(array[i]);
    }
    return string;
  }
  function toString(array, encoding = "utf8") {
    if (encoding === "utf8" || encoding === "utf-8") {
      return utf8Decoder.decode(array);
    }
    if (encoding === "ascii") {
      return uint8ArrayToAsciiString(array);
    }
    const codec = names[encoding];
    if (!codec) {
      throw new Error("Unknown base");
    }
    return codec.encode(array);
  }
  module2.exports = toString;
});

// node_modules/uint8arrays/from-string.js
var require_from_string2 = __commonJS((exports2, module2) => {
  "use strict";
  var {names} = require_constants();
  var {TextEncoder: TextEncoder2} = require_lib_browser();
  var utf8Encoder = new TextEncoder2();
  function asciiStringToUint8Array(string) {
    const array = new Uint8Array(string.length);
    for (let i = 0; i < string.length; i++) {
      array[i] = string.charCodeAt(i);
    }
    return array;
  }
  function fromString(string, encoding = "utf8") {
    if (encoding === "utf8" || encoding === "utf-8") {
      return utf8Encoder.encode(string);
    }
    if (encoding === "ascii") {
      return asciiStringToUint8Array(string);
    }
    const codec = names[encoding];
    if (!codec) {
      throw new Error("Unknown base");
    }
    return codec.decode(string);
  }
  module2.exports = fromString;
});

// node_modules/multicodec/src/util.js
var require_util2 = __commonJS((exports2, module2) => {
  "use strict";
  var varint = require_varint2();
  var uint8ArrayToString = require_to_string2();
  var uint8ArrayFromString = require_from_string2();
  module2.exports = {
    numberToUint8Array,
    uint8ArrayToNumber,
    varintUint8ArrayEncode,
    varintEncode
  };
  function uint8ArrayToNumber(buf) {
    return parseInt(uint8ArrayToString(buf, "base16"), 16);
  }
  function numberToUint8Array(num) {
    let hexString = num.toString(16);
    if (hexString.length % 2 === 1) {
      hexString = "0" + hexString;
    }
    return uint8ArrayFromString(hexString, "base16");
  }
  function varintUint8ArrayEncode(input) {
    return Uint8Array.from(varint.encode(uint8ArrayToNumber(input)));
  }
  function varintEncode(num) {
    return Uint8Array.from(varint.encode(num));
  }
});

// node_modules/multicodec/src/varint-table.js
var require_varint_table = __commonJS((exports2, module2) => {
  "use strict";
  var {baseTable} = require_base_table();
  var varintEncode = require_util2().varintEncode;
  var varintTable = {};
  for (const encodingName in baseTable) {
    const code = baseTable[encodingName];
    varintTable[encodingName] = varintEncode(code);
  }
  module2.exports = Object.freeze(varintTable);
});

// node_modules/uint8arrays/concat.js
var require_concat2 = __commonJS((exports2, module2) => {
  "use strict";
  function concat(arrays, length) {
    if (!length) {
      length = arrays.reduce((acc, curr) => acc + curr.length, 0);
    }
    const output = new Uint8Array(length);
    let offset = 0;
    for (const arr of arrays) {
      output.set(arr, offset);
      offset += arr.length;
    }
    return output;
  }
  module2.exports = concat;
});

// node_modules/multicodec/src/constants.js
var require_constants3 = __commonJS((exports2, module2) => {
  "use strict";
  var {baseTable} = require_base_table();
  var constants = {};
  for (const [name, code] of Object.entries(baseTable)) {
    const constant = name.toUpperCase().replace(/-/g, "_");
    constants[constant] = code;
  }
  module2.exports = Object.freeze(constants);
});

// node_modules/multicodec/src/print.js
var require_print = __commonJS((exports2, module2) => {
  "use strict";
  var {baseTable} = require_base_table();
  var tableByCode = {};
  for (const [name, code] of Object.entries(baseTable)) {
    if (tableByCode[code] === void 0) {
      tableByCode[code] = name;
    }
  }
  module2.exports = Object.freeze(tableByCode);
});

// node_modules/multicodec/src/index.js
var require_src6 = __commonJS((exports2, module2) => {
  "use strict";
  var varint = require_varint2();
  var intTable = require_int_table();
  var codecNameToCodeVarint = require_varint_table();
  var util = require_util2();
  var uint8ArrayConcat = require_concat2();
  function addPrefix(multicodecStrOrCode, data) {
    let prefix;
    if (multicodecStrOrCode instanceof Uint8Array) {
      prefix = util.varintUint8ArrayEncode(multicodecStrOrCode);
    } else {
      if (codecNameToCodeVarint[multicodecStrOrCode]) {
        prefix = codecNameToCodeVarint[multicodecStrOrCode];
      } else {
        throw new Error("multicodec not recognized");
      }
    }
    return uint8ArrayConcat([prefix, data], prefix.length + data.length);
  }
  function rmPrefix(data) {
    varint.decode(data);
    return data.slice(varint.decode.bytes);
  }
  function getCodec(prefixedData) {
    const code = varint.decode(prefixedData);
    const codecName = intTable.get(code);
    if (codecName === void 0) {
      throw new Error(`Code ${code} not found`);
    }
    return codecName;
  }
  function getName(codec) {
    return intTable.get(codec);
  }
  function getNumber(name) {
    const code = codecNameToCodeVarint[name];
    if (code === void 0) {
      throw new Error("Codec `" + name + "` not found");
    }
    return varint.decode(code);
  }
  function getCode(prefixedData) {
    return varint.decode(prefixedData);
  }
  function getCodeVarint(codecName) {
    const code = codecNameToCodeVarint[codecName];
    if (code === void 0) {
      throw new Error("Codec `" + codecName + "` not found");
    }
    return code;
  }
  function getVarint(code) {
    return varint.encode(code);
  }
  var constants = require_constants3();
  var print = require_print();
  module2.exports = {
    addPrefix,
    rmPrefix,
    getCodec,
    getName,
    getNumber,
    getCode,
    getCodeVarint,
    getVarint,
    print,
    ...constants
  };
});

// node_modules/cids/src/cid-util.js
var require_cid_util = __commonJS((exports2, module2) => {
  "use strict";
  var mh = require_src5();
  var CIDUtil = {
    checkCIDComponents: function(other) {
      if (other == null) {
        return "null values are not valid CIDs";
      }
      if (!(other.version === 0 || other.version === 1)) {
        return "Invalid version, must be a number equal to 1 or 0";
      }
      if (typeof other.codec !== "string") {
        return "codec must be string";
      }
      if (other.version === 0) {
        if (other.codec !== "dag-pb") {
          return "codec must be 'dag-pb' for CIDv0";
        }
        if (other.multibaseName !== "base58btc") {
          return "multibaseName must be 'base58btc' for CIDv0";
        }
      }
      if (!(other.multihash instanceof Uint8Array)) {
        return "multihash must be a Uint8Array";
      }
      try {
        mh.validate(other.multihash);
      } catch (err) {
        let errorMsg = err.message;
        if (!errorMsg) {
          errorMsg = "Multihash validation failed";
        }
        return errorMsg;
      }
    }
  };
  module2.exports = CIDUtil;
});

// node_modules/cids/node_modules/uint8arrays/concat.js
var require_concat3 = __commonJS((exports2, module2) => {
  "use strict";
  function concat(arrays, length) {
    if (!length) {
      length = arrays.reduce((acc, curr) => acc + curr.length, 0);
    }
    const output = new Uint8Array(length);
    let offset = 0;
    for (const arr of arrays) {
      output.set(arr, offset);
      offset += arr.length;
    }
    return output;
  }
  module2.exports = concat;
});

// node_modules/cids/node_modules/uint8arrays/to-string.js
var require_to_string3 = __commonJS((exports2, module2) => {
  "use strict";
  var {encoding: getCodec} = require_src4();
  var {TextDecoder: TextDecoder2} = require_lib_browser();
  var utf8Decoder = new TextDecoder2("utf8");
  function uint8ArrayToAsciiString(array) {
    let string = "";
    for (let i = 0; i < array.length; i++) {
      string += String.fromCharCode(array[i]);
    }
    return string;
  }
  function toString(array, encoding = "utf8") {
    if (encoding === "utf8" || encoding === "utf-8") {
      return utf8Decoder.decode(array);
    }
    if (encoding === "ascii") {
      return uint8ArrayToAsciiString(array);
    }
    return getCodec(encoding).encode(array);
  }
  module2.exports = toString;
});

// node_modules/cids/node_modules/uint8arrays/equals.js
var require_equals = __commonJS((exports2, module2) => {
  "use strict";
  function equals(a, b) {
    if (a === b) {
      return true;
    }
    if (a.byteLength !== b.byteLength) {
      return false;
    }
    for (let i = 0; i < a.byteLength; i++) {
      if (a[i] !== b[i]) {
        return false;
      }
    }
    return true;
  }
  module2.exports = equals;
});

// node_modules/cids/src/index.js
var require_src7 = __commonJS((exports2, module2) => {
  "use strict";
  var mh = require_src5();
  var multibase = require_src4();
  var multicodec = require_src6();
  var {baseTable: codecs} = require_base_table();
  var CIDUtil = require_cid_util();
  var uint8ArrayConcat = require_concat3();
  var uint8ArrayToString = require_to_string3();
  var uint8ArrayEquals = require_equals();
  var codecInts = Object.keys(codecs).reduce((p, name) => {
    p[codecs[name]] = name;
    return p;
  }, {});
  var symbol = Symbol.for("@ipld/js-cid/CID");
  var CID = class {
    constructor(version, codec, multihash, multibaseName) {
      this.version;
      this.codec;
      this.multihash;
      Object.defineProperty(this, symbol, {value: true});
      if (CID.isCID(version)) {
        const cid = version;
        this.version = cid.version;
        this.codec = cid.codec;
        this.multihash = cid.multihash;
        this.multibaseName = cid.multibaseName || (cid.version === 0 ? "base58btc" : "base32");
        return;
      }
      if (typeof version === "string") {
        const baseName = multibase.isEncoded(version);
        if (baseName) {
          const cid = multibase.decode(version);
          this.version = parseInt(cid[0].toString(), 16);
          this.codec = multicodec.getCodec(cid.slice(1));
          this.multihash = multicodec.rmPrefix(cid.slice(1));
          this.multibaseName = baseName;
        } else {
          this.version = 0;
          this.codec = "dag-pb";
          this.multihash = mh.fromB58String(version);
          this.multibaseName = "base58btc";
        }
        CID.validateCID(this);
        Object.defineProperty(this, "string", {value: version});
        return;
      }
      if (version instanceof Uint8Array) {
        const v = parseInt(version[0].toString(), 16);
        if (v === 1) {
          const cid = version;
          this.version = v;
          this.codec = multicodec.getCodec(cid.slice(1));
          this.multihash = multicodec.rmPrefix(cid.slice(1));
          this.multibaseName = "base32";
        } else {
          this.version = 0;
          this.codec = "dag-pb";
          this.multihash = version;
          this.multibaseName = "base58btc";
        }
        CID.validateCID(this);
        return;
      }
      this.version = version;
      if (typeof codec === "number") {
        codec = codecInts[codec];
      }
      this.codec = codec;
      this.multihash = multihash;
      this.multibaseName = multibaseName || (version === 0 ? "base58btc" : "base32");
      CID.validateCID(this);
    }
    get bytes() {
      let bytes = this._bytes;
      if (!bytes) {
        if (this.version === 0) {
          bytes = this.multihash;
        } else if (this.version === 1) {
          const codec = multicodec.getCodeVarint(this.codec);
          bytes = uint8ArrayConcat([
            [1],
            codec,
            this.multihash
          ], 1 + codec.byteLength + this.multihash.byteLength);
        } else {
          throw new Error("unsupported version");
        }
        Object.defineProperty(this, "_bytes", {value: bytes});
      }
      return bytes;
    }
    get prefix() {
      const codec = multicodec.getCodeVarint(this.codec);
      const multihash = mh.prefix(this.multihash);
      const prefix = uint8ArrayConcat([
        [this.version],
        codec,
        multihash
      ], 1 + codec.byteLength + multihash.byteLength);
      return prefix;
    }
    get code() {
      return codecs[this.codec];
    }
    toV0() {
      if (this.codec !== "dag-pb") {
        throw new Error("Cannot convert a non dag-pb CID to CIDv0");
      }
      const {name, length} = mh.decode(this.multihash);
      if (name !== "sha2-256") {
        throw new Error("Cannot convert non sha2-256 multihash CID to CIDv0");
      }
      if (length !== 32) {
        throw new Error("Cannot convert non 32 byte multihash CID to CIDv0");
      }
      return new CID(0, this.codec, this.multihash);
    }
    toV1() {
      return new CID(1, this.codec, this.multihash);
    }
    toBaseEncodedString(base = this.multibaseName) {
      if (this.string && this.string.length !== 0 && base === this.multibaseName) {
        return this.string;
      }
      let str;
      if (this.version === 0) {
        if (base !== "base58btc") {
          throw new Error("not supported with CIDv0, to support different bases, please migrate the instance do CIDv1, you can do that through cid.toV1()");
        }
        str = mh.toB58String(this.multihash);
      } else if (this.version === 1) {
        str = uint8ArrayToString(multibase.encode(base, this.bytes));
      } else {
        throw new Error("unsupported version");
      }
      if (base === this.multibaseName) {
        Object.defineProperty(this, "string", {value: str});
      }
      return str;
    }
    [Symbol.for("nodejs.util.inspect.custom")]() {
      return "CID(" + this.toString() + ")";
    }
    toString(base) {
      return this.toBaseEncodedString(base);
    }
    toJSON() {
      return {
        codec: this.codec,
        version: this.version,
        hash: this.multihash
      };
    }
    equals(other) {
      return this.codec === other.codec && this.version === other.version && uint8ArrayEquals(this.multihash, other.multihash);
    }
    static validateCID(other) {
      const errorMsg = CIDUtil.checkCIDComponents(other);
      if (errorMsg) {
        throw new Error(errorMsg);
      }
    }
    static isCID(value) {
      return value instanceof CID || Boolean(value && value[symbol]);
    }
  };
  CID.codecs = codecs;
  module2.exports = CID;
});

// node_modules/protocol-buffers-schema/tokenize.js
var require_tokenize = __commonJS((exports2, module2) => {
  module2.exports = function(sch) {
    var noComments = function(line) {
      var i = line.indexOf("//");
      return i > -1 ? line.slice(0, i) : line;
    };
    var noMultilineComments = function() {
      var inside = false;
      return function(token) {
        if (token === "/*") {
          inside = true;
          return false;
        }
        if (token === "*/") {
          inside = false;
          return false;
        }
        return !inside;
      };
    };
    var trim = function(line) {
      return line.trim();
    };
    var removeQuotedLines = function(list) {
      return function(str) {
        var s = "$" + list.length + "$";
        list.push(str);
        return s;
      };
    };
    var restoreQuotedLines = function(list) {
      var re = /^\$(\d+)\$$/;
      return function(line) {
        var m = line.match(re);
        return m ? list[+m[1]] : line;
      };
    };
    var replacements = [];
    return sch.replace(/"(\\"|[^"\n])*?"|'(\\'|[^'\n])*?'/gm, removeQuotedLines(replacements)).replace(/([;,{}()=:[\]<>]|\/\*|\*\/)/g, " $1 ").split(/\n/).map(trim).filter(Boolean).map(noComments).map(trim).filter(Boolean).join("\n").split(/\s+|\n+/gm).filter(noMultilineComments()).map(restoreQuotedLines(replacements));
  };
});

// node_modules/protocol-buffers-schema/parse.js
var require_parse = __commonJS((exports2, module2) => {
  var tokenize = require_tokenize();
  var MAX_RANGE = 536870911;
  var PACKABLE_TYPES = [
    "int32",
    "int64",
    "uint32",
    "uint64",
    "sint32",
    "sint64",
    "bool",
    "fixed64",
    "sfixed64",
    "double",
    "fixed32",
    "sfixed32",
    "float"
  ];
  var onfieldoptionvalue = function(tokens) {
    var value = tokens.shift();
    if (value !== "{") {
      return value;
    }
    value = {};
    var field = "";
    while (tokens.length) {
      switch (tokens[0]) {
        case "}":
          tokens.shift();
          return value;
        case ":":
          tokens.shift();
          value[field] = onfieldoptionvalue(tokens);
          break;
        default:
          field = tokens.shift();
      }
    }
  };
  var onfieldoptions = function(tokens) {
    var opts = {};
    while (tokens.length) {
      switch (tokens[0]) {
        case "[":
        case ",": {
          tokens.shift();
          var name = tokens.shift();
          if (name === "(") {
            name = tokens.shift();
            tokens.shift();
          }
          var field = [];
          if (tokens[0][0] === ".") {
            field = tokens[0].substr(1).split(".");
            tokens.shift();
          }
          if (tokens[0] !== "=")
            throw new Error("Unexpected token in field options: " + tokens[0]);
          tokens.shift();
          if (tokens[0] === "]")
            throw new Error("Unexpected ] in field option");
          var path = [name].concat(field);
          var lastFieldName = path.pop();
          var opt = path.reduce(function(opt2, n, index) {
            if (opt2[n] == null) {
              opt2[n] = {};
            }
            return opt2[n];
          }, opts);
          opt[lastFieldName] = onfieldoptionvalue(tokens);
          break;
        }
        case "]":
          tokens.shift();
          return opts;
        default:
          throw new Error("Unexpected token in field options: " + tokens[0]);
      }
    }
    throw new Error("No closing tag for field options");
  };
  var onfield = function(tokens) {
    var field = {
      name: null,
      type: null,
      tag: -1,
      map: null,
      oneof: null,
      required: false,
      repeated: false,
      options: {}
    };
    while (tokens.length) {
      switch (tokens[0]) {
        case "=":
          tokens.shift();
          field.tag = Number(tokens.shift());
          break;
        case "map":
          field.type = "map";
          field.map = {from: null, to: null};
          tokens.shift();
          if (tokens[0] !== "<")
            throw new Error("Unexpected token in map type: " + tokens[0]);
          tokens.shift();
          field.map.from = tokens.shift();
          if (tokens[0] !== ",")
            throw new Error("Unexpected token in map type: " + tokens[0]);
          tokens.shift();
          field.map.to = tokens.shift();
          if (tokens[0] !== ">")
            throw new Error("Unexpected token in map type: " + tokens[0]);
          tokens.shift();
          field.name = tokens.shift();
          break;
        case "repeated":
        case "required":
        case "optional":
          var t = tokens.shift();
          field.required = t === "required";
          field.repeated = t === "repeated";
          field.type = tokens.shift();
          field.name = tokens.shift();
          break;
        case "[":
          field.options = onfieldoptions(tokens);
          break;
        case ";":
          if (field.name === null)
            throw new Error("Missing field name");
          if (field.type === null)
            throw new Error("Missing type in message field: " + field.name);
          if (field.tag === -1)
            throw new Error("Missing tag number in message field: " + field.name);
          tokens.shift();
          return field;
        default:
          throw new Error("Unexpected token in message field: " + tokens[0]);
      }
    }
    throw new Error("No ; found for message field");
  };
  var onmessagebody = function(tokens) {
    var body = {
      enums: [],
      options: {},
      messages: [],
      fields: [],
      extends: [],
      extensions: null
    };
    while (tokens.length) {
      switch (tokens[0]) {
        case "map":
        case "repeated":
        case "optional":
        case "required":
          body.fields.push(onfield(tokens));
          break;
        case "enum":
          body.enums.push(onenum(tokens));
          break;
        case "message":
          body.messages.push(onmessage(tokens));
          break;
        case "extensions":
          body.extensions = onextensions(tokens);
          break;
        case "oneof":
          tokens.shift();
          var name = tokens.shift();
          if (tokens[0] !== "{")
            throw new Error("Unexpected token in oneof: " + tokens[0]);
          tokens.shift();
          while (tokens[0] !== "}") {
            tokens.unshift("optional");
            var field = onfield(tokens);
            field.oneof = name;
            body.fields.push(field);
          }
          tokens.shift();
          break;
        case "extend":
          body.extends.push(onextend(tokens));
          break;
        case ";":
          tokens.shift();
          break;
        case "reserved":
          tokens.shift();
          while (tokens[0] !== ";") {
            tokens.shift();
          }
          break;
        case "option":
          var opt = onoption(tokens);
          if (body.options[opt.name] !== void 0)
            throw new Error("Duplicate option " + opt.name);
          body.options[opt.name] = opt.value;
          break;
        default:
          tokens.unshift("optional");
          body.fields.push(onfield(tokens));
      }
    }
    return body;
  };
  var onextend = function(tokens) {
    var out = {
      name: tokens[1],
      message: onmessage(tokens)
    };
    return out;
  };
  var onextensions = function(tokens) {
    tokens.shift();
    var from = Number(tokens.shift());
    if (isNaN(from))
      throw new Error("Invalid from in extensions definition");
    if (tokens.shift() !== "to")
      throw new Error("Expected keyword 'to' in extensions definition");
    var to = tokens.shift();
    if (to === "max")
      to = MAX_RANGE;
    to = Number(to);
    if (isNaN(to))
      throw new Error("Invalid to in extensions definition");
    if (tokens.shift() !== ";")
      throw new Error("Missing ; in extensions definition");
    return {from, to};
  };
  var onmessage = function(tokens) {
    tokens.shift();
    var lvl = 1;
    var body = [];
    var msg = {
      name: tokens.shift(),
      options: {},
      enums: [],
      extends: [],
      messages: [],
      fields: []
    };
    if (tokens[0] !== "{")
      throw new Error("Expected { but found " + tokens[0]);
    tokens.shift();
    while (tokens.length) {
      if (tokens[0] === "{")
        lvl++;
      else if (tokens[0] === "}")
        lvl--;
      if (!lvl) {
        tokens.shift();
        body = onmessagebody(body);
        msg.enums = body.enums;
        msg.messages = body.messages;
        msg.fields = body.fields;
        msg.extends = body.extends;
        msg.extensions = body.extensions;
        msg.options = body.options;
        return msg;
      }
      body.push(tokens.shift());
    }
    if (lvl)
      throw new Error("No closing tag for message");
  };
  var onpackagename = function(tokens) {
    tokens.shift();
    var name = tokens.shift();
    if (tokens[0] !== ";")
      throw new Error("Expected ; but found " + tokens[0]);
    tokens.shift();
    return name;
  };
  var onsyntaxversion = function(tokens) {
    tokens.shift();
    if (tokens[0] !== "=")
      throw new Error("Expected = but found " + tokens[0]);
    tokens.shift();
    var version = tokens.shift();
    switch (version) {
      case '"proto2"':
        version = 2;
        break;
      case '"proto3"':
        version = 3;
        break;
      default:
        throw new Error("Expected protobuf syntax version but found " + version);
    }
    if (tokens[0] !== ";")
      throw new Error("Expected ; but found " + tokens[0]);
    tokens.shift();
    return version;
  };
  var onenumvalue = function(tokens) {
    if (tokens.length < 4)
      throw new Error("Invalid enum value: " + tokens.slice(0, 3).join(" "));
    if (tokens[1] !== "=")
      throw new Error("Expected = but found " + tokens[1]);
    if (tokens[3] !== ";" && tokens[3] !== "[")
      throw new Error("Expected ; or [ but found " + tokens[1]);
    var name = tokens.shift();
    tokens.shift();
    var val = {
      value: null,
      options: {}
    };
    val.value = Number(tokens.shift());
    if (tokens[0] === "[") {
      val.options = onfieldoptions(tokens);
    }
    tokens.shift();
    return {
      name,
      val
    };
  };
  var onenum = function(tokens) {
    tokens.shift();
    var options = {};
    var e = {
      name: tokens.shift(),
      values: {},
      options: {}
    };
    if (tokens[0] !== "{")
      throw new Error("Expected { but found " + tokens[0]);
    tokens.shift();
    while (tokens.length) {
      if (tokens[0] === "}") {
        tokens.shift();
        if (tokens[0] === ";")
          tokens.shift();
        return e;
      }
      if (tokens[0] === "option") {
        options = onoption(tokens);
        e.options[options.name] = options.value;
        continue;
      }
      var val = onenumvalue(tokens);
      e.values[val.name] = val.val;
    }
    throw new Error("No closing tag for enum");
  };
  var onoption = function(tokens) {
    var name = null;
    var value = null;
    var parse2 = function(value2) {
      if (value2 === "true")
        return true;
      if (value2 === "false")
        return false;
      return value2.replace(/^"+|"+$/gm, "");
    };
    while (tokens.length) {
      if (tokens[0] === ";") {
        tokens.shift();
        return {name, value};
      }
      switch (tokens[0]) {
        case "option":
          tokens.shift();
          var hasBracket = tokens[0] === "(";
          if (hasBracket)
            tokens.shift();
          name = tokens.shift();
          if (hasBracket) {
            if (tokens[0] !== ")")
              throw new Error("Expected ) but found " + tokens[0]);
            tokens.shift();
          }
          if (tokens[0][0] === ".") {
            name += tokens.shift();
          }
          break;
        case "=":
          tokens.shift();
          if (name === null)
            throw new Error("Expected key for option with value: " + tokens[0]);
          value = parse2(tokens.shift());
          if (name === "optimize_for" && !/^(SPEED|CODE_SIZE|LITE_RUNTIME)$/.test(value)) {
            throw new Error("Unexpected value for option optimize_for: " + value);
          } else if (value === "{") {
            value = onoptionMap(tokens);
          }
          break;
        default:
          throw new Error("Unexpected token in option: " + tokens[0]);
      }
    }
  };
  var onoptionMap = function(tokens) {
    var parse2 = function(value2) {
      if (value2 === "true")
        return true;
      if (value2 === "false")
        return false;
      return value2.replace(/^"+|"+$/gm, "");
    };
    var map = {};
    while (tokens.length) {
      if (tokens[0] === "}") {
        tokens.shift();
        return map;
      }
      var hasBracket = tokens[0] === "(";
      if (hasBracket)
        tokens.shift();
      var key = tokens.shift();
      if (hasBracket) {
        if (tokens[0] !== ")")
          throw new Error("Expected ) but found " + tokens[0]);
        tokens.shift();
      }
      var value = null;
      switch (tokens[0]) {
        case ":":
          if (map[key] !== void 0)
            throw new Error("Duplicate option map key " + key);
          tokens.shift();
          value = parse2(tokens.shift());
          if (value === "{") {
            value = onoptionMap(tokens);
          }
          map[key] = value;
          if (tokens[0] === ";") {
            tokens.shift();
          }
          break;
        case "{":
          tokens.shift();
          value = onoptionMap(tokens);
          if (map[key] === void 0)
            map[key] = [];
          if (!Array.isArray(map[key]))
            throw new Error("Duplicate option map key " + key);
          map[key].push(value);
          break;
        default:
          throw new Error("Unexpected token in option map: " + tokens[0]);
      }
    }
    throw new Error("No closing tag for option map");
  };
  var onimport = function(tokens) {
    tokens.shift();
    var file = tokens.shift().replace(/^"+|"+$/gm, "");
    if (tokens[0] !== ";")
      throw new Error("Unexpected token: " + tokens[0] + '. Expected ";"');
    tokens.shift();
    return file;
  };
  var onservice = function(tokens) {
    tokens.shift();
    var service = {
      name: tokens.shift(),
      methods: [],
      options: {}
    };
    if (tokens[0] !== "{")
      throw new Error("Expected { but found " + tokens[0]);
    tokens.shift();
    while (tokens.length) {
      if (tokens[0] === "}") {
        tokens.shift();
        if (tokens[0] === ";")
          tokens.shift();
        return service;
      }
      switch (tokens[0]) {
        case "option":
          var opt = onoption(tokens);
          if (service.options[opt.name] !== void 0)
            throw new Error("Duplicate option " + opt.name);
          service.options[opt.name] = opt.value;
          break;
        case "rpc":
          service.methods.push(onrpc(tokens));
          break;
        default:
          throw new Error("Unexpected token in service: " + tokens[0]);
      }
    }
    throw new Error("No closing tag for service");
  };
  var onrpc = function(tokens) {
    tokens.shift();
    var rpc = {
      name: tokens.shift(),
      input_type: null,
      output_type: null,
      client_streaming: false,
      server_streaming: false,
      options: {}
    };
    if (tokens[0] !== "(")
      throw new Error("Expected ( but found " + tokens[0]);
    tokens.shift();
    if (tokens[0] === "stream") {
      tokens.shift();
      rpc.client_streaming = true;
    }
    rpc.input_type = tokens.shift();
    if (tokens[0] !== ")")
      throw new Error("Expected ) but found " + tokens[0]);
    tokens.shift();
    if (tokens[0] !== "returns")
      throw new Error("Expected returns but found " + tokens[0]);
    tokens.shift();
    if (tokens[0] !== "(")
      throw new Error("Expected ( but found " + tokens[0]);
    tokens.shift();
    if (tokens[0] === "stream") {
      tokens.shift();
      rpc.server_streaming = true;
    }
    rpc.output_type = tokens.shift();
    if (tokens[0] !== ")")
      throw new Error("Expected ) but found " + tokens[0]);
    tokens.shift();
    if (tokens[0] === ";") {
      tokens.shift();
      return rpc;
    }
    if (tokens[0] !== "{")
      throw new Error("Expected { but found " + tokens[0]);
    tokens.shift();
    while (tokens.length) {
      if (tokens[0] === "}") {
        tokens.shift();
        if (tokens[0] === ";")
          tokens.shift();
        return rpc;
      }
      if (tokens[0] === "option") {
        var opt = onoption(tokens);
        if (rpc.options[opt.name] !== void 0)
          throw new Error("Duplicate option " + opt.name);
        rpc.options[opt.name] = opt.value;
      } else {
        throw new Error("Unexpected token in rpc options: " + tokens[0]);
      }
    }
    throw new Error("No closing tag for rpc");
  };
  var parse = function(buf) {
    var tokens = tokenize(buf.toString());
    for (var i = 0; i < tokens.length; i++) {
      if (/^("|')([^'"]*)$/.test(tokens[i])) {
        var j;
        if (tokens[i].length === 1) {
          j = i + 1;
        } else {
          j = i;
        }
        for (j; j < tokens.length; j++) {
          if (/^[^'"\\]*(?:\\.[^'"\\]*)*("|')$/.test(tokens[j])) {
            tokens = tokens.slice(0, i).concat(tokens.slice(i, j + 1).join("")).concat(tokens.slice(j + 1));
            break;
          }
        }
      }
    }
    var schema = {
      syntax: 3,
      package: null,
      imports: [],
      enums: [],
      messages: [],
      options: {},
      extends: []
    };
    var firstline = true;
    while (tokens.length) {
      switch (tokens[0]) {
        case "package":
          schema.package = onpackagename(tokens);
          break;
        case "syntax":
          if (!firstline)
            throw new Error("Protobuf syntax version should be first thing in file");
          schema.syntax = onsyntaxversion(tokens);
          break;
        case "message":
          schema.messages.push(onmessage(tokens));
          break;
        case "enum":
          schema.enums.push(onenum(tokens));
          break;
        case "option":
          var opt = onoption(tokens);
          if (schema.options[opt.name])
            throw new Error("Duplicate option " + opt.name);
          schema.options[opt.name] = opt.value;
          break;
        case "import":
          schema.imports.push(onimport(tokens));
          break;
        case "extend":
          schema.extends.push(onextend(tokens));
          break;
        case "service":
          if (!schema.services)
            schema.services = [];
          schema.services.push(onservice(tokens));
          break;
        default:
          throw new Error("Unexpected token: " + tokens[0]);
      }
      firstline = false;
    }
    schema.extends.forEach(function(ext) {
      schema.messages.forEach(function(msg) {
        if (msg.name === ext.name) {
          ext.message.fields.forEach(function(field) {
            if (!msg.extensions || field.tag < msg.extensions.from || field.tag > msg.extensions.to) {
              throw new Error(msg.name + " does not declare " + field.tag + " as an extension number");
            }
            msg.fields.push(field);
          });
        }
      });
    });
    schema.messages.forEach(function(msg) {
      msg.fields.forEach(function(field) {
        var fieldSplit;
        var messageName;
        var nestedEnumName;
        var message;
        function enumNameIsFieldType(en) {
          return en.name === field.type;
        }
        function enumNameIsNestedEnumName(en) {
          return en.name === nestedEnumName;
        }
        if (field.options && field.options.packed === "true") {
          if (PACKABLE_TYPES.indexOf(field.type) === -1) {
            if (field.type.indexOf(".") === -1) {
              if (msg.enums && msg.enums.some(enumNameIsFieldType)) {
                return;
              }
            } else {
              fieldSplit = field.type.split(".");
              if (fieldSplit.length > 2) {
                throw new Error("what is this?");
              }
              messageName = fieldSplit[0];
              nestedEnumName = fieldSplit[1];
              schema.messages.some(function(msg2) {
                if (msg2.name === messageName) {
                  message = msg2;
                  return msg2;
                }
              });
              if (message && message.enums && message.enums.some(enumNameIsNestedEnumName)) {
                return;
              }
            }
            throw new Error("Fields of type " + field.type + ' cannot be declared [packed=true]. Only repeated fields of primitive numeric types (types which use the varint, 32-bit, or 64-bit wire types) can be declared "packed". See https://developers.google.com/protocol-buffers/docs/encoding#optional');
          }
        }
      });
    });
    return schema;
  };
  module2.exports = parse;
});

// node_modules/protocol-buffers-schema/stringify.js
var require_stringify = __commonJS((exports2, module2) => {
  var onfield = function(f, result) {
    var prefix = f.repeated ? "repeated" : f.required ? "required" : "optional";
    if (f.type === "map")
      prefix = "map<" + f.map.from + "," + f.map.to + ">";
    if (f.oneof)
      prefix = "";
    var opts = Object.keys(f.options || {}).map(function(key) {
      return key + " = " + f.options[key];
    }).join(",");
    if (opts)
      opts = " [" + opts + "]";
    result.push((prefix ? prefix + " " : "") + (f.map === "map" ? "" : f.type + " ") + f.name + " = " + f.tag + opts + ";");
    return result;
  };
  var onmessage = function(m, result) {
    result.push("message " + m.name + " {");
    if (!m.options)
      m.options = {};
    onoption(m.options, result);
    if (!m.enums)
      m.enums = [];
    m.enums.forEach(function(e) {
      result.push(onenum(e, []));
    });
    if (!m.messages)
      m.messages = [];
    m.messages.forEach(function(m2) {
      result.push(onmessage(m2, []));
    });
    var oneofs = {};
    if (!m.fields)
      m.fields = [];
    m.fields.forEach(function(f) {
      if (f.oneof) {
        if (!oneofs[f.oneof])
          oneofs[f.oneof] = [];
        oneofs[f.oneof].push(onfield(f, []));
      } else {
        result.push(onfield(f, []));
      }
    });
    Object.keys(oneofs).forEach(function(n) {
      oneofs[n].unshift("oneof " + n + " {");
      oneofs[n].push("}");
      result.push(oneofs[n]);
    });
    result.push("}", "");
    return result;
  };
  var onenum = function(e, result) {
    result.push("enum " + e.name + " {");
    if (!e.options)
      e.options = {};
    var options = onoption(e.options, []);
    if (options.length > 1) {
      result.push(options.slice(0, -1));
    }
    Object.keys(e.values).map(function(v) {
      var val = onenumvalue(e.values[v]);
      result.push([v + " = " + val + ";"]);
    });
    result.push("}", "");
    return result;
  };
  var onenumvalue = function(v, result) {
    var opts = Object.keys(v.options || {}).map(function(key) {
      return key + " = " + v.options[key];
    }).join(",");
    if (opts)
      opts = " [" + opts + "]";
    var val = v.value + opts;
    return val;
  };
  var onoption = function(o, result) {
    var keys = Object.keys(o);
    keys.forEach(function(option) {
      var v = o[option];
      if (~option.indexOf("."))
        option = "(" + option + ")";
      var type = typeof v;
      if (type === "object") {
        v = onoptionMap(v, []);
        if (v.length)
          result.push("option " + option + " = {", v, "};");
      } else {
        if (type === "string" && option !== "optimize_for")
          v = '"' + v + '"';
        result.push("option " + option + " = " + v + ";");
      }
    });
    if (keys.length > 0) {
      result.push("");
    }
    return result;
  };
  var onoptionMap = function(o, result) {
    var keys = Object.keys(o);
    keys.forEach(function(k) {
      var v = o[k];
      var type = typeof v;
      if (type === "object") {
        if (Array.isArray(v)) {
          v.forEach(function(v2) {
            v2 = onoptionMap(v2, []);
            if (v2.length)
              result.push(k + " {", v2, "}");
          });
        } else {
          v = onoptionMap(v, []);
          if (v.length)
            result.push(k + " {", v, "}");
        }
      } else {
        if (type === "string")
          v = '"' + v + '"';
        result.push(k + ": " + v);
      }
    });
    return result;
  };
  var onservices = function(s, result) {
    result.push("service " + s.name + " {");
    if (!s.options)
      s.options = {};
    onoption(s.options, result);
    if (!s.methods)
      s.methods = [];
    s.methods.forEach(function(m) {
      result.push(onrpc(m, []));
    });
    result.push("}", "");
    return result;
  };
  var onrpc = function(rpc, result) {
    var def = "rpc " + rpc.name + "(";
    if (rpc.client_streaming)
      def += "stream ";
    def += rpc.input_type + ") returns (";
    if (rpc.server_streaming)
      def += "stream ";
    def += rpc.output_type + ")";
    if (!rpc.options)
      rpc.options = {};
    var options = onoption(rpc.options, []);
    if (options.length > 1) {
      result.push(def + " {", options.slice(0, -1), "}");
    } else {
      result.push(def + ";");
    }
    return result;
  };
  var indent = function(lvl) {
    return function(line) {
      if (Array.isArray(line))
        return line.map(indent(lvl + "  ")).join("\n");
      return lvl + line;
    };
  };
  module2.exports = function(schema) {
    var result = [];
    result.push('syntax = "proto' + schema.syntax + '";', "");
    if (schema.package)
      result.push("package " + schema.package + ";", "");
    if (!schema.options)
      schema.options = {};
    onoption(schema.options, result);
    if (!schema.enums)
      schema.enums = [];
    schema.enums.forEach(function(e) {
      onenum(e, result);
    });
    if (!schema.messages)
      schema.messages = [];
    schema.messages.forEach(function(m) {
      onmessage(m, result);
    });
    if (schema.services) {
      schema.services.forEach(function(s) {
        onservices(s, result);
      });
    }
    return result.map(indent("")).join("\n");
  };
});

// node_modules/protocol-buffers-schema/index.js
var require_protocol_buffers_schema = __commonJS((exports2, module2) => {
  var parse = require_parse();
  var stringify = require_stringify();
  module2.exports = parse;
  module2.exports.parse = parse;
  module2.exports.stringify = stringify;
});

// node_modules/protons/src/compile/encodings/encoder.js
var require_encoder = __commonJS((exports2, module2) => {
  "use strict";
  function encoder(type, encode, decode, encodingLength) {
    encode.bytes = decode.bytes = 0;
    return {
      type,
      encode,
      decode,
      encodingLength
    };
  }
  module2.exports = encoder;
});

// node_modules/varint/encode.js
var require_encode3 = __commonJS((exports2, module2) => {
  module2.exports = encode;
  var MSB = 128;
  var REST = 127;
  var MSBALL = ~REST;
  var INT = Math.pow(2, 31);
  function encode(num, out, offset) {
    out = out || [];
    offset = offset || 0;
    var oldOffset = offset;
    while (num >= INT) {
      out[offset++] = num & 255 | MSB;
      num /= 128;
    }
    while (num & MSBALL) {
      out[offset++] = num & 255 | MSB;
      num >>>= 7;
    }
    out[offset] = num | 0;
    encode.bytes = offset - oldOffset + 1;
    return out;
  }
});

// node_modules/varint/decode.js
var require_decode3 = __commonJS((exports2, module2) => {
  module2.exports = read;
  var MSB = 128;
  var REST = 127;
  function read(buf, offset) {
    var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf.length;
    do {
      if (counter >= l) {
        read.bytes = 0;
        throw new RangeError("Could not decode varint");
      }
      b = buf[counter++];
      res += shift < 28 ? (b & REST) << shift : (b & REST) * Math.pow(2, shift);
      shift += 7;
    } while (b >= MSB);
    read.bytes = counter - offset;
    return res;
  }
});

// node_modules/varint/length.js
var require_length3 = __commonJS((exports2, module2) => {
  var N1 = Math.pow(2, 7);
  var N2 = Math.pow(2, 14);
  var N3 = Math.pow(2, 21);
  var N4 = Math.pow(2, 28);
  var N5 = Math.pow(2, 35);
  var N6 = Math.pow(2, 42);
  var N7 = Math.pow(2, 49);
  var N8 = Math.pow(2, 56);
  var N9 = Math.pow(2, 63);
  module2.exports = function(value) {
    return value < N1 ? 1 : value < N2 ? 2 : value < N3 ? 3 : value < N4 ? 4 : value < N5 ? 5 : value < N6 ? 6 : value < N7 ? 7 : value < N8 ? 8 : value < N9 ? 9 : 10;
  };
});

// node_modules/varint/index.js
var require_varint3 = __commonJS((exports2, module2) => {
  module2.exports = {
    encode: require_encode3(),
    decode: require_decode3(),
    encodingLength: require_length3()
  };
});

// node_modules/protons/src/compile/encodings/bytes.js
var require_bytes = __commonJS((exports2, module2) => {
  "use strict";
  var varint = require_varint3();
  var encoder = require_encoder();
  function bytesBufferLength(val) {
    return val.byteLength;
  }
  function bytesEncodingLength(val) {
    const len = bytesBufferLength(val);
    return varint.encodingLength(len) + len;
  }
  function bytesEncode(val, buffer, dataView, offset) {
    const oldOffset = offset;
    const len = bytesBufferLength(val);
    varint.encode(len, buffer, offset);
    offset += varint.encode.bytes;
    buffer.set(val, offset);
    offset += len;
    bytesEncode.bytes = offset - oldOffset;
  }
  function bytesDecode(buffer, dataView, offset) {
    const oldOffset = offset;
    const len = varint.decode(buffer, offset);
    offset += varint.decode.bytes;
    const val = buffer.slice(offset, offset + len);
    offset += val.length;
    bytesDecode.bytes = offset - oldOffset;
    return val;
  }
  module2.exports = encoder(2, bytesEncode, bytesDecode, bytesEncodingLength);
});

// node_modules/protons/src/compile/encodings/string.js
var require_string = __commonJS((exports2, module2) => {
  "use strict";
  var varint = require_varint3();
  var uint8ArrayFromString = require_from_string2();
  var uint8ArrayToString = require_to_string2();
  var encoder = require_encoder();
  function stringEncodingLength(val) {
    const len = uint8ArrayFromString(val).byteLength;
    return varint.encodingLength(len) + len;
  }
  function stringEncode(val, buffer, dataView, offset) {
    const oldOffset = offset;
    const len = uint8ArrayFromString(val).byteLength;
    varint.encode(len, buffer, offset, "utf-8");
    offset += varint.encode.bytes;
    const arr = uint8ArrayFromString(val);
    buffer.set(arr, offset);
    offset += arr.length;
    stringEncode.bytes = offset - oldOffset;
  }
  function stringDecode(buffer, dataView, offset) {
    const oldOffset = offset;
    const len = varint.decode(buffer, offset);
    offset += varint.decode.bytes;
    const val = uint8ArrayToString(buffer.subarray(offset, offset + len));
    offset += len;
    stringDecode.bytes = offset - oldOffset;
    return val;
  }
  module2.exports = encoder(2, stringEncode, stringDecode, stringEncodingLength);
});

// node_modules/protons/src/compile/encodings/bool.js
var require_bool = __commonJS((exports2, module2) => {
  "use strict";
  var encoder = require_encoder();
  function boolEncodingLength() {
    return 1;
  }
  function boolEncode(value, buffer, dataView, offset) {
    buffer[offset] = value ? 1 : 0;
    boolEncode.bytes = 1;
  }
  function boolDecode(buffer, dataView, offset) {
    const bool = buffer[offset] > 0;
    boolDecode.bytes = 1;
    return bool;
  }
  module2.exports = encoder(0, boolEncode, boolDecode, boolEncodingLength);
});

// node_modules/protons/src/compile/encodings/int32.js
var require_int32 = __commonJS((exports2, module2) => {
  "use strict";
  var varint = require_varint3();
  var encoder = require_encoder();
  function in32Encode(val, buffer, dataView, offset) {
    varint.encode(val < 0 ? val + 4294967296 : val, buffer, offset);
    in32Encode.bytes = varint.encode.bytes;
  }
  function int32Decode(buffer, dataView, offset) {
    const val = varint.decode(buffer, offset);
    int32Decode.bytes = varint.decode.bytes;
    return val > 2147483647 ? val - 4294967296 : val;
  }
  function int32EncodingLength(val) {
    return varint.encodingLength(val < 0 ? val + 4294967296 : val);
  }
  module2.exports = encoder(0, in32Encode, int32Decode, int32EncodingLength);
});

// node_modules/protons/src/compile/encodings/int64.js
var require_int64 = __commonJS((exports2, module2) => {
  "use strict";
  var varint = require_varint3();
  var encoder = require_encoder();
  function int64Encode(val, buffer, dataView, offset) {
    if (val < 0) {
      const last = offset + 9;
      varint.encode(val * -1, buffer, offset);
      offset += varint.encode.bytes - 1;
      buffer[offset] = buffer[offset] | 128;
      while (offset < last - 1) {
        offset++;
        buffer[offset] = 255;
      }
      buffer[last] = 1;
      int64Encode.bytes = 10;
    } else {
      varint.encode(val, buffer, offset);
      int64Encode.bytes = varint.encode.bytes;
    }
  }
  function int64Decode(buffer, dataView, offset) {
    let val = varint.decode(buffer, offset);
    if (val >= Math.pow(2, 63)) {
      let limit = 9;
      while (buffer[offset + limit - 1] === 255)
        limit--;
      limit = limit || 9;
      const subset = buffer.subarray(offset, offset + limit);
      subset[limit - 1] = subset[limit - 1] & 127;
      val = -1 * varint.decode(subset, 0);
      int64Decode.bytes = 10;
    } else {
      int64Decode.bytes = varint.decode.bytes;
    }
    return val;
  }
  function int64EncodingLength(val) {
    return val < 0 ? 10 : varint.encodingLength(val);
  }
  module2.exports = encoder(0, int64Encode, int64Decode, int64EncodingLength);
});

// node_modules/signed-varint/index.js
var require_signed_varint = __commonJS((exports2) => {
  var varint = require_varint3();
  exports2.encode = function encode(v, b, o) {
    v = v >= 0 ? v * 2 : v * -2 - 1;
    var r = varint.encode(v, b, o);
    encode.bytes = varint.encode.bytes;
    return r;
  };
  exports2.decode = function decode(b, o) {
    var v = varint.decode(b, o);
    decode.bytes = varint.decode.bytes;
    return v & 1 ? (v + 1) / -2 : v / 2;
  };
  exports2.encodingLength = function(v) {
    return varint.encodingLength(v >= 0 ? v * 2 : v * -2 - 1);
  };
});

// node_modules/protons/src/compile/encodings/sint64.js
var require_sint64 = __commonJS((exports2, module2) => {
  "use strict";
  var svarint = require_signed_varint();
  var encoder = require_encoder();
  function svarintEncode(val, buffer, dataView, offset) {
    svarint.encode(val, buffer, offset);
    svarintEncode.bytes = svarint.encode.bytes;
  }
  function svarintDecode(buffer, dataView, offset) {
    const val = svarint.decode(buffer, offset);
    svarintDecode.bytes = svarint.decode.bytes;
    return val;
  }
  module2.exports = encoder(0, svarintEncode, svarintDecode, svarint.encodingLength);
});

// node_modules/protons/src/compile/encodings/varint.js
var require_varint4 = __commonJS((exports2, module2) => {
  "use strict";
  var varint = require_varint3();
  var encoder = require_encoder();
  function varintEncode(val, buffer, dataView, offset) {
    varint.encode(val, buffer, offset);
    varintEncode.bytes = varint.encode.bytes;
  }
  function varintDecode(buffer, dataView, offset) {
    const val = varint.decode(buffer, offset);
    varintDecode.bytes = varint.decode.bytes;
    return val;
  }
  module2.exports = encoder(0, varintEncode, varintDecode, varint.encodingLength);
});

// node_modules/protons/src/compile/encodings/fixed64.js
var require_fixed64 = __commonJS((exports2, module2) => {
  "use strict";
  var encoder = require_encoder();
  function fixed64EncodingLength() {
    return 8;
  }
  function fixed64Encode(val, buffer, dataView, offset) {
    for (const byte of val) {
      buffer[offset] = byte;
      offset++;
    }
    fixed64Encode.bytes = 8;
  }
  function fixed64Decode(buffer, dataView, offset) {
    const val = buffer.slice(offset, offset + 8);
    fixed64Decode.bytes = 8;
    return val;
  }
  module2.exports = encoder(1, fixed64Encode, fixed64Decode, fixed64EncodingLength);
});

// node_modules/protons/src/compile/encodings/double.js
var require_double = __commonJS((exports2, module2) => {
  "use strict";
  var encoder = require_encoder();
  function doubleEncodingLength() {
    return 8;
  }
  function doubleEncode(val, buffer, dataView, offset) {
    dataView.setFloat64(offset, val, true);
    doubleEncode.bytes = 8;
  }
  function doubleDecode(buffer, dataView, offset) {
    const val = dataView.getFloat64(offset, true);
    doubleDecode.bytes = 8;
    return val;
  }
  module2.exports = encoder(1, doubleEncode, doubleDecode, doubleEncodingLength);
});

// node_modules/protons/src/compile/encodings/fixed32.js
var require_fixed32 = __commonJS((exports2, module2) => {
  "use strict";
  var encoder = require_encoder();
  function fixed32EncodingLength(val) {
    return 4;
  }
  function fixed32Encode(val, buffer, dataView, offset) {
    dataView.setUint32(offset, val, true);
    fixed32Encode.bytes = 4;
  }
  function fixed32Decode(buffer, dataView, offset) {
    const val = dataView.getUint32(offset, true);
    fixed32Decode.bytes = 4;
    return val;
  }
  module2.exports = encoder(5, fixed32Encode, fixed32Decode, fixed32EncodingLength);
});

// node_modules/protons/src/compile/encodings/sfixed32.js
var require_sfixed32 = __commonJS((exports2, module2) => {
  "use strict";
  var encoder = require_encoder();
  function sfixed32EncodingLength(val) {
    return 4;
  }
  function sfixed32Encode(val, buffer, dataView, offset) {
    dataView.setInt32(offset, val, true);
    sfixed32Encode.bytes = 4;
  }
  function sfixed32Decode(buffer, dataView, offset) {
    const val = dataView.getInt32(offset, true);
    sfixed32Decode.bytes = 4;
    return val;
  }
  module2.exports = encoder(5, sfixed32Encode, sfixed32Decode, sfixed32EncodingLength);
});

// node_modules/protons/src/compile/encodings/float.js
var require_float = __commonJS((exports2, module2) => {
  "use strict";
  var encoder = require_encoder();
  function floatEncodingLength() {
    return 4;
  }
  function floatEncode(val, buffer, dataView, offset) {
    dataView.setFloat32(offset, val, true);
    floatEncode.bytes = 4;
  }
  function floatDecode(buffer, dataView, offset) {
    const val = dataView.getFloat32(offset, true);
    floatDecode.bytes = 4;
    return val;
  }
  module2.exports = encoder(5, floatEncode, floatDecode, floatEncodingLength);
});

// node_modules/protons/src/compile/encodings/index.js
var require_encodings = __commonJS((exports2) => {
  "use strict";
  exports2.make = require_encoder();
  exports2.bytes = require_bytes();
  exports2.string = require_string();
  exports2.bool = require_bool();
  exports2.int32 = require_int32();
  exports2.int64 = require_int64();
  exports2.sint32 = exports2.sint64 = require_sint64();
  exports2.uint32 = exports2.uint64 = exports2.enum = exports2.varint = require_varint4();
  exports2.fixed64 = exports2.sfixed64 = require_fixed64();
  exports2.double = require_double();
  exports2.fixed32 = require_fixed32();
  exports2.sfixed32 = require_sfixed32();
  exports2.float = require_float();
});

// node_modules/protons/src/compile/utils.js
var require_utils = __commonJS((exports2) => {
  "use strict";
  exports2.defined = function(val) {
    return val !== null && val !== void 0 && (typeof val !== "number" || !isNaN(val));
  };
});

// node_modules/protons/src/compile/decode.js
var require_decode4 = __commonJS((exports2, module2) => {
  "use strict";
  var varint = require_varint3();
  var defined = require_utils().defined;
  function toSentenceCase(string) {
    return `${string.substring(0, 1).toUpperCase()}${string.substring(1)}`;
  }
  function addPropertyAccessors(obj, name, value, defaultValue2) {
    if (Object.prototype.hasOwnProperty.call(obj, name)) {
      return;
    }
    const sentenceCaseName = toSentenceCase(name);
    Object.defineProperties(obj, {
      [name]: {
        enumerable: true,
        configurable: true,
        set: (val) => {
          value = val;
        },
        get: () => {
          if (value === void 0) {
            return defaultValue2;
          }
          return value;
        }
      },
      [`has${sentenceCaseName}`]: {
        configurable: true,
        value: () => {
          return value !== void 0;
        }
      },
      [`set${sentenceCaseName}`]: {
        configurable: true,
        value: (val) => {
          value = val;
        }
      },
      [`get${sentenceCaseName}`]: {
        configurable: true,
        value: () => {
          return value;
        }
      },
      [`clear${sentenceCaseName}`]: {
        configurable: true,
        value: () => {
          value = void 0;
          obj[name] = void 0;
        }
      }
    });
  }
  function compileDecode(m, resolve, enc) {
    const requiredFields = [];
    const fields = {};
    const oneofFields = [];
    const vals = [];
    for (var i = 0; i < enc.length; i++) {
      const field = m.fields[i];
      fields[field.tag] = i;
      const def = field.options && field.options.default;
      const resolved = resolve(field.type, m.id, false);
      vals[i] = [def, resolved && resolved.values];
      m.fields[i].packed = field.repeated && field.options && field.options.packed && field.options.packed !== "false";
      if (field.required) {
        requiredFields.push(field.name);
      }
      if (field.oneof) {
        oneofFields.push(field.name);
      }
    }
    function decodeField(e, field, obj, buf, dataView, offset, i2) {
      const name = field.name;
      if (field.oneof) {
        const props = Object.keys(obj);
        for (var j = 0; j < props.length; j++) {
          if (oneofFields.indexOf(props[j]) > -1) {
            const sentenceCase = toSentenceCase(props[j]);
            delete obj[`has${sentenceCase}`];
            delete obj[`get${sentenceCase}`];
            delete obj[`set${sentenceCase}`];
            delete obj[`clear${sentenceCase}`];
            delete obj[props[j]];
          }
        }
      }
      let value;
      if (e.message) {
        const len = varint.decode(buf, offset);
        offset += varint.decode.bytes;
        const decoded = e.decode(buf, dataView, offset, offset + len);
        if (field.map) {
          value = obj[name] || {};
          value[decoded.key] = decoded.value;
        } else if (field.repeated) {
          value = obj[name] || [];
          value.push(decoded);
        } else {
          value = decoded;
        }
      } else {
        if (field.repeated) {
          value = obj[name] || [];
          value.push(e.decode(buf, dataView, offset));
        } else {
          value = e.decode(buf, dataView, offset);
        }
      }
      addPropertyAccessors(obj, name, value);
      offset += e.decode.bytes;
      return offset;
    }
    return function decode(buf, view, offset, end) {
      if (offset == null) {
        offset = 0;
      }
      if (end == null) {
        end = buf.length;
      }
      if (!(end <= buf.length && offset <= buf.length)) {
        throw new Error("Decoded message is not valid");
      }
      if (!view) {
        view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
      }
      var oldOffset = offset;
      var obj = {};
      var field;
      while (true) {
        if (end <= offset) {
          var name = "";
          var j = 0;
          for (j = 0; j < requiredFields.length; j++) {
            name = requiredFields[j];
            if (!defined(obj[name])) {
              throw new Error("Decoded message is not valid, missing required field: " + name);
            }
          }
          var val;
          var def;
          for (j = 0; j < enc.length; j++) {
            field = m.fields[j];
            def = vals[j][0];
            val = vals[j][1];
            name = field.name;
            let defaultVal;
            if (Object.prototype.hasOwnProperty.call(obj, name)) {
              continue;
            }
            var done = false;
            if (field.oneof) {
              var props = Object.keys(obj);
              for (var k = 0; k < props.length; k++) {
                if (oneofFields.indexOf(props[k]) > -1) {
                  done = true;
                  break;
                }
              }
            }
            if (done) {
              continue;
            }
            if (val) {
              if (field.repeated) {
                def = [];
              } else {
                def = def && val[def] ? val[def].value : val[Object.keys(val)[0]].value;
                def = parseInt(def || 0, 10);
              }
            } else {
              defaultVal = defaultValue(field);
              def = coerceValue(field, def);
            }
            addPropertyAccessors(obj, name, def, defaultVal);
          }
          decode.bytes = offset - oldOffset;
          return obj;
        }
        var prefix = varint.decode(buf, offset);
        offset += varint.decode.bytes;
        var tag = prefix >> 3;
        var i2 = fields[tag];
        if (i2 == null) {
          offset = skip(prefix & 7, buf, view, offset);
          continue;
        }
        var e = enc[i2];
        field = m.fields[i2];
        if (field.packed) {
          var packedEnd = varint.decode(buf, offset);
          offset += varint.decode.bytes;
          packedEnd += offset;
          while (offset < packedEnd) {
            offset = decodeField(e, field, obj, buf, view, offset, i2);
          }
        } else {
          offset = decodeField(e, field, obj, buf, view, offset, i2);
        }
      }
    };
  }
  var skip = function(type, buffer, view, offset) {
    switch (type) {
      case 0:
        varint.decode(buffer, offset);
        return offset + varint.decode.bytes;
      case 1:
        return offset + 8;
      case 2:
        var len = varint.decode(buffer, offset);
        return offset + varint.decode.bytes + len;
      case 3:
      case 4:
        throw new Error("Groups are not supported");
      case 5:
        return offset + 4;
      default:
        throw new Error("Unknown wire type: " + type);
    }
  };
  var defaultValue = function(f) {
    if (f.map)
      return {};
    if (f.repeated)
      return [];
    switch (f.type) {
      case "string":
        return "";
      case "bool":
        return false;
      case "float":
      case "double":
      case "sfixed32":
      case "fixed32":
      case "varint":
      case "enum":
      case "uint64":
      case "uint32":
      case "int64":
      case "int32":
      case "sint64":
      case "sint32":
        return 0;
      default:
        return null;
    }
  };
  var coerceValue = function(f, def) {
    if (def === void 0) {
      return def;
    }
    switch (f.type) {
      case "bool":
        return def === "true";
      case "float":
      case "double":
      case "sfixed32":
      case "fixed32":
      case "varint":
      case "enum":
      case "uint64":
      case "uint32":
      case "int64":
      case "int32":
      case "sint64":
      case "sint32":
        return parseInt(def, 10);
      default:
        return def;
    }
  };
  module2.exports = compileDecode;
});

// node_modules/protons/src/compile/encode.js
var require_encode4 = __commonJS((exports2, module2) => {
  "use strict";
  var defined = require_utils().defined;
  var varint = require_varint3();
  function compileEncode(m, resolve, enc, oneofs, encodingLength) {
    const oneofsKeys = Object.keys(oneofs);
    const encLength = enc.length;
    const ints = {};
    for (let i = 0; i < encLength; i++) {
      ints[i] = {
        p: varint.encode(m.fields[i].tag << 3 | 2),
        h: varint.encode(m.fields[i].tag << 3 | enc[i].type)
      };
      const field = m.fields[i];
      m.fields[i].packed = field.repeated && field.options && field.options.packed && field.options.packed !== "false";
    }
    function encodeField(buf, view, offset, h, e, packed, innerVal) {
      let j = 0;
      if (!packed) {
        for (j = 0; j < h.length; j++) {
          buf[offset++] = h[j];
        }
      }
      if (e.message) {
        varint.encode(e.encodingLength(innerVal), buf, offset);
        offset += varint.encode.bytes;
      }
      e.encode(innerVal, buf, view, offset);
      return offset + e.encode.bytes;
    }
    return function encode(obj, buf, view, offset = 0) {
      if (buf == null) {
        buf = new Uint8Array(encodingLength(obj));
      }
      if (view == null) {
        view = new DataView(buf.buffer, buf.byteOffset, buf.byteLength);
      }
      const oldOffset = offset;
      const objKeys = Object.keys(obj);
      let i = 0;
      let match = false;
      for (i = 0; i < oneofsKeys.length; i++) {
        const name = oneofsKeys[i];
        const prop = oneofs[i];
        if (objKeys.indexOf(prop) > -1) {
          if (match) {
            throw new Error("only one of the properties defined in oneof " + name + " can be set");
          }
          match = true;
        }
      }
      for (i = 0; i < encLength; i++) {
        const e = enc[i];
        const field = m.fields[i];
        let val = obj[field.name];
        let j = 0;
        if (!defined(val)) {
          if (field.required) {
            throw new Error(field.name + " is required");
          }
          continue;
        }
        const p = ints[i].p;
        const h = ints[i].h;
        const packed = field.packed;
        if (field.map) {
          const tmp = Object.keys(val);
          for (j = 0; j < tmp.length; j++) {
            tmp[j] = {
              key: tmp[j],
              value: val[tmp[j]]
            };
          }
          val = tmp;
        }
        if (packed) {
          let packedLen = 0;
          for (j = 0; j < val.length; j++) {
            if (!Object.prototype.hasOwnProperty.call(val, j)) {
              continue;
            }
            packedLen += e.encodingLength(val[j]);
          }
          if (packedLen) {
            for (j = 0; j < h.length; j++) {
              buf[offset++] = p[j];
            }
            varint.encode(packedLen, buf, offset);
            offset += varint.encode.bytes;
          }
        }
        if (field.repeated) {
          let innerVal;
          for (j = 0; j < val.length; j++) {
            innerVal = val[j];
            if (!defined(innerVal)) {
              continue;
            }
            offset = encodeField(buf, view, offset, h, e, packed, innerVal);
          }
        } else {
          offset = encodeField(buf, view, offset, h, e, packed, val);
        }
      }
      encode.bytes = offset - oldOffset;
      return buf;
    };
  }
  module2.exports = compileEncode;
});

// node_modules/protons/src/compile/encoding-length.js
var require_encoding_length = __commonJS((exports2, module2) => {
  "use strict";
  var defined = require_utils().defined;
  var varint = require_varint3();
  function compileEncodingLength(m, enc, oneofs) {
    const oneofsKeys = Object.keys(oneofs);
    const encLength = enc.length;
    const hls = new Array(encLength);
    for (let i = 0; i < m.fields.length; i++) {
      hls[i] = varint.encodingLength(m.fields[i].tag << 3 | enc[i].type);
      const field = m.fields[i];
      m.fields[i].packed = field.repeated && field.options && field.options.packed && field.options.packed !== "false";
    }
    return function encodingLength(obj) {
      let length = 0;
      let i = 0;
      let j = 0;
      for (i = 0; i < oneofsKeys.length; i++) {
        const name = oneofsKeys[i];
        const props = oneofs[name];
        let match = false;
        for (j = 0; j < props.length; j++) {
          if (defined(obj[props[j]])) {
            if (match) {
              throw new Error("only one of the properties defined in oneof " + name + " can be set");
            }
            match = true;
          }
        }
      }
      for (i = 0; i < encLength; i++) {
        const e = enc[i];
        const field = m.fields[i];
        let val = obj[field.name];
        const hl = hls[i];
        let len;
        if (!defined(val)) {
          if (field.required) {
            throw new Error(field.name + " is required");
          }
          continue;
        }
        if (field.map) {
          const tmp = Object.keys(val);
          for (j = 0; j < tmp.length; j++) {
            tmp[j] = {
              key: tmp[j],
              value: val[tmp[j]]
            };
          }
          val = tmp;
        }
        if (field.packed) {
          let packedLen = 0;
          for (j = 0; j < val.length; j++) {
            if (!defined(val[j])) {
              continue;
            }
            len = e.encodingLength(val[j]);
            packedLen += len;
            if (e.message) {
              packedLen += varint.encodingLength(len);
            }
          }
          if (packedLen) {
            length += hl + packedLen + varint.encodingLength(packedLen);
          }
        } else if (field.repeated) {
          for (j = 0; j < val.length; j++) {
            if (!defined(val[j])) {
              continue;
            }
            len = e.encodingLength(val[j]);
            length += hl + len + (e.message ? varint.encodingLength(len) : 0);
          }
        } else {
          len = e.encodingLength(val);
          length += hl + len + (e.message ? varint.encodingLength(len) : 0);
        }
      }
      return length;
    };
  }
  module2.exports = compileEncodingLength;
});

// node_modules/protons/src/compile/index.js
var require_compile = __commonJS((exports2, module2) => {
  "use strict";
  var encodings = require_encodings();
  var compileDecode = require_decode4();
  var compileEncode = require_encode4();
  var compileEncodingLength = require_encoding_length();
  var varint = require_varint3();
  var flatten = function(values) {
    if (!values)
      return null;
    const result = {};
    Object.keys(values).forEach(function(k) {
      result[k] = values[k].value;
    });
    return result;
  };
  module2.exports = function(schema, extraEncodings) {
    const messages = {};
    const enums = {};
    const cache = {};
    const visit = function(schema2, prefix) {
      if (schema2.enums) {
        schema2.enums.forEach(function(e) {
          e.id = prefix + (prefix ? "." : "") + e.name;
          enums[e.id] = e;
          visit(e, e.id);
        });
      }
      if (schema2.messages) {
        schema2.messages.forEach(function(m) {
          m.id = prefix + (prefix ? "." : "") + m.name;
          messages[m.id] = m;
          m.fields.forEach(function(f) {
            if (!f.map)
              return;
            const name = "Map_" + f.map.from + "_" + f.map.to;
            const map = {
              name,
              enums: [],
              messages: [],
              fields: [{
                name: "key",
                type: f.map.from,
                tag: 1,
                repeated: false,
                required: true
              }, {
                name: "value",
                type: f.map.to,
                tag: 2,
                repeated: false,
                required: false
              }],
              extensions: null,
              id: prefix + (prefix ? "." : "") + name
            };
            if (!messages[map.id]) {
              messages[map.id] = map;
              schema2.messages.push(map);
            }
            f.type = name;
            f.repeated = true;
          });
          visit(m, m.id);
        });
      }
    };
    visit(schema, "");
    const compileEnum = function(e) {
      const values = Object.keys(e.values || []).map(function(k) {
        return parseInt(e.values[k].value, 10);
      });
      const encode = function enumEncode(val, buf, view, offset) {
        if (!values.length || values.indexOf(val) === -1) {
          throw new Error("Invalid enum value: " + val);
        }
        varint.encode(val, buf, offset);
        enumEncode.bytes = varint.encode.bytes;
        return buf;
      };
      const decode = function enumDecode(buf, view, offset) {
        var val = varint.decode(buf, offset);
        if (!values.length || values.indexOf(val) === -1) {
          throw new Error("Invalid enum value: " + val);
        }
        enumDecode.bytes = varint.decode.bytes;
        return val;
      };
      return encodings.make(0, encode, decode, varint.encodingLength);
    };
    const compileMessage = function(m, exports3) {
      m.messages.forEach(function(nested) {
        exports3[nested.name] = resolve(nested.name, m.id);
      });
      m.enums.forEach(function(val) {
        exports3[val.name] = flatten(val.values);
      });
      exports3.type = 2;
      exports3.message = true;
      exports3.name = m.name;
      const oneofs = {};
      m.fields.forEach(function(f) {
        if (!f.oneof)
          return;
        if (!oneofs[f.oneof])
          oneofs[f.oneof] = [];
        oneofs[f.oneof].push(f.name);
      });
      const enc = m.fields.map(function(f) {
        return resolve(f.type, m.id);
      });
      const encodingLength = compileEncodingLength(m, enc, oneofs);
      const encode = compileEncode(m, resolve, enc, oneofs, encodingLength);
      const decode = compileDecode(m, resolve, enc);
      encode.bytes = decode.bytes = 0;
      exports3.buffer = true;
      exports3.encode = encode;
      exports3.decode = decode;
      exports3.encodingLength = encodingLength;
      return exports3;
    };
    const resolve = function(name, from, compile) {
      if (extraEncodings && extraEncodings[name])
        return extraEncodings[name];
      if (encodings[name])
        return encodings[name];
      const m = (from ? from + "." + name : name).split(".").map(function(part, i, list) {
        return list.slice(0, i).concat(name).join(".");
      }).reverse().reduce(function(result, id) {
        return result || messages[id] || enums[id];
      }, null);
      if (compile === false)
        return m;
      if (!m)
        throw new Error("Could not resolve " + name);
      if (m.values)
        return compileEnum(m);
      const res = cache[m.id] || compileMessage(m, cache[m.id] = {});
      return res;
    };
    return (schema.enums || []).concat((schema.messages || []).map(function(message) {
      return resolve(message.id);
    }));
  };
});

// node_modules/protons/src/index.js
var require_src8 = __commonJS((exports2, module2) => {
  "use strict";
  var schema = require_protocol_buffers_schema();
  var compile = require_compile();
  var flatten = function(values) {
    if (!values)
      return null;
    var result = {};
    Object.keys(values).forEach(function(k) {
      result[k] = values[k].value;
    });
    return result;
  };
  module2.exports = function(proto, opts) {
    if (!opts)
      opts = {};
    if (!proto)
      throw new Error("Pass in a .proto string or a protobuf-schema parsed object");
    var sch = typeof proto === "object" && !(proto instanceof Uint8Array) ? proto : schema.parse(proto);
    var Messages = function() {
      var self2 = this;
      compile(sch, opts.encodings || {}).forEach(function(m) {
        self2[m.name] = flatten(m.values) || m;
      });
    };
    Messages.prototype.toString = function() {
      return schema.stringify(sch);
    };
    Messages.prototype.toJSON = function() {
      return sch;
    };
    return new Messages();
  };
});

// node_modules/libp2p-crypto/src/keys/keys.proto.js
var require_keys_proto = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = `enum KeyType {
  RSA = 0;
  Ed25519 = 1;
  Secp256k1 = 2;
}
message PublicKey {
  required KeyType Type = 1;
  required bytes Data = 2;
}
message PrivateKey {
  required KeyType Type = 1;
  required bytes Data = 2;
}`;
});

// node_modules/node-forge/lib/forge.js
var require_forge = __commonJS((exports2, module2) => {
  module2.exports = {
    options: {
      usePureJavaScript: false
    }
  };
});

// node_modules/node-forge/lib/baseN.js
var require_baseN = __commonJS((exports2, module2) => {
  var api = {};
  module2.exports = api;
  var _reverseAlphabets = {};
  api.encode = function(input, alphabet, maxline) {
    if (typeof alphabet !== "string") {
      throw new TypeError('"alphabet" must be a string.');
    }
    if (maxline !== void 0 && typeof maxline !== "number") {
      throw new TypeError('"maxline" must be a number.');
    }
    var output = "";
    if (!(input instanceof Uint8Array)) {
      output = _encodeWithByteBuffer(input, alphabet);
    } else {
      var i = 0;
      var base = alphabet.length;
      var first = alphabet.charAt(0);
      var digits = [0];
      for (i = 0; i < input.length; ++i) {
        for (var j = 0, carry = input[i]; j < digits.length; ++j) {
          carry += digits[j] << 8;
          digits[j] = carry % base;
          carry = carry / base | 0;
        }
        while (carry > 0) {
          digits.push(carry % base);
          carry = carry / base | 0;
        }
      }
      for (i = 0; input[i] === 0 && i < input.length - 1; ++i) {
        output += first;
      }
      for (i = digits.length - 1; i >= 0; --i) {
        output += alphabet[digits[i]];
      }
    }
    if (maxline) {
      var regex = new RegExp(".{1," + maxline + "}", "g");
      output = output.match(regex).join("\r\n");
    }
    return output;
  };
  api.decode = function(input, alphabet) {
    if (typeof input !== "string") {
      throw new TypeError('"input" must be a string.');
    }
    if (typeof alphabet !== "string") {
      throw new TypeError('"alphabet" must be a string.');
    }
    var table = _reverseAlphabets[alphabet];
    if (!table) {
      table = _reverseAlphabets[alphabet] = [];
      for (var i = 0; i < alphabet.length; ++i) {
        table[alphabet.charCodeAt(i)] = i;
      }
    }
    input = input.replace(/\s/g, "");
    var base = alphabet.length;
    var first = alphabet.charAt(0);
    var bytes = [0];
    for (var i = 0; i < input.length; i++) {
      var value = table[input.charCodeAt(i)];
      if (value === void 0) {
        return;
      }
      for (var j = 0, carry = value; j < bytes.length; ++j) {
        carry += bytes[j] * base;
        bytes[j] = carry & 255;
        carry >>= 8;
      }
      while (carry > 0) {
        bytes.push(carry & 255);
        carry >>= 8;
      }
    }
    for (var k = 0; input[k] === first && k < input.length - 1; ++k) {
      bytes.push(0);
    }
    if (typeof Buffer !== "undefined") {
      return Buffer.from(bytes.reverse());
    }
    return new Uint8Array(bytes.reverse());
  };
  function _encodeWithByteBuffer(input, alphabet) {
    var i = 0;
    var base = alphabet.length;
    var first = alphabet.charAt(0);
    var digits = [0];
    for (i = 0; i < input.length(); ++i) {
      for (var j = 0, carry = input.at(i); j < digits.length; ++j) {
        carry += digits[j] << 8;
        digits[j] = carry % base;
        carry = carry / base | 0;
      }
      while (carry > 0) {
        digits.push(carry % base);
        carry = carry / base | 0;
      }
    }
    var output = "";
    for (i = 0; input.at(i) === 0 && i < input.length() - 1; ++i) {
      output += first;
    }
    for (i = digits.length - 1; i >= 0; --i) {
      output += alphabet[digits[i]];
    }
    return output;
  }
});

// node_modules/node-forge/lib/util.js
var require_util3 = __commonJS((exports2, module2) => {
  var forge = require_forge();
  var baseN = require_baseN();
  var util = module2.exports = forge.util = forge.util || {};
  (function() {
    if (typeof process !== "undefined" && process.nextTick && !process.browser) {
      util.nextTick = process.nextTick;
      if (typeof setImmediate === "function") {
        util.setImmediate = setImmediate;
      } else {
        util.setImmediate = util.nextTick;
      }
      return;
    }
    if (typeof setImmediate === "function") {
      util.setImmediate = function() {
        return setImmediate.apply(void 0, arguments);
      };
      util.nextTick = function(callback) {
        return setImmediate(callback);
      };
      return;
    }
    util.setImmediate = function(callback) {
      setTimeout(callback, 0);
    };
    if (typeof window !== "undefined" && typeof window.postMessage === "function") {
      var msg = "forge.setImmediate";
      var callbacks = [];
      util.setImmediate = function(callback) {
        callbacks.push(callback);
        if (callbacks.length === 1) {
          window.postMessage(msg, "*");
        }
      };
      function handler(event) {
        if (event.source === window && event.data === msg) {
          event.stopPropagation();
          var copy = callbacks.slice();
          callbacks.length = 0;
          copy.forEach(function(callback) {
            callback();
          });
        }
      }
      window.addEventListener("message", handler, true);
    }
    if (typeof MutationObserver !== "undefined") {
      var now = Date.now();
      var attr = true;
      var div = document.createElement("div");
      var callbacks = [];
      new MutationObserver(function() {
        var copy = callbacks.slice();
        callbacks.length = 0;
        copy.forEach(function(callback) {
          callback();
        });
      }).observe(div, {attributes: true});
      var oldSetImmediate = util.setImmediate;
      util.setImmediate = function(callback) {
        if (Date.now() - now > 15) {
          now = Date.now();
          oldSetImmediate(callback);
        } else {
          callbacks.push(callback);
          if (callbacks.length === 1) {
            div.setAttribute("a", attr = !attr);
          }
        }
      };
    }
    util.nextTick = util.setImmediate;
  })();
  util.isNodejs = typeof process !== "undefined" && process.versions && process.versions.node;
  util.globalScope = function() {
    if (util.isNodejs) {
      return global;
    }
    return typeof self === "undefined" ? window : self;
  }();
  util.isArray = Array.isArray || function(x) {
    return Object.prototype.toString.call(x) === "[object Array]";
  };
  util.isArrayBuffer = function(x) {
    return typeof ArrayBuffer !== "undefined" && x instanceof ArrayBuffer;
  };
  util.isArrayBufferView = function(x) {
    return x && util.isArrayBuffer(x.buffer) && x.byteLength !== void 0;
  };
  function _checkBitsParam(n) {
    if (!(n === 8 || n === 16 || n === 24 || n === 32)) {
      throw new Error("Only 8, 16, 24, or 32 bits supported: " + n);
    }
  }
  util.ByteBuffer = ByteStringBuffer;
  function ByteStringBuffer(b) {
    this.data = "";
    this.read = 0;
    if (typeof b === "string") {
      this.data = b;
    } else if (util.isArrayBuffer(b) || util.isArrayBufferView(b)) {
      if (typeof Buffer !== "undefined" && b instanceof Buffer) {
        this.data = b.toString("binary");
      } else {
        var arr = new Uint8Array(b);
        try {
          this.data = String.fromCharCode.apply(null, arr);
        } catch (e) {
          for (var i = 0; i < arr.length; ++i) {
            this.putByte(arr[i]);
          }
        }
      }
    } else if (b instanceof ByteStringBuffer || typeof b === "object" && typeof b.data === "string" && typeof b.read === "number") {
      this.data = b.data;
      this.read = b.read;
    }
    this._constructedStringLength = 0;
  }
  util.ByteStringBuffer = ByteStringBuffer;
  var _MAX_CONSTRUCTED_STRING_LENGTH = 4096;
  util.ByteStringBuffer.prototype._optimizeConstructedString = function(x) {
    this._constructedStringLength += x;
    if (this._constructedStringLength > _MAX_CONSTRUCTED_STRING_LENGTH) {
      this.data.substr(0, 1);
      this._constructedStringLength = 0;
    }
  };
  util.ByteStringBuffer.prototype.length = function() {
    return this.data.length - this.read;
  };
  util.ByteStringBuffer.prototype.isEmpty = function() {
    return this.length() <= 0;
  };
  util.ByteStringBuffer.prototype.putByte = function(b) {
    return this.putBytes(String.fromCharCode(b));
  };
  util.ByteStringBuffer.prototype.fillWithByte = function(b, n) {
    b = String.fromCharCode(b);
    var d = this.data;
    while (n > 0) {
      if (n & 1) {
        d += b;
      }
      n >>>= 1;
      if (n > 0) {
        b += b;
      }
    }
    this.data = d;
    this._optimizeConstructedString(n);
    return this;
  };
  util.ByteStringBuffer.prototype.putBytes = function(bytes) {
    this.data += bytes;
    this._optimizeConstructedString(bytes.length);
    return this;
  };
  util.ByteStringBuffer.prototype.putString = function(str) {
    return this.putBytes(util.encodeUtf8(str));
  };
  util.ByteStringBuffer.prototype.putInt16 = function(i) {
    return this.putBytes(String.fromCharCode(i >> 8 & 255) + String.fromCharCode(i & 255));
  };
  util.ByteStringBuffer.prototype.putInt24 = function(i) {
    return this.putBytes(String.fromCharCode(i >> 16 & 255) + String.fromCharCode(i >> 8 & 255) + String.fromCharCode(i & 255));
  };
  util.ByteStringBuffer.prototype.putInt32 = function(i) {
    return this.putBytes(String.fromCharCode(i >> 24 & 255) + String.fromCharCode(i >> 16 & 255) + String.fromCharCode(i >> 8 & 255) + String.fromCharCode(i & 255));
  };
  util.ByteStringBuffer.prototype.putInt16Le = function(i) {
    return this.putBytes(String.fromCharCode(i & 255) + String.fromCharCode(i >> 8 & 255));
  };
  util.ByteStringBuffer.prototype.putInt24Le = function(i) {
    return this.putBytes(String.fromCharCode(i & 255) + String.fromCharCode(i >> 8 & 255) + String.fromCharCode(i >> 16 & 255));
  };
  util.ByteStringBuffer.prototype.putInt32Le = function(i) {
    return this.putBytes(String.fromCharCode(i & 255) + String.fromCharCode(i >> 8 & 255) + String.fromCharCode(i >> 16 & 255) + String.fromCharCode(i >> 24 & 255));
  };
  util.ByteStringBuffer.prototype.putInt = function(i, n) {
    _checkBitsParam(n);
    var bytes = "";
    do {
      n -= 8;
      bytes += String.fromCharCode(i >> n & 255);
    } while (n > 0);
    return this.putBytes(bytes);
  };
  util.ByteStringBuffer.prototype.putSignedInt = function(i, n) {
    if (i < 0) {
      i += 2 << n - 1;
    }
    return this.putInt(i, n);
  };
  util.ByteStringBuffer.prototype.putBuffer = function(buffer) {
    return this.putBytes(buffer.getBytes());
  };
  util.ByteStringBuffer.prototype.getByte = function() {
    return this.data.charCodeAt(this.read++);
  };
  util.ByteStringBuffer.prototype.getInt16 = function() {
    var rval = this.data.charCodeAt(this.read) << 8 ^ this.data.charCodeAt(this.read + 1);
    this.read += 2;
    return rval;
  };
  util.ByteStringBuffer.prototype.getInt24 = function() {
    var rval = this.data.charCodeAt(this.read) << 16 ^ this.data.charCodeAt(this.read + 1) << 8 ^ this.data.charCodeAt(this.read + 2);
    this.read += 3;
    return rval;
  };
  util.ByteStringBuffer.prototype.getInt32 = function() {
    var rval = this.data.charCodeAt(this.read) << 24 ^ this.data.charCodeAt(this.read + 1) << 16 ^ this.data.charCodeAt(this.read + 2) << 8 ^ this.data.charCodeAt(this.read + 3);
    this.read += 4;
    return rval;
  };
  util.ByteStringBuffer.prototype.getInt16Le = function() {
    var rval = this.data.charCodeAt(this.read) ^ this.data.charCodeAt(this.read + 1) << 8;
    this.read += 2;
    return rval;
  };
  util.ByteStringBuffer.prototype.getInt24Le = function() {
    var rval = this.data.charCodeAt(this.read) ^ this.data.charCodeAt(this.read + 1) << 8 ^ this.data.charCodeAt(this.read + 2) << 16;
    this.read += 3;
    return rval;
  };
  util.ByteStringBuffer.prototype.getInt32Le = function() {
    var rval = this.data.charCodeAt(this.read) ^ this.data.charCodeAt(this.read + 1) << 8 ^ this.data.charCodeAt(this.read + 2) << 16 ^ this.data.charCodeAt(this.read + 3) << 24;
    this.read += 4;
    return rval;
  };
  util.ByteStringBuffer.prototype.getInt = function(n) {
    _checkBitsParam(n);
    var rval = 0;
    do {
      rval = (rval << 8) + this.data.charCodeAt(this.read++);
      n -= 8;
    } while (n > 0);
    return rval;
  };
  util.ByteStringBuffer.prototype.getSignedInt = function(n) {
    var x = this.getInt(n);
    var max = 2 << n - 2;
    if (x >= max) {
      x -= max << 1;
    }
    return x;
  };
  util.ByteStringBuffer.prototype.getBytes = function(count) {
    var rval;
    if (count) {
      count = Math.min(this.length(), count);
      rval = this.data.slice(this.read, this.read + count);
      this.read += count;
    } else if (count === 0) {
      rval = "";
    } else {
      rval = this.read === 0 ? this.data : this.data.slice(this.read);
      this.clear();
    }
    return rval;
  };
  util.ByteStringBuffer.prototype.bytes = function(count) {
    return typeof count === "undefined" ? this.data.slice(this.read) : this.data.slice(this.read, this.read + count);
  };
  util.ByteStringBuffer.prototype.at = function(i) {
    return this.data.charCodeAt(this.read + i);
  };
  util.ByteStringBuffer.prototype.setAt = function(i, b) {
    this.data = this.data.substr(0, this.read + i) + String.fromCharCode(b) + this.data.substr(this.read + i + 1);
    return this;
  };
  util.ByteStringBuffer.prototype.last = function() {
    return this.data.charCodeAt(this.data.length - 1);
  };
  util.ByteStringBuffer.prototype.copy = function() {
    var c = util.createBuffer(this.data);
    c.read = this.read;
    return c;
  };
  util.ByteStringBuffer.prototype.compact = function() {
    if (this.read > 0) {
      this.data = this.data.slice(this.read);
      this.read = 0;
    }
    return this;
  };
  util.ByteStringBuffer.prototype.clear = function() {
    this.data = "";
    this.read = 0;
    return this;
  };
  util.ByteStringBuffer.prototype.truncate = function(count) {
    var len = Math.max(0, this.length() - count);
    this.data = this.data.substr(this.read, len);
    this.read = 0;
    return this;
  };
  util.ByteStringBuffer.prototype.toHex = function() {
    var rval = "";
    for (var i = this.read; i < this.data.length; ++i) {
      var b = this.data.charCodeAt(i);
      if (b < 16) {
        rval += "0";
      }
      rval += b.toString(16);
    }
    return rval;
  };
  util.ByteStringBuffer.prototype.toString = function() {
    return util.decodeUtf8(this.bytes());
  };
  function DataBuffer(b, options) {
    options = options || {};
    this.read = options.readOffset || 0;
    this.growSize = options.growSize || 1024;
    var isArrayBuffer = util.isArrayBuffer(b);
    var isArrayBufferView = util.isArrayBufferView(b);
    if (isArrayBuffer || isArrayBufferView) {
      if (isArrayBuffer) {
        this.data = new DataView(b);
      } else {
        this.data = new DataView(b.buffer, b.byteOffset, b.byteLength);
      }
      this.write = "writeOffset" in options ? options.writeOffset : this.data.byteLength;
      return;
    }
    this.data = new DataView(new ArrayBuffer(0));
    this.write = 0;
    if (b !== null && b !== void 0) {
      this.putBytes(b);
    }
    if ("writeOffset" in options) {
      this.write = options.writeOffset;
    }
  }
  util.DataBuffer = DataBuffer;
  util.DataBuffer.prototype.length = function() {
    return this.write - this.read;
  };
  util.DataBuffer.prototype.isEmpty = function() {
    return this.length() <= 0;
  };
  util.DataBuffer.prototype.accommodate = function(amount, growSize) {
    if (this.length() >= amount) {
      return this;
    }
    growSize = Math.max(growSize || this.growSize, amount);
    var src = new Uint8Array(this.data.buffer, this.data.byteOffset, this.data.byteLength);
    var dst = new Uint8Array(this.length() + growSize);
    dst.set(src);
    this.data = new DataView(dst.buffer);
    return this;
  };
  util.DataBuffer.prototype.putByte = function(b) {
    this.accommodate(1);
    this.data.setUint8(this.write++, b);
    return this;
  };
  util.DataBuffer.prototype.fillWithByte = function(b, n) {
    this.accommodate(n);
    for (var i = 0; i < n; ++i) {
      this.data.setUint8(b);
    }
    return this;
  };
  util.DataBuffer.prototype.putBytes = function(bytes, encoding) {
    if (util.isArrayBufferView(bytes)) {
      var src = new Uint8Array(bytes.buffer, bytes.byteOffset, bytes.byteLength);
      var len = src.byteLength - src.byteOffset;
      this.accommodate(len);
      var dst = new Uint8Array(this.data.buffer, this.write);
      dst.set(src);
      this.write += len;
      return this;
    }
    if (util.isArrayBuffer(bytes)) {
      var src = new Uint8Array(bytes);
      this.accommodate(src.byteLength);
      var dst = new Uint8Array(this.data.buffer);
      dst.set(src, this.write);
      this.write += src.byteLength;
      return this;
    }
    if (bytes instanceof util.DataBuffer || typeof bytes === "object" && typeof bytes.read === "number" && typeof bytes.write === "number" && util.isArrayBufferView(bytes.data)) {
      var src = new Uint8Array(bytes.data.byteLength, bytes.read, bytes.length());
      this.accommodate(src.byteLength);
      var dst = new Uint8Array(bytes.data.byteLength, this.write);
      dst.set(src);
      this.write += src.byteLength;
      return this;
    }
    if (bytes instanceof util.ByteStringBuffer) {
      bytes = bytes.data;
      encoding = "binary";
    }
    encoding = encoding || "binary";
    if (typeof bytes === "string") {
      var view;
      if (encoding === "hex") {
        this.accommodate(Math.ceil(bytes.length / 2));
        view = new Uint8Array(this.data.buffer, this.write);
        this.write += util.binary.hex.decode(bytes, view, this.write);
        return this;
      }
      if (encoding === "base64") {
        this.accommodate(Math.ceil(bytes.length / 4) * 3);
        view = new Uint8Array(this.data.buffer, this.write);
        this.write += util.binary.base64.decode(bytes, view, this.write);
        return this;
      }
      if (encoding === "utf8") {
        bytes = util.encodeUtf8(bytes);
        encoding = "binary";
      }
      if (encoding === "binary" || encoding === "raw") {
        this.accommodate(bytes.length);
        view = new Uint8Array(this.data.buffer, this.write);
        this.write += util.binary.raw.decode(view);
        return this;
      }
      if (encoding === "utf16") {
        this.accommodate(bytes.length * 2);
        view = new Uint16Array(this.data.buffer, this.write);
        this.write += util.text.utf16.encode(view);
        return this;
      }
      throw new Error("Invalid encoding: " + encoding);
    }
    throw Error("Invalid parameter: " + bytes);
  };
  util.DataBuffer.prototype.putBuffer = function(buffer) {
    this.putBytes(buffer);
    buffer.clear();
    return this;
  };
  util.DataBuffer.prototype.putString = function(str) {
    return this.putBytes(str, "utf16");
  };
  util.DataBuffer.prototype.putInt16 = function(i) {
    this.accommodate(2);
    this.data.setInt16(this.write, i);
    this.write += 2;
    return this;
  };
  util.DataBuffer.prototype.putInt24 = function(i) {
    this.accommodate(3);
    this.data.setInt16(this.write, i >> 8 & 65535);
    this.data.setInt8(this.write, i >> 16 & 255);
    this.write += 3;
    return this;
  };
  util.DataBuffer.prototype.putInt32 = function(i) {
    this.accommodate(4);
    this.data.setInt32(this.write, i);
    this.write += 4;
    return this;
  };
  util.DataBuffer.prototype.putInt16Le = function(i) {
    this.accommodate(2);
    this.data.setInt16(this.write, i, true);
    this.write += 2;
    return this;
  };
  util.DataBuffer.prototype.putInt24Le = function(i) {
    this.accommodate(3);
    this.data.setInt8(this.write, i >> 16 & 255);
    this.data.setInt16(this.write, i >> 8 & 65535, true);
    this.write += 3;
    return this;
  };
  util.DataBuffer.prototype.putInt32Le = function(i) {
    this.accommodate(4);
    this.data.setInt32(this.write, i, true);
    this.write += 4;
    return this;
  };
  util.DataBuffer.prototype.putInt = function(i, n) {
    _checkBitsParam(n);
    this.accommodate(n / 8);
    do {
      n -= 8;
      this.data.setInt8(this.write++, i >> n & 255);
    } while (n > 0);
    return this;
  };
  util.DataBuffer.prototype.putSignedInt = function(i, n) {
    _checkBitsParam(n);
    this.accommodate(n / 8);
    if (i < 0) {
      i += 2 << n - 1;
    }
    return this.putInt(i, n);
  };
  util.DataBuffer.prototype.getByte = function() {
    return this.data.getInt8(this.read++);
  };
  util.DataBuffer.prototype.getInt16 = function() {
    var rval = this.data.getInt16(this.read);
    this.read += 2;
    return rval;
  };
  util.DataBuffer.prototype.getInt24 = function() {
    var rval = this.data.getInt16(this.read) << 8 ^ this.data.getInt8(this.read + 2);
    this.read += 3;
    return rval;
  };
  util.DataBuffer.prototype.getInt32 = function() {
    var rval = this.data.getInt32(this.read);
    this.read += 4;
    return rval;
  };
  util.DataBuffer.prototype.getInt16Le = function() {
    var rval = this.data.getInt16(this.read, true);
    this.read += 2;
    return rval;
  };
  util.DataBuffer.prototype.getInt24Le = function() {
    var rval = this.data.getInt8(this.read) ^ this.data.getInt16(this.read + 1, true) << 8;
    this.read += 3;
    return rval;
  };
  util.DataBuffer.prototype.getInt32Le = function() {
    var rval = this.data.getInt32(this.read, true);
    this.read += 4;
    return rval;
  };
  util.DataBuffer.prototype.getInt = function(n) {
    _checkBitsParam(n);
    var rval = 0;
    do {
      rval = (rval << 8) + this.data.getInt8(this.read++);
      n -= 8;
    } while (n > 0);
    return rval;
  };
  util.DataBuffer.prototype.getSignedInt = function(n) {
    var x = this.getInt(n);
    var max = 2 << n - 2;
    if (x >= max) {
      x -= max << 1;
    }
    return x;
  };
  util.DataBuffer.prototype.getBytes = function(count) {
    var rval;
    if (count) {
      count = Math.min(this.length(), count);
      rval = this.data.slice(this.read, this.read + count);
      this.read += count;
    } else if (count === 0) {
      rval = "";
    } else {
      rval = this.read === 0 ? this.data : this.data.slice(this.read);
      this.clear();
    }
    return rval;
  };
  util.DataBuffer.prototype.bytes = function(count) {
    return typeof count === "undefined" ? this.data.slice(this.read) : this.data.slice(this.read, this.read + count);
  };
  util.DataBuffer.prototype.at = function(i) {
    return this.data.getUint8(this.read + i);
  };
  util.DataBuffer.prototype.setAt = function(i, b) {
    this.data.setUint8(i, b);
    return this;
  };
  util.DataBuffer.prototype.last = function() {
    return this.data.getUint8(this.write - 1);
  };
  util.DataBuffer.prototype.copy = function() {
    return new util.DataBuffer(this);
  };
  util.DataBuffer.prototype.compact = function() {
    if (this.read > 0) {
      var src = new Uint8Array(this.data.buffer, this.read);
      var dst = new Uint8Array(src.byteLength);
      dst.set(src);
      this.data = new DataView(dst);
      this.write -= this.read;
      this.read = 0;
    }
    return this;
  };
  util.DataBuffer.prototype.clear = function() {
    this.data = new DataView(new ArrayBuffer(0));
    this.read = this.write = 0;
    return this;
  };
  util.DataBuffer.prototype.truncate = function(count) {
    this.write = Math.max(0, this.length() - count);
    this.read = Math.min(this.read, this.write);
    return this;
  };
  util.DataBuffer.prototype.toHex = function() {
    var rval = "";
    for (var i = this.read; i < this.data.byteLength; ++i) {
      var b = this.data.getUint8(i);
      if (b < 16) {
        rval += "0";
      }
      rval += b.toString(16);
    }
    return rval;
  };
  util.DataBuffer.prototype.toString = function(encoding) {
    var view = new Uint8Array(this.data, this.read, this.length());
    encoding = encoding || "utf8";
    if (encoding === "binary" || encoding === "raw") {
      return util.binary.raw.encode(view);
    }
    if (encoding === "hex") {
      return util.binary.hex.encode(view);
    }
    if (encoding === "base64") {
      return util.binary.base64.encode(view);
    }
    if (encoding === "utf8") {
      return util.text.utf8.decode(view);
    }
    if (encoding === "utf16") {
      return util.text.utf16.decode(view);
    }
    throw new Error("Invalid encoding: " + encoding);
  };
  util.createBuffer = function(input, encoding) {
    encoding = encoding || "raw";
    if (input !== void 0 && encoding === "utf8") {
      input = util.encodeUtf8(input);
    }
    return new util.ByteBuffer(input);
  };
  util.fillString = function(c, n) {
    var s = "";
    while (n > 0) {
      if (n & 1) {
        s += c;
      }
      n >>>= 1;
      if (n > 0) {
        c += c;
      }
    }
    return s;
  };
  util.xorBytes = function(s1, s2, n) {
    var s3 = "";
    var b = "";
    var t = "";
    var i = 0;
    var c = 0;
    for (; n > 0; --n, ++i) {
      b = s1.charCodeAt(i) ^ s2.charCodeAt(i);
      if (c >= 10) {
        s3 += t;
        t = "";
        c = 0;
      }
      t += String.fromCharCode(b);
      ++c;
    }
    s3 += t;
    return s3;
  };
  util.hexToBytes = function(hex) {
    var rval = "";
    var i = 0;
    if (hex.length & true) {
      i = 1;
      rval += String.fromCharCode(parseInt(hex[0], 16));
    }
    for (; i < hex.length; i += 2) {
      rval += String.fromCharCode(parseInt(hex.substr(i, 2), 16));
    }
    return rval;
  };
  util.bytesToHex = function(bytes) {
    return util.createBuffer(bytes).toHex();
  };
  util.int32ToBytes = function(i) {
    return String.fromCharCode(i >> 24 & 255) + String.fromCharCode(i >> 16 & 255) + String.fromCharCode(i >> 8 & 255) + String.fromCharCode(i & 255);
  };
  var _base64 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
  var _base64Idx = [
    62,
    -1,
    -1,
    -1,
    63,
    52,
    53,
    54,
    55,
    56,
    57,
    58,
    59,
    60,
    61,
    -1,
    -1,
    -1,
    64,
    -1,
    -1,
    -1,
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    12,
    13,
    14,
    15,
    16,
    17,
    18,
    19,
    20,
    21,
    22,
    23,
    24,
    25,
    -1,
    -1,
    -1,
    -1,
    -1,
    -1,
    26,
    27,
    28,
    29,
    30,
    31,
    32,
    33,
    34,
    35,
    36,
    37,
    38,
    39,
    40,
    41,
    42,
    43,
    44,
    45,
    46,
    47,
    48,
    49,
    50,
    51
  ];
  var _base58 = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
  util.encode64 = function(input, maxline) {
    var line = "";
    var output = "";
    var chr1, chr2, chr3;
    var i = 0;
    while (i < input.length) {
      chr1 = input.charCodeAt(i++);
      chr2 = input.charCodeAt(i++);
      chr3 = input.charCodeAt(i++);
      line += _base64.charAt(chr1 >> 2);
      line += _base64.charAt((chr1 & 3) << 4 | chr2 >> 4);
      if (isNaN(chr2)) {
        line += "==";
      } else {
        line += _base64.charAt((chr2 & 15) << 2 | chr3 >> 6);
        line += isNaN(chr3) ? "=" : _base64.charAt(chr3 & 63);
      }
      if (maxline && line.length > maxline) {
        output += line.substr(0, maxline) + "\r\n";
        line = line.substr(maxline);
      }
    }
    output += line;
    return output;
  };
  util.decode64 = function(input) {
    input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");
    var output = "";
    var enc1, enc2, enc3, enc4;
    var i = 0;
    while (i < input.length) {
      enc1 = _base64Idx[input.charCodeAt(i++) - 43];
      enc2 = _base64Idx[input.charCodeAt(i++) - 43];
      enc3 = _base64Idx[input.charCodeAt(i++) - 43];
      enc4 = _base64Idx[input.charCodeAt(i++) - 43];
      output += String.fromCharCode(enc1 << 2 | enc2 >> 4);
      if (enc3 !== 64) {
        output += String.fromCharCode((enc2 & 15) << 4 | enc3 >> 2);
        if (enc4 !== 64) {
          output += String.fromCharCode((enc3 & 3) << 6 | enc4);
        }
      }
    }
    return output;
  };
  util.encodeUtf8 = function(str) {
    return unescape(encodeURIComponent(str));
  };
  util.decodeUtf8 = function(str) {
    return decodeURIComponent(escape(str));
  };
  util.binary = {
    raw: {},
    hex: {},
    base64: {},
    base58: {},
    baseN: {
      encode: baseN.encode,
      decode: baseN.decode
    }
  };
  util.binary.raw.encode = function(bytes) {
    return String.fromCharCode.apply(null, bytes);
  };
  util.binary.raw.decode = function(str, output, offset) {
    var out = output;
    if (!out) {
      out = new Uint8Array(str.length);
    }
    offset = offset || 0;
    var j = offset;
    for (var i = 0; i < str.length; ++i) {
      out[j++] = str.charCodeAt(i);
    }
    return output ? j - offset : out;
  };
  util.binary.hex.encode = util.bytesToHex;
  util.binary.hex.decode = function(hex, output, offset) {
    var out = output;
    if (!out) {
      out = new Uint8Array(Math.ceil(hex.length / 2));
    }
    offset = offset || 0;
    var i = 0, j = offset;
    if (hex.length & 1) {
      i = 1;
      out[j++] = parseInt(hex[0], 16);
    }
    for (; i < hex.length; i += 2) {
      out[j++] = parseInt(hex.substr(i, 2), 16);
    }
    return output ? j - offset : out;
  };
  util.binary.base64.encode = function(input, maxline) {
    var line = "";
    var output = "";
    var chr1, chr2, chr3;
    var i = 0;
    while (i < input.byteLength) {
      chr1 = input[i++];
      chr2 = input[i++];
      chr3 = input[i++];
      line += _base64.charAt(chr1 >> 2);
      line += _base64.charAt((chr1 & 3) << 4 | chr2 >> 4);
      if (isNaN(chr2)) {
        line += "==";
      } else {
        line += _base64.charAt((chr2 & 15) << 2 | chr3 >> 6);
        line += isNaN(chr3) ? "=" : _base64.charAt(chr3 & 63);
      }
      if (maxline && line.length > maxline) {
        output += line.substr(0, maxline) + "\r\n";
        line = line.substr(maxline);
      }
    }
    output += line;
    return output;
  };
  util.binary.base64.decode = function(input, output, offset) {
    var out = output;
    if (!out) {
      out = new Uint8Array(Math.ceil(input.length / 4) * 3);
    }
    input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");
    offset = offset || 0;
    var enc1, enc2, enc3, enc4;
    var i = 0, j = offset;
    while (i < input.length) {
      enc1 = _base64Idx[input.charCodeAt(i++) - 43];
      enc2 = _base64Idx[input.charCodeAt(i++) - 43];
      enc3 = _base64Idx[input.charCodeAt(i++) - 43];
      enc4 = _base64Idx[input.charCodeAt(i++) - 43];
      out[j++] = enc1 << 2 | enc2 >> 4;
      if (enc3 !== 64) {
        out[j++] = (enc2 & 15) << 4 | enc3 >> 2;
        if (enc4 !== 64) {
          out[j++] = (enc3 & 3) << 6 | enc4;
        }
      }
    }
    return output ? j - offset : out.subarray(0, j);
  };
  util.binary.base58.encode = function(input, maxline) {
    return util.binary.baseN.encode(input, _base58, maxline);
  };
  util.binary.base58.decode = function(input, maxline) {
    return util.binary.baseN.decode(input, _base58, maxline);
  };
  util.text = {
    utf8: {},
    utf16: {}
  };
  util.text.utf8.encode = function(str, output, offset) {
    str = util.encodeUtf8(str);
    var out = output;
    if (!out) {
      out = new Uint8Array(str.length);
    }
    offset = offset || 0;
    var j = offset;
    for (var i = 0; i < str.length; ++i) {
      out[j++] = str.charCodeAt(i);
    }
    return output ? j - offset : out;
  };
  util.text.utf8.decode = function(bytes) {
    return util.decodeUtf8(String.fromCharCode.apply(null, bytes));
  };
  util.text.utf16.encode = function(str, output, offset) {
    var out = output;
    if (!out) {
      out = new Uint8Array(str.length * 2);
    }
    var view = new Uint16Array(out.buffer);
    offset = offset || 0;
    var j = offset;
    var k = offset;
    for (var i = 0; i < str.length; ++i) {
      view[k++] = str.charCodeAt(i);
      j += 2;
    }
    return output ? j - offset : out;
  };
  util.text.utf16.decode = function(bytes) {
    return String.fromCharCode.apply(null, new Uint16Array(bytes.buffer));
  };
  util.deflate = function(api, bytes, raw) {
    bytes = util.decode64(api.deflate(util.encode64(bytes)).rval);
    if (raw) {
      var start = 2;
      var flg = bytes.charCodeAt(1);
      if (flg & 32) {
        start = 6;
      }
      bytes = bytes.substring(start, bytes.length - 4);
    }
    return bytes;
  };
  util.inflate = function(api, bytes, raw) {
    var rval = api.inflate(util.encode64(bytes)).rval;
    return rval === null ? null : util.decode64(rval);
  };
  var _setStorageObject = function(api, id, obj) {
    if (!api) {
      throw new Error("WebStorage not available.");
    }
    var rval;
    if (obj === null) {
      rval = api.removeItem(id);
    } else {
      obj = util.encode64(JSON.stringify(obj));
      rval = api.setItem(id, obj);
    }
    if (typeof rval !== "undefined" && rval.rval !== true) {
      var error = new Error(rval.error.message);
      error.id = rval.error.id;
      error.name = rval.error.name;
      throw error;
    }
  };
  var _getStorageObject = function(api, id) {
    if (!api) {
      throw new Error("WebStorage not available.");
    }
    var rval = api.getItem(id);
    if (api.init) {
      if (rval.rval === null) {
        if (rval.error) {
          var error = new Error(rval.error.message);
          error.id = rval.error.id;
          error.name = rval.error.name;
          throw error;
        }
        rval = null;
      } else {
        rval = rval.rval;
      }
    }
    if (rval !== null) {
      rval = JSON.parse(util.decode64(rval));
    }
    return rval;
  };
  var _setItem = function(api, id, key, data) {
    var obj = _getStorageObject(api, id);
    if (obj === null) {
      obj = {};
    }
    obj[key] = data;
    _setStorageObject(api, id, obj);
  };
  var _getItem = function(api, id, key) {
    var rval = _getStorageObject(api, id);
    if (rval !== null) {
      rval = key in rval ? rval[key] : null;
    }
    return rval;
  };
  var _removeItem = function(api, id, key) {
    var obj = _getStorageObject(api, id);
    if (obj !== null && key in obj) {
      delete obj[key];
      var empty = true;
      for (var prop in obj) {
        empty = false;
        break;
      }
      if (empty) {
        obj = null;
      }
      _setStorageObject(api, id, obj);
    }
  };
  var _clearItems = function(api, id) {
    _setStorageObject(api, id, null);
  };
  var _callStorageFunction = function(func, args, location2) {
    var rval = null;
    if (typeof location2 === "undefined") {
      location2 = ["web", "flash"];
    }
    var type;
    var done = false;
    var exception = null;
    for (var idx in location2) {
      type = location2[idx];
      try {
        if (type === "flash" || type === "both") {
          if (args[0] === null) {
            throw new Error("Flash local storage not available.");
          }
          rval = func.apply(this, args);
          done = type === "flash";
        }
        if (type === "web" || type === "both") {
          args[0] = localStorage;
          rval = func.apply(this, args);
          done = true;
        }
      } catch (ex) {
        exception = ex;
      }
      if (done) {
        break;
      }
    }
    if (!done) {
      throw exception;
    }
    return rval;
  };
  util.setItem = function(api, id, key, data, location2) {
    _callStorageFunction(_setItem, arguments, location2);
  };
  util.getItem = function(api, id, key, location2) {
    return _callStorageFunction(_getItem, arguments, location2);
  };
  util.removeItem = function(api, id, key, location2) {
    _callStorageFunction(_removeItem, arguments, location2);
  };
  util.clearItems = function(api, id, location2) {
    _callStorageFunction(_clearItems, arguments, location2);
  };
  util.parseUrl = function(str) {
    var regex = /^(https?):\/\/([^:&^\/]*):?(\d*)(.*)$/g;
    regex.lastIndex = 0;
    var m = regex.exec(str);
    var url = m === null ? null : {
      full: str,
      scheme: m[1],
      host: m[2],
      port: m[3],
      path: m[4]
    };
    if (url) {
      url.fullHost = url.host;
      if (url.port) {
        if (url.port !== 80 && url.scheme === "http") {
          url.fullHost += ":" + url.port;
        } else if (url.port !== 443 && url.scheme === "https") {
          url.fullHost += ":" + url.port;
        }
      } else if (url.scheme === "http") {
        url.port = 80;
      } else if (url.scheme === "https") {
        url.port = 443;
      }
      url.full = url.scheme + "://" + url.fullHost;
    }
    return url;
  };
  var _queryVariables = null;
  util.getQueryVariables = function(query) {
    var parse = function(q) {
      var rval2 = {};
      var kvpairs = q.split("&");
      for (var i = 0; i < kvpairs.length; i++) {
        var pos = kvpairs[i].indexOf("=");
        var key;
        var val;
        if (pos > 0) {
          key = kvpairs[i].substring(0, pos);
          val = kvpairs[i].substring(pos + 1);
        } else {
          key = kvpairs[i];
          val = null;
        }
        if (!(key in rval2)) {
          rval2[key] = [];
        }
        if (!(key in Object.prototype) && val !== null) {
          rval2[key].push(unescape(val));
        }
      }
      return rval2;
    };
    var rval;
    if (typeof query === "undefined") {
      if (_queryVariables === null) {
        if (typeof window !== "undefined" && window.location && window.location.search) {
          _queryVariables = parse(window.location.search.substring(1));
        } else {
          _queryVariables = {};
        }
      }
      rval = _queryVariables;
    } else {
      rval = parse(query);
    }
    return rval;
  };
  util.parseFragment = function(fragment) {
    var fp = fragment;
    var fq = "";
    var pos = fragment.indexOf("?");
    if (pos > 0) {
      fp = fragment.substring(0, pos);
      fq = fragment.substring(pos + 1);
    }
    var path = fp.split("/");
    if (path.length > 0 && path[0] === "") {
      path.shift();
    }
    var query = fq === "" ? {} : util.getQueryVariables(fq);
    return {
      pathString: fp,
      queryString: fq,
      path,
      query
    };
  };
  util.makeRequest = function(reqString) {
    var frag = util.parseFragment(reqString);
    var req = {
      path: frag.pathString,
      query: frag.queryString,
      getPath: function(i) {
        return typeof i === "undefined" ? frag.path : frag.path[i];
      },
      getQuery: function(k, i) {
        var rval;
        if (typeof k === "undefined") {
          rval = frag.query;
        } else {
          rval = frag.query[k];
          if (rval && typeof i !== "undefined") {
            rval = rval[i];
          }
        }
        return rval;
      },
      getQueryLast: function(k, _default) {
        var rval;
        var vals = req.getQuery(k);
        if (vals) {
          rval = vals[vals.length - 1];
        } else {
          rval = _default;
        }
        return rval;
      }
    };
    return req;
  };
  util.makeLink = function(path, query, fragment) {
    path = jQuery.isArray(path) ? path.join("/") : path;
    var qstr = jQuery.param(query || {});
    fragment = fragment || "";
    return path + (qstr.length > 0 ? "?" + qstr : "") + (fragment.length > 0 ? "#" + fragment : "");
  };
  util.isEmpty = function(obj) {
    for (var prop in obj) {
      if (obj.hasOwnProperty(prop)) {
        return false;
      }
    }
    return true;
  };
  util.format = function(format) {
    var re = /%./g;
    var match;
    var part;
    var argi = 0;
    var parts = [];
    var last = 0;
    while (match = re.exec(format)) {
      part = format.substring(last, re.lastIndex - 2);
      if (part.length > 0) {
        parts.push(part);
      }
      last = re.lastIndex;
      var code = match[0][1];
      switch (code) {
        case "s":
        case "o":
          if (argi < arguments.length) {
            parts.push(arguments[argi++ + 1]);
          } else {
            parts.push("<?>");
          }
          break;
        case "%":
          parts.push("%");
          break;
        default:
          parts.push("<%" + code + "?>");
      }
    }
    parts.push(format.substring(last));
    return parts.join("");
  };
  util.formatNumber = function(number, decimals, dec_point, thousands_sep) {
    var n = number, c = isNaN(decimals = Math.abs(decimals)) ? 2 : decimals;
    var d = dec_point === void 0 ? "," : dec_point;
    var t = thousands_sep === void 0 ? "." : thousands_sep, s = n < 0 ? "-" : "";
    var i = parseInt(n = Math.abs(+n || 0).toFixed(c), 10) + "";
    var j = i.length > 3 ? i.length % 3 : 0;
    return s + (j ? i.substr(0, j) + t : "") + i.substr(j).replace(/(\d{3})(?=\d)/g, "$1" + t) + (c ? d + Math.abs(n - i).toFixed(c).slice(2) : "");
  };
  util.formatSize = function(size) {
    if (size >= 1073741824) {
      size = util.formatNumber(size / 1073741824, 2, ".", "") + " GiB";
    } else if (size >= 1048576) {
      size = util.formatNumber(size / 1048576, 2, ".", "") + " MiB";
    } else if (size >= 1024) {
      size = util.formatNumber(size / 1024, 0) + " KiB";
    } else {
      size = util.formatNumber(size, 0) + " bytes";
    }
    return size;
  };
  util.bytesFromIP = function(ip) {
    if (ip.indexOf(".") !== -1) {
      return util.bytesFromIPv4(ip);
    }
    if (ip.indexOf(":") !== -1) {
      return util.bytesFromIPv6(ip);
    }
    return null;
  };
  util.bytesFromIPv4 = function(ip) {
    ip = ip.split(".");
    if (ip.length !== 4) {
      return null;
    }
    var b = util.createBuffer();
    for (var i = 0; i < ip.length; ++i) {
      var num = parseInt(ip[i], 10);
      if (isNaN(num)) {
        return null;
      }
      b.putByte(num);
    }
    return b.getBytes();
  };
  util.bytesFromIPv6 = function(ip) {
    var blanks = 0;
    ip = ip.split(":").filter(function(e) {
      if (e.length === 0)
        ++blanks;
      return true;
    });
    var zeros = (8 - ip.length + blanks) * 2;
    var b = util.createBuffer();
    for (var i = 0; i < 8; ++i) {
      if (!ip[i] || ip[i].length === 0) {
        b.fillWithByte(0, zeros);
        zeros = 0;
        continue;
      }
      var bytes = util.hexToBytes(ip[i]);
      if (bytes.length < 2) {
        b.putByte(0);
      }
      b.putBytes(bytes);
    }
    return b.getBytes();
  };
  util.bytesToIP = function(bytes) {
    if (bytes.length === 4) {
      return util.bytesToIPv4(bytes);
    }
    if (bytes.length === 16) {
      return util.bytesToIPv6(bytes);
    }
    return null;
  };
  util.bytesToIPv4 = function(bytes) {
    if (bytes.length !== 4) {
      return null;
    }
    var ip = [];
    for (var i = 0; i < bytes.length; ++i) {
      ip.push(bytes.charCodeAt(i));
    }
    return ip.join(".");
  };
  util.bytesToIPv6 = function(bytes) {
    if (bytes.length !== 16) {
      return null;
    }
    var ip = [];
    var zeroGroups = [];
    var zeroMaxGroup = 0;
    for (var i = 0; i < bytes.length; i += 2) {
      var hex = util.bytesToHex(bytes[i] + bytes[i + 1]);
      while (hex[0] === "0" && hex !== "0") {
        hex = hex.substr(1);
      }
      if (hex === "0") {
        var last = zeroGroups[zeroGroups.length - 1];
        var idx = ip.length;
        if (!last || idx !== last.end + 1) {
          zeroGroups.push({start: idx, end: idx});
        } else {
          last.end = idx;
          if (last.end - last.start > zeroGroups[zeroMaxGroup].end - zeroGroups[zeroMaxGroup].start) {
            zeroMaxGroup = zeroGroups.length - 1;
          }
        }
      }
      ip.push(hex);
    }
    if (zeroGroups.length > 0) {
      var group = zeroGroups[zeroMaxGroup];
      if (group.end - group.start > 0) {
        ip.splice(group.start, group.end - group.start + 1, "");
        if (group.start === 0) {
          ip.unshift("");
        }
        if (group.end === 7) {
          ip.push("");
        }
      }
    }
    return ip.join(":");
  };
  util.estimateCores = function(options, callback) {
    if (typeof options === "function") {
      callback = options;
      options = {};
    }
    options = options || {};
    if ("cores" in util && !options.update) {
      return callback(null, util.cores);
    }
    if (typeof navigator !== "undefined" && "hardwareConcurrency" in navigator && navigator.hardwareConcurrency > 0) {
      util.cores = navigator.hardwareConcurrency;
      return callback(null, util.cores);
    }
    if (typeof Worker === "undefined") {
      util.cores = 1;
      return callback(null, util.cores);
    }
    if (typeof Blob === "undefined") {
      util.cores = 2;
      return callback(null, util.cores);
    }
    var blobUrl = URL.createObjectURL(new Blob([
      "(",
      function() {
        self.addEventListener("message", function(e) {
          var st = Date.now();
          var et = st + 4;
          while (Date.now() < et)
            ;
          self.postMessage({st, et});
        });
      }.toString(),
      ")()"
    ], {type: "application/javascript"}));
    sample([], 5, 16);
    function sample(max, samples, numWorkers) {
      if (samples === 0) {
        var avg = Math.floor(max.reduce(function(avg2, x) {
          return avg2 + x;
        }, 0) / max.length);
        util.cores = Math.max(1, avg);
        URL.revokeObjectURL(blobUrl);
        return callback(null, util.cores);
      }
      map(numWorkers, function(err, results) {
        max.push(reduce(numWorkers, results));
        sample(max, samples - 1, numWorkers);
      });
    }
    function map(numWorkers, callback2) {
      var workers = [];
      var results = [];
      for (var i = 0; i < numWorkers; ++i) {
        var worker = new Worker(blobUrl);
        worker.addEventListener("message", function(e) {
          results.push(e.data);
          if (results.length === numWorkers) {
            for (var i2 = 0; i2 < numWorkers; ++i2) {
              workers[i2].terminate();
            }
            callback2(null, results);
          }
        });
        workers.push(worker);
      }
      for (var i = 0; i < numWorkers; ++i) {
        workers[i].postMessage(i);
      }
    }
    function reduce(numWorkers, results) {
      var overlaps = [];
      for (var n = 0; n < numWorkers; ++n) {
        var r1 = results[n];
        var overlap = overlaps[n] = [];
        for (var i = 0; i < numWorkers; ++i) {
          if (n === i) {
            continue;
          }
          var r2 = results[i];
          if (r1.st > r2.st && r1.st < r2.et || r2.st > r1.st && r2.st < r1.et) {
            overlap.push(i);
          }
        }
      }
      return overlaps.reduce(function(max, overlap2) {
        return Math.max(max, overlap2.length);
      }, 0);
    }
  };
});

// node_modules/node-forge/lib/oids.js
var require_oids = __commonJS((exports2, module2) => {
  var forge = require_forge();
  forge.pki = forge.pki || {};
  var oids = module2.exports = forge.pki.oids = forge.oids = forge.oids || {};
  function _IN(id, name) {
    oids[id] = name;
    oids[name] = id;
  }
  function _I_(id, name) {
    oids[id] = name;
  }
  _IN("1.2.840.113549.1.1.1", "rsaEncryption");
  _IN("1.2.840.113549.1.1.4", "md5WithRSAEncryption");
  _IN("1.2.840.113549.1.1.5", "sha1WithRSAEncryption");
  _IN("1.2.840.113549.1.1.7", "RSAES-OAEP");
  _IN("1.2.840.113549.1.1.8", "mgf1");
  _IN("1.2.840.113549.1.1.9", "pSpecified");
  _IN("1.2.840.113549.1.1.10", "RSASSA-PSS");
  _IN("1.2.840.113549.1.1.11", "sha256WithRSAEncryption");
  _IN("1.2.840.113549.1.1.12", "sha384WithRSAEncryption");
  _IN("1.2.840.113549.1.1.13", "sha512WithRSAEncryption");
  _IN("1.3.101.112", "EdDSA25519");
  _IN("1.2.840.10040.4.3", "dsa-with-sha1");
  _IN("1.3.14.3.2.7", "desCBC");
  _IN("1.3.14.3.2.26", "sha1");
  _IN("2.16.840.1.101.3.4.2.1", "sha256");
  _IN("2.16.840.1.101.3.4.2.2", "sha384");
  _IN("2.16.840.1.101.3.4.2.3", "sha512");
  _IN("1.2.840.113549.2.5", "md5");
  _IN("1.2.840.113549.1.7.1", "data");
  _IN("1.2.840.113549.1.7.2", "signedData");
  _IN("1.2.840.113549.1.7.3", "envelopedData");
  _IN("1.2.840.113549.1.7.4", "signedAndEnvelopedData");
  _IN("1.2.840.113549.1.7.5", "digestedData");
  _IN("1.2.840.113549.1.7.6", "encryptedData");
  _IN("1.2.840.113549.1.9.1", "emailAddress");
  _IN("1.2.840.113549.1.9.2", "unstructuredName");
  _IN("1.2.840.113549.1.9.3", "contentType");
  _IN("1.2.840.113549.1.9.4", "messageDigest");
  _IN("1.2.840.113549.1.9.5", "signingTime");
  _IN("1.2.840.113549.1.9.6", "counterSignature");
  _IN("1.2.840.113549.1.9.7", "challengePassword");
  _IN("1.2.840.113549.1.9.8", "unstructuredAddress");
  _IN("1.2.840.113549.1.9.14", "extensionRequest");
  _IN("1.2.840.113549.1.9.20", "friendlyName");
  _IN("1.2.840.113549.1.9.21", "localKeyId");
  _IN("1.2.840.113549.1.9.22.1", "x509Certificate");
  _IN("1.2.840.113549.1.12.10.1.1", "keyBag");
  _IN("1.2.840.113549.1.12.10.1.2", "pkcs8ShroudedKeyBag");
  _IN("1.2.840.113549.1.12.10.1.3", "certBag");
  _IN("1.2.840.113549.1.12.10.1.4", "crlBag");
  _IN("1.2.840.113549.1.12.10.1.5", "secretBag");
  _IN("1.2.840.113549.1.12.10.1.6", "safeContentsBag");
  _IN("1.2.840.113549.1.5.13", "pkcs5PBES2");
  _IN("1.2.840.113549.1.5.12", "pkcs5PBKDF2");
  _IN("1.2.840.113549.1.12.1.1", "pbeWithSHAAnd128BitRC4");
  _IN("1.2.840.113549.1.12.1.2", "pbeWithSHAAnd40BitRC4");
  _IN("1.2.840.113549.1.12.1.3", "pbeWithSHAAnd3-KeyTripleDES-CBC");
  _IN("1.2.840.113549.1.12.1.4", "pbeWithSHAAnd2-KeyTripleDES-CBC");
  _IN("1.2.840.113549.1.12.1.5", "pbeWithSHAAnd128BitRC2-CBC");
  _IN("1.2.840.113549.1.12.1.6", "pbewithSHAAnd40BitRC2-CBC");
  _IN("1.2.840.113549.2.7", "hmacWithSHA1");
  _IN("1.2.840.113549.2.8", "hmacWithSHA224");
  _IN("1.2.840.113549.2.9", "hmacWithSHA256");
  _IN("1.2.840.113549.2.10", "hmacWithSHA384");
  _IN("1.2.840.113549.2.11", "hmacWithSHA512");
  _IN("1.2.840.113549.3.7", "des-EDE3-CBC");
  _IN("2.16.840.1.101.3.4.1.2", "aes128-CBC");
  _IN("2.16.840.1.101.3.4.1.22", "aes192-CBC");
  _IN("2.16.840.1.101.3.4.1.42", "aes256-CBC");
  _IN("2.5.4.3", "commonName");
  _IN("2.5.4.5", "serialName");
  _IN("2.5.4.6", "countryName");
  _IN("2.5.4.7", "localityName");
  _IN("2.5.4.8", "stateOrProvinceName");
  _IN("2.5.4.9", "streetAddress");
  _IN("2.5.4.10", "organizationName");
  _IN("2.5.4.11", "organizationalUnitName");
  _IN("2.5.4.13", "description");
  _IN("2.5.4.15", "businessCategory");
  _IN("2.5.4.17", "postalCode");
  _IN("1.3.6.1.4.1.311.60.2.1.2", "jurisdictionOfIncorporationStateOrProvinceName");
  _IN("1.3.6.1.4.1.311.60.2.1.3", "jurisdictionOfIncorporationCountryName");
  _IN("2.16.840.1.113730.1.1", "nsCertType");
  _IN("2.16.840.1.113730.1.13", "nsComment");
  _I_("2.5.29.1", "authorityKeyIdentifier");
  _I_("2.5.29.2", "keyAttributes");
  _I_("2.5.29.3", "certificatePolicies");
  _I_("2.5.29.4", "keyUsageRestriction");
  _I_("2.5.29.5", "policyMapping");
  _I_("2.5.29.6", "subtreesConstraint");
  _I_("2.5.29.7", "subjectAltName");
  _I_("2.5.29.8", "issuerAltName");
  _I_("2.5.29.9", "subjectDirectoryAttributes");
  _I_("2.5.29.10", "basicConstraints");
  _I_("2.5.29.11", "nameConstraints");
  _I_("2.5.29.12", "policyConstraints");
  _I_("2.5.29.13", "basicConstraints");
  _IN("2.5.29.14", "subjectKeyIdentifier");
  _IN("2.5.29.15", "keyUsage");
  _I_("2.5.29.16", "privateKeyUsagePeriod");
  _IN("2.5.29.17", "subjectAltName");
  _IN("2.5.29.18", "issuerAltName");
  _IN("2.5.29.19", "basicConstraints");
  _I_("2.5.29.20", "cRLNumber");
  _I_("2.5.29.21", "cRLReason");
  _I_("2.5.29.22", "expirationDate");
  _I_("2.5.29.23", "instructionCode");
  _I_("2.5.29.24", "invalidityDate");
  _I_("2.5.29.25", "cRLDistributionPoints");
  _I_("2.5.29.26", "issuingDistributionPoint");
  _I_("2.5.29.27", "deltaCRLIndicator");
  _I_("2.5.29.28", "issuingDistributionPoint");
  _I_("2.5.29.29", "certificateIssuer");
  _I_("2.5.29.30", "nameConstraints");
  _IN("2.5.29.31", "cRLDistributionPoints");
  _IN("2.5.29.32", "certificatePolicies");
  _I_("2.5.29.33", "policyMappings");
  _I_("2.5.29.34", "policyConstraints");
  _IN("2.5.29.35", "authorityKeyIdentifier");
  _I_("2.5.29.36", "policyConstraints");
  _IN("2.5.29.37", "extKeyUsage");
  _I_("2.5.29.46", "freshestCRL");
  _I_("2.5.29.54", "inhibitAnyPolicy");
  _IN("1.3.6.1.4.1.11129.2.4.2", "timestampList");
  _IN("1.3.6.1.5.5.7.1.1", "authorityInfoAccess");
  _IN("1.3.6.1.5.5.7.3.1", "serverAuth");
  _IN("1.3.6.1.5.5.7.3.2", "clientAuth");
  _IN("1.3.6.1.5.5.7.3.3", "codeSigning");
  _IN("1.3.6.1.5.5.7.3.4", "emailProtection");
  _IN("1.3.6.1.5.5.7.3.8", "timeStamping");
});

// node_modules/node-forge/lib/asn1.js
var require_asn1 = __commonJS((exports2, module2) => {
  var forge = require_forge();
  require_util3();
  require_oids();
  var asn1 = module2.exports = forge.asn1 = forge.asn1 || {};
  asn1.Class = {
    UNIVERSAL: 0,
    APPLICATION: 64,
    CONTEXT_SPECIFIC: 128,
    PRIVATE: 192
  };
  asn1.Type = {
    NONE: 0,
    BOOLEAN: 1,
    INTEGER: 2,
    BITSTRING: 3,
    OCTETSTRING: 4,
    NULL: 5,
    OID: 6,
    ODESC: 7,
    EXTERNAL: 8,
    REAL: 9,
    ENUMERATED: 10,
    EMBEDDED: 11,
    UTF8: 12,
    ROID: 13,
    SEQUENCE: 16,
    SET: 17,
    PRINTABLESTRING: 19,
    IA5STRING: 22,
    UTCTIME: 23,
    GENERALIZEDTIME: 24,
    BMPSTRING: 30
  };
  asn1.create = function(tagClass, type, constructed, value, options) {
    if (forge.util.isArray(value)) {
      var tmp = [];
      for (var i = 0; i < value.length; ++i) {
        if (value[i] !== void 0) {
          tmp.push(value[i]);
        }
      }
      value = tmp;
    }
    var obj = {
      tagClass,
      type,
      constructed,
      composed: constructed || forge.util.isArray(value),
      value
    };
    if (options && "bitStringContents" in options) {
      obj.bitStringContents = options.bitStringContents;
      obj.original = asn1.copy(obj);
    }
    return obj;
  };
  asn1.copy = function(obj, options) {
    var copy;
    if (forge.util.isArray(obj)) {
      copy = [];
      for (var i = 0; i < obj.length; ++i) {
        copy.push(asn1.copy(obj[i], options));
      }
      return copy;
    }
    if (typeof obj === "string") {
      return obj;
    }
    copy = {
      tagClass: obj.tagClass,
      type: obj.type,
      constructed: obj.constructed,
      composed: obj.composed,
      value: asn1.copy(obj.value, options)
    };
    if (options && !options.excludeBitStringContents) {
      copy.bitStringContents = obj.bitStringContents;
    }
    return copy;
  };
  asn1.equals = function(obj1, obj2, options) {
    if (forge.util.isArray(obj1)) {
      if (!forge.util.isArray(obj2)) {
        return false;
      }
      if (obj1.length !== obj2.length) {
        return false;
      }
      for (var i = 0; i < obj1.length; ++i) {
        if (!asn1.equals(obj1[i], obj2[i])) {
          return false;
        }
      }
      return true;
    }
    if (typeof obj1 !== typeof obj2) {
      return false;
    }
    if (typeof obj1 === "string") {
      return obj1 === obj2;
    }
    var equal = obj1.tagClass === obj2.tagClass && obj1.type === obj2.type && obj1.constructed === obj2.constructed && obj1.composed === obj2.composed && asn1.equals(obj1.value, obj2.value);
    if (options && options.includeBitStringContents) {
      equal = equal && obj1.bitStringContents === obj2.bitStringContents;
    }
    return equal;
  };
  asn1.getBerValueLength = function(b) {
    var b2 = b.getByte();
    if (b2 === 128) {
      return void 0;
    }
    var length;
    var longForm = b2 & 128;
    if (!longForm) {
      length = b2;
    } else {
      length = b.getInt((b2 & 127) << 3);
    }
    return length;
  };
  function _checkBufferLength(bytes, remaining, n) {
    if (n > remaining) {
      var error = new Error("Too few bytes to parse DER.");
      error.available = bytes.length();
      error.remaining = remaining;
      error.requested = n;
      throw error;
    }
  }
  var _getValueLength = function(bytes, remaining) {
    var b2 = bytes.getByte();
    remaining--;
    if (b2 === 128) {
      return void 0;
    }
    var length;
    var longForm = b2 & 128;
    if (!longForm) {
      length = b2;
    } else {
      var longFormBytes = b2 & 127;
      _checkBufferLength(bytes, remaining, longFormBytes);
      length = bytes.getInt(longFormBytes << 3);
    }
    if (length < 0) {
      throw new Error("Negative length: " + length);
    }
    return length;
  };
  asn1.fromDer = function(bytes, options) {
    if (options === void 0) {
      options = {
        strict: true,
        decodeBitStrings: true
      };
    }
    if (typeof options === "boolean") {
      options = {
        strict: options,
        decodeBitStrings: true
      };
    }
    if (!("strict" in options)) {
      options.strict = true;
    }
    if (!("decodeBitStrings" in options)) {
      options.decodeBitStrings = true;
    }
    if (typeof bytes === "string") {
      bytes = forge.util.createBuffer(bytes);
    }
    return _fromDer(bytes, bytes.length(), 0, options);
  };
  function _fromDer(bytes, remaining, depth, options) {
    var start;
    _checkBufferLength(bytes, remaining, 2);
    var b1 = bytes.getByte();
    remaining--;
    var tagClass = b1 & 192;
    var type = b1 & 31;
    start = bytes.length();
    var length = _getValueLength(bytes, remaining);
    remaining -= start - bytes.length();
    if (length !== void 0 && length > remaining) {
      if (options.strict) {
        var error = new Error("Too few bytes to read ASN.1 value.");
        error.available = bytes.length();
        error.remaining = remaining;
        error.requested = length;
        throw error;
      }
      length = remaining;
    }
    var value;
    var bitStringContents;
    var constructed = (b1 & 32) === 32;
    if (constructed) {
      value = [];
      if (length === void 0) {
        for (; ; ) {
          _checkBufferLength(bytes, remaining, 2);
          if (bytes.bytes(2) === String.fromCharCode(0, 0)) {
            bytes.getBytes(2);
            remaining -= 2;
            break;
          }
          start = bytes.length();
          value.push(_fromDer(bytes, remaining, depth + 1, options));
          remaining -= start - bytes.length();
        }
      } else {
        while (length > 0) {
          start = bytes.length();
          value.push(_fromDer(bytes, length, depth + 1, options));
          remaining -= start - bytes.length();
          length -= start - bytes.length();
        }
      }
    }
    if (value === void 0 && tagClass === asn1.Class.UNIVERSAL && type === asn1.Type.BITSTRING) {
      bitStringContents = bytes.bytes(length);
    }
    if (value === void 0 && options.decodeBitStrings && tagClass === asn1.Class.UNIVERSAL && type === asn1.Type.BITSTRING && length > 1) {
      var savedRead = bytes.read;
      var savedRemaining = remaining;
      var unused = 0;
      if (type === asn1.Type.BITSTRING) {
        _checkBufferLength(bytes, remaining, 1);
        unused = bytes.getByte();
        remaining--;
      }
      if (unused === 0) {
        try {
          start = bytes.length();
          var subOptions = {
            verbose: options.verbose,
            strict: true,
            decodeBitStrings: true
          };
          var composed = _fromDer(bytes, remaining, depth + 1, subOptions);
          var used = start - bytes.length();
          remaining -= used;
          if (type == asn1.Type.BITSTRING) {
            used++;
          }
          var tc = composed.tagClass;
          if (used === length && (tc === asn1.Class.UNIVERSAL || tc === asn1.Class.CONTEXT_SPECIFIC)) {
            value = [composed];
          }
        } catch (ex) {
        }
      }
      if (value === void 0) {
        bytes.read = savedRead;
        remaining = savedRemaining;
      }
    }
    if (value === void 0) {
      if (length === void 0) {
        if (options.strict) {
          throw new Error("Non-constructed ASN.1 object of indefinite length.");
        }
        length = remaining;
      }
      if (type === asn1.Type.BMPSTRING) {
        value = "";
        for (; length > 0; length -= 2) {
          _checkBufferLength(bytes, remaining, 2);
          value += String.fromCharCode(bytes.getInt16());
          remaining -= 2;
        }
      } else {
        value = bytes.getBytes(length);
      }
    }
    var asn1Options = bitStringContents === void 0 ? null : {
      bitStringContents
    };
    return asn1.create(tagClass, type, constructed, value, asn1Options);
  }
  asn1.toDer = function(obj) {
    var bytes = forge.util.createBuffer();
    var b1 = obj.tagClass | obj.type;
    var value = forge.util.createBuffer();
    var useBitStringContents = false;
    if ("bitStringContents" in obj) {
      useBitStringContents = true;
      if (obj.original) {
        useBitStringContents = asn1.equals(obj, obj.original);
      }
    }
    if (useBitStringContents) {
      value.putBytes(obj.bitStringContents);
    } else if (obj.composed) {
      if (obj.constructed) {
        b1 |= 32;
      } else {
        value.putByte(0);
      }
      for (var i = 0; i < obj.value.length; ++i) {
        if (obj.value[i] !== void 0) {
          value.putBuffer(asn1.toDer(obj.value[i]));
        }
      }
    } else {
      if (obj.type === asn1.Type.BMPSTRING) {
        for (var i = 0; i < obj.value.length; ++i) {
          value.putInt16(obj.value.charCodeAt(i));
        }
      } else {
        if (obj.type === asn1.Type.INTEGER && obj.value.length > 1 && (obj.value.charCodeAt(0) === 0 && (obj.value.charCodeAt(1) & 128) === 0 || obj.value.charCodeAt(0) === 255 && (obj.value.charCodeAt(1) & 128) === 128)) {
          value.putBytes(obj.value.substr(1));
        } else {
          value.putBytes(obj.value);
        }
      }
    }
    bytes.putByte(b1);
    if (value.length() <= 127) {
      bytes.putByte(value.length() & 127);
    } else {
      var len = value.length();
      var lenBytes = "";
      do {
        lenBytes += String.fromCharCode(len & 255);
        len = len >>> 8;
      } while (len > 0);
      bytes.putByte(lenBytes.length | 128);
      for (var i = lenBytes.length - 1; i >= 0; --i) {
        bytes.putByte(lenBytes.charCodeAt(i));
      }
    }
    bytes.putBuffer(value);
    return bytes;
  };
  asn1.oidToDer = function(oid) {
    var values = oid.split(".");
    var bytes = forge.util.createBuffer();
    bytes.putByte(40 * parseInt(values[0], 10) + parseInt(values[1], 10));
    var last, valueBytes, value, b;
    for (var i = 2; i < values.length; ++i) {
      last = true;
      valueBytes = [];
      value = parseInt(values[i], 10);
      do {
        b = value & 127;
        value = value >>> 7;
        if (!last) {
          b |= 128;
        }
        valueBytes.push(b);
        last = false;
      } while (value > 0);
      for (var n = valueBytes.length - 1; n >= 0; --n) {
        bytes.putByte(valueBytes[n]);
      }
    }
    return bytes;
  };
  asn1.derToOid = function(bytes) {
    var oid;
    if (typeof bytes === "string") {
      bytes = forge.util.createBuffer(bytes);
    }
    var b = bytes.getByte();
    oid = Math.floor(b / 40) + "." + b % 40;
    var value = 0;
    while (bytes.length() > 0) {
      b = bytes.getByte();
      value = value << 7;
      if (b & 128) {
        value += b & 127;
      } else {
        oid += "." + (value + b);
        value = 0;
      }
    }
    return oid;
  };
  asn1.utcTimeToDate = function(utc) {
    var date = new Date();
    var year = parseInt(utc.substr(0, 2), 10);
    year = year >= 50 ? 1900 + year : 2e3 + year;
    var MM = parseInt(utc.substr(2, 2), 10) - 1;
    var DD = parseInt(utc.substr(4, 2), 10);
    var hh = parseInt(utc.substr(6, 2), 10);
    var mm = parseInt(utc.substr(8, 2), 10);
    var ss = 0;
    if (utc.length > 11) {
      var c = utc.charAt(10);
      var end = 10;
      if (c !== "+" && c !== "-") {
        ss = parseInt(utc.substr(10, 2), 10);
        end += 2;
      }
    }
    date.setUTCFullYear(year, MM, DD);
    date.setUTCHours(hh, mm, ss, 0);
    if (end) {
      c = utc.charAt(end);
      if (c === "+" || c === "-") {
        var hhoffset = parseInt(utc.substr(end + 1, 2), 10);
        var mmoffset = parseInt(utc.substr(end + 4, 2), 10);
        var offset = hhoffset * 60 + mmoffset;
        offset *= 6e4;
        if (c === "+") {
          date.setTime(+date - offset);
        } else {
          date.setTime(+date + offset);
        }
      }
    }
    return date;
  };
  asn1.generalizedTimeToDate = function(gentime) {
    var date = new Date();
    var YYYY = parseInt(gentime.substr(0, 4), 10);
    var MM = parseInt(gentime.substr(4, 2), 10) - 1;
    var DD = parseInt(gentime.substr(6, 2), 10);
    var hh = parseInt(gentime.substr(8, 2), 10);
    var mm = parseInt(gentime.substr(10, 2), 10);
    var ss = parseInt(gentime.substr(12, 2), 10);
    var fff = 0;
    var offset = 0;
    var isUTC = false;
    if (gentime.charAt(gentime.length - 1) === "Z") {
      isUTC = true;
    }
    var end = gentime.length - 5, c = gentime.charAt(end);
    if (c === "+" || c === "-") {
      var hhoffset = parseInt(gentime.substr(end + 1, 2), 10);
      var mmoffset = parseInt(gentime.substr(end + 4, 2), 10);
      offset = hhoffset * 60 + mmoffset;
      offset *= 6e4;
      if (c === "+") {
        offset *= -1;
      }
      isUTC = true;
    }
    if (gentime.charAt(14) === ".") {
      fff = parseFloat(gentime.substr(14), 10) * 1e3;
    }
    if (isUTC) {
      date.setUTCFullYear(YYYY, MM, DD);
      date.setUTCHours(hh, mm, ss, fff);
      date.setTime(+date + offset);
    } else {
      date.setFullYear(YYYY, MM, DD);
      date.setHours(hh, mm, ss, fff);
    }
    return date;
  };
  asn1.dateToUtcTime = function(date) {
    if (typeof date === "string") {
      return date;
    }
    var rval = "";
    var format = [];
    format.push(("" + date.getUTCFullYear()).substr(2));
    format.push("" + (date.getUTCMonth() + 1));
    format.push("" + date.getUTCDate());
    format.push("" + date.getUTCHours());
    format.push("" + date.getUTCMinutes());
    format.push("" + date.getUTCSeconds());
    for (var i = 0; i < format.length; ++i) {
      if (format[i].length < 2) {
        rval += "0";
      }
      rval += format[i];
    }
    rval += "Z";
    return rval;
  };
  asn1.dateToGeneralizedTime = function(date) {
    if (typeof date === "string") {
      return date;
    }
    var rval = "";
    var format = [];
    format.push("" + date.getUTCFullYear());
    format.push("" + (date.getUTCMonth() + 1));
    format.push("" + date.getUTCDate());
    format.push("" + date.getUTCHours());
    format.push("" + date.getUTCMinutes());
    format.push("" + date.getUTCSeconds());
    for (var i = 0; i < format.length; ++i) {
      if (format[i].length < 2) {
        rval += "0";
      }
      rval += format[i];
    }
    rval += "Z";
    return rval;
  };
  asn1.integerToDer = function(x) {
    var rval = forge.util.createBuffer();
    if (x >= -128 && x < 128) {
      return rval.putSignedInt(x, 8);
    }
    if (x >= -32768 && x < 32768) {
      return rval.putSignedInt(x, 16);
    }
    if (x >= -8388608 && x < 8388608) {
      return rval.putSignedInt(x, 24);
    }
    if (x >= -2147483648 && x < 2147483648) {
      return rval.putSignedInt(x, 32);
    }
    var error = new Error("Integer too large; max is 32-bits.");
    error.integer = x;
    throw error;
  };
  asn1.derToInteger = function(bytes) {
    if (typeof bytes === "string") {
      bytes = forge.util.createBuffer(bytes);
    }
    var n = bytes.length() * 8;
    if (n > 32) {
      throw new Error("Integer too large; max is 32-bits.");
    }
    return bytes.getSignedInt(n);
  };
  asn1.validate = function(obj, v, capture, errors) {
    var rval = false;
    if ((obj.tagClass === v.tagClass || typeof v.tagClass === "undefined") && (obj.type === v.type || typeof v.type === "undefined")) {
      if (obj.constructed === v.constructed || typeof v.constructed === "undefined") {
        rval = true;
        if (v.value && forge.util.isArray(v.value)) {
          var j = 0;
          for (var i = 0; rval && i < v.value.length; ++i) {
            rval = v.value[i].optional || false;
            if (obj.value[j]) {
              rval = asn1.validate(obj.value[j], v.value[i], capture, errors);
              if (rval) {
                ++j;
              } else if (v.value[i].optional) {
                rval = true;
              }
            }
            if (!rval && errors) {
              errors.push("[" + v.name + '] Tag class "' + v.tagClass + '", type "' + v.type + '" expected value length "' + v.value.length + '", got "' + obj.value.length + '"');
            }
          }
        }
        if (rval && capture) {
          if (v.capture) {
            capture[v.capture] = obj.value;
          }
          if (v.captureAsn1) {
            capture[v.captureAsn1] = obj;
          }
          if (v.captureBitStringContents && "bitStringContents" in obj) {
            capture[v.captureBitStringContents] = obj.bitStringContents;
          }
          if (v.captureBitStringValue && "bitStringContents" in obj) {
            var value;
            if (obj.bitStringContents.length < 2) {
              capture[v.captureBitStringValue] = "";
            } else {
              var unused = obj.bitStringContents.charCodeAt(0);
              if (unused !== 0) {
                throw new Error("captureBitStringValue only supported for zero unused bits");
              }
              capture[v.captureBitStringValue] = obj.bitStringContents.slice(1);
            }
          }
        }
      } else if (errors) {
        errors.push("[" + v.name + '] Expected constructed "' + v.constructed + '", got "' + obj.constructed + '"');
      }
    } else if (errors) {
      if (obj.tagClass !== v.tagClass) {
        errors.push("[" + v.name + '] Expected tag class "' + v.tagClass + '", got "' + obj.tagClass + '"');
      }
      if (obj.type !== v.type) {
        errors.push("[" + v.name + '] Expected type "' + v.type + '", got "' + obj.type + '"');
      }
    }
    return rval;
  };
  var _nonLatinRegex = /[^\\u0000-\\u00ff]/;
  asn1.prettyPrint = function(obj, level, indentation) {
    var rval = "";
    level = level || 0;
    indentation = indentation || 2;
    if (level > 0) {
      rval += "\n";
    }
    var indent = "";
    for (var i = 0; i < level * indentation; ++i) {
      indent += " ";
    }
    rval += indent + "Tag: ";
    switch (obj.tagClass) {
      case asn1.Class.UNIVERSAL:
        rval += "Universal:";
        break;
      case asn1.Class.APPLICATION:
        rval += "Application:";
        break;
      case asn1.Class.CONTEXT_SPECIFIC:
        rval += "Context-Specific:";
        break;
      case asn1.Class.PRIVATE:
        rval += "Private:";
        break;
    }
    if (obj.tagClass === asn1.Class.UNIVERSAL) {
      rval += obj.type;
      switch (obj.type) {
        case asn1.Type.NONE:
          rval += " (None)";
          break;
        case asn1.Type.BOOLEAN:
          rval += " (Boolean)";
          break;
        case asn1.Type.INTEGER:
          rval += " (Integer)";
          break;
        case asn1.Type.BITSTRING:
          rval += " (Bit string)";
          break;
        case asn1.Type.OCTETSTRING:
          rval += " (Octet string)";
          break;
        case asn1.Type.NULL:
          rval += " (Null)";
          break;
        case asn1.Type.OID:
          rval += " (Object Identifier)";
          break;
        case asn1.Type.ODESC:
          rval += " (Object Descriptor)";
          break;
        case asn1.Type.EXTERNAL:
          rval += " (External or Instance of)";
          break;
        case asn1.Type.REAL:
          rval += " (Real)";
          break;
        case asn1.Type.ENUMERATED:
          rval += " (Enumerated)";
          break;
        case asn1.Type.EMBEDDED:
          rval += " (Embedded PDV)";
          break;
        case asn1.Type.UTF8:
          rval += " (UTF8)";
          break;
        case asn1.Type.ROID:
          rval += " (Relative Object Identifier)";
          break;
        case asn1.Type.SEQUENCE:
          rval += " (Sequence)";
          break;
        case asn1.Type.SET:
          rval += " (Set)";
          break;
        case asn1.Type.PRINTABLESTRING:
          rval += " (Printable String)";
          break;
        case asn1.Type.IA5String:
          rval += " (IA5String (ASCII))";
          break;
        case asn1.Type.UTCTIME:
          rval += " (UTC time)";
          break;
        case asn1.Type.GENERALIZEDTIME:
          rval += " (Generalized time)";
          break;
        case asn1.Type.BMPSTRING:
          rval += " (BMP String)";
          break;
      }
    } else {
      rval += obj.type;
    }
    rval += "\n";
    rval += indent + "Constructed: " + obj.constructed + "\n";
    if (obj.composed) {
      var subvalues = 0;
      var sub = "";
      for (var i = 0; i < obj.value.length; ++i) {
        if (obj.value[i] !== void 0) {
          subvalues += 1;
          sub += asn1.prettyPrint(obj.value[i], level + 1, indentation);
          if (i + 1 < obj.value.length) {
            sub += ",";
          }
        }
      }
      rval += indent + "Sub values: " + subvalues + sub;
    } else {
      rval += indent + "Value: ";
      if (obj.type === asn1.Type.OID) {
        var oid = asn1.derToOid(obj.value);
        rval += oid;
        if (forge.pki && forge.pki.oids) {
          if (oid in forge.pki.oids) {
            rval += " (" + forge.pki.oids[oid] + ") ";
          }
        }
      }
      if (obj.type === asn1.Type.INTEGER) {
        try {
          rval += asn1.derToInteger(obj.value);
        } catch (ex) {
          rval += "0x" + forge.util.bytesToHex(obj.value);
        }
      } else if (obj.type === asn1.Type.BITSTRING) {
        if (obj.value.length > 1) {
          rval += "0x" + forge.util.bytesToHex(obj.value.slice(1));
        } else {
          rval += "(none)";
        }
        if (obj.value.length > 0) {
          var unused = obj.value.charCodeAt(0);
          if (unused == 1) {
            rval += " (1 unused bit shown)";
          } else if (unused > 1) {
            rval += " (" + unused + " unused bits shown)";
          }
        }
      } else if (obj.type === asn1.Type.OCTETSTRING) {
        if (!_nonLatinRegex.test(obj.value)) {
          rval += "(" + obj.value + ") ";
        }
        rval += "0x" + forge.util.bytesToHex(obj.value);
      } else if (obj.type === asn1.Type.UTF8) {
        rval += forge.util.decodeUtf8(obj.value);
      } else if (obj.type === asn1.Type.PRINTABLESTRING || obj.type === asn1.Type.IA5String) {
        rval += obj.value;
      } else if (_nonLatinRegex.test(obj.value)) {
        rval += "0x" + forge.util.bytesToHex(obj.value);
      } else if (obj.value.length === 0) {
        rval += "[null]";
      } else {
        rval += obj.value;
      }
    }
    return rval;
  };
});

// node_modules/node-forge/lib/cipher.js
var require_cipher = __commonJS((exports2, module2) => {
  var forge = require_forge();
  require_util3();
  module2.exports = forge.cipher = forge.cipher || {};
  forge.cipher.algorithms = forge.cipher.algorithms || {};
  forge.cipher.createCipher = function(algorithm, key) {
    var api = algorithm;
    if (typeof api === "string") {
      api = forge.cipher.getAlgorithm(api);
      if (api) {
        api = api();
      }
    }
    if (!api) {
      throw new Error("Unsupported algorithm: " + algorithm);
    }
    return new forge.cipher.BlockCipher({
      algorithm: api,
      key,
      decrypt: false
    });
  };
  forge.cipher.createDecipher = function(algorithm, key) {
    var api = algorithm;
    if (typeof api === "string") {
      api = forge.cipher.getAlgorithm(api);
      if (api) {
        api = api();
      }
    }
    if (!api) {
      throw new Error("Unsupported algorithm: " + algorithm);
    }
    return new forge.cipher.BlockCipher({
      algorithm: api,
      key,
      decrypt: true
    });
  };
  forge.cipher.registerAlgorithm = function(name, algorithm) {
    name = name.toUpperCase();
    forge.cipher.algorithms[name] = algorithm;
  };
  forge.cipher.getAlgorithm = function(name) {
    name = name.toUpperCase();
    if (name in forge.cipher.algorithms) {
      return forge.cipher.algorithms[name];
    }
    return null;
  };
  var BlockCipher = forge.cipher.BlockCipher = function(options) {
    this.algorithm = options.algorithm;
    this.mode = this.algorithm.mode;
    this.blockSize = this.mode.blockSize;
    this._finish = false;
    this._input = null;
    this.output = null;
    this._op = options.decrypt ? this.mode.decrypt : this.mode.encrypt;
    this._decrypt = options.decrypt;
    this.algorithm.initialize(options);
  };
  BlockCipher.prototype.start = function(options) {
    options = options || {};
    var opts = {};
    for (var key in options) {
      opts[key] = options[key];
    }
    opts.decrypt = this._decrypt;
    this._finish = false;
    this._input = forge.util.createBuffer();
    this.output = options.output || forge.util.createBuffer();
    this.mode.start(opts);
  };
  BlockCipher.prototype.update = function(input) {
    if (input) {
      this._input.putBuffer(input);
    }
    while (!this._op.call(this.mode, this._input, this.output, this._finish) && !this._finish) {
    }
    this._input.compact();
  };
  BlockCipher.prototype.finish = function(pad) {
    if (pad && (this.mode.name === "ECB" || this.mode.name === "CBC")) {
      this.mode.pad = function(input) {
        return pad(this.blockSize, input, false);
      };
      this.mode.unpad = function(output) {
        return pad(this.blockSize, output, true);
      };
    }
    var options = {};
    options.decrypt = this._decrypt;
    options.overflow = this._input.length() % this.blockSize;
    if (!this._decrypt && this.mode.pad) {
      if (!this.mode.pad(this._input, options)) {
        return false;
      }
    }
    this._finish = true;
    this.update();
    if (this._decrypt && this.mode.unpad) {
      if (!this.mode.unpad(this.output, options)) {
        return false;
      }
    }
    if (this.mode.afterFinish) {
      if (!this.mode.afterFinish(this.output, options)) {
        return false;
      }
    }
    return true;
  };
});

// node_modules/node-forge/lib/cipherModes.js
var require_cipherModes = __commonJS((exports2, module2) => {
  var forge = require_forge();
  require_util3();
  forge.cipher = forge.cipher || {};
  var modes = module2.exports = forge.cipher.modes = forge.cipher.modes || {};
  modes.ecb = function(options) {
    options = options || {};
    this.name = "ECB";
    this.cipher = options.cipher;
    this.blockSize = options.blockSize || 16;
    this._ints = this.blockSize / 4;
    this._inBlock = new Array(this._ints);
    this._outBlock = new Array(this._ints);
  };
  modes.ecb.prototype.start = function(options) {
  };
  modes.ecb.prototype.encrypt = function(input, output, finish) {
    if (input.length() < this.blockSize && !(finish && input.length() > 0)) {
      return true;
    }
    for (var i = 0; i < this._ints; ++i) {
      this._inBlock[i] = input.getInt32();
    }
    this.cipher.encrypt(this._inBlock, this._outBlock);
    for (var i = 0; i < this._ints; ++i) {
      output.putInt32(this._outBlock[i]);
    }
  };
  modes.ecb.prototype.decrypt = function(input, output, finish) {
    if (input.length() < this.blockSize && !(finish && input.length() > 0)) {
      return true;
    }
    for (var i = 0; i < this._ints; ++i) {
      this._inBlock[i] = input.getInt32();
    }
    this.cipher.decrypt(this._inBlock, this._outBlock);
    for (var i = 0; i < this._ints; ++i) {
      output.putInt32(this._outBlock[i]);
    }
  };
  modes.ecb.prototype.pad = function(input, options) {
    var padding = input.length() === this.blockSize ? this.blockSize : this.blockSize - input.length();
    input.fillWithByte(padding, padding);
    return true;
  };
  modes.ecb.prototype.unpad = function(output, options) {
    if (options.overflow > 0) {
      return false;
    }
    var len = output.length();
    var count = output.at(len - 1);
    if (count > this.blockSize << 2) {
      return false;
    }
    output.truncate(count);
    return true;
  };
  modes.cbc = function(options) {
    options = options || {};
    this.name = "CBC";
    this.cipher = options.cipher;
    this.blockSize = options.blockSize || 16;
    this._ints = this.blockSize / 4;
    this._inBlock = new Array(this._ints);
    this._outBlock = new Array(this._ints);
  };
  modes.cbc.prototype.start = function(options) {
    if (options.iv === null) {
      if (!this._prev) {
        throw new Error("Invalid IV parameter.");
      }
      this._iv = this._prev.slice(0);
    } else if (!("iv" in options)) {
      throw new Error("Invalid IV parameter.");
    } else {
      this._iv = transformIV(options.iv, this.blockSize);
      this._prev = this._iv.slice(0);
    }
  };
  modes.cbc.prototype.encrypt = function(input, output, finish) {
    if (input.length() < this.blockSize && !(finish && input.length() > 0)) {
      return true;
    }
    for (var i = 0; i < this._ints; ++i) {
      this._inBlock[i] = this._prev[i] ^ input.getInt32();
    }
    this.cipher.encrypt(this._inBlock, this._outBlock);
    for (var i = 0; i < this._ints; ++i) {
      output.putInt32(this._outBlock[i]);
    }
    this._prev = this._outBlock;
  };
  modes.cbc.prototype.decrypt = function(input, output, finish) {
    if (input.length() < this.blockSize && !(finish && input.length() > 0)) {
      return true;
    }
    for (var i = 0; i < this._ints; ++i) {
      this._inBlock[i] = input.getInt32();
    }
    this.cipher.decrypt(this._inBlock, this._outBlock);
    for (var i = 0; i < this._ints; ++i) {
      output.putInt32(this._prev[i] ^ this._outBlock[i]);
    }
    this._prev = this._inBlock.slice(0);
  };
  modes.cbc.prototype.pad = function(input, options) {
    var padding = input.length() === this.blockSize ? this.blockSize : this.blockSize - input.length();
    input.fillWithByte(padding, padding);
    return true;
  };
  modes.cbc.prototype.unpad = function(output, options) {
    if (options.overflow > 0) {
      return false;
    }
    var len = output.length();
    var count = output.at(len - 1);
    if (count > this.blockSize << 2) {
      return false;
    }
    output.truncate(count);
    return true;
  };
  modes.cfb = function(options) {
    options = options || {};
    this.name = "CFB";
    this.cipher = options.cipher;
    this.blockSize = options.blockSize || 16;
    this._ints = this.blockSize / 4;
    this._inBlock = null;
    this._outBlock = new Array(this._ints);
    this._partialBlock = new Array(this._ints);
    this._partialOutput = forge.util.createBuffer();
    this._partialBytes = 0;
  };
  modes.cfb.prototype.start = function(options) {
    if (!("iv" in options)) {
      throw new Error("Invalid IV parameter.");
    }
    this._iv = transformIV(options.iv, this.blockSize);
    this._inBlock = this._iv.slice(0);
    this._partialBytes = 0;
  };
  modes.cfb.prototype.encrypt = function(input, output, finish) {
    var inputLength = input.length();
    if (inputLength === 0) {
      return true;
    }
    this.cipher.encrypt(this._inBlock, this._outBlock);
    if (this._partialBytes === 0 && inputLength >= this.blockSize) {
      for (var i = 0; i < this._ints; ++i) {
        this._inBlock[i] = input.getInt32() ^ this._outBlock[i];
        output.putInt32(this._inBlock[i]);
      }
      return;
    }
    var partialBytes = (this.blockSize - inputLength) % this.blockSize;
    if (partialBytes > 0) {
      partialBytes = this.blockSize - partialBytes;
    }
    this._partialOutput.clear();
    for (var i = 0; i < this._ints; ++i) {
      this._partialBlock[i] = input.getInt32() ^ this._outBlock[i];
      this._partialOutput.putInt32(this._partialBlock[i]);
    }
    if (partialBytes > 0) {
      input.read -= this.blockSize;
    } else {
      for (var i = 0; i < this._ints; ++i) {
        this._inBlock[i] = this._partialBlock[i];
      }
    }
    if (this._partialBytes > 0) {
      this._partialOutput.getBytes(this._partialBytes);
    }
    if (partialBytes > 0 && !finish) {
      output.putBytes(this._partialOutput.getBytes(partialBytes - this._partialBytes));
      this._partialBytes = partialBytes;
      return true;
    }
    output.putBytes(this._partialOutput.getBytes(inputLength - this._partialBytes));
    this._partialBytes = 0;
  };
  modes.cfb.prototype.decrypt = function(input, output, finish) {
    var inputLength = input.length();
    if (inputLength === 0) {
      return true;
    }
    this.cipher.encrypt(this._inBlock, this._outBlock);
    if (this._partialBytes === 0 && inputLength >= this.blockSize) {
      for (var i = 0; i < this._ints; ++i) {
        this._inBlock[i] = input.getInt32();
        output.putInt32(this._inBlock[i] ^ this._outBlock[i]);
      }
      return;
    }
    var partialBytes = (this.blockSize - inputLength) % this.blockSize;
    if (partialBytes > 0) {
      partialBytes = this.blockSize - partialBytes;
    }
    this._partialOutput.clear();
    for (var i = 0; i < this._ints; ++i) {
      this._partialBlock[i] = input.getInt32();
      this._partialOutput.putInt32(this._partialBlock[i] ^ this._outBlock[i]);
    }
    if (partialBytes > 0) {
      input.read -= this.blockSize;
    } else {
      for (var i = 0; i < this._ints; ++i) {
        this._inBlock[i] = this._partialBlock[i];
      }
    }
    if (this._partialBytes > 0) {
      this._partialOutput.getBytes(this._partialBytes);
    }
    if (partialBytes > 0 && !finish) {
      output.putBytes(this._partialOutput.getBytes(partialBytes - this._partialBytes));
      this._partialBytes = partialBytes;
      return true;
    }
    output.putBytes(this._partialOutput.getBytes(inputLength - this._partialBytes));
    this._partialBytes = 0;
  };
  modes.ofb = function(options) {
    options = options || {};
    this.name = "OFB";
    this.cipher = options.cipher;
    this.blockSize = options.blockSize || 16;
    this._ints = this.blockSize / 4;
    this._inBlock = null;
    this._outBlock = new Array(this._ints);
    this._partialOutput = forge.util.createBuffer();
    this._partialBytes = 0;
  };
  modes.ofb.prototype.start = function(options) {
    if (!("iv" in options)) {
      throw new Error("Invalid IV parameter.");
    }
    this._iv = transformIV(options.iv, this.blockSize);
    this._inBlock = this._iv.slice(0);
    this._partialBytes = 0;
  };
  modes.ofb.prototype.encrypt = function(input, output, finish) {
    var inputLength = input.length();
    if (input.length() === 0) {
      return true;
    }
    this.cipher.encrypt(this._inBlock, this._outBlock);
    if (this._partialBytes === 0 && inputLength >= this.blockSize) {
      for (var i = 0; i < this._ints; ++i) {
        output.putInt32(input.getInt32() ^ this._outBlock[i]);
        this._inBlock[i] = this._outBlock[i];
      }
      return;
    }
    var partialBytes = (this.blockSize - inputLength) % this.blockSize;
    if (partialBytes > 0) {
      partialBytes = this.blockSize - partialBytes;
    }
    this._partialOutput.clear();
    for (var i = 0; i < this._ints; ++i) {
      this._partialOutput.putInt32(input.getInt32() ^ this._outBlock[i]);
    }
    if (partialBytes > 0) {
      input.read -= this.blockSize;
    } else {
      for (var i = 0; i < this._ints; ++i) {
        this._inBlock[i] = this._outBlock[i];
      }
    }
    if (this._partialBytes > 0) {
      this._partialOutput.getBytes(this._partialBytes);
    }
    if (partialBytes > 0 && !finish) {
      output.putBytes(this._partialOutput.getBytes(partialBytes - this._partialBytes));
      this._partialBytes = partialBytes;
      return true;
    }
    output.putBytes(this._partialOutput.getBytes(inputLength - this._partialBytes));
    this._partialBytes = 0;
  };
  modes.ofb.prototype.decrypt = modes.ofb.prototype.encrypt;
  modes.ctr = function(options) {
    options = options || {};
    this.name = "CTR";
    this.cipher = options.cipher;
    this.blockSize = options.blockSize || 16;
    this._ints = this.blockSize / 4;
    this._inBlock = null;
    this._outBlock = new Array(this._ints);
    this._partialOutput = forge.util.createBuffer();
    this._partialBytes = 0;
  };
  modes.ctr.prototype.start = function(options) {
    if (!("iv" in options)) {
      throw new Error("Invalid IV parameter.");
    }
    this._iv = transformIV(options.iv, this.blockSize);
    this._inBlock = this._iv.slice(0);
    this._partialBytes = 0;
  };
  modes.ctr.prototype.encrypt = function(input, output, finish) {
    var inputLength = input.length();
    if (inputLength === 0) {
      return true;
    }
    this.cipher.encrypt(this._inBlock, this._outBlock);
    if (this._partialBytes === 0 && inputLength >= this.blockSize) {
      for (var i = 0; i < this._ints; ++i) {
        output.putInt32(input.getInt32() ^ this._outBlock[i]);
      }
    } else {
      var partialBytes = (this.blockSize - inputLength) % this.blockSize;
      if (partialBytes > 0) {
        partialBytes = this.blockSize - partialBytes;
      }
      this._partialOutput.clear();
      for (var i = 0; i < this._ints; ++i) {
        this._partialOutput.putInt32(input.getInt32() ^ this._outBlock[i]);
      }
      if (partialBytes > 0) {
        input.read -= this.blockSize;
      }
      if (this._partialBytes > 0) {
        this._partialOutput.getBytes(this._partialBytes);
      }
      if (partialBytes > 0 && !finish) {
        output.putBytes(this._partialOutput.getBytes(partialBytes - this._partialBytes));
        this._partialBytes = partialBytes;
        return true;
      }
      output.putBytes(this._partialOutput.getBytes(inputLength - this._partialBytes));
      this._partialBytes = 0;
    }
    inc32(this._inBlock);
  };
  modes.ctr.prototype.decrypt = modes.ctr.prototype.encrypt;
  modes.gcm = function(options) {
    options = options || {};
    this.name = "GCM";
    this.cipher = options.cipher;
    this.blockSize = options.blockSize || 16;
    this._ints = this.blockSize / 4;
    this._inBlock = new Array(this._ints);
    this._outBlock = new Array(this._ints);
    this._partialOutput = forge.util.createBuffer();
    this._partialBytes = 0;
    this._R = 3774873600;
  };
  modes.gcm.prototype.start = function(options) {
    if (!("iv" in options)) {
      throw new Error("Invalid IV parameter.");
    }
    var iv = forge.util.createBuffer(options.iv);
    this._cipherLength = 0;
    var additionalData;
    if ("additionalData" in options) {
      additionalData = forge.util.createBuffer(options.additionalData);
    } else {
      additionalData = forge.util.createBuffer();
    }
    if ("tagLength" in options) {
      this._tagLength = options.tagLength;
    } else {
      this._tagLength = 128;
    }
    this._tag = null;
    if (options.decrypt) {
      this._tag = forge.util.createBuffer(options.tag).getBytes();
      if (this._tag.length !== this._tagLength / 8) {
        throw new Error("Authentication tag does not match tag length.");
      }
    }
    this._hashBlock = new Array(this._ints);
    this.tag = null;
    this._hashSubkey = new Array(this._ints);
    this.cipher.encrypt([0, 0, 0, 0], this._hashSubkey);
    this.componentBits = 4;
    this._m = this.generateHashTable(this._hashSubkey, this.componentBits);
    var ivLength = iv.length();
    if (ivLength === 12) {
      this._j0 = [iv.getInt32(), iv.getInt32(), iv.getInt32(), 1];
    } else {
      this._j0 = [0, 0, 0, 0];
      while (iv.length() > 0) {
        this._j0 = this.ghash(this._hashSubkey, this._j0, [iv.getInt32(), iv.getInt32(), iv.getInt32(), iv.getInt32()]);
      }
      this._j0 = this.ghash(this._hashSubkey, this._j0, [0, 0].concat(from64To32(ivLength * 8)));
    }
    this._inBlock = this._j0.slice(0);
    inc32(this._inBlock);
    this._partialBytes = 0;
    additionalData = forge.util.createBuffer(additionalData);
    this._aDataLength = from64To32(additionalData.length() * 8);
    var overflow = additionalData.length() % this.blockSize;
    if (overflow) {
      additionalData.fillWithByte(0, this.blockSize - overflow);
    }
    this._s = [0, 0, 0, 0];
    while (additionalData.length() > 0) {
      this._s = this.ghash(this._hashSubkey, this._s, [
        additionalData.getInt32(),
        additionalData.getInt32(),
        additionalData.getInt32(),
        additionalData.getInt32()
      ]);
    }
  };
  modes.gcm.prototype.encrypt = function(input, output, finish) {
    var inputLength = input.length();
    if (inputLength === 0) {
      return true;
    }
    this.cipher.encrypt(this._inBlock, this._outBlock);
    if (this._partialBytes === 0 && inputLength >= this.blockSize) {
      for (var i = 0; i < this._ints; ++i) {
        output.putInt32(this._outBlock[i] ^= input.getInt32());
      }
      this._cipherLength += this.blockSize;
    } else {
      var partialBytes = (this.blockSize - inputLength) % this.blockSize;
      if (partialBytes > 0) {
        partialBytes = this.blockSize - partialBytes;
      }
      this._partialOutput.clear();
      for (var i = 0; i < this._ints; ++i) {
        this._partialOutput.putInt32(input.getInt32() ^ this._outBlock[i]);
      }
      if (partialBytes <= 0 || finish) {
        if (finish) {
          var overflow = inputLength % this.blockSize;
          this._cipherLength += overflow;
          this._partialOutput.truncate(this.blockSize - overflow);
        } else {
          this._cipherLength += this.blockSize;
        }
        for (var i = 0; i < this._ints; ++i) {
          this._outBlock[i] = this._partialOutput.getInt32();
        }
        this._partialOutput.read -= this.blockSize;
      }
      if (this._partialBytes > 0) {
        this._partialOutput.getBytes(this._partialBytes);
      }
      if (partialBytes > 0 && !finish) {
        input.read -= this.blockSize;
        output.putBytes(this._partialOutput.getBytes(partialBytes - this._partialBytes));
        this._partialBytes = partialBytes;
        return true;
      }
      output.putBytes(this._partialOutput.getBytes(inputLength - this._partialBytes));
      this._partialBytes = 0;
    }
    this._s = this.ghash(this._hashSubkey, this._s, this._outBlock);
    inc32(this._inBlock);
  };
  modes.gcm.prototype.decrypt = function(input, output, finish) {
    var inputLength = input.length();
    if (inputLength < this.blockSize && !(finish && inputLength > 0)) {
      return true;
    }
    this.cipher.encrypt(this._inBlock, this._outBlock);
    inc32(this._inBlock);
    this._hashBlock[0] = input.getInt32();
    this._hashBlock[1] = input.getInt32();
    this._hashBlock[2] = input.getInt32();
    this._hashBlock[3] = input.getInt32();
    this._s = this.ghash(this._hashSubkey, this._s, this._hashBlock);
    for (var i = 0; i < this._ints; ++i) {
      output.putInt32(this._outBlock[i] ^ this._hashBlock[i]);
    }
    if (inputLength < this.blockSize) {
      this._cipherLength += inputLength % this.blockSize;
    } else {
      this._cipherLength += this.blockSize;
    }
  };
  modes.gcm.prototype.afterFinish = function(output, options) {
    var rval = true;
    if (options.decrypt && options.overflow) {
      output.truncate(this.blockSize - options.overflow);
    }
    this.tag = forge.util.createBuffer();
    var lengths = this._aDataLength.concat(from64To32(this._cipherLength * 8));
    this._s = this.ghash(this._hashSubkey, this._s, lengths);
    var tag = [];
    this.cipher.encrypt(this._j0, tag);
    for (var i = 0; i < this._ints; ++i) {
      this.tag.putInt32(this._s[i] ^ tag[i]);
    }
    this.tag.truncate(this.tag.length() % (this._tagLength / 8));
    if (options.decrypt && this.tag.bytes() !== this._tag) {
      rval = false;
    }
    return rval;
  };
  modes.gcm.prototype.multiply = function(x, y) {
    var z_i = [0, 0, 0, 0];
    var v_i = y.slice(0);
    for (var i = 0; i < 128; ++i) {
      var x_i = x[i / 32 | 0] & 1 << 31 - i % 32;
      if (x_i) {
        z_i[0] ^= v_i[0];
        z_i[1] ^= v_i[1];
        z_i[2] ^= v_i[2];
        z_i[3] ^= v_i[3];
      }
      this.pow(v_i, v_i);
    }
    return z_i;
  };
  modes.gcm.prototype.pow = function(x, out) {
    var lsb = x[3] & 1;
    for (var i = 3; i > 0; --i) {
      out[i] = x[i] >>> 1 | (x[i - 1] & 1) << 31;
    }
    out[0] = x[0] >>> 1;
    if (lsb) {
      out[0] ^= this._R;
    }
  };
  modes.gcm.prototype.tableMultiply = function(x) {
    var z = [0, 0, 0, 0];
    for (var i = 0; i < 32; ++i) {
      var idx = i / 8 | 0;
      var x_i = x[idx] >>> (7 - i % 8) * 4 & 15;
      var ah = this._m[i][x_i];
      z[0] ^= ah[0];
      z[1] ^= ah[1];
      z[2] ^= ah[2];
      z[3] ^= ah[3];
    }
    return z;
  };
  modes.gcm.prototype.ghash = function(h, y, x) {
    y[0] ^= x[0];
    y[1] ^= x[1];
    y[2] ^= x[2];
    y[3] ^= x[3];
    return this.tableMultiply(y);
  };
  modes.gcm.prototype.generateHashTable = function(h, bits) {
    var multiplier = 8 / bits;
    var perInt = 4 * multiplier;
    var size = 16 * multiplier;
    var m = new Array(size);
    for (var i = 0; i < size; ++i) {
      var tmp = [0, 0, 0, 0];
      var idx = i / perInt | 0;
      var shft = (perInt - 1 - i % perInt) * bits;
      tmp[idx] = 1 << bits - 1 << shft;
      m[i] = this.generateSubHashTable(this.multiply(tmp, h), bits);
    }
    return m;
  };
  modes.gcm.prototype.generateSubHashTable = function(mid, bits) {
    var size = 1 << bits;
    var half = size >>> 1;
    var m = new Array(size);
    m[half] = mid.slice(0);
    var i = half >>> 1;
    while (i > 0) {
      this.pow(m[2 * i], m[i] = []);
      i >>= 1;
    }
    i = 2;
    while (i < half) {
      for (var j = 1; j < i; ++j) {
        var m_i = m[i];
        var m_j = m[j];
        m[i + j] = [
          m_i[0] ^ m_j[0],
          m_i[1] ^ m_j[1],
          m_i[2] ^ m_j[2],
          m_i[3] ^ m_j[3]
        ];
      }
      i *= 2;
    }
    m[0] = [0, 0, 0, 0];
    for (i = half + 1; i < size; ++i) {
      var c = m[i ^ half];
      m[i] = [mid[0] ^ c[0], mid[1] ^ c[1], mid[2] ^ c[2], mid[3] ^ c[3]];
    }
    return m;
  };
  function transformIV(iv, blockSize) {
    if (typeof iv === "string") {
      iv = forge.util.createBuffer(iv);
    }
    if (forge.util.isArray(iv) && iv.length > 4) {
      var tmp = iv;
      iv = forge.util.createBuffer();
      for (var i = 0; i < tmp.length; ++i) {
        iv.putByte(tmp[i]);
      }
    }
    if (iv.length() < blockSize) {
      throw new Error("Invalid IV length; got " + iv.length() + " bytes and expected " + blockSize + " bytes.");
    }
    if (!forge.util.isArray(iv)) {
      var ints = [];
      var blocks = blockSize / 4;
      for (var i = 0; i < blocks; ++i) {
        ints.push(iv.getInt32());
      }
      iv = ints;
    }
    return iv;
  }
  function inc32(block) {
    block[block.length - 1] = block[block.length - 1] + 1 & 4294967295;
  }
  function from64To32(num) {
    return [num / 4294967296 | 0, num & 4294967295];
  }
});

// node_modules/node-forge/lib/aes.js
var require_aes = __commonJS((exports2, module2) => {
  var forge = require_forge();
  require_cipher();
  require_cipherModes();
  require_util3();
  module2.exports = forge.aes = forge.aes || {};
  forge.aes.startEncrypting = function(key, iv, output, mode) {
    var cipher = _createCipher({
      key,
      output,
      decrypt: false,
      mode
    });
    cipher.start(iv);
    return cipher;
  };
  forge.aes.createEncryptionCipher = function(key, mode) {
    return _createCipher({
      key,
      output: null,
      decrypt: false,
      mode
    });
  };
  forge.aes.startDecrypting = function(key, iv, output, mode) {
    var cipher = _createCipher({
      key,
      output,
      decrypt: true,
      mode
    });
    cipher.start(iv);
    return cipher;
  };
  forge.aes.createDecryptionCipher = function(key, mode) {
    return _createCipher({
      key,
      output: null,
      decrypt: true,
      mode
    });
  };
  forge.aes.Algorithm = function(name, mode) {
    if (!init) {
      initialize();
    }
    var self2 = this;
    self2.name = name;
    self2.mode = new mode({
      blockSize: 16,
      cipher: {
        encrypt: function(inBlock, outBlock) {
          return _updateBlock(self2._w, inBlock, outBlock, false);
        },
        decrypt: function(inBlock, outBlock) {
          return _updateBlock(self2._w, inBlock, outBlock, true);
        }
      }
    });
    self2._init = false;
  };
  forge.aes.Algorithm.prototype.initialize = function(options) {
    if (this._init) {
      return;
    }
    var key = options.key;
    var tmp;
    if (typeof key === "string" && (key.length === 16 || key.length === 24 || key.length === 32)) {
      key = forge.util.createBuffer(key);
    } else if (forge.util.isArray(key) && (key.length === 16 || key.length === 24 || key.length === 32)) {
      tmp = key;
      key = forge.util.createBuffer();
      for (var i = 0; i < tmp.length; ++i) {
        key.putByte(tmp[i]);
      }
    }
    if (!forge.util.isArray(key)) {
      tmp = key;
      key = [];
      var len = tmp.length();
      if (len === 16 || len === 24 || len === 32) {
        len = len >>> 2;
        for (var i = 0; i < len; ++i) {
          key.push(tmp.getInt32());
        }
      }
    }
    if (!forge.util.isArray(key) || !(key.length === 4 || key.length === 6 || key.length === 8)) {
      throw new Error("Invalid key parameter.");
    }
    var mode = this.mode.name;
    var encryptOp = ["CFB", "OFB", "CTR", "GCM"].indexOf(mode) !== -1;
    this._w = _expandKey(key, options.decrypt && !encryptOp);
    this._init = true;
  };
  forge.aes._expandKey = function(key, decrypt) {
    if (!init) {
      initialize();
    }
    return _expandKey(key, decrypt);
  };
  forge.aes._updateBlock = _updateBlock;
  registerAlgorithm("AES-ECB", forge.cipher.modes.ecb);
  registerAlgorithm("AES-CBC", forge.cipher.modes.cbc);
  registerAlgorithm("AES-CFB", forge.cipher.modes.cfb);
  registerAlgorithm("AES-OFB", forge.cipher.modes.ofb);
  registerAlgorithm("AES-CTR", forge.cipher.modes.ctr);
  registerAlgorithm("AES-GCM", forge.cipher.modes.gcm);
  function registerAlgorithm(name, mode) {
    var factory = function() {
      return new forge.aes.Algorithm(name, mode);
    };
    forge.cipher.registerAlgorithm(name, factory);
  }
  var init = false;
  var Nb = 4;
  var sbox;
  var isbox;
  var rcon;
  var mix;
  var imix;
  function initialize() {
    init = true;
    rcon = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54];
    var xtime = new Array(256);
    for (var i = 0; i < 128; ++i) {
      xtime[i] = i << 1;
      xtime[i + 128] = i + 128 << 1 ^ 283;
    }
    sbox = new Array(256);
    isbox = new Array(256);
    mix = new Array(4);
    imix = new Array(4);
    for (var i = 0; i < 4; ++i) {
      mix[i] = new Array(256);
      imix[i] = new Array(256);
    }
    var e = 0, ei = 0, e2, e4, e8, sx, sx2, me, ime;
    for (var i = 0; i < 256; ++i) {
      sx = ei ^ ei << 1 ^ ei << 2 ^ ei << 3 ^ ei << 4;
      sx = sx >> 8 ^ sx & 255 ^ 99;
      sbox[e] = sx;
      isbox[sx] = e;
      sx2 = xtime[sx];
      e2 = xtime[e];
      e4 = xtime[e2];
      e8 = xtime[e4];
      me = sx2 << 24 ^ sx << 16 ^ sx << 8 ^ (sx ^ sx2);
      ime = (e2 ^ e4 ^ e8) << 24 ^ (e ^ e8) << 16 ^ (e ^ e4 ^ e8) << 8 ^ (e ^ e2 ^ e8);
      for (var n = 0; n < 4; ++n) {
        mix[n][e] = me;
        imix[n][sx] = ime;
        me = me << 24 | me >>> 8;
        ime = ime << 24 | ime >>> 8;
      }
      if (e === 0) {
        e = ei = 1;
      } else {
        e = e2 ^ xtime[xtime[xtime[e2 ^ e8]]];
        ei ^= xtime[xtime[ei]];
      }
    }
  }
  function _expandKey(key, decrypt) {
    var w = key.slice(0);
    var temp, iNk = 1;
    var Nk = w.length;
    var Nr1 = Nk + 6 + 1;
    var end = Nb * Nr1;
    for (var i = Nk; i < end; ++i) {
      temp = w[i - 1];
      if (i % Nk === 0) {
        temp = sbox[temp >>> 16 & 255] << 24 ^ sbox[temp >>> 8 & 255] << 16 ^ sbox[temp & 255] << 8 ^ sbox[temp >>> 24] ^ rcon[iNk] << 24;
        iNk++;
      } else if (Nk > 6 && i % Nk === 4) {
        temp = sbox[temp >>> 24] << 24 ^ sbox[temp >>> 16 & 255] << 16 ^ sbox[temp >>> 8 & 255] << 8 ^ sbox[temp & 255];
      }
      w[i] = w[i - Nk] ^ temp;
    }
    if (decrypt) {
      var tmp;
      var m0 = imix[0];
      var m1 = imix[1];
      var m2 = imix[2];
      var m3 = imix[3];
      var wnew = w.slice(0);
      end = w.length;
      for (var i = 0, wi = end - Nb; i < end; i += Nb, wi -= Nb) {
        if (i === 0 || i === end - Nb) {
          wnew[i] = w[wi];
          wnew[i + 1] = w[wi + 3];
          wnew[i + 2] = w[wi + 2];
          wnew[i + 3] = w[wi + 1];
        } else {
          for (var n = 0; n < Nb; ++n) {
            tmp = w[wi + n];
            wnew[i + (3 & -n)] = m0[sbox[tmp >>> 24]] ^ m1[sbox[tmp >>> 16 & 255]] ^ m2[sbox[tmp >>> 8 & 255]] ^ m3[sbox[tmp & 255]];
          }
        }
      }
      w = wnew;
    }
    return w;
  }
  function _updateBlock(w, input, output, decrypt) {
    var Nr = w.length / 4 - 1;
    var m0, m1, m2, m3, sub;
    if (decrypt) {
      m0 = imix[0];
      m1 = imix[1];
      m2 = imix[2];
      m3 = imix[3];
      sub = isbox;
    } else {
      m0 = mix[0];
      m1 = mix[1];
      m2 = mix[2];
      m3 = mix[3];
      sub = sbox;
    }
    var a, b, c, d, a2, b2, c2;
    a = input[0] ^ w[0];
    b = input[decrypt ? 3 : 1] ^ w[1];
    c = input[2] ^ w[2];
    d = input[decrypt ? 1 : 3] ^ w[3];
    var i = 3;
    for (var round = 1; round < Nr; ++round) {
      a2 = m0[a >>> 24] ^ m1[b >>> 16 & 255] ^ m2[c >>> 8 & 255] ^ m3[d & 255] ^ w[++i];
      b2 = m0[b >>> 24] ^ m1[c >>> 16 & 255] ^ m2[d >>> 8 & 255] ^ m3[a & 255] ^ w[++i];
      c2 = m0[c >>> 24] ^ m1[d >>> 16 & 255] ^ m2[a >>> 8 & 255] ^ m3[b & 255] ^ w[++i];
      d = m0[d >>> 24] ^ m1[a >>> 16 & 255] ^ m2[b >>> 8 & 255] ^ m3[c & 255] ^ w[++i];
      a = a2;
      b = b2;
      c = c2;
    }
    output[0] = sub[a >>> 24] << 24 ^ sub[b >>> 16 & 255] << 16 ^ sub[c >>> 8 & 255] << 8 ^ sub[d & 255] ^ w[++i];
    output[decrypt ? 3 : 1] = sub[b >>> 24] << 24 ^ sub[c >>> 16 & 255] << 16 ^ sub[d >>> 8 & 255] << 8 ^ sub[a & 255] ^ w[++i];
    output[2] = sub[c >>> 24] << 24 ^ sub[d >>> 16 & 255] << 16 ^ sub[a >>> 8 & 255] << 8 ^ sub[b & 255] ^ w[++i];
    output[decrypt ? 1 : 3] = sub[d >>> 24] << 24 ^ sub[a >>> 16 & 255] << 16 ^ sub[b >>> 8 & 255] << 8 ^ sub[c & 255] ^ w[++i];
  }
  function _createCipher(options) {
    options = options || {};
    var mode = (options.mode || "CBC").toUpperCase();
    var algorithm = "AES-" + mode;
    var cipher;
    if (options.decrypt) {
      cipher = forge.cipher.createDecipher(algorithm, options.key);
    } else {
      cipher = forge.cipher.createCipher(algorithm, options.key);
    }
    var start = cipher.start;
    cipher.start = function(iv, options2) {
      var output = null;
      if (options2 instanceof forge.util.ByteBuffer) {
        output = options2;
        options2 = {};
      }
      options2 = options2 || {};
      options2.output = output;
      options2.iv = iv;
      start.call(cipher, options2);
    };
    return cipher;
  }
});

// node_modules/node-forge/lib/des.js
var require_des = __commonJS((exports2, module2) => {
  var forge = require_forge();
  require_cipher();
  require_cipherModes();
  require_util3();
  module2.exports = forge.des = forge.des || {};
  forge.des.startEncrypting = function(key, iv, output, mode) {
    var cipher = _createCipher({
      key,
      output,
      decrypt: false,
      mode: mode || (iv === null ? "ECB" : "CBC")
    });
    cipher.start(iv);
    return cipher;
  };
  forge.des.createEncryptionCipher = function(key, mode) {
    return _createCipher({
      key,
      output: null,
      decrypt: false,
      mode
    });
  };
  forge.des.startDecrypting = function(key, iv, output, mode) {
    var cipher = _createCipher({
      key,
      output,
      decrypt: true,
      mode: mode || (iv === null ? "ECB" : "CBC")
    });
    cipher.start(iv);
    return cipher;
  };
  forge.des.createDecryptionCipher = function(key, mode) {
    return _createCipher({
      key,
      output: null,
      decrypt: true,
      mode
    });
  };
  forge.des.Algorithm = function(name, mode) {
    var self2 = this;
    self2.name = name;
    self2.mode = new mode({
      blockSize: 8,
      cipher: {
        encrypt: function(inBlock, outBlock) {
          return _updateBlock(self2._keys, inBlock, outBlock, false);
        },
        decrypt: function(inBlock, outBlock) {
          return _updateBlock(self2._keys, inBlock, outBlock, true);
        }
      }
    });
    self2._init = false;
  };
  forge.des.Algorithm.prototype.initialize = function(options) {
    if (this._init) {
      return;
    }
    var key = forge.util.createBuffer(options.key);
    if (this.name.indexOf("3DES") === 0) {
      if (key.length() !== 24) {
        throw new Error("Invalid Triple-DES key size: " + key.length() * 8);
      }
    }
    this._keys = _createKeys(key);
    this._init = true;
  };
  registerAlgorithm("DES-ECB", forge.cipher.modes.ecb);
  registerAlgorithm("DES-CBC", forge.cipher.modes.cbc);
  registerAlgorithm("DES-CFB", forge.cipher.modes.cfb);
  registerAlgorithm("DES-OFB", forge.cipher.modes.ofb);
  registerAlgorithm("DES-CTR", forge.cipher.modes.ctr);
  registerAlgorithm("3DES-ECB", forge.cipher.modes.ecb);
  registerAlgorithm("3DES-CBC", forge.cipher.modes.cbc);
  registerAlgorithm("3DES-CFB", forge.cipher.modes.cfb);
  registerAlgorithm("3DES-OFB", forge.cipher.modes.ofb);
  registerAlgorithm("3DES-CTR", forge.cipher.modes.ctr);
  function registerAlgorithm(name, mode) {
    var factory = function() {
      return new forge.des.Algorithm(name, mode);
    };
    forge.cipher.registerAlgorithm(name, factory);
  }
  var spfunction1 = [16843776, 0, 65536, 16843780, 16842756, 66564, 4, 65536, 1024, 16843776, 16843780, 1024, 16778244, 16842756, 16777216, 4, 1028, 16778240, 16778240, 66560, 66560, 16842752, 16842752, 16778244, 65540, 16777220, 16777220, 65540, 0, 1028, 66564, 16777216, 65536, 16843780, 4, 16842752, 16843776, 16777216, 16777216, 1024, 16842756, 65536, 66560, 16777220, 1024, 4, 16778244, 66564, 16843780, 65540, 16842752, 16778244, 16777220, 1028, 66564, 16843776, 1028, 16778240, 16778240, 0, 65540, 66560, 0, 16842756];
  var spfunction2 = [-2146402272, -2147450880, 32768, 1081376, 1048576, 32, -2146435040, -2147450848, -2147483616, -2146402272, -2146402304, -2147483648, -2147450880, 1048576, 32, -2146435040, 1081344, 1048608, -2147450848, 0, -2147483648, 32768, 1081376, -2146435072, 1048608, -2147483616, 0, 1081344, 32800, -2146402304, -2146435072, 32800, 0, 1081376, -2146435040, 1048576, -2147450848, -2146435072, -2146402304, 32768, -2146435072, -2147450880, 32, -2146402272, 1081376, 32, 32768, -2147483648, 32800, -2146402304, 1048576, -2147483616, 1048608, -2147450848, -2147483616, 1048608, 1081344, 0, -2147450880, 32800, -2147483648, -2146435040, -2146402272, 1081344];
  var spfunction3 = [520, 134349312, 0, 134348808, 134218240, 0, 131592, 134218240, 131080, 134217736, 134217736, 131072, 134349320, 131080, 134348800, 520, 134217728, 8, 134349312, 512, 131584, 134348800, 134348808, 131592, 134218248, 131584, 131072, 134218248, 8, 134349320, 512, 134217728, 134349312, 134217728, 131080, 520, 131072, 134349312, 134218240, 0, 512, 131080, 134349320, 134218240, 134217736, 512, 0, 134348808, 134218248, 131072, 134217728, 134349320, 8, 131592, 131584, 134217736, 134348800, 134218248, 520, 134348800, 131592, 8, 134348808, 131584];
  var spfunction4 = [8396801, 8321, 8321, 128, 8396928, 8388737, 8388609, 8193, 0, 8396800, 8396800, 8396929, 129, 0, 8388736, 8388609, 1, 8192, 8388608, 8396801, 128, 8388608, 8193, 8320, 8388737, 1, 8320, 8388736, 8192, 8396928, 8396929, 129, 8388736, 8388609, 8396800, 8396929, 129, 0, 0, 8396800, 8320, 8388736, 8388737, 1, 8396801, 8321, 8321, 128, 8396929, 129, 1, 8192, 8388609, 8193, 8396928, 8388737, 8193, 8320, 8388608, 8396801, 128, 8388608, 8192, 8396928];
  var spfunction5 = [256, 34078976, 34078720, 1107296512, 524288, 256, 1073741824, 34078720, 1074266368, 524288, 33554688, 1074266368, 1107296512, 1107820544, 524544, 1073741824, 33554432, 1074266112, 1074266112, 0, 1073742080, 1107820800, 1107820800, 33554688, 1107820544, 1073742080, 0, 1107296256, 34078976, 33554432, 1107296256, 524544, 524288, 1107296512, 256, 33554432, 1073741824, 34078720, 1107296512, 1074266368, 33554688, 1073741824, 1107820544, 34078976, 1074266368, 256, 33554432, 1107820544, 1107820800, 524544, 1107296256, 1107820800, 34078720, 0, 1074266112, 1107296256, 524544, 33554688, 1073742080, 524288, 0, 1074266112, 34078976, 1073742080];
  var spfunction6 = [536870928, 541065216, 16384, 541081616, 541065216, 16, 541081616, 4194304, 536887296, 4210704, 4194304, 536870928, 4194320, 536887296, 536870912, 16400, 0, 4194320, 536887312, 16384, 4210688, 536887312, 16, 541065232, 541065232, 0, 4210704, 541081600, 16400, 4210688, 541081600, 536870912, 536887296, 16, 541065232, 4210688, 541081616, 4194304, 16400, 536870928, 4194304, 536887296, 536870912, 16400, 536870928, 541081616, 4210688, 541065216, 4210704, 541081600, 0, 541065232, 16, 16384, 541065216, 4210704, 16384, 4194320, 536887312, 0, 541081600, 536870912, 4194320, 536887312];
  var spfunction7 = [2097152, 69206018, 67110914, 0, 2048, 67110914, 2099202, 69208064, 69208066, 2097152, 0, 67108866, 2, 67108864, 69206018, 2050, 67110912, 2099202, 2097154, 67110912, 67108866, 69206016, 69208064, 2097154, 69206016, 2048, 2050, 69208066, 2099200, 2, 67108864, 2099200, 67108864, 2099200, 2097152, 67110914, 67110914, 69206018, 69206018, 2, 2097154, 67108864, 67110912, 2097152, 69208064, 2050, 2099202, 69208064, 2050, 67108866, 69208066, 69206016, 2099200, 0, 2, 69208066, 0, 2099202, 69206016, 2048, 67108866, 67110912, 2048, 2097154];
  var spfunction8 = [268439616, 4096, 262144, 268701760, 268435456, 268439616, 64, 268435456, 262208, 268697600, 268701760, 266240, 268701696, 266304, 4096, 64, 268697600, 268435520, 268439552, 4160, 266240, 262208, 268697664, 268701696, 4160, 0, 0, 268697664, 268435520, 268439552, 266304, 262144, 266304, 262144, 268701696, 4096, 64, 268697664, 4096, 266304, 268439552, 64, 268435520, 268697600, 268697664, 268435456, 262144, 268439616, 0, 268701760, 262208, 268435520, 268697600, 268439552, 268439616, 0, 268701760, 266240, 266240, 4160, 4160, 262208, 268435456, 268701696];
  function _createKeys(key) {
    var pc2bytes0 = [0, 4, 536870912, 536870916, 65536, 65540, 536936448, 536936452, 512, 516, 536871424, 536871428, 66048, 66052, 536936960, 536936964], pc2bytes1 = [0, 1, 1048576, 1048577, 67108864, 67108865, 68157440, 68157441, 256, 257, 1048832, 1048833, 67109120, 67109121, 68157696, 68157697], pc2bytes2 = [0, 8, 2048, 2056, 16777216, 16777224, 16779264, 16779272, 0, 8, 2048, 2056, 16777216, 16777224, 16779264, 16779272], pc2bytes3 = [0, 2097152, 134217728, 136314880, 8192, 2105344, 134225920, 136323072, 131072, 2228224, 134348800, 136445952, 139264, 2236416, 134356992, 136454144], pc2bytes4 = [0, 262144, 16, 262160, 0, 262144, 16, 262160, 4096, 266240, 4112, 266256, 4096, 266240, 4112, 266256], pc2bytes5 = [0, 1024, 32, 1056, 0, 1024, 32, 1056, 33554432, 33555456, 33554464, 33555488, 33554432, 33555456, 33554464, 33555488], pc2bytes6 = [0, 268435456, 524288, 268959744, 2, 268435458, 524290, 268959746, 0, 268435456, 524288, 268959744, 2, 268435458, 524290, 268959746], pc2bytes7 = [0, 65536, 2048, 67584, 536870912, 536936448, 536872960, 536938496, 131072, 196608, 133120, 198656, 537001984, 537067520, 537004032, 537069568], pc2bytes8 = [0, 262144, 0, 262144, 2, 262146, 2, 262146, 33554432, 33816576, 33554432, 33816576, 33554434, 33816578, 33554434, 33816578], pc2bytes9 = [0, 268435456, 8, 268435464, 0, 268435456, 8, 268435464, 1024, 268436480, 1032, 268436488, 1024, 268436480, 1032, 268436488], pc2bytes10 = [0, 32, 0, 32, 1048576, 1048608, 1048576, 1048608, 8192, 8224, 8192, 8224, 1056768, 1056800, 1056768, 1056800], pc2bytes11 = [0, 16777216, 512, 16777728, 2097152, 18874368, 2097664, 18874880, 67108864, 83886080, 67109376, 83886592, 69206016, 85983232, 69206528, 85983744], pc2bytes12 = [0, 4096, 134217728, 134221824, 524288, 528384, 134742016, 134746112, 16, 4112, 134217744, 134221840, 524304, 528400, 134742032, 134746128], pc2bytes13 = [0, 4, 256, 260, 0, 4, 256, 260, 1, 5, 257, 261, 1, 5, 257, 261];
    var iterations = key.length() > 8 ? 3 : 1;
    var keys = [];
    var shifts = [0, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0];
    var n = 0, tmp;
    for (var j = 0; j < iterations; j++) {
      var left = key.getInt32();
      var right = key.getInt32();
      tmp = (left >>> 4 ^ right) & 252645135;
      right ^= tmp;
      left ^= tmp << 4;
      tmp = (right >>> -16 ^ left) & 65535;
      left ^= tmp;
      right ^= tmp << -16;
      tmp = (left >>> 2 ^ right) & 858993459;
      right ^= tmp;
      left ^= tmp << 2;
      tmp = (right >>> -16 ^ left) & 65535;
      left ^= tmp;
      right ^= tmp << -16;
      tmp = (left >>> 1 ^ right) & 1431655765;
      right ^= tmp;
      left ^= tmp << 1;
      tmp = (right >>> 8 ^ left) & 16711935;
      left ^= tmp;
      right ^= tmp << 8;
      tmp = (left >>> 1 ^ right) & 1431655765;
      right ^= tmp;
      left ^= tmp << 1;
      tmp = left << 8 | right >>> 20 & 240;
      left = right << 24 | right << 8 & 16711680 | right >>> 8 & 65280 | right >>> 24 & 240;
      right = tmp;
      for (var i = 0; i < shifts.length; ++i) {
        if (shifts[i]) {
          left = left << 2 | left >>> 26;
          right = right << 2 | right >>> 26;
        } else {
          left = left << 1 | left >>> 27;
          right = right << 1 | right >>> 27;
        }
        left &= -15;
        right &= -15;
        var lefttmp = pc2bytes0[left >>> 28] | pc2bytes1[left >>> 24 & 15] | pc2bytes2[left >>> 20 & 15] | pc2bytes3[left >>> 16 & 15] | pc2bytes4[left >>> 12 & 15] | pc2bytes5[left >>> 8 & 15] | pc2bytes6[left >>> 4 & 15];
        var righttmp = pc2bytes7[right >>> 28] | pc2bytes8[right >>> 24 & 15] | pc2bytes9[right >>> 20 & 15] | pc2bytes10[right >>> 16 & 15] | pc2bytes11[right >>> 12 & 15] | pc2bytes12[right >>> 8 & 15] | pc2bytes13[right >>> 4 & 15];
        tmp = (righttmp >>> 16 ^ lefttmp) & 65535;
        keys[n++] = lefttmp ^ tmp;
        keys[n++] = righttmp ^ tmp << 16;
      }
    }
    return keys;
  }
  function _updateBlock(keys, input, output, decrypt) {
    var iterations = keys.length === 32 ? 3 : 9;
    var looping;
    if (iterations === 3) {
      looping = decrypt ? [30, -2, -2] : [0, 32, 2];
    } else {
      looping = decrypt ? [94, 62, -2, 32, 64, 2, 30, -2, -2] : [0, 32, 2, 62, 30, -2, 64, 96, 2];
    }
    var tmp;
    var left = input[0];
    var right = input[1];
    tmp = (left >>> 4 ^ right) & 252645135;
    right ^= tmp;
    left ^= tmp << 4;
    tmp = (left >>> 16 ^ right) & 65535;
    right ^= tmp;
    left ^= tmp << 16;
    tmp = (right >>> 2 ^ left) & 858993459;
    left ^= tmp;
    right ^= tmp << 2;
    tmp = (right >>> 8 ^ left) & 16711935;
    left ^= tmp;
    right ^= tmp << 8;
    tmp = (left >>> 1 ^ right) & 1431655765;
    right ^= tmp;
    left ^= tmp << 1;
    left = left << 1 | left >>> 31;
    right = right << 1 | right >>> 31;
    for (var j = 0; j < iterations; j += 3) {
      var endloop = looping[j + 1];
      var loopinc = looping[j + 2];
      for (var i = looping[j]; i != endloop; i += loopinc) {
        var right1 = right ^ keys[i];
        var right2 = (right >>> 4 | right << 28) ^ keys[i + 1];
        tmp = left;
        left = right;
        right = tmp ^ (spfunction2[right1 >>> 24 & 63] | spfunction4[right1 >>> 16 & 63] | spfunction6[right1 >>> 8 & 63] | spfunction8[right1 & 63] | spfunction1[right2 >>> 24 & 63] | spfunction3[right2 >>> 16 & 63] | spfunction5[right2 >>> 8 & 63] | spfunction7[right2 & 63]);
      }
      tmp = left;
      left = right;
      right = tmp;
    }
    left = left >>> 1 | left << 31;
    right = right >>> 1 | right << 31;
    tmp = (left >>> 1 ^ right) & 1431655765;
    right ^= tmp;
    left ^= tmp << 1;
    tmp = (right >>> 8 ^ left) & 16711935;
    left ^= tmp;
    right ^= tmp << 8;
    tmp = (right >>> 2 ^ left) & 858993459;
    left ^= tmp;
    right ^= tmp << 2;
    tmp = (left >>> 16 ^ right) & 65535;
    right ^= tmp;
    left ^= tmp << 16;
    tmp = (left >>> 4 ^ right) & 252645135;
    right ^= tmp;
    left ^= tmp << 4;
    output[0] = left;
    output[1] = right;
  }
  function _createCipher(options) {
    options = options || {};
    var mode = (options.mode || "CBC").toUpperCase();
    var algorithm = "DES-" + mode;
    var cipher;
    if (options.decrypt) {
      cipher = forge.cipher.createDecipher(algorithm, options.key);
    } else {
      cipher = forge.cipher.createCipher(algorithm, options.key);
    }
    var start = cipher.start;
    cipher.start = function(iv, options2) {
      var output = null;
      if (options2 instanceof forge.util.ByteBuffer) {
        output = options2;
        options2 = {};
      }
      options2 = options2 || {};
      options2.output = output;
      options2.iv = iv;
      start.call(cipher, options2);
    };
    return cipher;
  }
});

// node_modules/node-forge/lib/md.js
var require_md = __commonJS((exports2, module2) => {
  var forge = require_forge();
  module2.exports = forge.md = forge.md || {};
  forge.md.algorithms = forge.md.algorithms || {};
});

// node_modules/node-forge/lib/hmac.js
var require_hmac = __commonJS((exports2, module2) => {
  var forge = require_forge();
  require_md();
  require_util3();
  var hmac = module2.exports = forge.hmac = forge.hmac || {};
  hmac.create = function() {
    var _key = null;
    var _md = null;
    var _ipadding = null;
    var _opadding = null;
    var ctx = {};
    ctx.start = function(md, key) {
      if (md !== null) {
        if (typeof md === "string") {
          md = md.toLowerCase();
          if (md in forge.md.algorithms) {
            _md = forge.md.algorithms[md].create();
          } else {
            throw new Error('Unknown hash algorithm "' + md + '"');
          }
        } else {
          _md = md;
        }
      }
      if (key === null) {
        key = _key;
      } else {
        if (typeof key === "string") {
          key = forge.util.createBuffer(key);
        } else if (forge.util.isArray(key)) {
          var tmp = key;
          key = forge.util.createBuffer();
          for (var i = 0; i < tmp.length; ++i) {
            key.putByte(tmp[i]);
          }
        }
        var keylen = key.length();
        if (keylen > _md.blockLength) {
          _md.start();
          _md.update(key.bytes());
          key = _md.digest();
        }
        _ipadding = forge.util.createBuffer();
        _opadding = forge.util.createBuffer();
        keylen = key.length();
        for (var i = 0; i < keylen; ++i) {
          var tmp = key.at(i);
          _ipadding.putByte(54 ^ tmp);
          _opadding.putByte(92 ^ tmp);
        }
        if (keylen < _md.blockLength) {
          var tmp = _md.blockLength - keylen;
          for (var i = 0; i < tmp; ++i) {
            _ipadding.putByte(54);
            _opadding.putByte(92);
          }
        }
        _key = key;
        _ipadding = _ipadding.bytes();
        _opadding = _opadding.bytes();
      }
      _md.start();
      _md.update(_ipadding);
    };
    ctx.update = function(bytes) {
      _md.update(bytes);
    };
    ctx.getMac = function() {
      var inner = _md.digest().bytes();
      _md.start();
      _md.update(_opadding);
      _md.update(inner);
      return _md.digest();
    };
    ctx.digest = ctx.getMac;
    return ctx;
  };
});

// empty:crypto
var require_crypto = __commonJS(() => {
});

// node_modules/node-forge/lib/pbkdf2.js
var require_pbkdf2 = __commonJS((exports2, module2) => {
  var forge = require_forge();
  require_hmac();
  require_md();
  require_util3();
  var pkcs5 = forge.pkcs5 = forge.pkcs5 || {};
  var crypto2;
  if (forge.util.isNodejs && !forge.options.usePureJavaScript) {
    crypto2 = require_crypto();
  }
  module2.exports = forge.pbkdf2 = pkcs5.pbkdf2 = function(p, s, c, dkLen, md, callback) {
    if (typeof md === "function") {
      callback = md;
      md = null;
    }
    if (forge.util.isNodejs && !forge.options.usePureJavaScript && crypto2.pbkdf2 && (md === null || typeof md !== "object") && (crypto2.pbkdf2Sync.length > 4 || (!md || md === "sha1"))) {
      if (typeof md !== "string") {
        md = "sha1";
      }
      p = Buffer.from(p, "binary");
      s = Buffer.from(s, "binary");
      if (!callback) {
        if (crypto2.pbkdf2Sync.length === 4) {
          return crypto2.pbkdf2Sync(p, s, c, dkLen).toString("binary");
        }
        return crypto2.pbkdf2Sync(p, s, c, dkLen, md).toString("binary");
      }
      if (crypto2.pbkdf2Sync.length === 4) {
        return crypto2.pbkdf2(p, s, c, dkLen, function(err2, key) {
          if (err2) {
            return callback(err2);
          }
          callback(null, key.toString("binary"));
        });
      }
      return crypto2.pbkdf2(p, s, c, dkLen, md, function(err2, key) {
        if (err2) {
          return callback(err2);
        }
        callback(null, key.toString("binary"));
      });
    }
    if (typeof md === "undefined" || md === null) {
      md = "sha1";
    }
    if (typeof md === "string") {
      if (!(md in forge.md.algorithms)) {
        throw new Error("Unknown hash algorithm: " + md);
      }
      md = forge.md[md].create();
    }
    var hLen = md.digestLength;
    if (dkLen > 4294967295 * hLen) {
      var err = new Error("Derived key is too long.");
      if (callback) {
        return callback(err);
      }
      throw err;
    }
    var len = Math.ceil(dkLen / hLen);
    var r = dkLen - (len - 1) * hLen;
    var prf = forge.hmac.create();
    prf.start(md, p);
    var dk = "";
    var xor, u_c, u_c1;
    if (!callback) {
      for (var i = 1; i <= len; ++i) {
        prf.start(null, null);
        prf.update(s);
        prf.update(forge.util.int32ToBytes(i));
        xor = u_c1 = prf.digest().getBytes();
        for (var j = 2; j <= c; ++j) {
          prf.start(null, null);
          prf.update(u_c1);
          u_c = prf.digest().getBytes();
          xor = forge.util.xorBytes(xor, u_c, hLen);
          u_c1 = u_c;
        }
        dk += i < len ? xor : xor.substr(0, r);
      }
      return dk;
    }
    var i = 1, j;
    function outer() {
      if (i > len) {
        return callback(null, dk);
      }
      prf.start(null, null);
      prf.update(s);
      prf.update(forge.util.int32ToBytes(i));
      xor = u_c1 = prf.digest().getBytes();
      j = 2;
      inner();
    }
    function inner() {
      if (j <= c) {
        prf.start(null, null);
        prf.update(u_c1);
        u_c = prf.digest().getBytes();
        xor = forge.util.xorBytes(xor, u_c, hLen);
        u_c1 = u_c;
        ++j;
        return forge.util.setImmediate(inner);
      }
      dk += i < len ? xor : xor.substr(0, r);
      ++i;
      outer();
    }
    outer();
  };
});

// node_modules/node-forge/lib/pem.js
var require_pem = __commonJS((exports2, module2) => {
  var forge = require_forge();
  require_util3();
  var pem = module2.exports = forge.pem = forge.pem || {};
  pem.encode = function(msg, options) {
    options = options || {};
    var rval = "-----BEGIN " + msg.type + "-----\r\n";
    var header;
    if (msg.procType) {
      header = {
        name: "Proc-Type",
        values: [String(msg.procType.version), msg.procType.type]
      };
      rval += foldHeader(header);
    }
    if (msg.contentDomain) {
      header = {name: "Content-Domain", values: [msg.contentDomain]};
      rval += foldHeader(header);
    }
    if (msg.dekInfo) {
      header = {name: "DEK-Info", values: [msg.dekInfo.algorithm]};
      if (msg.dekInfo.parameters) {
        header.values.push(msg.dekInfo.parameters);
      }
      rval += foldHeader(header);
    }
    if (msg.headers) {
      for (var i = 0; i < msg.headers.length; ++i) {
        rval += foldHeader(msg.headers[i]);
      }
    }
    if (msg.procType) {
      rval += "\r\n";
    }
    rval += forge.util.encode64(msg.body, options.maxline || 64) + "\r\n";
    rval += "-----END " + msg.type + "-----\r\n";
    return rval;
  };
  pem.decode = function(str) {
    var rval = [];
    var rMessage = /\s*-----BEGIN ([A-Z0-9- ]+)-----\r?\n?([\x21-\x7e\s]+?(?:\r?\n\r?\n))?([:A-Za-z0-9+\/=\s]+?)-----END \1-----/g;
    var rHeader = /([\x21-\x7e]+):\s*([\x21-\x7e\s^:]+)/;
    var rCRLF = /\r?\n/;
    var match;
    while (true) {
      match = rMessage.exec(str);
      if (!match) {
        break;
      }
      var msg = {
        type: match[1],
        procType: null,
        contentDomain: null,
        dekInfo: null,
        headers: [],
        body: forge.util.decode64(match[3])
      };
      rval.push(msg);
      if (!match[2]) {
        continue;
      }
      var lines = match[2].split(rCRLF);
      var li = 0;
      while (match && li < lines.length) {
        var line = lines[li].replace(/\s+$/, "");
        for (var nl = li + 1; nl < lines.length; ++nl) {
          var next = lines[nl];
          if (!/\s/.test(next[0])) {
            break;
          }
          line += next;
          li = nl;
        }
        match = line.match(rHeader);
        if (match) {
          var header = {name: match[1], values: []};
          var values = match[2].split(",");
          for (var vi = 0; vi < values.length; ++vi) {
            header.values.push(ltrim(values[vi]));
          }
          if (!msg.procType) {
            if (header.name !== "Proc-Type") {
              throw new Error('Invalid PEM formatted message. The first encapsulated header must be "Proc-Type".');
            } else if (header.values.length !== 2) {
              throw new Error('Invalid PEM formatted message. The "Proc-Type" header must have two subfields.');
            }
            msg.procType = {version: values[0], type: values[1]};
          } else if (!msg.contentDomain && header.name === "Content-Domain") {
            msg.contentDomain = values[0] || "";
          } else if (!msg.dekInfo && header.name === "DEK-Info") {
            if (header.values.length === 0) {
              throw new Error('Invalid PEM formatted message. The "DEK-Info" header must have at least one subfield.');
            }
            msg.dekInfo = {algorithm: values[0], parameters: values[1] || null};
          } else {
            msg.headers.push(header);
          }
        }
        ++li;
      }
      if (msg.procType === "ENCRYPTED" && !msg.dekInfo) {
        throw new Error('Invalid PEM formatted message. The "DEK-Info" header must be present if "Proc-Type" is "ENCRYPTED".');
      }
    }
    if (rval.length === 0) {
      throw new Error("Invalid PEM formatted message.");
    }
    return rval;
  };
  function foldHeader(header) {
    var rval = header.name + ": ";
    var values = [];
    var insertSpace = function(match, $1) {
      return " " + $1;
    };
    for (var i = 0; i < header.values.length; ++i) {
      values.push(header.values[i].replace(/^(\S+\r\n)/, insertSpace));
    }
    rval += values.join(",") + "\r\n";
    var length = 0;
    var candidate = -1;
    for (var i = 0; i < rval.length; ++i, ++length) {
      if (length > 65 && candidate !== -1) {
        var insert = rval[candidate];
        if (insert === ",") {
          ++candidate;
          rval = rval.substr(0, candidate) + "\r\n " + rval.substr(candidate);
        } else {
          rval = rval.substr(0, candidate) + "\r\n" + insert + rval.substr(candidate + 1);
        }
        length = i - candidate - 1;
        candidate = -1;
        ++i;
      } else if (rval[i] === " " || rval[i] === "	" || rval[i] === ",") {
        candidate = i;
      }
    }
    return rval;
  }
  function ltrim(str) {
    return str.replace(/^\s+/, "");
  }
});

// node_modules/node-forge/lib/sha256.js
var require_sha256 = __commonJS((exports2, module2) => {
  var forge = require_forge();
  require_md();
  require_util3();
  var sha256 = module2.exports = forge.sha256 = forge.sha256 || {};
  forge.md.sha256 = forge.md.algorithms.sha256 = sha256;
  sha256.create = function() {
    if (!_initialized) {
      _init();
    }
    var _state = null;
    var _input = forge.util.createBuffer();
    var _w = new Array(64);
    var md = {
      algorithm: "sha256",
      blockLength: 64,
      digestLength: 32,
      messageLength: 0,
      fullMessageLength: null,
      messageLengthSize: 8
    };
    md.start = function() {
      md.messageLength = 0;
      md.fullMessageLength = md.messageLength64 = [];
      var int32s = md.messageLengthSize / 4;
      for (var i = 0; i < int32s; ++i) {
        md.fullMessageLength.push(0);
      }
      _input = forge.util.createBuffer();
      _state = {
        h0: 1779033703,
        h1: 3144134277,
        h2: 1013904242,
        h3: 2773480762,
        h4: 1359893119,
        h5: 2600822924,
        h6: 528734635,
        h7: 1541459225
      };
      return md;
    };
    md.start();
    md.update = function(msg, encoding) {
      if (encoding === "utf8") {
        msg = forge.util.encodeUtf8(msg);
      }
      var len = msg.length;
      md.messageLength += len;
      len = [len / 4294967296 >>> 0, len >>> 0];
      for (var i = md.fullMessageLength.length - 1; i >= 0; --i) {
        md.fullMessageLength[i] += len[1];
        len[1] = len[0] + (md.fullMessageLength[i] / 4294967296 >>> 0);
        md.fullMessageLength[i] = md.fullMessageLength[i] >>> 0;
        len[0] = len[1] / 4294967296 >>> 0;
      }
      _input.putBytes(msg);
      _update(_state, _w, _input);
      if (_input.read > 2048 || _input.length() === 0) {
        _input.compact();
      }
      return md;
    };
    md.digest = function() {
      var finalBlock = forge.util.createBuffer();
      finalBlock.putBytes(_input.bytes());
      var remaining = md.fullMessageLength[md.fullMessageLength.length - 1] + md.messageLengthSize;
      var overflow = remaining & md.blockLength - 1;
      finalBlock.putBytes(_padding.substr(0, md.blockLength - overflow));
      var next, carry;
      var bits = md.fullMessageLength[0] * 8;
      for (var i = 0; i < md.fullMessageLength.length - 1; ++i) {
        next = md.fullMessageLength[i + 1] * 8;
        carry = next / 4294967296 >>> 0;
        bits += carry;
        finalBlock.putInt32(bits >>> 0);
        bits = next >>> 0;
      }
      finalBlock.putInt32(bits);
      var s2 = {
        h0: _state.h0,
        h1: _state.h1,
        h2: _state.h2,
        h3: _state.h3,
        h4: _state.h4,
        h5: _state.h5,
        h6: _state.h6,
        h7: _state.h7
      };
      _update(s2, _w, finalBlock);
      var rval = forge.util.createBuffer();
      rval.putInt32(s2.h0);
      rval.putInt32(s2.h1);
      rval.putInt32(s2.h2);
      rval.putInt32(s2.h3);
      rval.putInt32(s2.h4);
      rval.putInt32(s2.h5);
      rval.putInt32(s2.h6);
      rval.putInt32(s2.h7);
      return rval;
    };
    return md;
  };
  var _padding = null;
  var _initialized = false;
  var _k = null;
  function _init() {
    _padding = String.fromCharCode(128);
    _padding += forge.util.fillString(String.fromCharCode(0), 64);
    _k = [
      1116352408,
      1899447441,
      3049323471,
      3921009573,
      961987163,
      1508970993,
      2453635748,
      2870763221,
      3624381080,
      310598401,
      607225278,
      1426881987,
      1925078388,
      2162078206,
      2614888103,
      3248222580,
      3835390401,
      4022224774,
      264347078,
      604807628,
      770255983,
      1249150122,
      1555081692,
      1996064986,
      2554220882,
      2821834349,
      2952996808,
      3210313671,
      3336571891,
      3584528711,
      113926993,
      338241895,
      666307205,
      773529912,
      1294757372,
      1396182291,
      1695183700,
      1986661051,
      2177026350,
      2456956037,
      2730485921,
      2820302411,
      3259730800,
      3345764771,
      3516065817,
      3600352804,
      4094571909,
      275423344,
      430227734,
      506948616,
      659060556,
      883997877,
      958139571,
      1322822218,
      1537002063,
      1747873779,
      1955562222,
      2024104815,
      2227730452,
      2361852424,
      2428436474,
      2756734187,
      3204031479,
      3329325298
    ];
    _initialized = true;
  }
  function _update(s, w, bytes) {
    var t1, t2, s0, s1, ch, maj, i, a, b, c, d, e, f, g, h;
    var len = bytes.length();
    while (len >= 64) {
      for (i = 0; i < 16; ++i) {
        w[i] = bytes.getInt32();
      }
      for (; i < 64; ++i) {
        t1 = w[i - 2];
        t1 = (t1 >>> 17 | t1 << 15) ^ (t1 >>> 19 | t1 << 13) ^ t1 >>> 10;
        t2 = w[i - 15];
        t2 = (t2 >>> 7 | t2 << 25) ^ (t2 >>> 18 | t2 << 14) ^ t2 >>> 3;
        w[i] = t1 + w[i - 7] + t2 + w[i - 16] | 0;
      }
      a = s.h0;
      b = s.h1;
      c = s.h2;
      d = s.h3;
      e = s.h4;
      f = s.h5;
      g = s.h6;
      h = s.h7;
      for (i = 0; i < 64; ++i) {
        s1 = (e >>> 6 | e << 26) ^ (e >>> 11 | e << 21) ^ (e >>> 25 | e << 7);
        ch = g ^ e & (f ^ g);
        s0 = (a >>> 2 | a << 30) ^ (a >>> 13 | a << 19) ^ (a >>> 22 | a << 10);
        maj = a & b | c & (a ^ b);
        t1 = h + s1 + ch + _k[i] + w[i];
        t2 = s0 + maj;
        h = g;
        g = f;
        f = e;
        e = d + t1 >>> 0;
        d = c;
        c = b;
        b = a;
        a = t1 + t2 >>> 0;
      }
      s.h0 = s.h0 + a | 0;
      s.h1 = s.h1 + b | 0;
      s.h2 = s.h2 + c | 0;
      s.h3 = s.h3 + d | 0;
      s.h4 = s.h4 + e | 0;
      s.h5 = s.h5 + f | 0;
      s.h6 = s.h6 + g | 0;
      s.h7 = s.h7 + h | 0;
      len -= 64;
    }
  }
});

// node_modules/node-forge/lib/prng.js
var require_prng = __commonJS((exports2, module2) => {
  var forge = require_forge();
  require_util3();
  var _crypto = null;
  if (forge.util.isNodejs && !forge.options.usePureJavaScript && !process.versions["node-webkit"]) {
    _crypto = require_crypto();
  }
  var prng = module2.exports = forge.prng = forge.prng || {};
  prng.create = function(plugin) {
    var ctx = {
      plugin,
      key: null,
      seed: null,
      time: null,
      reseeds: 0,
      generated: 0,
      keyBytes: ""
    };
    var md = plugin.md;
    var pools = new Array(32);
    for (var i = 0; i < 32; ++i) {
      pools[i] = md.create();
    }
    ctx.pools = pools;
    ctx.pool = 0;
    ctx.generate = function(count, callback) {
      if (!callback) {
        return ctx.generateSync(count);
      }
      var cipher = ctx.plugin.cipher;
      var increment = ctx.plugin.increment;
      var formatKey = ctx.plugin.formatKey;
      var formatSeed = ctx.plugin.formatSeed;
      var b = forge.util.createBuffer();
      ctx.key = null;
      generate();
      function generate(err) {
        if (err) {
          return callback(err);
        }
        if (b.length() >= count) {
          return callback(null, b.getBytes(count));
        }
        if (ctx.generated > 1048575) {
          ctx.key = null;
        }
        if (ctx.key === null) {
          return forge.util.nextTick(function() {
            _reseed(generate);
          });
        }
        var bytes = cipher(ctx.key, ctx.seed);
        ctx.generated += bytes.length;
        b.putBytes(bytes);
        ctx.key = formatKey(cipher(ctx.key, increment(ctx.seed)));
        ctx.seed = formatSeed(cipher(ctx.key, ctx.seed));
        forge.util.setImmediate(generate);
      }
    };
    ctx.generateSync = function(count) {
      var cipher = ctx.plugin.cipher;
      var increment = ctx.plugin.increment;
      var formatKey = ctx.plugin.formatKey;
      var formatSeed = ctx.plugin.formatSeed;
      ctx.key = null;
      var b = forge.util.createBuffer();
      while (b.length() < count) {
        if (ctx.generated > 1048575) {
          ctx.key = null;
        }
        if (ctx.key === null) {
          _reseedSync();
        }
        var bytes = cipher(ctx.key, ctx.seed);
        ctx.generated += bytes.length;
        b.putBytes(bytes);
        ctx.key = formatKey(cipher(ctx.key, increment(ctx.seed)));
        ctx.seed = formatSeed(cipher(ctx.key, ctx.seed));
      }
      return b.getBytes(count);
    };
    function _reseed(callback) {
      if (ctx.pools[0].messageLength >= 32) {
        _seed();
        return callback();
      }
      var needed = 32 - ctx.pools[0].messageLength << 5;
      ctx.seedFile(needed, function(err, bytes) {
        if (err) {
          return callback(err);
        }
        ctx.collect(bytes);
        _seed();
        callback();
      });
    }
    function _reseedSync() {
      if (ctx.pools[0].messageLength >= 32) {
        return _seed();
      }
      var needed = 32 - ctx.pools[0].messageLength << 5;
      ctx.collect(ctx.seedFileSync(needed));
      _seed();
    }
    function _seed() {
      ctx.reseeds = ctx.reseeds === 4294967295 ? 0 : ctx.reseeds + 1;
      var md2 = ctx.plugin.md.create();
      md2.update(ctx.keyBytes);
      var _2powK = 1;
      for (var k = 0; k < 32; ++k) {
        if (ctx.reseeds % _2powK === 0) {
          md2.update(ctx.pools[k].digest().getBytes());
          ctx.pools[k].start();
        }
        _2powK = _2powK << 1;
      }
      ctx.keyBytes = md2.digest().getBytes();
      md2.start();
      md2.update(ctx.keyBytes);
      var seedBytes = md2.digest().getBytes();
      ctx.key = ctx.plugin.formatKey(ctx.keyBytes);
      ctx.seed = ctx.plugin.formatSeed(seedBytes);
      ctx.generated = 0;
    }
    function defaultSeedFile(needed) {
      var getRandomValues = null;
      var globalScope = forge.util.globalScope;
      var _crypto2 = globalScope.crypto || globalScope.msCrypto;
      if (_crypto2 && _crypto2.getRandomValues) {
        getRandomValues = function(arr) {
          return _crypto2.getRandomValues(arr);
        };
      }
      var b = forge.util.createBuffer();
      if (getRandomValues) {
        while (b.length() < needed) {
          var count = Math.max(1, Math.min(needed - b.length(), 65536) / 4);
          var entropy = new Uint32Array(Math.floor(count));
          try {
            getRandomValues(entropy);
            for (var i2 = 0; i2 < entropy.length; ++i2) {
              b.putInt32(entropy[i2]);
            }
          } catch (e) {
            if (!(typeof QuotaExceededError !== "undefined" && e instanceof QuotaExceededError)) {
              throw e;
            }
          }
        }
      }
      if (b.length() < needed) {
        var hi, lo, next;
        var seed = Math.floor(Math.random() * 65536);
        while (b.length() < needed) {
          lo = 16807 * (seed & 65535);
          hi = 16807 * (seed >> 16);
          lo += (hi & 32767) << 16;
          lo += hi >> 15;
          lo = (lo & 2147483647) + (lo >> 31);
          seed = lo & 4294967295;
          for (var i2 = 0; i2 < 3; ++i2) {
            next = seed >>> (i2 << 3);
            next ^= Math.floor(Math.random() * 256);
            b.putByte(String.fromCharCode(next & 255));
          }
        }
      }
      return b.getBytes(needed);
    }
    if (_crypto) {
      ctx.seedFile = function(needed, callback) {
        _crypto.randomBytes(needed, function(err, bytes) {
          if (err) {
            return callback(err);
          }
          callback(null, bytes.toString());
        });
      };
      ctx.seedFileSync = function(needed) {
        return _crypto.randomBytes(needed).toString();
      };
    } else {
      ctx.seedFile = function(needed, callback) {
        try {
          callback(null, defaultSeedFile(needed));
        } catch (e) {
          callback(e);
        }
      };
      ctx.seedFileSync = defaultSeedFile;
    }
    ctx.collect = function(bytes) {
      var count = bytes.length;
      for (var i2 = 0; i2 < count; ++i2) {
        ctx.pools[ctx.pool].update(bytes.substr(i2, 1));
        ctx.pool = ctx.pool === 31 ? 0 : ctx.pool + 1;
      }
    };
    ctx.collectInt = function(i2, n) {
      var bytes = "";
      for (var x = 0; x < n; x += 8) {
        bytes += String.fromCharCode(i2 >> x & 255);
      }
      ctx.collect(bytes);
    };
    ctx.registerWorker = function(worker) {
      if (worker === self) {
        ctx.seedFile = function(needed, callback) {
          function listener2(e) {
            var data = e.data;
            if (data.forge && data.forge.prng) {
              self.removeEventListener("message", listener2);
              callback(data.forge.prng.err, data.forge.prng.bytes);
            }
          }
          self.addEventListener("message", listener2);
          self.postMessage({forge: {prng: {needed}}});
        };
      } else {
        var listener = function(e) {
          var data = e.data;
          if (data.forge && data.forge.prng) {
            ctx.seedFile(data.forge.prng.needed, function(err, bytes) {
              worker.postMessage({forge: {prng: {err, bytes}}});
            });
          }
        };
        worker.addEventListener("message", listener);
      }
    };
    return ctx;
  };
});

// node_modules/node-forge/lib/random.js
var require_random = __commonJS((exports2, module2) => {
  var forge = require_forge();
  require_aes();
  require_sha256();
  require_prng();
  require_util3();
  (function() {
    if (forge.random && forge.random.getBytes) {
      module2.exports = forge.random;
      return;
    }
    (function(jQuery2) {
      var prng_aes = {};
      var _prng_aes_output = new Array(4);
      var _prng_aes_buffer = forge.util.createBuffer();
      prng_aes.formatKey = function(key2) {
        var tmp = forge.util.createBuffer(key2);
        key2 = new Array(4);
        key2[0] = tmp.getInt32();
        key2[1] = tmp.getInt32();
        key2[2] = tmp.getInt32();
        key2[3] = tmp.getInt32();
        return forge.aes._expandKey(key2, false);
      };
      prng_aes.formatSeed = function(seed) {
        var tmp = forge.util.createBuffer(seed);
        seed = new Array(4);
        seed[0] = tmp.getInt32();
        seed[1] = tmp.getInt32();
        seed[2] = tmp.getInt32();
        seed[3] = tmp.getInt32();
        return seed;
      };
      prng_aes.cipher = function(key2, seed) {
        forge.aes._updateBlock(key2, seed, _prng_aes_output, false);
        _prng_aes_buffer.putInt32(_prng_aes_output[0]);
        _prng_aes_buffer.putInt32(_prng_aes_output[1]);
        _prng_aes_buffer.putInt32(_prng_aes_output[2]);
        _prng_aes_buffer.putInt32(_prng_aes_output[3]);
        return _prng_aes_buffer.getBytes();
      };
      prng_aes.increment = function(seed) {
        ++seed[3];
        return seed;
      };
      prng_aes.md = forge.md.sha256;
      function spawnPrng() {
        var ctx = forge.prng.create(prng_aes);
        ctx.getBytes = function(count, callback) {
          return ctx.generate(count, callback);
        };
        ctx.getBytesSync = function(count) {
          return ctx.generate(count);
        };
        return ctx;
      }
      var _ctx = spawnPrng();
      var getRandomValues = null;
      var globalScope = forge.util.globalScope;
      var _crypto = globalScope.crypto || globalScope.msCrypto;
      if (_crypto && _crypto.getRandomValues) {
        getRandomValues = function(arr) {
          return _crypto.getRandomValues(arr);
        };
      }
      if (forge.options.usePureJavaScript || !forge.util.isNodejs && !getRandomValues) {
        if (typeof window === "undefined" || window.document === void 0) {
        }
        _ctx.collectInt(+new Date(), 32);
        if (typeof navigator !== "undefined") {
          var _navBytes = "";
          for (var key in navigator) {
            try {
              if (typeof navigator[key] == "string") {
                _navBytes += navigator[key];
              }
            } catch (e) {
            }
          }
          _ctx.collect(_navBytes);
          _navBytes = null;
        }
        if (jQuery2) {
          jQuery2().mousemove(function(e) {
            _ctx.collectInt(e.clientX, 16);
            _ctx.collectInt(e.clientY, 16);
          });
          jQuery2().keypress(function(e) {
            _ctx.collectInt(e.charCode, 8);
          });
        }
      }
      if (!forge.random) {
        forge.random = _ctx;
      } else {
        for (var key in _ctx) {
          forge.random[key] = _ctx[key];
        }
      }
      forge.random.createInstance = spawnPrng;
      module2.exports = forge.random;
    })(typeof jQuery !== "undefined" ? jQuery : null);
  })();
});

// node_modules/node-forge/lib/rc2.js
var require_rc2 = __commonJS((exports2, module2) => {
  var forge = require_forge();
  require_util3();
  var piTable = [
    217,
    120,
    249,
    196,
    25,
    221,
    181,
    237,
    40,
    233,
    253,
    121,
    74,
    160,
    216,
    157,
    198,
    126,
    55,
    131,
    43,
    118,
    83,
    142,
    98,
    76,
    100,
    136,
    68,
    139,
    251,
    162,
    23,
    154,
    89,
    245,
    135,
    179,
    79,
    19,
    97,
    69,
    109,
    141,
    9,
    129,
    125,
    50,
    189,
    143,
    64,
    235,
    134,
    183,
    123,
    11,
    240,
    149,
    33,
    34,
    92,
    107,
    78,
    130,
    84,
    214,
    101,
    147,
    206,
    96,
    178,
    28,
    115,
    86,
    192,
    20,
    167,
    140,
    241,
    220,
    18,
    117,
    202,
    31,
    59,
    190,
    228,
    209,
    66,
    61,
    212,
    48,
    163,
    60,
    182,
    38,
    111,
    191,
    14,
    218,
    70,
    105,
    7,
    87,
    39,
    242,
    29,
    155,
    188,
    148,
    67,
    3,
    248,
    17,
    199,
    246,
    144,
    239,
    62,
    231,
    6,
    195,
    213,
    47,
    200,
    102,
    30,
    215,
    8,
    232,
    234,
    222,
    128,
    82,
    238,
    247,
    132,
    170,
    114,
    172,
    53,
    77,
    106,
    42,
    150,
    26,
    210,
    113,
    90,
    21,
    73,
    116,
    75,
    159,
    208,
    94,
    4,
    24,
    164,
    236,
    194,
    224,
    65,
    110,
    15,
    81,
    203,
    204,
    36,
    145,
    175,
    80,
    161,
    244,
    112,
    57,
    153,
    124,
    58,
    133,
    35,
    184,
    180,
    122,
    252,
    2,
    54,
    91,
    37,
    85,
    151,
    49,
    45,
    93,
    250,
    152,
    227,
    138,
    146,
    174,
    5,
    223,
    41,
    16,
    103,
    108,
    186,
    201,
    211,
    0,
    230,
    207,
    225,
    158,
    168,
    44,
    99,
    22,
    1,
    63,
    88,
    226,
    137,
    169,
    13,
    56,
    52,
    27,
    171,
    51,
    255,
    176,
    187,
    72,
    12,
    95,
    185,
    177,
    205,
    46,
    197,
    243,
    219,
    71,
    229,
    165,
    156,
    119,
    10,
    166,
    32,
    104,
    254,
    127,
    193,
    173
  ];
  var s = [1, 2, 3, 5];
  var rol = function(word, bits) {
    return word << bits & 65535 | (word & 65535) >> 16 - bits;
  };
  var ror = function(word, bits) {
    return (word & 65535) >> bits | word << 16 - bits & 65535;
  };
  module2.exports = forge.rc2 = forge.rc2 || {};
  forge.rc2.expandKey = function(key, effKeyBits) {
    if (typeof key === "string") {
      key = forge.util.createBuffer(key);
    }
    effKeyBits = effKeyBits || 128;
    var L = key;
    var T = key.length();
    var T1 = effKeyBits;
    var T8 = Math.ceil(T1 / 8);
    var TM = 255 >> (T1 & 7);
    var i;
    for (i = T; i < 128; i++) {
      L.putByte(piTable[L.at(i - 1) + L.at(i - T) & 255]);
    }
    L.setAt(128 - T8, piTable[L.at(128 - T8) & TM]);
    for (i = 127 - T8; i >= 0; i--) {
      L.setAt(i, piTable[L.at(i + 1) ^ L.at(i + T8)]);
    }
    return L;
  };
  var createCipher = function(key, bits, encrypt) {
    var _finish = false, _input = null, _output = null, _iv = null;
    var mixRound, mashRound;
    var i, j, K = [];
    key = forge.rc2.expandKey(key, bits);
    for (i = 0; i < 64; i++) {
      K.push(key.getInt16Le());
    }
    if (encrypt) {
      mixRound = function(R) {
        for (i = 0; i < 4; i++) {
          R[i] += K[j] + (R[(i + 3) % 4] & R[(i + 2) % 4]) + (~R[(i + 3) % 4] & R[(i + 1) % 4]);
          R[i] = rol(R[i], s[i]);
          j++;
        }
      };
      mashRound = function(R) {
        for (i = 0; i < 4; i++) {
          R[i] += K[R[(i + 3) % 4] & 63];
        }
      };
    } else {
      mixRound = function(R) {
        for (i = 3; i >= 0; i--) {
          R[i] = ror(R[i], s[i]);
          R[i] -= K[j] + (R[(i + 3) % 4] & R[(i + 2) % 4]) + (~R[(i + 3) % 4] & R[(i + 1) % 4]);
          j--;
        }
      };
      mashRound = function(R) {
        for (i = 3; i >= 0; i--) {
          R[i] -= K[R[(i + 3) % 4] & 63];
        }
      };
    }
    var runPlan = function(plan) {
      var R = [];
      for (i = 0; i < 4; i++) {
        var val = _input.getInt16Le();
        if (_iv !== null) {
          if (encrypt) {
            val ^= _iv.getInt16Le();
          } else {
            _iv.putInt16Le(val);
          }
        }
        R.push(val & 65535);
      }
      j = encrypt ? 0 : 63;
      for (var ptr = 0; ptr < plan.length; ptr++) {
        for (var ctr = 0; ctr < plan[ptr][0]; ctr++) {
          plan[ptr][1](R);
        }
      }
      for (i = 0; i < 4; i++) {
        if (_iv !== null) {
          if (encrypt) {
            _iv.putInt16Le(R[i]);
          } else {
            R[i] ^= _iv.getInt16Le();
          }
        }
        _output.putInt16Le(R[i]);
      }
    };
    var cipher = null;
    cipher = {
      start: function(iv, output) {
        if (iv) {
          if (typeof iv === "string") {
            iv = forge.util.createBuffer(iv);
          }
        }
        _finish = false;
        _input = forge.util.createBuffer();
        _output = output || new forge.util.createBuffer();
        _iv = iv;
        cipher.output = _output;
      },
      update: function(input) {
        if (!_finish) {
          _input.putBuffer(input);
        }
        while (_input.length() >= 8) {
          runPlan([
            [5, mixRound],
            [1, mashRound],
            [6, mixRound],
            [1, mashRound],
            [5, mixRound]
          ]);
        }
      },
      finish: function(pad) {
        var rval = true;
        if (encrypt) {
          if (pad) {
            rval = pad(8, _input, !encrypt);
          } else {
            var padding = _input.length() === 8 ? 8 : 8 - _input.length();
            _input.fillWithByte(padding, padding);
          }
        }
        if (rval) {
          _finish = true;
          cipher.update();
        }
        if (!encrypt) {
          rval = _input.length() === 0;
          if (rval) {
            if (pad) {
              rval = pad(8, _output, !encrypt);
            } else {
              var len = _output.length();
              var count = _output.at(len - 1);
              if (count > len) {
                rval = false;
              } else {
                _output.truncate(count);
              }
            }
          }
        }
        return rval;
      }
    };
    return cipher;
  };
  forge.rc2.startEncrypting = function(key, iv, output) {
    var cipher = forge.rc2.createEncryptionCipher(key, 128);
    cipher.start(iv, output);
    return cipher;
  };
  forge.rc2.createEncryptionCipher = function(key, bits) {
    return createCipher(key, bits, true);
  };
  forge.rc2.startDecrypting = function(key, iv, output) {
    var cipher = forge.rc2.createDecryptionCipher(key, 128);
    cipher.start(iv, output);
    return cipher;
  };
  forge.rc2.createDecryptionCipher = function(key, bits) {
    return createCipher(key, bits, false);
  };
});

// node_modules/node-forge/lib/jsbn.js
var require_jsbn = __commonJS((exports2, module2) => {
  var forge = require_forge();
  module2.exports = forge.jsbn = forge.jsbn || {};
  var dbits;
  var canary = 244837814094590;
  var j_lm = (canary & 16777215) == 15715070;
  function BigInteger(a, b, c) {
    this.data = [];
    if (a != null)
      if (typeof a == "number")
        this.fromNumber(a, b, c);
      else if (b == null && typeof a != "string")
        this.fromString(a, 256);
      else
        this.fromString(a, b);
  }
  forge.jsbn.BigInteger = BigInteger;
  function nbi() {
    return new BigInteger(null);
  }
  function am1(i, x, w, j, c, n) {
    while (--n >= 0) {
      var v = x * this.data[i++] + w.data[j] + c;
      c = Math.floor(v / 67108864);
      w.data[j++] = v & 67108863;
    }
    return c;
  }
  function am2(i, x, w, j, c, n) {
    var xl = x & 32767, xh = x >> 15;
    while (--n >= 0) {
      var l = this.data[i] & 32767;
      var h = this.data[i++] >> 15;
      var m = xh * l + h * xl;
      l = xl * l + ((m & 32767) << 15) + w.data[j] + (c & 1073741823);
      c = (l >>> 30) + (m >>> 15) + xh * h + (c >>> 30);
      w.data[j++] = l & 1073741823;
    }
    return c;
  }
  function am3(i, x, w, j, c, n) {
    var xl = x & 16383, xh = x >> 14;
    while (--n >= 0) {
      var l = this.data[i] & 16383;
      var h = this.data[i++] >> 14;
      var m = xh * l + h * xl;
      l = xl * l + ((m & 16383) << 14) + w.data[j] + c;
      c = (l >> 28) + (m >> 14) + xh * h;
      w.data[j++] = l & 268435455;
    }
    return c;
  }
  if (typeof navigator === "undefined") {
    BigInteger.prototype.am = am3;
    dbits = 28;
  } else if (j_lm && navigator.appName == "Microsoft Internet Explorer") {
    BigInteger.prototype.am = am2;
    dbits = 30;
  } else if (j_lm && navigator.appName != "Netscape") {
    BigInteger.prototype.am = am1;
    dbits = 26;
  } else {
    BigInteger.prototype.am = am3;
    dbits = 28;
  }
  BigInteger.prototype.DB = dbits;
  BigInteger.prototype.DM = (1 << dbits) - 1;
  BigInteger.prototype.DV = 1 << dbits;
  var BI_FP = 52;
  BigInteger.prototype.FV = Math.pow(2, BI_FP);
  BigInteger.prototype.F1 = BI_FP - dbits;
  BigInteger.prototype.F2 = 2 * dbits - BI_FP;
  var BI_RM = "0123456789abcdefghijklmnopqrstuvwxyz";
  var BI_RC = new Array();
  var rr;
  var vv;
  rr = "0".charCodeAt(0);
  for (vv = 0; vv <= 9; ++vv)
    BI_RC[rr++] = vv;
  rr = "a".charCodeAt(0);
  for (vv = 10; vv < 36; ++vv)
    BI_RC[rr++] = vv;
  rr = "A".charCodeAt(0);
  for (vv = 10; vv < 36; ++vv)
    BI_RC[rr++] = vv;
  function int2char(n) {
    return BI_RM.charAt(n);
  }
  function intAt(s, i) {
    var c = BI_RC[s.charCodeAt(i)];
    return c == null ? -1 : c;
  }
  function bnpCopyTo(r) {
    for (var i = this.t - 1; i >= 0; --i)
      r.data[i] = this.data[i];
    r.t = this.t;
    r.s = this.s;
  }
  function bnpFromInt(x) {
    this.t = 1;
    this.s = x < 0 ? -1 : 0;
    if (x > 0)
      this.data[0] = x;
    else if (x < -1)
      this.data[0] = x + this.DV;
    else
      this.t = 0;
  }
  function nbv(i) {
    var r = nbi();
    r.fromInt(i);
    return r;
  }
  function bnpFromString(s, b) {
    var k;
    if (b == 16)
      k = 4;
    else if (b == 8)
      k = 3;
    else if (b == 256)
      k = 8;
    else if (b == 2)
      k = 1;
    else if (b == 32)
      k = 5;
    else if (b == 4)
      k = 2;
    else {
      this.fromRadix(s, b);
      return;
    }
    this.t = 0;
    this.s = 0;
    var i = s.length, mi = false, sh = 0;
    while (--i >= 0) {
      var x = k == 8 ? s[i] & 255 : intAt(s, i);
      if (x < 0) {
        if (s.charAt(i) == "-")
          mi = true;
        continue;
      }
      mi = false;
      if (sh == 0)
        this.data[this.t++] = x;
      else if (sh + k > this.DB) {
        this.data[this.t - 1] |= (x & (1 << this.DB - sh) - 1) << sh;
        this.data[this.t++] = x >> this.DB - sh;
      } else
        this.data[this.t - 1] |= x << sh;
      sh += k;
      if (sh >= this.DB)
        sh -= this.DB;
    }
    if (k == 8 && (s[0] & 128) != 0) {
      this.s = -1;
      if (sh > 0)
        this.data[this.t - 1] |= (1 << this.DB - sh) - 1 << sh;
    }
    this.clamp();
    if (mi)
      BigInteger.ZERO.subTo(this, this);
  }
  function bnpClamp() {
    var c = this.s & this.DM;
    while (this.t > 0 && this.data[this.t - 1] == c)
      --this.t;
  }
  function bnToString(b) {
    if (this.s < 0)
      return "-" + this.negate().toString(b);
    var k;
    if (b == 16)
      k = 4;
    else if (b == 8)
      k = 3;
    else if (b == 2)
      k = 1;
    else if (b == 32)
      k = 5;
    else if (b == 4)
      k = 2;
    else
      return this.toRadix(b);
    var km = (1 << k) - 1, d, m = false, r = "", i = this.t;
    var p = this.DB - i * this.DB % k;
    if (i-- > 0) {
      if (p < this.DB && (d = this.data[i] >> p) > 0) {
        m = true;
        r = int2char(d);
      }
      while (i >= 0) {
        if (p < k) {
          d = (this.data[i] & (1 << p) - 1) << k - p;
          d |= this.data[--i] >> (p += this.DB - k);
        } else {
          d = this.data[i] >> (p -= k) & km;
          if (p <= 0) {
            p += this.DB;
            --i;
          }
        }
        if (d > 0)
          m = true;
        if (m)
          r += int2char(d);
      }
    }
    return m ? r : "0";
  }
  function bnNegate() {
    var r = nbi();
    BigInteger.ZERO.subTo(this, r);
    return r;
  }
  function bnAbs() {
    return this.s < 0 ? this.negate() : this;
  }
  function bnCompareTo(a) {
    var r = this.s - a.s;
    if (r != 0)
      return r;
    var i = this.t;
    r = i - a.t;
    if (r != 0)
      return this.s < 0 ? -r : r;
    while (--i >= 0)
      if ((r = this.data[i] - a.data[i]) != 0)
        return r;
    return 0;
  }
  function nbits(x) {
    var r = 1, t;
    if ((t = x >>> 16) != 0) {
      x = t;
      r += 16;
    }
    if ((t = x >> 8) != 0) {
      x = t;
      r += 8;
    }
    if ((t = x >> 4) != 0) {
      x = t;
      r += 4;
    }
    if ((t = x >> 2) != 0) {
      x = t;
      r += 2;
    }
    if ((t = x >> 1) != 0) {
      x = t;
      r += 1;
    }
    return r;
  }
  function bnBitLength() {
    if (this.t <= 0)
      return 0;
    return this.DB * (this.t - 1) + nbits(this.data[this.t - 1] ^ this.s & this.DM);
  }
  function bnpDLShiftTo(n, r) {
    var i;
    for (i = this.t - 1; i >= 0; --i)
      r.data[i + n] = this.data[i];
    for (i = n - 1; i >= 0; --i)
      r.data[i] = 0;
    r.t = this.t + n;
    r.s = this.s;
  }
  function bnpDRShiftTo(n, r) {
    for (var i = n; i < this.t; ++i)
      r.data[i - n] = this.data[i];
    r.t = Math.max(this.t - n, 0);
    r.s = this.s;
  }
  function bnpLShiftTo(n, r) {
    var bs = n % this.DB;
    var cbs = this.DB - bs;
    var bm = (1 << cbs) - 1;
    var ds = Math.floor(n / this.DB), c = this.s << bs & this.DM, i;
    for (i = this.t - 1; i >= 0; --i) {
      r.data[i + ds + 1] = this.data[i] >> cbs | c;
      c = (this.data[i] & bm) << bs;
    }
    for (i = ds - 1; i >= 0; --i)
      r.data[i] = 0;
    r.data[ds] = c;
    r.t = this.t + ds + 1;
    r.s = this.s;
    r.clamp();
  }
  function bnpRShiftTo(n, r) {
    r.s = this.s;
    var ds = Math.floor(n / this.DB);
    if (ds >= this.t) {
      r.t = 0;
      return;
    }
    var bs = n % this.DB;
    var cbs = this.DB - bs;
    var bm = (1 << bs) - 1;
    r.data[0] = this.data[ds] >> bs;
    for (var i = ds + 1; i < this.t; ++i) {
      r.data[i - ds - 1] |= (this.data[i] & bm) << cbs;
      r.data[i - ds] = this.data[i] >> bs;
    }
    if (bs > 0)
      r.data[this.t - ds - 1] |= (this.s & bm) << cbs;
    r.t = this.t - ds;
    r.clamp();
  }
  function bnpSubTo(a, r) {
    var i = 0, c = 0, m = Math.min(a.t, this.t);
    while (i < m) {
      c += this.data[i] - a.data[i];
      r.data[i++] = c & this.DM;
      c >>= this.DB;
    }
    if (a.t < this.t) {
      c -= a.s;
      while (i < this.t) {
        c += this.data[i];
        r.data[i++] = c & this.DM;
        c >>= this.DB;
      }
      c += this.s;
    } else {
      c += this.s;
      while (i < a.t) {
        c -= a.data[i];
        r.data[i++] = c & this.DM;
        c >>= this.DB;
      }
      c -= a.s;
    }
    r.s = c < 0 ? -1 : 0;
    if (c < -1)
      r.data[i++] = this.DV + c;
    else if (c > 0)
      r.data[i++] = c;
    r.t = i;
    r.clamp();
  }
  function bnpMultiplyTo(a, r) {
    var x = this.abs(), y = a.abs();
    var i = x.t;
    r.t = i + y.t;
    while (--i >= 0)
      r.data[i] = 0;
    for (i = 0; i < y.t; ++i)
      r.data[i + x.t] = x.am(0, y.data[i], r, i, 0, x.t);
    r.s = 0;
    r.clamp();
    if (this.s != a.s)
      BigInteger.ZERO.subTo(r, r);
  }
  function bnpSquareTo(r) {
    var x = this.abs();
    var i = r.t = 2 * x.t;
    while (--i >= 0)
      r.data[i] = 0;
    for (i = 0; i < x.t - 1; ++i) {
      var c = x.am(i, x.data[i], r, 2 * i, 0, 1);
      if ((r.data[i + x.t] += x.am(i + 1, 2 * x.data[i], r, 2 * i + 1, c, x.t - i - 1)) >= x.DV) {
        r.data[i + x.t] -= x.DV;
        r.data[i + x.t + 1] = 1;
      }
    }
    if (r.t > 0)
      r.data[r.t - 1] += x.am(i, x.data[i], r, 2 * i, 0, 1);
    r.s = 0;
    r.clamp();
  }
  function bnpDivRemTo(m, q, r) {
    var pm = m.abs();
    if (pm.t <= 0)
      return;
    var pt = this.abs();
    if (pt.t < pm.t) {
      if (q != null)
        q.fromInt(0);
      if (r != null)
        this.copyTo(r);
      return;
    }
    if (r == null)
      r = nbi();
    var y = nbi(), ts = this.s, ms = m.s;
    var nsh = this.DB - nbits(pm.data[pm.t - 1]);
    if (nsh > 0) {
      pm.lShiftTo(nsh, y);
      pt.lShiftTo(nsh, r);
    } else {
      pm.copyTo(y);
      pt.copyTo(r);
    }
    var ys = y.t;
    var y0 = y.data[ys - 1];
    if (y0 == 0)
      return;
    var yt = y0 * (1 << this.F1) + (ys > 1 ? y.data[ys - 2] >> this.F2 : 0);
    var d1 = this.FV / yt, d2 = (1 << this.F1) / yt, e = 1 << this.F2;
    var i = r.t, j = i - ys, t = q == null ? nbi() : q;
    y.dlShiftTo(j, t);
    if (r.compareTo(t) >= 0) {
      r.data[r.t++] = 1;
      r.subTo(t, r);
    }
    BigInteger.ONE.dlShiftTo(ys, t);
    t.subTo(y, y);
    while (y.t < ys)
      y.data[y.t++] = 0;
    while (--j >= 0) {
      var qd = r.data[--i] == y0 ? this.DM : Math.floor(r.data[i] * d1 + (r.data[i - 1] + e) * d2);
      if ((r.data[i] += y.am(0, qd, r, j, 0, ys)) < qd) {
        y.dlShiftTo(j, t);
        r.subTo(t, r);
        while (r.data[i] < --qd)
          r.subTo(t, r);
      }
    }
    if (q != null) {
      r.drShiftTo(ys, q);
      if (ts != ms)
        BigInteger.ZERO.subTo(q, q);
    }
    r.t = ys;
    r.clamp();
    if (nsh > 0)
      r.rShiftTo(nsh, r);
    if (ts < 0)
      BigInteger.ZERO.subTo(r, r);
  }
  function bnMod(a) {
    var r = nbi();
    this.abs().divRemTo(a, null, r);
    if (this.s < 0 && r.compareTo(BigInteger.ZERO) > 0)
      a.subTo(r, r);
    return r;
  }
  function Classic(m) {
    this.m = m;
  }
  function cConvert(x) {
    if (x.s < 0 || x.compareTo(this.m) >= 0)
      return x.mod(this.m);
    else
      return x;
  }
  function cRevert(x) {
    return x;
  }
  function cReduce(x) {
    x.divRemTo(this.m, null, x);
  }
  function cMulTo(x, y, r) {
    x.multiplyTo(y, r);
    this.reduce(r);
  }
  function cSqrTo(x, r) {
    x.squareTo(r);
    this.reduce(r);
  }
  Classic.prototype.convert = cConvert;
  Classic.prototype.revert = cRevert;
  Classic.prototype.reduce = cReduce;
  Classic.prototype.mulTo = cMulTo;
  Classic.prototype.sqrTo = cSqrTo;
  function bnpInvDigit() {
    if (this.t < 1)
      return 0;
    var x = this.data[0];
    if ((x & 1) == 0)
      return 0;
    var y = x & 3;
    y = y * (2 - (x & 15) * y) & 15;
    y = y * (2 - (x & 255) * y) & 255;
    y = y * (2 - ((x & 65535) * y & 65535)) & 65535;
    y = y * (2 - x * y % this.DV) % this.DV;
    return y > 0 ? this.DV - y : -y;
  }
  function Montgomery(m) {
    this.m = m;
    this.mp = m.invDigit();
    this.mpl = this.mp & 32767;
    this.mph = this.mp >> 15;
    this.um = (1 << m.DB - 15) - 1;
    this.mt2 = 2 * m.t;
  }
  function montConvert(x) {
    var r = nbi();
    x.abs().dlShiftTo(this.m.t, r);
    r.divRemTo(this.m, null, r);
    if (x.s < 0 && r.compareTo(BigInteger.ZERO) > 0)
      this.m.subTo(r, r);
    return r;
  }
  function montRevert(x) {
    var r = nbi();
    x.copyTo(r);
    this.reduce(r);
    return r;
  }
  function montReduce(x) {
    while (x.t <= this.mt2)
      x.data[x.t++] = 0;
    for (var i = 0; i < this.m.t; ++i) {
      var j = x.data[i] & 32767;
      var u0 = j * this.mpl + ((j * this.mph + (x.data[i] >> 15) * this.mpl & this.um) << 15) & x.DM;
      j = i + this.m.t;
      x.data[j] += this.m.am(0, u0, x, i, 0, this.m.t);
      while (x.data[j] >= x.DV) {
        x.data[j] -= x.DV;
        x.data[++j]++;
      }
    }
    x.clamp();
    x.drShiftTo(this.m.t, x);
    if (x.compareTo(this.m) >= 0)
      x.subTo(this.m, x);
  }
  function montSqrTo(x, r) {
    x.squareTo(r);
    this.reduce(r);
  }
  function montMulTo(x, y, r) {
    x.multiplyTo(y, r);
    this.reduce(r);
  }
  Montgomery.prototype.convert = montConvert;
  Montgomery.prototype.revert = montRevert;
  Montgomery.prototype.reduce = montReduce;
  Montgomery.prototype.mulTo = montMulTo;
  Montgomery.prototype.sqrTo = montSqrTo;
  function bnpIsEven() {
    return (this.t > 0 ? this.data[0] & 1 : this.s) == 0;
  }
  function bnpExp(e, z) {
    if (e > 4294967295 || e < 1)
      return BigInteger.ONE;
    var r = nbi(), r2 = nbi(), g = z.convert(this), i = nbits(e) - 1;
    g.copyTo(r);
    while (--i >= 0) {
      z.sqrTo(r, r2);
      if ((e & 1 << i) > 0)
        z.mulTo(r2, g, r);
      else {
        var t = r;
        r = r2;
        r2 = t;
      }
    }
    return z.revert(r);
  }
  function bnModPowInt(e, m) {
    var z;
    if (e < 256 || m.isEven())
      z = new Classic(m);
    else
      z = new Montgomery(m);
    return this.exp(e, z);
  }
  BigInteger.prototype.copyTo = bnpCopyTo;
  BigInteger.prototype.fromInt = bnpFromInt;
  BigInteger.prototype.fromString = bnpFromString;
  BigInteger.prototype.clamp = bnpClamp;
  BigInteger.prototype.dlShiftTo = bnpDLShiftTo;
  BigInteger.prototype.drShiftTo = bnpDRShiftTo;
  BigInteger.prototype.lShiftTo = bnpLShiftTo;
  BigInteger.prototype.rShiftTo = bnpRShiftTo;
  BigInteger.prototype.subTo = bnpSubTo;
  BigInteger.prototype.multiplyTo = bnpMultiplyTo;
  BigInteger.prototype.squareTo = bnpSquareTo;
  BigInteger.prototype.divRemTo = bnpDivRemTo;
  BigInteger.prototype.invDigit = bnpInvDigit;
  BigInteger.prototype.isEven = bnpIsEven;
  BigInteger.prototype.exp = bnpExp;
  BigInteger.prototype.toString = bnToString;
  BigInteger.prototype.negate = bnNegate;
  BigInteger.prototype.abs = bnAbs;
  BigInteger.prototype.compareTo = bnCompareTo;
  BigInteger.prototype.bitLength = bnBitLength;
  BigInteger.prototype.mod = bnMod;
  BigInteger.prototype.modPowInt = bnModPowInt;
  BigInteger.ZERO = nbv(0);
  BigInteger.ONE = nbv(1);
  function bnClone() {
    var r = nbi();
    this.copyTo(r);
    return r;
  }
  function bnIntValue() {
    if (this.s < 0) {
      if (this.t == 1)
        return this.data[0] - this.DV;
      else if (this.t == 0)
        return -1;
    } else if (this.t == 1)
      return this.data[0];
    else if (this.t == 0)
      return 0;
    return (this.data[1] & (1 << 32 - this.DB) - 1) << this.DB | this.data[0];
  }
  function bnByteValue() {
    return this.t == 0 ? this.s : this.data[0] << 24 >> 24;
  }
  function bnShortValue() {
    return this.t == 0 ? this.s : this.data[0] << 16 >> 16;
  }
  function bnpChunkSize(r) {
    return Math.floor(Math.LN2 * this.DB / Math.log(r));
  }
  function bnSigNum() {
    if (this.s < 0)
      return -1;
    else if (this.t <= 0 || this.t == 1 && this.data[0] <= 0)
      return 0;
    else
      return 1;
  }
  function bnpToRadix(b) {
    if (b == null)
      b = 10;
    if (this.signum() == 0 || b < 2 || b > 36)
      return "0";
    var cs = this.chunkSize(b);
    var a = Math.pow(b, cs);
    var d = nbv(a), y = nbi(), z = nbi(), r = "";
    this.divRemTo(d, y, z);
    while (y.signum() > 0) {
      r = (a + z.intValue()).toString(b).substr(1) + r;
      y.divRemTo(d, y, z);
    }
    return z.intValue().toString(b) + r;
  }
  function bnpFromRadix(s, b) {
    this.fromInt(0);
    if (b == null)
      b = 10;
    var cs = this.chunkSize(b);
    var d = Math.pow(b, cs), mi = false, j = 0, w = 0;
    for (var i = 0; i < s.length; ++i) {
      var x = intAt(s, i);
      if (x < 0) {
        if (s.charAt(i) == "-" && this.signum() == 0)
          mi = true;
        continue;
      }
      w = b * w + x;
      if (++j >= cs) {
        this.dMultiply(d);
        this.dAddOffset(w, 0);
        j = 0;
        w = 0;
      }
    }
    if (j > 0) {
      this.dMultiply(Math.pow(b, j));
      this.dAddOffset(w, 0);
    }
    if (mi)
      BigInteger.ZERO.subTo(this, this);
  }
  function bnpFromNumber(a, b, c) {
    if (typeof b == "number") {
      if (a < 2)
        this.fromInt(1);
      else {
        this.fromNumber(a, c);
        if (!this.testBit(a - 1))
          this.bitwiseTo(BigInteger.ONE.shiftLeft(a - 1), op_or, this);
        if (this.isEven())
          this.dAddOffset(1, 0);
        while (!this.isProbablePrime(b)) {
          this.dAddOffset(2, 0);
          if (this.bitLength() > a)
            this.subTo(BigInteger.ONE.shiftLeft(a - 1), this);
        }
      }
    } else {
      var x = new Array(), t = a & 7;
      x.length = (a >> 3) + 1;
      b.nextBytes(x);
      if (t > 0)
        x[0] &= (1 << t) - 1;
      else
        x[0] = 0;
      this.fromString(x, 256);
    }
  }
  function bnToByteArray() {
    var i = this.t, r = new Array();
    r[0] = this.s;
    var p = this.DB - i * this.DB % 8, d, k = 0;
    if (i-- > 0) {
      if (p < this.DB && (d = this.data[i] >> p) != (this.s & this.DM) >> p)
        r[k++] = d | this.s << this.DB - p;
      while (i >= 0) {
        if (p < 8) {
          d = (this.data[i] & (1 << p) - 1) << 8 - p;
          d |= this.data[--i] >> (p += this.DB - 8);
        } else {
          d = this.data[i] >> (p -= 8) & 255;
          if (p <= 0) {
            p += this.DB;
            --i;
          }
        }
        if ((d & 128) != 0)
          d |= -256;
        if (k == 0 && (this.s & 128) != (d & 128))
          ++k;
        if (k > 0 || d != this.s)
          r[k++] = d;
      }
    }
    return r;
  }
  function bnEquals(a) {
    return this.compareTo(a) == 0;
  }
  function bnMin(a) {
    return this.compareTo(a) < 0 ? this : a;
  }
  function bnMax(a) {
    return this.compareTo(a) > 0 ? this : a;
  }
  function bnpBitwiseTo(a, op, r) {
    var i, f, m = Math.min(a.t, this.t);
    for (i = 0; i < m; ++i)
      r.data[i] = op(this.data[i], a.data[i]);
    if (a.t < this.t) {
      f = a.s & this.DM;
      for (i = m; i < this.t; ++i)
        r.data[i] = op(this.data[i], f);
      r.t = this.t;
    } else {
      f = this.s & this.DM;
      for (i = m; i < a.t; ++i)
        r.data[i] = op(f, a.data[i]);
      r.t = a.t;
    }
    r.s = op(this.s, a.s);
    r.clamp();
  }
  function op_and(x, y) {
    return x & y;
  }
  function bnAnd(a) {
    var r = nbi();
    this.bitwiseTo(a, op_and, r);
    return r;
  }
  function op_or(x, y) {
    return x | y;
  }
  function bnOr(a) {
    var r = nbi();
    this.bitwiseTo(a, op_or, r);
    return r;
  }
  function op_xor(x, y) {
    return x ^ y;
  }
  function bnXor(a) {
    var r = nbi();
    this.bitwiseTo(a, op_xor, r);
    return r;
  }
  function op_andnot(x, y) {
    return x & ~y;
  }
  function bnAndNot(a) {
    var r = nbi();
    this.bitwiseTo(a, op_andnot, r);
    return r;
  }
  function bnNot() {
    var r = nbi();
    for (var i = 0; i < this.t; ++i)
      r.data[i] = this.DM & ~this.data[i];
    r.t = this.t;
    r.s = ~this.s;
    return r;
  }
  function bnShiftLeft(n) {
    var r = nbi();
    if (n < 0)
      this.rShiftTo(-n, r);
    else
      this.lShiftTo(n, r);
    return r;
  }
  function bnShiftRight(n) {
    var r = nbi();
    if (n < 0)
      this.lShiftTo(-n, r);
    else
      this.rShiftTo(n, r);
    return r;
  }
  function lbit(x) {
    if (x == 0)
      return -1;
    var r = 0;
    if ((x & 65535) == 0) {
      x >>= 16;
      r += 16;
    }
    if ((x & 255) == 0) {
      x >>= 8;
      r += 8;
    }
    if ((x & 15) == 0) {
      x >>= 4;
      r += 4;
    }
    if ((x & 3) == 0) {
      x >>= 2;
      r += 2;
    }
    if ((x & 1) == 0)
      ++r;
    return r;
  }
  function bnGetLowestSetBit() {
    for (var i = 0; i < this.t; ++i)
      if (this.data[i] != 0)
        return i * this.DB + lbit(this.data[i]);
    if (this.s < 0)
      return this.t * this.DB;
    return -1;
  }
  function cbit(x) {
    var r = 0;
    while (x != 0) {
      x &= x - 1;
      ++r;
    }
    return r;
  }
  function bnBitCount() {
    var r = 0, x = this.s & this.DM;
    for (var i = 0; i < this.t; ++i)
      r += cbit(this.data[i] ^ x);
    return r;
  }
  function bnTestBit(n) {
    var j = Math.floor(n / this.DB);
    if (j >= this.t)
      return this.s != 0;
    return (this.data[j] & 1 << n % this.DB) != 0;
  }
  function bnpChangeBit(n, op) {
    var r = BigInteger.ONE.shiftLeft(n);
    this.bitwiseTo(r, op, r);
    return r;
  }
  function bnSetBit(n) {
    return this.changeBit(n, op_or);
  }
  function bnClearBit(n) {
    return this.changeBit(n, op_andnot);
  }
  function bnFlipBit(n) {
    return this.changeBit(n, op_xor);
  }
  function bnpAddTo(a, r) {
    var i = 0, c = 0, m = Math.min(a.t, this.t);
    while (i < m) {
      c += this.data[i] + a.data[i];
      r.data[i++] = c & this.DM;
      c >>= this.DB;
    }
    if (a.t < this.t) {
      c += a.s;
      while (i < this.t) {
        c += this.data[i];
        r.data[i++] = c & this.DM;
        c >>= this.DB;
      }
      c += this.s;
    } else {
      c += this.s;
      while (i < a.t) {
        c += a.data[i];
        r.data[i++] = c & this.DM;
        c >>= this.DB;
      }
      c += a.s;
    }
    r.s = c < 0 ? -1 : 0;
    if (c > 0)
      r.data[i++] = c;
    else if (c < -1)
      r.data[i++] = this.DV + c;
    r.t = i;
    r.clamp();
  }
  function bnAdd(a) {
    var r = nbi();
    this.addTo(a, r);
    return r;
  }
  function bnSubtract(a) {
    var r = nbi();
    this.subTo(a, r);
    return r;
  }
  function bnMultiply(a) {
    var r = nbi();
    this.multiplyTo(a, r);
    return r;
  }
  function bnDivide(a) {
    var r = nbi();
    this.divRemTo(a, r, null);
    return r;
  }
  function bnRemainder(a) {
    var r = nbi();
    this.divRemTo(a, null, r);
    return r;
  }
  function bnDivideAndRemainder(a) {
    var q = nbi(), r = nbi();
    this.divRemTo(a, q, r);
    return new Array(q, r);
  }
  function bnpDMultiply(n) {
    this.data[this.t] = this.am(0, n - 1, this, 0, 0, this.t);
    ++this.t;
    this.clamp();
  }
  function bnpDAddOffset(n, w) {
    if (n == 0)
      return;
    while (this.t <= w)
      this.data[this.t++] = 0;
    this.data[w] += n;
    while (this.data[w] >= this.DV) {
      this.data[w] -= this.DV;
      if (++w >= this.t)
        this.data[this.t++] = 0;
      ++this.data[w];
    }
  }
  function NullExp() {
  }
  function nNop(x) {
    return x;
  }
  function nMulTo(x, y, r) {
    x.multiplyTo(y, r);
  }
  function nSqrTo(x, r) {
    x.squareTo(r);
  }
  NullExp.prototype.convert = nNop;
  NullExp.prototype.revert = nNop;
  NullExp.prototype.mulTo = nMulTo;
  NullExp.prototype.sqrTo = nSqrTo;
  function bnPow(e) {
    return this.exp(e, new NullExp());
  }
  function bnpMultiplyLowerTo(a, n, r) {
    var i = Math.min(this.t + a.t, n);
    r.s = 0;
    r.t = i;
    while (i > 0)
      r.data[--i] = 0;
    var j;
    for (j = r.t - this.t; i < j; ++i)
      r.data[i + this.t] = this.am(0, a.data[i], r, i, 0, this.t);
    for (j = Math.min(a.t, n); i < j; ++i)
      this.am(0, a.data[i], r, i, 0, n - i);
    r.clamp();
  }
  function bnpMultiplyUpperTo(a, n, r) {
    --n;
    var i = r.t = this.t + a.t - n;
    r.s = 0;
    while (--i >= 0)
      r.data[i] = 0;
    for (i = Math.max(n - this.t, 0); i < a.t; ++i)
      r.data[this.t + i - n] = this.am(n - i, a.data[i], r, 0, 0, this.t + i - n);
    r.clamp();
    r.drShiftTo(1, r);
  }
  function Barrett(m) {
    this.r2 = nbi();
    this.q3 = nbi();
    BigInteger.ONE.dlShiftTo(2 * m.t, this.r2);
    this.mu = this.r2.divide(m);
    this.m = m;
  }
  function barrettConvert(x) {
    if (x.s < 0 || x.t > 2 * this.m.t)
      return x.mod(this.m);
    else if (x.compareTo(this.m) < 0)
      return x;
    else {
      var r = nbi();
      x.copyTo(r);
      this.reduce(r);
      return r;
    }
  }
  function barrettRevert(x) {
    return x;
  }
  function barrettReduce(x) {
    x.drShiftTo(this.m.t - 1, this.r2);
    if (x.t > this.m.t + 1) {
      x.t = this.m.t + 1;
      x.clamp();
    }
    this.mu.multiplyUpperTo(this.r2, this.m.t + 1, this.q3);
    this.m.multiplyLowerTo(this.q3, this.m.t + 1, this.r2);
    while (x.compareTo(this.r2) < 0)
      x.dAddOffset(1, this.m.t + 1);
    x.subTo(this.r2, x);
    while (x.compareTo(this.m) >= 0)
      x.subTo(this.m, x);
  }
  function barrettSqrTo(x, r) {
    x.squareTo(r);
    this.reduce(r);
  }
  function barrettMulTo(x, y, r) {
    x.multiplyTo(y, r);
    this.reduce(r);
  }
  Barrett.prototype.convert = barrettConvert;
  Barrett.prototype.revert = barrettRevert;
  Barrett.prototype.reduce = barrettReduce;
  Barrett.prototype.mulTo = barrettMulTo;
  Barrett.prototype.sqrTo = barrettSqrTo;
  function bnModPow(e, m) {
    var i = e.bitLength(), k, r = nbv(1), z;
    if (i <= 0)
      return r;
    else if (i < 18)
      k = 1;
    else if (i < 48)
      k = 3;
    else if (i < 144)
      k = 4;
    else if (i < 768)
      k = 5;
    else
      k = 6;
    if (i < 8)
      z = new Classic(m);
    else if (m.isEven())
      z = new Barrett(m);
    else
      z = new Montgomery(m);
    var g = new Array(), n = 3, k1 = k - 1, km = (1 << k) - 1;
    g[1] = z.convert(this);
    if (k > 1) {
      var g2 = nbi();
      z.sqrTo(g[1], g2);
      while (n <= km) {
        g[n] = nbi();
        z.mulTo(g2, g[n - 2], g[n]);
        n += 2;
      }
    }
    var j = e.t - 1, w, is1 = true, r2 = nbi(), t;
    i = nbits(e.data[j]) - 1;
    while (j >= 0) {
      if (i >= k1)
        w = e.data[j] >> i - k1 & km;
      else {
        w = (e.data[j] & (1 << i + 1) - 1) << k1 - i;
        if (j > 0)
          w |= e.data[j - 1] >> this.DB + i - k1;
      }
      n = k;
      while ((w & 1) == 0) {
        w >>= 1;
        --n;
      }
      if ((i -= n) < 0) {
        i += this.DB;
        --j;
      }
      if (is1) {
        g[w].copyTo(r);
        is1 = false;
      } else {
        while (n > 1) {
          z.sqrTo(r, r2);
          z.sqrTo(r2, r);
          n -= 2;
        }
        if (n > 0)
          z.sqrTo(r, r2);
        else {
          t = r;
          r = r2;
          r2 = t;
        }
        z.mulTo(r2, g[w], r);
      }
      while (j >= 0 && (e.data[j] & 1 << i) == 0) {
        z.sqrTo(r, r2);
        t = r;
        r = r2;
        r2 = t;
        if (--i < 0) {
          i = this.DB - 1;
          --j;
        }
      }
    }
    return z.revert(r);
  }
  function bnGCD(a) {
    var x = this.s < 0 ? this.negate() : this.clone();
    var y = a.s < 0 ? a.negate() : a.clone();
    if (x.compareTo(y) < 0) {
      var t = x;
      x = y;
      y = t;
    }
    var i = x.getLowestSetBit(), g = y.getLowestSetBit();
    if (g < 0)
      return x;
    if (i < g)
      g = i;
    if (g > 0) {
      x.rShiftTo(g, x);
      y.rShiftTo(g, y);
    }
    while (x.signum() > 0) {
      if ((i = x.getLowestSetBit()) > 0)
        x.rShiftTo(i, x);
      if ((i = y.getLowestSetBit()) > 0)
        y.rShiftTo(i, y);
      if (x.compareTo(y) >= 0) {
        x.subTo(y, x);
        x.rShiftTo(1, x);
      } else {
        y.subTo(x, y);
        y.rShiftTo(1, y);
      }
    }
    if (g > 0)
      y.lShiftTo(g, y);
    return y;
  }
  function bnpModInt(n) {
    if (n <= 0)
      return 0;
    var d = this.DV % n, r = this.s < 0 ? n - 1 : 0;
    if (this.t > 0)
      if (d == 0)
        r = this.data[0] % n;
      else
        for (var i = this.t - 1; i >= 0; --i)
          r = (d * r + this.data[i]) % n;
    return r;
  }
  function bnModInverse(m) {
    var ac = m.isEven();
    if (this.isEven() && ac || m.signum() == 0)
      return BigInteger.ZERO;
    var u = m.clone(), v = this.clone();
    var a = nbv(1), b = nbv(0), c = nbv(0), d = nbv(1);
    while (u.signum() != 0) {
      while (u.isEven()) {
        u.rShiftTo(1, u);
        if (ac) {
          if (!a.isEven() || !b.isEven()) {
            a.addTo(this, a);
            b.subTo(m, b);
          }
          a.rShiftTo(1, a);
        } else if (!b.isEven())
          b.subTo(m, b);
        b.rShiftTo(1, b);
      }
      while (v.isEven()) {
        v.rShiftTo(1, v);
        if (ac) {
          if (!c.isEven() || !d.isEven()) {
            c.addTo(this, c);
            d.subTo(m, d);
          }
          c.rShiftTo(1, c);
        } else if (!d.isEven())
          d.subTo(m, d);
        d.rShiftTo(1, d);
      }
      if (u.compareTo(v) >= 0) {
        u.subTo(v, u);
        if (ac)
          a.subTo(c, a);
        b.subTo(d, b);
      } else {
        v.subTo(u, v);
        if (ac)
          c.subTo(a, c);
        d.subTo(b, d);
      }
    }
    if (v.compareTo(BigInteger.ONE) != 0)
      return BigInteger.ZERO;
    if (d.compareTo(m) >= 0)
      return d.subtract(m);
    if (d.signum() < 0)
      d.addTo(m, d);
    else
      return d;
    if (d.signum() < 0)
      return d.add(m);
    else
      return d;
  }
  var lowprimes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509];
  var lplim = (1 << 26) / lowprimes[lowprimes.length - 1];
  function bnIsProbablePrime(t) {
    var i, x = this.abs();
    if (x.t == 1 && x.data[0] <= lowprimes[lowprimes.length - 1]) {
      for (i = 0; i < lowprimes.length; ++i)
        if (x.data[0] == lowprimes[i])
          return true;
      return false;
    }
    if (x.isEven())
      return false;
    i = 1;
    while (i < lowprimes.length) {
      var m = lowprimes[i], j = i + 1;
      while (j < lowprimes.length && m < lplim)
        m *= lowprimes[j++];
      m = x.modInt(m);
      while (i < j)
        if (m % lowprimes[i++] == 0)
          return false;
    }
    return x.millerRabin(t);
  }
  function bnpMillerRabin(t) {
    var n1 = this.subtract(BigInteger.ONE);
    var k = n1.getLowestSetBit();
    if (k <= 0)
      return false;
    var r = n1.shiftRight(k);
    var prng = bnGetPrng();
    var a;
    for (var i = 0; i < t; ++i) {
      do {
        a = new BigInteger(this.bitLength(), prng);
      } while (a.compareTo(BigInteger.ONE) <= 0 || a.compareTo(n1) >= 0);
      var y = a.modPow(r, this);
      if (y.compareTo(BigInteger.ONE) != 0 && y.compareTo(n1) != 0) {
        var j = 1;
        while (j++ < k && y.compareTo(n1) != 0) {
          y = y.modPowInt(2, this);
          if (y.compareTo(BigInteger.ONE) == 0)
            return false;
        }
        if (y.compareTo(n1) != 0)
          return false;
      }
    }
    return true;
  }
  function bnGetPrng() {
    return {
      nextBytes: function(x) {
        for (var i = 0; i < x.length; ++i) {
          x[i] = Math.floor(Math.random() * 256);
        }
      }
    };
  }
  BigInteger.prototype.chunkSize = bnpChunkSize;
  BigInteger.prototype.toRadix = bnpToRadix;
  BigInteger.prototype.fromRadix = bnpFromRadix;
  BigInteger.prototype.fromNumber = bnpFromNumber;
  BigInteger.prototype.bitwiseTo = bnpBitwiseTo;
  BigInteger.prototype.changeBit = bnpChangeBit;
  BigInteger.prototype.addTo = bnpAddTo;
  BigInteger.prototype.dMultiply = bnpDMultiply;
  BigInteger.prototype.dAddOffset = bnpDAddOffset;
  BigInteger.prototype.multiplyLowerTo = bnpMultiplyLowerTo;
  BigInteger.prototype.multiplyUpperTo = bnpMultiplyUpperTo;
  BigInteger.prototype.modInt = bnpModInt;
  BigInteger.prototype.millerRabin = bnpMillerRabin;
  BigInteger.prototype.clone = bnClone;
  BigInteger.prototype.intValue = bnIntValue;
  BigInteger.prototype.byteValue = bnByteValue;
  BigInteger.prototype.shortValue = bnShortValue;
  BigInteger.prototype.signum = bnSigNum;
  BigInteger.prototype.toByteArray = bnToByteArray;
  BigInteger.prototype.equals = bnEquals;
  BigInteger.prototype.min = bnMin;
  BigInteger.prototype.max = bnMax;
  BigInteger.prototype.and = bnAnd;
  BigInteger.prototype.or = bnOr;
  BigInteger.prototype.xor = bnXor;
  BigInteger.prototype.andNot = bnAndNot;
  BigInteger.prototype.not = bnNot;
  BigInteger.prototype.shiftLeft = bnShiftLeft;
  BigInteger.prototype.shiftRight = bnShiftRight;
  BigInteger.prototype.getLowestSetBit = bnGetLowestSetBit;
  BigInteger.prototype.bitCount = bnBitCount;
  BigInteger.prototype.testBit = bnTestBit;
  BigInteger.prototype.setBit = bnSetBit;
  BigInteger.prototype.clearBit = bnClearBit;
  BigInteger.prototype.flipBit = bnFlipBit;
  BigInteger.prototype.add = bnAdd;
  BigInteger.prototype.subtract = bnSubtract;
  BigInteger.prototype.multiply = bnMultiply;
  BigInteger.prototype.divide = bnDivide;
  BigInteger.prototype.remainder = bnRemainder;
  BigInteger.prototype.divideAndRemainder = bnDivideAndRemainder;
  BigInteger.prototype.modPow = bnModPow;
  BigInteger.prototype.modInverse = bnModInverse;
  BigInteger.prototype.pow = bnPow;
  BigInteger.prototype.gcd = bnGCD;
  BigInteger.prototype.isProbablePrime = bnIsProbablePrime;
});

// node_modules/node-forge/lib/sha1.js
var require_sha1 = __commonJS((exports2, module2) => {
  var forge = require_forge();
  require_md();
  require_util3();
  var sha1 = module2.exports = forge.sha1 = forge.sha1 || {};
  forge.md.sha1 = forge.md.algorithms.sha1 = sha1;
  sha1.create = function() {
    if (!_initialized) {
      _init();
    }
    var _state = null;
    var _input = forge.util.createBuffer();
    var _w = new Array(80);
    var md = {
      algorithm: "sha1",
      blockLength: 64,
      digestLength: 20,
      messageLength: 0,
      fullMessageLength: null,
      messageLengthSize: 8
    };
    md.start = function() {
      md.messageLength = 0;
      md.fullMessageLength = md.messageLength64 = [];
      var int32s = md.messageLengthSize / 4;
      for (var i = 0; i < int32s; ++i) {
        md.fullMessageLength.push(0);
      }
      _input = forge.util.createBuffer();
      _state = {
        h0: 1732584193,
        h1: 4023233417,
        h2: 2562383102,
        h3: 271733878,
        h4: 3285377520
      };
      return md;
    };
    md.start();
    md.update = function(msg, encoding) {
      if (encoding === "utf8") {
        msg = forge.util.encodeUtf8(msg);
      }
      var len = msg.length;
      md.messageLength += len;
      len = [len / 4294967296 >>> 0, len >>> 0];
      for (var i = md.fullMessageLength.length - 1; i >= 0; --i) {
        md.fullMessageLength[i] += len[1];
        len[1] = len[0] + (md.fullMessageLength[i] / 4294967296 >>> 0);
        md.fullMessageLength[i] = md.fullMessageLength[i] >>> 0;
        len[0] = len[1] / 4294967296 >>> 0;
      }
      _input.putBytes(msg);
      _update(_state, _w, _input);
      if (_input.read > 2048 || _input.length() === 0) {
        _input.compact();
      }
      return md;
    };
    md.digest = function() {
      var finalBlock = forge.util.createBuffer();
      finalBlock.putBytes(_input.bytes());
      var remaining = md.fullMessageLength[md.fullMessageLength.length - 1] + md.messageLengthSize;
      var overflow = remaining & md.blockLength - 1;
      finalBlock.putBytes(_padding.substr(0, md.blockLength - overflow));
      var next, carry;
      var bits = md.fullMessageLength[0] * 8;
      for (var i = 0; i < md.fullMessageLength.length - 1; ++i) {
        next = md.fullMessageLength[i + 1] * 8;
        carry = next / 4294967296 >>> 0;
        bits += carry;
        finalBlock.putInt32(bits >>> 0);
        bits = next >>> 0;
      }
      finalBlock.putInt32(bits);
      var s2 = {
        h0: _state.h0,
        h1: _state.h1,
        h2: _state.h2,
        h3: _state.h3,
        h4: _state.h4
      };
      _update(s2, _w, finalBlock);
      var rval = forge.util.createBuffer();
      rval.putInt32(s2.h0);
      rval.putInt32(s2.h1);
      rval.putInt32(s2.h2);
      rval.putInt32(s2.h3);
      rval.putInt32(s2.h4);
      return rval;
    };
    return md;
  };
  var _padding = null;
  var _initialized = false;
  function _init() {
    _padding = String.fromCharCode(128);
    _padding += forge.util.fillString(String.fromCharCode(0), 64);
    _initialized = true;
  }
  function _update(s, w, bytes) {
    var t, a, b, c, d, e, f, i;
    var len = bytes.length();
    while (len >= 64) {
      a = s.h0;
      b = s.h1;
      c = s.h2;
      d = s.h3;
      e = s.h4;
      for (i = 0; i < 16; ++i) {
        t = bytes.getInt32();
        w[i] = t;
        f = d ^ b & (c ^ d);
        t = (a << 5 | a >>> 27) + f + e + 1518500249 + t;
        e = d;
        d = c;
        c = (b << 30 | b >>> 2) >>> 0;
        b = a;
        a = t;
      }
      for (; i < 20; ++i) {
        t = w[i - 3] ^ w[i - 8] ^ w[i - 14] ^ w[i - 16];
        t = t << 1 | t >>> 31;
        w[i] = t;
        f = d ^ b & (c ^ d);
        t = (a << 5 | a >>> 27) + f + e + 1518500249 + t;
        e = d;
        d = c;
        c = (b << 30 | b >>> 2) >>> 0;
        b = a;
        a = t;
      }
      for (; i < 32; ++i) {
        t = w[i - 3] ^ w[i - 8] ^ w[i - 14] ^ w[i - 16];
        t = t << 1 | t >>> 31;
        w[i] = t;
        f = b ^ c ^ d;
        t = (a << 5 | a >>> 27) + f + e + 1859775393 + t;
        e = d;
        d = c;
        c = (b << 30 | b >>> 2) >>> 0;
        b = a;
        a = t;
      }
      for (; i < 40; ++i) {
        t = w[i - 6] ^ w[i - 16] ^ w[i - 28] ^ w[i - 32];
        t = t << 2 | t >>> 30;
        w[i] = t;
        f = b ^ c ^ d;
        t = (a << 5 | a >>> 27) + f + e + 1859775393 + t;
        e = d;
        d = c;
        c = (b << 30 | b >>> 2) >>> 0;
        b = a;
        a = t;
      }
      for (; i < 60; ++i) {
        t = w[i - 6] ^ w[i - 16] ^ w[i - 28] ^ w[i - 32];
        t = t << 2 | t >>> 30;
        w[i] = t;
        f = b & c | d & (b ^ c);
        t = (a << 5 | a >>> 27) + f + e + 2400959708 + t;
        e = d;
        d = c;
        c = (b << 30 | b >>> 2) >>> 0;
        b = a;
        a = t;
      }
      for (; i < 80; ++i) {
        t = w[i - 6] ^ w[i - 16] ^ w[i - 28] ^ w[i - 32];
        t = t << 2 | t >>> 30;
        w[i] = t;
        f = b ^ c ^ d;
        t = (a << 5 | a >>> 27) + f + e + 3395469782 + t;
        e = d;
        d = c;
        c = (b << 30 | b >>> 2) >>> 0;
        b = a;
        a = t;
      }
      s.h0 = s.h0 + a | 0;
      s.h1 = s.h1 + b | 0;
      s.h2 = s.h2 + c | 0;
      s.h3 = s.h3 + d | 0;
      s.h4 = s.h4 + e | 0;
      len -= 64;
    }
  }
});

// node_modules/node-forge/lib/pkcs1.js
var require_pkcs1 = __commonJS((exports2, module2) => {
  var forge = require_forge();
  require_util3();
  require_random();
  require_sha1();
  var pkcs1 = module2.exports = forge.pkcs1 = forge.pkcs1 || {};
  pkcs1.encode_rsa_oaep = function(key, message, options) {
    var label;
    var seed;
    var md;
    var mgf1Md;
    if (typeof options === "string") {
      label = options;
      seed = arguments[3] || void 0;
      md = arguments[4] || void 0;
    } else if (options) {
      label = options.label || void 0;
      seed = options.seed || void 0;
      md = options.md || void 0;
      if (options.mgf1 && options.mgf1.md) {
        mgf1Md = options.mgf1.md;
      }
    }
    if (!md) {
      md = forge.md.sha1.create();
    } else {
      md.start();
    }
    if (!mgf1Md) {
      mgf1Md = md;
    }
    var keyLength = Math.ceil(key.n.bitLength() / 8);
    var maxLength = keyLength - 2 * md.digestLength - 2;
    if (message.length > maxLength) {
      var error = new Error("RSAES-OAEP input message length is too long.");
      error.length = message.length;
      error.maxLength = maxLength;
      throw error;
    }
    if (!label) {
      label = "";
    }
    md.update(label, "raw");
    var lHash = md.digest();
    var PS = "";
    var PS_length = maxLength - message.length;
    for (var i = 0; i < PS_length; i++) {
      PS += "\0";
    }
    var DB = lHash.getBytes() + PS + "" + message;
    if (!seed) {
      seed = forge.random.getBytes(md.digestLength);
    } else if (seed.length !== md.digestLength) {
      var error = new Error("Invalid RSAES-OAEP seed. The seed length must match the digest length.");
      error.seedLength = seed.length;
      error.digestLength = md.digestLength;
      throw error;
    }
    var dbMask = rsa_mgf1(seed, keyLength - md.digestLength - 1, mgf1Md);
    var maskedDB = forge.util.xorBytes(DB, dbMask, DB.length);
    var seedMask = rsa_mgf1(maskedDB, md.digestLength, mgf1Md);
    var maskedSeed = forge.util.xorBytes(seed, seedMask, seed.length);
    return "\0" + maskedSeed + maskedDB;
  };
  pkcs1.decode_rsa_oaep = function(key, em, options) {
    var label;
    var md;
    var mgf1Md;
    if (typeof options === "string") {
      label = options;
      md = arguments[3] || void 0;
    } else if (options) {
      label = options.label || void 0;
      md = options.md || void 0;
      if (options.mgf1 && options.mgf1.md) {
        mgf1Md = options.mgf1.md;
      }
    }
    var keyLength = Math.ceil(key.n.bitLength() / 8);
    if (em.length !== keyLength) {
      var error = new Error("RSAES-OAEP encoded message length is invalid.");
      error.length = em.length;
      error.expectedLength = keyLength;
      throw error;
    }
    if (md === void 0) {
      md = forge.md.sha1.create();
    } else {
      md.start();
    }
    if (!mgf1Md) {
      mgf1Md = md;
    }
    if (keyLength < 2 * md.digestLength + 2) {
      throw new Error("RSAES-OAEP key is too short for the hash function.");
    }
    if (!label) {
      label = "";
    }
    md.update(label, "raw");
    var lHash = md.digest().getBytes();
    var y = em.charAt(0);
    var maskedSeed = em.substring(1, md.digestLength + 1);
    var maskedDB = em.substring(1 + md.digestLength);
    var seedMask = rsa_mgf1(maskedDB, md.digestLength, mgf1Md);
    var seed = forge.util.xorBytes(maskedSeed, seedMask, maskedSeed.length);
    var dbMask = rsa_mgf1(seed, keyLength - md.digestLength - 1, mgf1Md);
    var db = forge.util.xorBytes(maskedDB, dbMask, maskedDB.length);
    var lHashPrime = db.substring(0, md.digestLength);
    var error = y !== "\0";
    for (var i = 0; i < md.digestLength; ++i) {
      error |= lHash.charAt(i) !== lHashPrime.charAt(i);
    }
    var in_ps = 1;
    var index = md.digestLength;
    for (var j = md.digestLength; j < db.length; j++) {
      var code = db.charCodeAt(j);
      var is_0 = code & 1 ^ 1;
      var error_mask = in_ps ? 65534 : 0;
      error |= code & error_mask;
      in_ps = in_ps & is_0;
      index += in_ps;
    }
    if (error || db.charCodeAt(index) !== 1) {
      throw new Error("Invalid RSAES-OAEP padding.");
    }
    return db.substring(index + 1);
  };
  function rsa_mgf1(seed, maskLength, hash) {
    if (!hash) {
      hash = forge.md.sha1.create();
    }
    var t = "";
    var count = Math.ceil(maskLength / hash.digestLength);
    for (var i = 0; i < count; ++i) {
      var c = String.fromCharCode(i >> 24 & 255, i >> 16 & 255, i >> 8 & 255, i & 255);
      hash.start();
      hash.update(seed + c);
      t += hash.digest().getBytes();
    }
    return t.substring(0, maskLength);
  }
});

// node_modules/node-forge/lib/prime.js
var require_prime = __commonJS((exports2, module2) => {
  var forge = require_forge();
  require_util3();
  require_jsbn();
  require_random();
  (function() {
    if (forge.prime) {
      module2.exports = forge.prime;
      return;
    }
    var prime = module2.exports = forge.prime = forge.prime || {};
    var BigInteger = forge.jsbn.BigInteger;
    var GCD_30_DELTA = [6, 4, 2, 4, 2, 4, 6, 2];
    var THIRTY = new BigInteger(null);
    THIRTY.fromInt(30);
    var op_or = function(x, y) {
      return x | y;
    };
    prime.generateProbablePrime = function(bits, options, callback) {
      if (typeof options === "function") {
        callback = options;
        options = {};
      }
      options = options || {};
      var algorithm = options.algorithm || "PRIMEINC";
      if (typeof algorithm === "string") {
        algorithm = {name: algorithm};
      }
      algorithm.options = algorithm.options || {};
      var prng = options.prng || forge.random;
      var rng = {
        nextBytes: function(x) {
          var b = prng.getBytesSync(x.length);
          for (var i = 0; i < x.length; ++i) {
            x[i] = b.charCodeAt(i);
          }
        }
      };
      if (algorithm.name === "PRIMEINC") {
        return primeincFindPrime(bits, rng, algorithm.options, callback);
      }
      throw new Error("Invalid prime generation algorithm: " + algorithm.name);
    };
    function primeincFindPrime(bits, rng, options, callback) {
      if ("workers" in options) {
        return primeincFindPrimeWithWorkers(bits, rng, options, callback);
      }
      return primeincFindPrimeWithoutWorkers(bits, rng, options, callback);
    }
    function primeincFindPrimeWithoutWorkers(bits, rng, options, callback) {
      var num = generateRandom(bits, rng);
      var deltaIdx = 0;
      var mrTests = getMillerRabinTests(num.bitLength());
      if ("millerRabinTests" in options) {
        mrTests = options.millerRabinTests;
      }
      var maxBlockTime = 10;
      if ("maxBlockTime" in options) {
        maxBlockTime = options.maxBlockTime;
      }
      _primeinc(num, bits, rng, deltaIdx, mrTests, maxBlockTime, callback);
    }
    function _primeinc(num, bits, rng, deltaIdx, mrTests, maxBlockTime, callback) {
      var start = +new Date();
      do {
        if (num.bitLength() > bits) {
          num = generateRandom(bits, rng);
        }
        if (num.isProbablePrime(mrTests)) {
          return callback(null, num);
        }
        num.dAddOffset(GCD_30_DELTA[deltaIdx++ % 8], 0);
      } while (maxBlockTime < 0 || +new Date() - start < maxBlockTime);
      forge.util.setImmediate(function() {
        _primeinc(num, bits, rng, deltaIdx, mrTests, maxBlockTime, callback);
      });
    }
    function primeincFindPrimeWithWorkers(bits, rng, options, callback) {
      if (typeof Worker === "undefined") {
        return primeincFindPrimeWithoutWorkers(bits, rng, options, callback);
      }
      var num = generateRandom(bits, rng);
      var numWorkers = options.workers;
      var workLoad = options.workLoad || 100;
      var range = workLoad * 30 / 8;
      var workerScript = options.workerScript || "forge/prime.worker.js";
      if (numWorkers === -1) {
        return forge.util.estimateCores(function(err, cores) {
          if (err) {
            cores = 2;
          }
          numWorkers = cores - 1;
          generate();
        });
      }
      generate();
      function generate() {
        numWorkers = Math.max(1, numWorkers);
        var workers = [];
        for (var i = 0; i < numWorkers; ++i) {
          workers[i] = new Worker(workerScript);
        }
        var running = numWorkers;
        for (var i = 0; i < numWorkers; ++i) {
          workers[i].addEventListener("message", workerMessage);
        }
        var found = false;
        function workerMessage(e) {
          if (found) {
            return;
          }
          --running;
          var data = e.data;
          if (data.found) {
            for (var i2 = 0; i2 < workers.length; ++i2) {
              workers[i2].terminate();
            }
            found = true;
            return callback(null, new BigInteger(data.prime, 16));
          }
          if (num.bitLength() > bits) {
            num = generateRandom(bits, rng);
          }
          var hex = num.toString(16);
          e.target.postMessage({
            hex,
            workLoad
          });
          num.dAddOffset(range, 0);
        }
      }
    }
    function generateRandom(bits, rng) {
      var num = new BigInteger(bits, rng);
      var bits1 = bits - 1;
      if (!num.testBit(bits1)) {
        num.bitwiseTo(BigInteger.ONE.shiftLeft(bits1), op_or, num);
      }
      num.dAddOffset(31 - num.mod(THIRTY).byteValue(), 0);
      return num;
    }
    function getMillerRabinTests(bits) {
      if (bits <= 100)
        return 27;
      if (bits <= 150)
        return 18;
      if (bits <= 200)
        return 15;
      if (bits <= 250)
        return 12;
      if (bits <= 300)
        return 9;
      if (bits <= 350)
        return 8;
      if (bits <= 400)
        return 7;
      if (bits <= 500)
        return 6;
      if (bits <= 600)
        return 5;
      if (bits <= 800)
        return 4;
      if (bits <= 1250)
        return 3;
      return 2;
    }
  })();
});

// node_modules/node-forge/lib/rsa.js
var require_rsa = __commonJS((exports2, module2) => {
  var forge = require_forge();
  require_asn1();
  require_jsbn();
  require_oids();
  require_pkcs1();
  require_prime();
  require_random();
  require_util3();
  if (typeof BigInteger === "undefined") {
    BigInteger = forge.jsbn.BigInteger;
  }
  var BigInteger;
  var _crypto = forge.util.isNodejs ? require_crypto() : null;
  var asn1 = forge.asn1;
  var util = forge.util;
  forge.pki = forge.pki || {};
  module2.exports = forge.pki.rsa = forge.rsa = forge.rsa || {};
  var pki = forge.pki;
  var GCD_30_DELTA = [6, 4, 2, 4, 2, 4, 6, 2];
  var privateKeyValidator = {
    name: "PrivateKeyInfo",
    tagClass: asn1.Class.UNIVERSAL,
    type: asn1.Type.SEQUENCE,
    constructed: true,
    value: [{
      name: "PrivateKeyInfo.version",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.INTEGER,
      constructed: false,
      capture: "privateKeyVersion"
    }, {
      name: "PrivateKeyInfo.privateKeyAlgorithm",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "AlgorithmIdentifier.algorithm",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.OID,
        constructed: false,
        capture: "privateKeyOid"
      }]
    }, {
      name: "PrivateKeyInfo",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.OCTETSTRING,
      constructed: false,
      capture: "privateKey"
    }]
  };
  var rsaPrivateKeyValidator = {
    name: "RSAPrivateKey",
    tagClass: asn1.Class.UNIVERSAL,
    type: asn1.Type.SEQUENCE,
    constructed: true,
    value: [{
      name: "RSAPrivateKey.version",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.INTEGER,
      constructed: false,
      capture: "privateKeyVersion"
    }, {
      name: "RSAPrivateKey.modulus",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.INTEGER,
      constructed: false,
      capture: "privateKeyModulus"
    }, {
      name: "RSAPrivateKey.publicExponent",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.INTEGER,
      constructed: false,
      capture: "privateKeyPublicExponent"
    }, {
      name: "RSAPrivateKey.privateExponent",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.INTEGER,
      constructed: false,
      capture: "privateKeyPrivateExponent"
    }, {
      name: "RSAPrivateKey.prime1",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.INTEGER,
      constructed: false,
      capture: "privateKeyPrime1"
    }, {
      name: "RSAPrivateKey.prime2",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.INTEGER,
      constructed: false,
      capture: "privateKeyPrime2"
    }, {
      name: "RSAPrivateKey.exponent1",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.INTEGER,
      constructed: false,
      capture: "privateKeyExponent1"
    }, {
      name: "RSAPrivateKey.exponent2",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.INTEGER,
      constructed: false,
      capture: "privateKeyExponent2"
    }, {
      name: "RSAPrivateKey.coefficient",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.INTEGER,
      constructed: false,
      capture: "privateKeyCoefficient"
    }]
  };
  var rsaPublicKeyValidator = {
    name: "RSAPublicKey",
    tagClass: asn1.Class.UNIVERSAL,
    type: asn1.Type.SEQUENCE,
    constructed: true,
    value: [{
      name: "RSAPublicKey.modulus",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.INTEGER,
      constructed: false,
      capture: "publicKeyModulus"
    }, {
      name: "RSAPublicKey.exponent",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.INTEGER,
      constructed: false,
      capture: "publicKeyExponent"
    }]
  };
  var publicKeyValidator = forge.pki.rsa.publicKeyValidator = {
    name: "SubjectPublicKeyInfo",
    tagClass: asn1.Class.UNIVERSAL,
    type: asn1.Type.SEQUENCE,
    constructed: true,
    captureAsn1: "subjectPublicKeyInfo",
    value: [{
      name: "SubjectPublicKeyInfo.AlgorithmIdentifier",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "AlgorithmIdentifier.algorithm",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.OID,
        constructed: false,
        capture: "publicKeyOid"
      }]
    }, {
      name: "SubjectPublicKeyInfo.subjectPublicKey",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.BITSTRING,
      constructed: false,
      value: [{
        name: "SubjectPublicKeyInfo.subjectPublicKey.RSAPublicKey",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        optional: true,
        captureAsn1: "rsaPublicKey"
      }]
    }]
  };
  var emsaPkcs1v15encode = function(md) {
    var oid;
    if (md.algorithm in pki.oids) {
      oid = pki.oids[md.algorithm];
    } else {
      var error = new Error("Unknown message digest algorithm.");
      error.algorithm = md.algorithm;
      throw error;
    }
    var oidBytes = asn1.oidToDer(oid).getBytes();
    var digestInfo = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);
    var digestAlgorithm = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);
    digestAlgorithm.value.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, oidBytes));
    digestAlgorithm.value.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, ""));
    var digest = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, md.digest().getBytes());
    digestInfo.value.push(digestAlgorithm);
    digestInfo.value.push(digest);
    return asn1.toDer(digestInfo).getBytes();
  };
  var _modPow = function(x, key, pub) {
    if (pub) {
      return x.modPow(key.e, key.n);
    }
    if (!key.p || !key.q) {
      return x.modPow(key.d, key.n);
    }
    if (!key.dP) {
      key.dP = key.d.mod(key.p.subtract(BigInteger.ONE));
    }
    if (!key.dQ) {
      key.dQ = key.d.mod(key.q.subtract(BigInteger.ONE));
    }
    if (!key.qInv) {
      key.qInv = key.q.modInverse(key.p);
    }
    var r;
    do {
      r = new BigInteger(forge.util.bytesToHex(forge.random.getBytes(key.n.bitLength() / 8)), 16);
    } while (r.compareTo(key.n) >= 0 || !r.gcd(key.n).equals(BigInteger.ONE));
    x = x.multiply(r.modPow(key.e, key.n)).mod(key.n);
    var xp = x.mod(key.p).modPow(key.dP, key.p);
    var xq = x.mod(key.q).modPow(key.dQ, key.q);
    while (xp.compareTo(xq) < 0) {
      xp = xp.add(key.p);
    }
    var y = xp.subtract(xq).multiply(key.qInv).mod(key.p).multiply(key.q).add(xq);
    y = y.multiply(r.modInverse(key.n)).mod(key.n);
    return y;
  };
  pki.rsa.encrypt = function(m, key, bt) {
    var pub = bt;
    var eb;
    var k = Math.ceil(key.n.bitLength() / 8);
    if (bt !== false && bt !== true) {
      pub = bt === 2;
      eb = _encodePkcs1_v1_5(m, key, bt);
    } else {
      eb = forge.util.createBuffer();
      eb.putBytes(m);
    }
    var x = new BigInteger(eb.toHex(), 16);
    var y = _modPow(x, key, pub);
    var yhex = y.toString(16);
    var ed = forge.util.createBuffer();
    var zeros = k - Math.ceil(yhex.length / 2);
    while (zeros > 0) {
      ed.putByte(0);
      --zeros;
    }
    ed.putBytes(forge.util.hexToBytes(yhex));
    return ed.getBytes();
  };
  pki.rsa.decrypt = function(ed, key, pub, ml) {
    var k = Math.ceil(key.n.bitLength() / 8);
    if (ed.length !== k) {
      var error = new Error("Encrypted message length is invalid.");
      error.length = ed.length;
      error.expected = k;
      throw error;
    }
    var y = new BigInteger(forge.util.createBuffer(ed).toHex(), 16);
    if (y.compareTo(key.n) >= 0) {
      throw new Error("Encrypted message is invalid.");
    }
    var x = _modPow(y, key, pub);
    var xhex = x.toString(16);
    var eb = forge.util.createBuffer();
    var zeros = k - Math.ceil(xhex.length / 2);
    while (zeros > 0) {
      eb.putByte(0);
      --zeros;
    }
    eb.putBytes(forge.util.hexToBytes(xhex));
    if (ml !== false) {
      return _decodePkcs1_v1_5(eb.getBytes(), key, pub);
    }
    return eb.getBytes();
  };
  pki.rsa.createKeyPairGenerationState = function(bits, e, options) {
    if (typeof bits === "string") {
      bits = parseInt(bits, 10);
    }
    bits = bits || 2048;
    options = options || {};
    var prng = options.prng || forge.random;
    var rng = {
      nextBytes: function(x) {
        var b = prng.getBytesSync(x.length);
        for (var i = 0; i < x.length; ++i) {
          x[i] = b.charCodeAt(i);
        }
      }
    };
    var algorithm = options.algorithm || "PRIMEINC";
    var rval;
    if (algorithm === "PRIMEINC") {
      rval = {
        algorithm,
        state: 0,
        bits,
        rng,
        eInt: e || 65537,
        e: new BigInteger(null),
        p: null,
        q: null,
        qBits: bits >> 1,
        pBits: bits - (bits >> 1),
        pqState: 0,
        num: null,
        keys: null
      };
      rval.e.fromInt(rval.eInt);
    } else {
      throw new Error("Invalid key generation algorithm: " + algorithm);
    }
    return rval;
  };
  pki.rsa.stepKeyPairGenerationState = function(state, n) {
    if (!("algorithm" in state)) {
      state.algorithm = "PRIMEINC";
    }
    var THIRTY = new BigInteger(null);
    THIRTY.fromInt(30);
    var deltaIdx = 0;
    var op_or = function(x, y) {
      return x | y;
    };
    var t1 = +new Date();
    var t2;
    var total = 0;
    while (state.keys === null && (n <= 0 || total < n)) {
      if (state.state === 0) {
        var bits = state.p === null ? state.pBits : state.qBits;
        var bits1 = bits - 1;
        if (state.pqState === 0) {
          state.num = new BigInteger(bits, state.rng);
          if (!state.num.testBit(bits1)) {
            state.num.bitwiseTo(BigInteger.ONE.shiftLeft(bits1), op_or, state.num);
          }
          state.num.dAddOffset(31 - state.num.mod(THIRTY).byteValue(), 0);
          deltaIdx = 0;
          ++state.pqState;
        } else if (state.pqState === 1) {
          if (state.num.bitLength() > bits) {
            state.pqState = 0;
          } else if (state.num.isProbablePrime(_getMillerRabinTests(state.num.bitLength()))) {
            ++state.pqState;
          } else {
            state.num.dAddOffset(GCD_30_DELTA[deltaIdx++ % 8], 0);
          }
        } else if (state.pqState === 2) {
          state.pqState = state.num.subtract(BigInteger.ONE).gcd(state.e).compareTo(BigInteger.ONE) === 0 ? 3 : 0;
        } else if (state.pqState === 3) {
          state.pqState = 0;
          if (state.p === null) {
            state.p = state.num;
          } else {
            state.q = state.num;
          }
          if (state.p !== null && state.q !== null) {
            ++state.state;
          }
          state.num = null;
        }
      } else if (state.state === 1) {
        if (state.p.compareTo(state.q) < 0) {
          state.num = state.p;
          state.p = state.q;
          state.q = state.num;
        }
        ++state.state;
      } else if (state.state === 2) {
        state.p1 = state.p.subtract(BigInteger.ONE);
        state.q1 = state.q.subtract(BigInteger.ONE);
        state.phi = state.p1.multiply(state.q1);
        ++state.state;
      } else if (state.state === 3) {
        if (state.phi.gcd(state.e).compareTo(BigInteger.ONE) === 0) {
          ++state.state;
        } else {
          state.p = null;
          state.q = null;
          state.state = 0;
        }
      } else if (state.state === 4) {
        state.n = state.p.multiply(state.q);
        if (state.n.bitLength() === state.bits) {
          ++state.state;
        } else {
          state.q = null;
          state.state = 0;
        }
      } else if (state.state === 5) {
        var d = state.e.modInverse(state.phi);
        state.keys = {
          privateKey: pki.rsa.setPrivateKey(state.n, state.e, d, state.p, state.q, d.mod(state.p1), d.mod(state.q1), state.q.modInverse(state.p)),
          publicKey: pki.rsa.setPublicKey(state.n, state.e)
        };
      }
      t2 = +new Date();
      total += t2 - t1;
      t1 = t2;
    }
    return state.keys !== null;
  };
  pki.rsa.generateKeyPair = function(bits, e, options, callback) {
    if (arguments.length === 1) {
      if (typeof bits === "object") {
        options = bits;
        bits = void 0;
      } else if (typeof bits === "function") {
        callback = bits;
        bits = void 0;
      }
    } else if (arguments.length === 2) {
      if (typeof bits === "number") {
        if (typeof e === "function") {
          callback = e;
          e = void 0;
        } else if (typeof e !== "number") {
          options = e;
          e = void 0;
        }
      } else {
        options = bits;
        callback = e;
        bits = void 0;
        e = void 0;
      }
    } else if (arguments.length === 3) {
      if (typeof e === "number") {
        if (typeof options === "function") {
          callback = options;
          options = void 0;
        }
      } else {
        callback = options;
        options = e;
        e = void 0;
      }
    }
    options = options || {};
    if (bits === void 0) {
      bits = options.bits || 2048;
    }
    if (e === void 0) {
      e = options.e || 65537;
    }
    if (!forge.options.usePureJavaScript && !options.prng && bits >= 256 && bits <= 16384 && (e === 65537 || e === 3)) {
      if (callback) {
        if (_detectNodeCrypto("generateKeyPair")) {
          return _crypto.generateKeyPair("rsa", {
            modulusLength: bits,
            publicExponent: e,
            publicKeyEncoding: {
              type: "spki",
              format: "pem"
            },
            privateKeyEncoding: {
              type: "pkcs8",
              format: "pem"
            }
          }, function(err, pub, priv) {
            if (err) {
              return callback(err);
            }
            callback(null, {
              privateKey: pki.privateKeyFromPem(priv),
              publicKey: pki.publicKeyFromPem(pub)
            });
          });
        }
        if (_detectSubtleCrypto("generateKey") && _detectSubtleCrypto("exportKey")) {
          return util.globalScope.crypto.subtle.generateKey({
            name: "RSASSA-PKCS1-v1_5",
            modulusLength: bits,
            publicExponent: _intToUint8Array(e),
            hash: {name: "SHA-256"}
          }, true, ["sign", "verify"]).then(function(pair) {
            return util.globalScope.crypto.subtle.exportKey("pkcs8", pair.privateKey);
          }).then(void 0, function(err) {
            callback(err);
          }).then(function(pkcs8) {
            if (pkcs8) {
              var privateKey = pki.privateKeyFromAsn1(asn1.fromDer(forge.util.createBuffer(pkcs8)));
              callback(null, {
                privateKey,
                publicKey: pki.setRsaPublicKey(privateKey.n, privateKey.e)
              });
            }
          });
        }
        if (_detectSubtleMsCrypto("generateKey") && _detectSubtleMsCrypto("exportKey")) {
          var genOp = util.globalScope.msCrypto.subtle.generateKey({
            name: "RSASSA-PKCS1-v1_5",
            modulusLength: bits,
            publicExponent: _intToUint8Array(e),
            hash: {name: "SHA-256"}
          }, true, ["sign", "verify"]);
          genOp.oncomplete = function(e2) {
            var pair = e2.target.result;
            var exportOp = util.globalScope.msCrypto.subtle.exportKey("pkcs8", pair.privateKey);
            exportOp.oncomplete = function(e3) {
              var pkcs8 = e3.target.result;
              var privateKey = pki.privateKeyFromAsn1(asn1.fromDer(forge.util.createBuffer(pkcs8)));
              callback(null, {
                privateKey,
                publicKey: pki.setRsaPublicKey(privateKey.n, privateKey.e)
              });
            };
            exportOp.onerror = function(err) {
              callback(err);
            };
          };
          genOp.onerror = function(err) {
            callback(err);
          };
          return;
        }
      } else {
        if (_detectNodeCrypto("generateKeyPairSync")) {
          var keypair = _crypto.generateKeyPairSync("rsa", {
            modulusLength: bits,
            publicExponent: e,
            publicKeyEncoding: {
              type: "spki",
              format: "pem"
            },
            privateKeyEncoding: {
              type: "pkcs8",
              format: "pem"
            }
          });
          return {
            privateKey: pki.privateKeyFromPem(keypair.privateKey),
            publicKey: pki.publicKeyFromPem(keypair.publicKey)
          };
        }
      }
    }
    var state = pki.rsa.createKeyPairGenerationState(bits, e, options);
    if (!callback) {
      pki.rsa.stepKeyPairGenerationState(state, 0);
      return state.keys;
    }
    _generateKeyPair(state, options, callback);
  };
  pki.setRsaPublicKey = pki.rsa.setPublicKey = function(n, e) {
    var key = {
      n,
      e
    };
    key.encrypt = function(data, scheme, schemeOptions) {
      if (typeof scheme === "string") {
        scheme = scheme.toUpperCase();
      } else if (scheme === void 0) {
        scheme = "RSAES-PKCS1-V1_5";
      }
      if (scheme === "RSAES-PKCS1-V1_5") {
        scheme = {
          encode: function(m, key2, pub) {
            return _encodePkcs1_v1_5(m, key2, 2).getBytes();
          }
        };
      } else if (scheme === "RSA-OAEP" || scheme === "RSAES-OAEP") {
        scheme = {
          encode: function(m, key2) {
            return forge.pkcs1.encode_rsa_oaep(key2, m, schemeOptions);
          }
        };
      } else if (["RAW", "NONE", "NULL", null].indexOf(scheme) !== -1) {
        scheme = {encode: function(e3) {
          return e3;
        }};
      } else if (typeof scheme === "string") {
        throw new Error('Unsupported encryption scheme: "' + scheme + '".');
      }
      var e2 = scheme.encode(data, key, true);
      return pki.rsa.encrypt(e2, key, true);
    };
    key.verify = function(digest, signature, scheme) {
      if (typeof scheme === "string") {
        scheme = scheme.toUpperCase();
      } else if (scheme === void 0) {
        scheme = "RSASSA-PKCS1-V1_5";
      }
      if (scheme === "RSASSA-PKCS1-V1_5") {
        scheme = {
          verify: function(digest2, d2) {
            d2 = _decodePkcs1_v1_5(d2, key, true);
            var obj = asn1.fromDer(d2);
            return digest2 === obj.value[1].value;
          }
        };
      } else if (scheme === "NONE" || scheme === "NULL" || scheme === null) {
        scheme = {
          verify: function(digest2, d2) {
            d2 = _decodePkcs1_v1_5(d2, key, true);
            return digest2 === d2;
          }
        };
      }
      var d = pki.rsa.decrypt(signature, key, true, false);
      return scheme.verify(digest, d, key.n.bitLength());
    };
    return key;
  };
  pki.setRsaPrivateKey = pki.rsa.setPrivateKey = function(n, e, d, p, q, dP, dQ, qInv) {
    var key = {
      n,
      e,
      d,
      p,
      q,
      dP,
      dQ,
      qInv
    };
    key.decrypt = function(data, scheme, schemeOptions) {
      if (typeof scheme === "string") {
        scheme = scheme.toUpperCase();
      } else if (scheme === void 0) {
        scheme = "RSAES-PKCS1-V1_5";
      }
      var d2 = pki.rsa.decrypt(data, key, false, false);
      if (scheme === "RSAES-PKCS1-V1_5") {
        scheme = {decode: _decodePkcs1_v1_5};
      } else if (scheme === "RSA-OAEP" || scheme === "RSAES-OAEP") {
        scheme = {
          decode: function(d3, key2) {
            return forge.pkcs1.decode_rsa_oaep(key2, d3, schemeOptions);
          }
        };
      } else if (["RAW", "NONE", "NULL", null].indexOf(scheme) !== -1) {
        scheme = {decode: function(d3) {
          return d3;
        }};
      } else {
        throw new Error('Unsupported encryption scheme: "' + scheme + '".');
      }
      return scheme.decode(d2, key, false);
    };
    key.sign = function(md, scheme) {
      var bt = false;
      if (typeof scheme === "string") {
        scheme = scheme.toUpperCase();
      }
      if (scheme === void 0 || scheme === "RSASSA-PKCS1-V1_5") {
        scheme = {encode: emsaPkcs1v15encode};
        bt = 1;
      } else if (scheme === "NONE" || scheme === "NULL" || scheme === null) {
        scheme = {encode: function() {
          return md;
        }};
        bt = 1;
      }
      var d2 = scheme.encode(md, key.n.bitLength());
      return pki.rsa.encrypt(d2, key, bt);
    };
    return key;
  };
  pki.wrapRsaPrivateKey = function(rsaKey) {
    return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, asn1.integerToDer(0).getBytes()),
      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(pki.oids.rsaEncryption).getBytes()),
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, "")
      ]),
      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, asn1.toDer(rsaKey).getBytes())
    ]);
  };
  pki.privateKeyFromAsn1 = function(obj) {
    var capture = {};
    var errors = [];
    if (asn1.validate(obj, privateKeyValidator, capture, errors)) {
      obj = asn1.fromDer(forge.util.createBuffer(capture.privateKey));
    }
    capture = {};
    errors = [];
    if (!asn1.validate(obj, rsaPrivateKeyValidator, capture, errors)) {
      var error = new Error("Cannot read private key. ASN.1 object does not contain an RSAPrivateKey.");
      error.errors = errors;
      throw error;
    }
    var n, e, d, p, q, dP, dQ, qInv;
    n = forge.util.createBuffer(capture.privateKeyModulus).toHex();
    e = forge.util.createBuffer(capture.privateKeyPublicExponent).toHex();
    d = forge.util.createBuffer(capture.privateKeyPrivateExponent).toHex();
    p = forge.util.createBuffer(capture.privateKeyPrime1).toHex();
    q = forge.util.createBuffer(capture.privateKeyPrime2).toHex();
    dP = forge.util.createBuffer(capture.privateKeyExponent1).toHex();
    dQ = forge.util.createBuffer(capture.privateKeyExponent2).toHex();
    qInv = forge.util.createBuffer(capture.privateKeyCoefficient).toHex();
    return pki.setRsaPrivateKey(new BigInteger(n, 16), new BigInteger(e, 16), new BigInteger(d, 16), new BigInteger(p, 16), new BigInteger(q, 16), new BigInteger(dP, 16), new BigInteger(dQ, 16), new BigInteger(qInv, 16));
  };
  pki.privateKeyToAsn1 = pki.privateKeyToRSAPrivateKey = function(key) {
    return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, asn1.integerToDer(0).getBytes()),
      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, _bnToBytes(key.n)),
      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, _bnToBytes(key.e)),
      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, _bnToBytes(key.d)),
      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, _bnToBytes(key.p)),
      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, _bnToBytes(key.q)),
      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, _bnToBytes(key.dP)),
      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, _bnToBytes(key.dQ)),
      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, _bnToBytes(key.qInv))
    ]);
  };
  pki.publicKeyFromAsn1 = function(obj) {
    var capture = {};
    var errors = [];
    if (asn1.validate(obj, publicKeyValidator, capture, errors)) {
      var oid = asn1.derToOid(capture.publicKeyOid);
      if (oid !== pki.oids.rsaEncryption) {
        var error = new Error("Cannot read public key. Unknown OID.");
        error.oid = oid;
        throw error;
      }
      obj = capture.rsaPublicKey;
    }
    errors = [];
    if (!asn1.validate(obj, rsaPublicKeyValidator, capture, errors)) {
      var error = new Error("Cannot read public key. ASN.1 object does not contain an RSAPublicKey.");
      error.errors = errors;
      throw error;
    }
    var n = forge.util.createBuffer(capture.publicKeyModulus).toHex();
    var e = forge.util.createBuffer(capture.publicKeyExponent).toHex();
    return pki.setRsaPublicKey(new BigInteger(n, 16), new BigInteger(e, 16));
  };
  pki.publicKeyToAsn1 = pki.publicKeyToSubjectPublicKeyInfo = function(key) {
    return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(pki.oids.rsaEncryption).getBytes()),
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, "")
      ]),
      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.BITSTRING, false, [
        pki.publicKeyToRSAPublicKey(key)
      ])
    ]);
  };
  pki.publicKeyToRSAPublicKey = function(key) {
    return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, _bnToBytes(key.n)),
      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, _bnToBytes(key.e))
    ]);
  };
  function _encodePkcs1_v1_5(m, key, bt) {
    var eb = forge.util.createBuffer();
    var k = Math.ceil(key.n.bitLength() / 8);
    if (m.length > k - 11) {
      var error = new Error("Message is too long for PKCS#1 v1.5 padding.");
      error.length = m.length;
      error.max = k - 11;
      throw error;
    }
    eb.putByte(0);
    eb.putByte(bt);
    var padNum = k - 3 - m.length;
    var padByte;
    if (bt === 0 || bt === 1) {
      padByte = bt === 0 ? 0 : 255;
      for (var i = 0; i < padNum; ++i) {
        eb.putByte(padByte);
      }
    } else {
      while (padNum > 0) {
        var numZeros = 0;
        var padBytes = forge.random.getBytes(padNum);
        for (var i = 0; i < padNum; ++i) {
          padByte = padBytes.charCodeAt(i);
          if (padByte === 0) {
            ++numZeros;
          } else {
            eb.putByte(padByte);
          }
        }
        padNum = numZeros;
      }
    }
    eb.putByte(0);
    eb.putBytes(m);
    return eb;
  }
  function _decodePkcs1_v1_5(em, key, pub, ml) {
    var k = Math.ceil(key.n.bitLength() / 8);
    var eb = forge.util.createBuffer(em);
    var first = eb.getByte();
    var bt = eb.getByte();
    if (first !== 0 || pub && bt !== 0 && bt !== 1 || !pub && bt != 2 || pub && bt === 0 && typeof ml === "undefined") {
      throw new Error("Encryption block is invalid.");
    }
    var padNum = 0;
    if (bt === 0) {
      padNum = k - 3 - ml;
      for (var i = 0; i < padNum; ++i) {
        if (eb.getByte() !== 0) {
          throw new Error("Encryption block is invalid.");
        }
      }
    } else if (bt === 1) {
      padNum = 0;
      while (eb.length() > 1) {
        if (eb.getByte() !== 255) {
          --eb.read;
          break;
        }
        ++padNum;
      }
    } else if (bt === 2) {
      padNum = 0;
      while (eb.length() > 1) {
        if (eb.getByte() === 0) {
          --eb.read;
          break;
        }
        ++padNum;
      }
    }
    var zero = eb.getByte();
    if (zero !== 0 || padNum !== k - 3 - eb.length()) {
      throw new Error("Encryption block is invalid.");
    }
    return eb.getBytes();
  }
  function _generateKeyPair(state, options, callback) {
    if (typeof options === "function") {
      callback = options;
      options = {};
    }
    options = options || {};
    var opts = {
      algorithm: {
        name: options.algorithm || "PRIMEINC",
        options: {
          workers: options.workers || 2,
          workLoad: options.workLoad || 100,
          workerScript: options.workerScript
        }
      }
    };
    if ("prng" in options) {
      opts.prng = options.prng;
    }
    generate();
    function generate() {
      getPrime(state.pBits, function(err, num) {
        if (err) {
          return callback(err);
        }
        state.p = num;
        if (state.q !== null) {
          return finish(err, state.q);
        }
        getPrime(state.qBits, finish);
      });
    }
    function getPrime(bits, callback2) {
      forge.prime.generateProbablePrime(bits, opts, callback2);
    }
    function finish(err, num) {
      if (err) {
        return callback(err);
      }
      state.q = num;
      if (state.p.compareTo(state.q) < 0) {
        var tmp = state.p;
        state.p = state.q;
        state.q = tmp;
      }
      if (state.p.subtract(BigInteger.ONE).gcd(state.e).compareTo(BigInteger.ONE) !== 0) {
        state.p = null;
        generate();
        return;
      }
      if (state.q.subtract(BigInteger.ONE).gcd(state.e).compareTo(BigInteger.ONE) !== 0) {
        state.q = null;
        getPrime(state.qBits, finish);
        return;
      }
      state.p1 = state.p.subtract(BigInteger.ONE);
      state.q1 = state.q.subtract(BigInteger.ONE);
      state.phi = state.p1.multiply(state.q1);
      if (state.phi.gcd(state.e).compareTo(BigInteger.ONE) !== 0) {
        state.p = state.q = null;
        generate();
        return;
      }
      state.n = state.p.multiply(state.q);
      if (state.n.bitLength() !== state.bits) {
        state.q = null;
        getPrime(state.qBits, finish);
        return;
      }
      var d = state.e.modInverse(state.phi);
      state.keys = {
        privateKey: pki.rsa.setPrivateKey(state.n, state.e, d, state.p, state.q, d.mod(state.p1), d.mod(state.q1), state.q.modInverse(state.p)),
        publicKey: pki.rsa.setPublicKey(state.n, state.e)
      };
      callback(null, state.keys);
    }
  }
  function _bnToBytes(b) {
    var hex = b.toString(16);
    if (hex[0] >= "8") {
      hex = "00" + hex;
    }
    var bytes = forge.util.hexToBytes(hex);
    if (bytes.length > 1 && (bytes.charCodeAt(0) === 0 && (bytes.charCodeAt(1) & 128) === 0 || bytes.charCodeAt(0) === 255 && (bytes.charCodeAt(1) & 128) === 128)) {
      return bytes.substr(1);
    }
    return bytes;
  }
  function _getMillerRabinTests(bits) {
    if (bits <= 100)
      return 27;
    if (bits <= 150)
      return 18;
    if (bits <= 200)
      return 15;
    if (bits <= 250)
      return 12;
    if (bits <= 300)
      return 9;
    if (bits <= 350)
      return 8;
    if (bits <= 400)
      return 7;
    if (bits <= 500)
      return 6;
    if (bits <= 600)
      return 5;
    if (bits <= 800)
      return 4;
    if (bits <= 1250)
      return 3;
    return 2;
  }
  function _detectNodeCrypto(fn) {
    return forge.util.isNodejs && typeof _crypto[fn] === "function";
  }
  function _detectSubtleCrypto(fn) {
    return typeof util.globalScope !== "undefined" && typeof util.globalScope.crypto === "object" && typeof util.globalScope.crypto.subtle === "object" && typeof util.globalScope.crypto.subtle[fn] === "function";
  }
  function _detectSubtleMsCrypto(fn) {
    return typeof util.globalScope !== "undefined" && typeof util.globalScope.msCrypto === "object" && typeof util.globalScope.msCrypto.subtle === "object" && typeof util.globalScope.msCrypto.subtle[fn] === "function";
  }
  function _intToUint8Array(x) {
    var bytes = forge.util.hexToBytes(x.toString(16));
    var buffer = new Uint8Array(bytes.length);
    for (var i = 0; i < bytes.length; ++i) {
      buffer[i] = bytes.charCodeAt(i);
    }
    return buffer;
  }
});

// node_modules/node-forge/lib/pbe.js
var require_pbe = __commonJS((exports2, module2) => {
  var forge = require_forge();
  require_aes();
  require_asn1();
  require_des();
  require_md();
  require_oids();
  require_pbkdf2();
  require_pem();
  require_random();
  require_rc2();
  require_rsa();
  require_util3();
  if (typeof BigInteger === "undefined") {
    BigInteger = forge.jsbn.BigInteger;
  }
  var BigInteger;
  var asn1 = forge.asn1;
  var pki = forge.pki = forge.pki || {};
  module2.exports = pki.pbe = forge.pbe = forge.pbe || {};
  var oids = pki.oids;
  var encryptedPrivateKeyValidator = {
    name: "EncryptedPrivateKeyInfo",
    tagClass: asn1.Class.UNIVERSAL,
    type: asn1.Type.SEQUENCE,
    constructed: true,
    value: [{
      name: "EncryptedPrivateKeyInfo.encryptionAlgorithm",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "AlgorithmIdentifier.algorithm",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.OID,
        constructed: false,
        capture: "encryptionOid"
      }, {
        name: "AlgorithmIdentifier.parameters",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        captureAsn1: "encryptionParams"
      }]
    }, {
      name: "EncryptedPrivateKeyInfo.encryptedData",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.OCTETSTRING,
      constructed: false,
      capture: "encryptedData"
    }]
  };
  var PBES2AlgorithmsValidator = {
    name: "PBES2Algorithms",
    tagClass: asn1.Class.UNIVERSAL,
    type: asn1.Type.SEQUENCE,
    constructed: true,
    value: [{
      name: "PBES2Algorithms.keyDerivationFunc",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "PBES2Algorithms.keyDerivationFunc.oid",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.OID,
        constructed: false,
        capture: "kdfOid"
      }, {
        name: "PBES2Algorithms.params",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: "PBES2Algorithms.params.salt",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.OCTETSTRING,
          constructed: false,
          capture: "kdfSalt"
        }, {
          name: "PBES2Algorithms.params.iterationCount",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.INTEGER,
          constructed: false,
          capture: "kdfIterationCount"
        }, {
          name: "PBES2Algorithms.params.keyLength",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.INTEGER,
          constructed: false,
          optional: true,
          capture: "keyLength"
        }, {
          name: "PBES2Algorithms.params.prf",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.SEQUENCE,
          constructed: true,
          optional: true,
          value: [{
            name: "PBES2Algorithms.params.prf.algorithm",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.OID,
            constructed: false,
            capture: "prfOid"
          }]
        }]
      }]
    }, {
      name: "PBES2Algorithms.encryptionScheme",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "PBES2Algorithms.encryptionScheme.oid",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.OID,
        constructed: false,
        capture: "encOid"
      }, {
        name: "PBES2Algorithms.encryptionScheme.iv",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.OCTETSTRING,
        constructed: false,
        capture: "encIv"
      }]
    }]
  };
  var pkcs12PbeParamsValidator = {
    name: "pkcs-12PbeParams",
    tagClass: asn1.Class.UNIVERSAL,
    type: asn1.Type.SEQUENCE,
    constructed: true,
    value: [{
      name: "pkcs-12PbeParams.salt",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.OCTETSTRING,
      constructed: false,
      capture: "salt"
    }, {
      name: "pkcs-12PbeParams.iterations",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.INTEGER,
      constructed: false,
      capture: "iterations"
    }]
  };
  pki.encryptPrivateKeyInfo = function(obj, password, options) {
    options = options || {};
    options.saltSize = options.saltSize || 8;
    options.count = options.count || 2048;
    options.algorithm = options.algorithm || "aes128";
    options.prfAlgorithm = options.prfAlgorithm || "sha1";
    var salt = forge.random.getBytesSync(options.saltSize);
    var count = options.count;
    var countBytes = asn1.integerToDer(count);
    var dkLen;
    var encryptionAlgorithm;
    var encryptedData;
    if (options.algorithm.indexOf("aes") === 0 || options.algorithm === "des") {
      var ivLen, encOid, cipherFn;
      switch (options.algorithm) {
        case "aes128":
          dkLen = 16;
          ivLen = 16;
          encOid = oids["aes128-CBC"];
          cipherFn = forge.aes.createEncryptionCipher;
          break;
        case "aes192":
          dkLen = 24;
          ivLen = 16;
          encOid = oids["aes192-CBC"];
          cipherFn = forge.aes.createEncryptionCipher;
          break;
        case "aes256":
          dkLen = 32;
          ivLen = 16;
          encOid = oids["aes256-CBC"];
          cipherFn = forge.aes.createEncryptionCipher;
          break;
        case "des":
          dkLen = 8;
          ivLen = 8;
          encOid = oids["desCBC"];
          cipherFn = forge.des.createEncryptionCipher;
          break;
        default:
          var error = new Error("Cannot encrypt private key. Unknown encryption algorithm.");
          error.algorithm = options.algorithm;
          throw error;
      }
      var prfAlgorithm = "hmacWith" + options.prfAlgorithm.toUpperCase();
      var md = prfAlgorithmToMessageDigest(prfAlgorithm);
      var dk = forge.pkcs5.pbkdf2(password, salt, count, dkLen, md);
      var iv = forge.random.getBytesSync(ivLen);
      var cipher = cipherFn(dk);
      cipher.start(iv);
      cipher.update(asn1.toDer(obj));
      cipher.finish();
      encryptedData = cipher.output.getBytes();
      var params = createPbkdf2Params(salt, countBytes, dkLen, prfAlgorithm);
      encryptionAlgorithm = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(oids["pkcs5PBES2"]).getBytes()),
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(oids["pkcs5PBKDF2"]).getBytes()),
            params
          ]),
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(encOid).getBytes()),
            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, iv)
          ])
        ])
      ]);
    } else if (options.algorithm === "3des") {
      dkLen = 24;
      var saltBytes = new forge.util.ByteBuffer(salt);
      var dk = pki.pbe.generatePkcs12Key(password, saltBytes, 1, count, dkLen);
      var iv = pki.pbe.generatePkcs12Key(password, saltBytes, 2, count, dkLen);
      var cipher = forge.des.createEncryptionCipher(dk);
      cipher.start(iv);
      cipher.update(asn1.toDer(obj));
      cipher.finish();
      encryptedData = cipher.output.getBytes();
      encryptionAlgorithm = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(oids["pbeWithSHAAnd3-KeyTripleDES-CBC"]).getBytes()),
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, salt),
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, countBytes.getBytes())
        ])
      ]);
    } else {
      var error = new Error("Cannot encrypt private key. Unknown encryption algorithm.");
      error.algorithm = options.algorithm;
      throw error;
    }
    var rval = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
      encryptionAlgorithm,
      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, encryptedData)
    ]);
    return rval;
  };
  pki.decryptPrivateKeyInfo = function(obj, password) {
    var rval = null;
    var capture = {};
    var errors = [];
    if (!asn1.validate(obj, encryptedPrivateKeyValidator, capture, errors)) {
      var error = new Error("Cannot read encrypted private key. ASN.1 object is not a supported EncryptedPrivateKeyInfo.");
      error.errors = errors;
      throw error;
    }
    var oid = asn1.derToOid(capture.encryptionOid);
    var cipher = pki.pbe.getCipher(oid, capture.encryptionParams, password);
    var encrypted = forge.util.createBuffer(capture.encryptedData);
    cipher.update(encrypted);
    if (cipher.finish()) {
      rval = asn1.fromDer(cipher.output);
    }
    return rval;
  };
  pki.encryptedPrivateKeyToPem = function(epki, maxline) {
    var msg = {
      type: "ENCRYPTED PRIVATE KEY",
      body: asn1.toDer(epki).getBytes()
    };
    return forge.pem.encode(msg, {maxline});
  };
  pki.encryptedPrivateKeyFromPem = function(pem) {
    var msg = forge.pem.decode(pem)[0];
    if (msg.type !== "ENCRYPTED PRIVATE KEY") {
      var error = new Error('Could not convert encrypted private key from PEM; PEM header type is "ENCRYPTED PRIVATE KEY".');
      error.headerType = msg.type;
      throw error;
    }
    if (msg.procType && msg.procType.type === "ENCRYPTED") {
      throw new Error("Could not convert encrypted private key from PEM; PEM is encrypted.");
    }
    return asn1.fromDer(msg.body);
  };
  pki.encryptRsaPrivateKey = function(rsaKey, password, options) {
    options = options || {};
    if (!options.legacy) {
      var rval = pki.wrapRsaPrivateKey(pki.privateKeyToAsn1(rsaKey));
      rval = pki.encryptPrivateKeyInfo(rval, password, options);
      return pki.encryptedPrivateKeyToPem(rval);
    }
    var algorithm;
    var iv;
    var dkLen;
    var cipherFn;
    switch (options.algorithm) {
      case "aes128":
        algorithm = "AES-128-CBC";
        dkLen = 16;
        iv = forge.random.getBytesSync(16);
        cipherFn = forge.aes.createEncryptionCipher;
        break;
      case "aes192":
        algorithm = "AES-192-CBC";
        dkLen = 24;
        iv = forge.random.getBytesSync(16);
        cipherFn = forge.aes.createEncryptionCipher;
        break;
      case "aes256":
        algorithm = "AES-256-CBC";
        dkLen = 32;
        iv = forge.random.getBytesSync(16);
        cipherFn = forge.aes.createEncryptionCipher;
        break;
      case "3des":
        algorithm = "DES-EDE3-CBC";
        dkLen = 24;
        iv = forge.random.getBytesSync(8);
        cipherFn = forge.des.createEncryptionCipher;
        break;
      case "des":
        algorithm = "DES-CBC";
        dkLen = 8;
        iv = forge.random.getBytesSync(8);
        cipherFn = forge.des.createEncryptionCipher;
        break;
      default:
        var error = new Error('Could not encrypt RSA private key; unsupported encryption algorithm "' + options.algorithm + '".');
        error.algorithm = options.algorithm;
        throw error;
    }
    var dk = forge.pbe.opensslDeriveBytes(password, iv.substr(0, 8), dkLen);
    var cipher = cipherFn(dk);
    cipher.start(iv);
    cipher.update(asn1.toDer(pki.privateKeyToAsn1(rsaKey)));
    cipher.finish();
    var msg = {
      type: "RSA PRIVATE KEY",
      procType: {
        version: "4",
        type: "ENCRYPTED"
      },
      dekInfo: {
        algorithm,
        parameters: forge.util.bytesToHex(iv).toUpperCase()
      },
      body: cipher.output.getBytes()
    };
    return forge.pem.encode(msg);
  };
  pki.decryptRsaPrivateKey = function(pem, password) {
    var rval = null;
    var msg = forge.pem.decode(pem)[0];
    if (msg.type !== "ENCRYPTED PRIVATE KEY" && msg.type !== "PRIVATE KEY" && msg.type !== "RSA PRIVATE KEY") {
      var error = new Error('Could not convert private key from PEM; PEM header type is not "ENCRYPTED PRIVATE KEY", "PRIVATE KEY", or "RSA PRIVATE KEY".');
      error.headerType = error;
      throw error;
    }
    if (msg.procType && msg.procType.type === "ENCRYPTED") {
      var dkLen;
      var cipherFn;
      switch (msg.dekInfo.algorithm) {
        case "DES-CBC":
          dkLen = 8;
          cipherFn = forge.des.createDecryptionCipher;
          break;
        case "DES-EDE3-CBC":
          dkLen = 24;
          cipherFn = forge.des.createDecryptionCipher;
          break;
        case "AES-128-CBC":
          dkLen = 16;
          cipherFn = forge.aes.createDecryptionCipher;
          break;
        case "AES-192-CBC":
          dkLen = 24;
          cipherFn = forge.aes.createDecryptionCipher;
          break;
        case "AES-256-CBC":
          dkLen = 32;
          cipherFn = forge.aes.createDecryptionCipher;
          break;
        case "RC2-40-CBC":
          dkLen = 5;
          cipherFn = function(key) {
            return forge.rc2.createDecryptionCipher(key, 40);
          };
          break;
        case "RC2-64-CBC":
          dkLen = 8;
          cipherFn = function(key) {
            return forge.rc2.createDecryptionCipher(key, 64);
          };
          break;
        case "RC2-128-CBC":
          dkLen = 16;
          cipherFn = function(key) {
            return forge.rc2.createDecryptionCipher(key, 128);
          };
          break;
        default:
          var error = new Error('Could not decrypt private key; unsupported encryption algorithm "' + msg.dekInfo.algorithm + '".');
          error.algorithm = msg.dekInfo.algorithm;
          throw error;
      }
      var iv = forge.util.hexToBytes(msg.dekInfo.parameters);
      var dk = forge.pbe.opensslDeriveBytes(password, iv.substr(0, 8), dkLen);
      var cipher = cipherFn(dk);
      cipher.start(iv);
      cipher.update(forge.util.createBuffer(msg.body));
      if (cipher.finish()) {
        rval = cipher.output.getBytes();
      } else {
        return rval;
      }
    } else {
      rval = msg.body;
    }
    if (msg.type === "ENCRYPTED PRIVATE KEY") {
      rval = pki.decryptPrivateKeyInfo(asn1.fromDer(rval), password);
    } else {
      rval = asn1.fromDer(rval);
    }
    if (rval !== null) {
      rval = pki.privateKeyFromAsn1(rval);
    }
    return rval;
  };
  pki.pbe.generatePkcs12Key = function(password, salt, id, iter, n, md) {
    var j, l;
    if (typeof md === "undefined" || md === null) {
      if (!("sha1" in forge.md)) {
        throw new Error('"sha1" hash algorithm unavailable.');
      }
      md = forge.md.sha1.create();
    }
    var u = md.digestLength;
    var v = md.blockLength;
    var result = new forge.util.ByteBuffer();
    var passBuf = new forge.util.ByteBuffer();
    if (password !== null && password !== void 0) {
      for (l = 0; l < password.length; l++) {
        passBuf.putInt16(password.charCodeAt(l));
      }
      passBuf.putInt16(0);
    }
    var p = passBuf.length();
    var s = salt.length();
    var D = new forge.util.ByteBuffer();
    D.fillWithByte(id, v);
    var Slen = v * Math.ceil(s / v);
    var S = new forge.util.ByteBuffer();
    for (l = 0; l < Slen; l++) {
      S.putByte(salt.at(l % s));
    }
    var Plen = v * Math.ceil(p / v);
    var P = new forge.util.ByteBuffer();
    for (l = 0; l < Plen; l++) {
      P.putByte(passBuf.at(l % p));
    }
    var I = S;
    I.putBuffer(P);
    var c = Math.ceil(n / u);
    for (var i = 1; i <= c; i++) {
      var buf = new forge.util.ByteBuffer();
      buf.putBytes(D.bytes());
      buf.putBytes(I.bytes());
      for (var round = 0; round < iter; round++) {
        md.start();
        md.update(buf.getBytes());
        buf = md.digest();
      }
      var B = new forge.util.ByteBuffer();
      for (l = 0; l < v; l++) {
        B.putByte(buf.at(l % u));
      }
      var k = Math.ceil(s / v) + Math.ceil(p / v);
      var Inew = new forge.util.ByteBuffer();
      for (j = 0; j < k; j++) {
        var chunk = new forge.util.ByteBuffer(I.getBytes(v));
        var x = 511;
        for (l = B.length() - 1; l >= 0; l--) {
          x = x >> 8;
          x += B.at(l) + chunk.at(l);
          chunk.setAt(l, x & 255);
        }
        Inew.putBuffer(chunk);
      }
      I = Inew;
      result.putBuffer(buf);
    }
    result.truncate(result.length() - n);
    return result;
  };
  pki.pbe.getCipher = function(oid, params, password) {
    switch (oid) {
      case pki.oids["pkcs5PBES2"]:
        return pki.pbe.getCipherForPBES2(oid, params, password);
      case pki.oids["pbeWithSHAAnd3-KeyTripleDES-CBC"]:
      case pki.oids["pbewithSHAAnd40BitRC2-CBC"]:
        return pki.pbe.getCipherForPKCS12PBE(oid, params, password);
      default:
        var error = new Error("Cannot read encrypted PBE data block. Unsupported OID.");
        error.oid = oid;
        error.supportedOids = [
          "pkcs5PBES2",
          "pbeWithSHAAnd3-KeyTripleDES-CBC",
          "pbewithSHAAnd40BitRC2-CBC"
        ];
        throw error;
    }
  };
  pki.pbe.getCipherForPBES2 = function(oid, params, password) {
    var capture = {};
    var errors = [];
    if (!asn1.validate(params, PBES2AlgorithmsValidator, capture, errors)) {
      var error = new Error("Cannot read password-based-encryption algorithm parameters. ASN.1 object is not a supported EncryptedPrivateKeyInfo.");
      error.errors = errors;
      throw error;
    }
    oid = asn1.derToOid(capture.kdfOid);
    if (oid !== pki.oids["pkcs5PBKDF2"]) {
      var error = new Error("Cannot read encrypted private key. Unsupported key derivation function OID.");
      error.oid = oid;
      error.supportedOids = ["pkcs5PBKDF2"];
      throw error;
    }
    oid = asn1.derToOid(capture.encOid);
    if (oid !== pki.oids["aes128-CBC"] && oid !== pki.oids["aes192-CBC"] && oid !== pki.oids["aes256-CBC"] && oid !== pki.oids["des-EDE3-CBC"] && oid !== pki.oids["desCBC"]) {
      var error = new Error("Cannot read encrypted private key. Unsupported encryption scheme OID.");
      error.oid = oid;
      error.supportedOids = [
        "aes128-CBC",
        "aes192-CBC",
        "aes256-CBC",
        "des-EDE3-CBC",
        "desCBC"
      ];
      throw error;
    }
    var salt = capture.kdfSalt;
    var count = forge.util.createBuffer(capture.kdfIterationCount);
    count = count.getInt(count.length() << 3);
    var dkLen;
    var cipherFn;
    switch (pki.oids[oid]) {
      case "aes128-CBC":
        dkLen = 16;
        cipherFn = forge.aes.createDecryptionCipher;
        break;
      case "aes192-CBC":
        dkLen = 24;
        cipherFn = forge.aes.createDecryptionCipher;
        break;
      case "aes256-CBC":
        dkLen = 32;
        cipherFn = forge.aes.createDecryptionCipher;
        break;
      case "des-EDE3-CBC":
        dkLen = 24;
        cipherFn = forge.des.createDecryptionCipher;
        break;
      case "desCBC":
        dkLen = 8;
        cipherFn = forge.des.createDecryptionCipher;
        break;
    }
    var md = prfOidToMessageDigest(capture.prfOid);
    var dk = forge.pkcs5.pbkdf2(password, salt, count, dkLen, md);
    var iv = capture.encIv;
    var cipher = cipherFn(dk);
    cipher.start(iv);
    return cipher;
  };
  pki.pbe.getCipherForPKCS12PBE = function(oid, params, password) {
    var capture = {};
    var errors = [];
    if (!asn1.validate(params, pkcs12PbeParamsValidator, capture, errors)) {
      var error = new Error("Cannot read password-based-encryption algorithm parameters. ASN.1 object is not a supported EncryptedPrivateKeyInfo.");
      error.errors = errors;
      throw error;
    }
    var salt = forge.util.createBuffer(capture.salt);
    var count = forge.util.createBuffer(capture.iterations);
    count = count.getInt(count.length() << 3);
    var dkLen, dIvLen, cipherFn;
    switch (oid) {
      case pki.oids["pbeWithSHAAnd3-KeyTripleDES-CBC"]:
        dkLen = 24;
        dIvLen = 8;
        cipherFn = forge.des.startDecrypting;
        break;
      case pki.oids["pbewithSHAAnd40BitRC2-CBC"]:
        dkLen = 5;
        dIvLen = 8;
        cipherFn = function(key2, iv2) {
          var cipher = forge.rc2.createDecryptionCipher(key2, 40);
          cipher.start(iv2, null);
          return cipher;
        };
        break;
      default:
        var error = new Error("Cannot read PKCS #12 PBE data block. Unsupported OID.");
        error.oid = oid;
        throw error;
    }
    var md = prfOidToMessageDigest(capture.prfOid);
    var key = pki.pbe.generatePkcs12Key(password, salt, 1, count, dkLen, md);
    md.start();
    var iv = pki.pbe.generatePkcs12Key(password, salt, 2, count, dIvLen, md);
    return cipherFn(key, iv);
  };
  pki.pbe.opensslDeriveBytes = function(password, salt, dkLen, md) {
    if (typeof md === "undefined" || md === null) {
      if (!("md5" in forge.md)) {
        throw new Error('"md5" hash algorithm unavailable.');
      }
      md = forge.md.md5.create();
    }
    if (salt === null) {
      salt = "";
    }
    var digests = [hash(md, password + salt)];
    for (var length = 16, i = 1; length < dkLen; ++i, length += 16) {
      digests.push(hash(md, digests[i - 1] + password + salt));
    }
    return digests.join("").substr(0, dkLen);
  };
  function hash(md, bytes) {
    return md.start().update(bytes).digest().getBytes();
  }
  function prfOidToMessageDigest(prfOid) {
    var prfAlgorithm;
    if (!prfOid) {
      prfAlgorithm = "hmacWithSHA1";
    } else {
      prfAlgorithm = pki.oids[asn1.derToOid(prfOid)];
      if (!prfAlgorithm) {
        var error = new Error("Unsupported PRF OID.");
        error.oid = prfOid;
        error.supported = [
          "hmacWithSHA1",
          "hmacWithSHA224",
          "hmacWithSHA256",
          "hmacWithSHA384",
          "hmacWithSHA512"
        ];
        throw error;
      }
    }
    return prfAlgorithmToMessageDigest(prfAlgorithm);
  }
  function prfAlgorithmToMessageDigest(prfAlgorithm) {
    var factory = forge.md;
    switch (prfAlgorithm) {
      case "hmacWithSHA224":
        factory = forge.md.sha512;
      case "hmacWithSHA1":
      case "hmacWithSHA256":
      case "hmacWithSHA384":
      case "hmacWithSHA512":
        prfAlgorithm = prfAlgorithm.substr(8).toLowerCase();
        break;
      default:
        var error = new Error("Unsupported PRF algorithm.");
        error.algorithm = prfAlgorithm;
        error.supported = [
          "hmacWithSHA1",
          "hmacWithSHA224",
          "hmacWithSHA256",
          "hmacWithSHA384",
          "hmacWithSHA512"
        ];
        throw error;
    }
    if (!factory || !(prfAlgorithm in factory)) {
      throw new Error("Unknown hash algorithm: " + prfAlgorithm);
    }
    return factory[prfAlgorithm].create();
  }
  function createPbkdf2Params(salt, countBytes, dkLen, prfAlgorithm) {
    var params = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, salt),
      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, countBytes.getBytes())
    ]);
    if (prfAlgorithm !== "hmacWithSHA1") {
      params.value.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, forge.util.hexToBytes(dkLen.toString(16))), asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(pki.oids[prfAlgorithm]).getBytes()),
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, "")
      ]));
    }
    return params;
  }
});

// node_modules/err-code/index.js
var require_err_code = __commonJS((exports2, module2) => {
  "use strict";
  function assign(obj, props) {
    for (const key in props) {
      Object.defineProperty(obj, key, {
        value: props[key],
        enumerable: true,
        configurable: true
      });
    }
    return obj;
  }
  function createError(err, code, props) {
    if (!err || typeof err === "string") {
      throw new TypeError("Please pass an Error to err-code");
    }
    if (!props) {
      props = {};
    }
    if (typeof code === "object") {
      props = code;
      code = void 0;
    }
    if (code != null) {
      props.code = code;
    }
    try {
      return assign(err, props);
    } catch (_) {
      props.message = err.message;
      props.stack = err.stack;
      const ErrClass = function() {
      };
      ErrClass.prototype = Object.create(Object.getPrototypeOf(err));
      return assign(new ErrClass(), props);
    }
  }
  module2.exports = createError;
});

// node_modules/libp2p-crypto/src/webcrypto.js
var require_webcrypto = __commonJS((exports2) => {
  "use strict";
  exports2.get = (win = self) => {
    const nativeCrypto = win.crypto || win.msCrypto;
    if (!nativeCrypto || !nativeCrypto.subtle) {
      throw Object.assign(new Error("Missing Web Crypto API. The most likely cause of this error is that this page is being accessed from an insecure context (i.e. not HTTPS). For more information and possible resolutions see https://github.com/libp2p/js-libp2p-crypto/blob/master/README.md#web-crypto-api"), {code: "ERR_MISSING_WEB_CRYPTO"});
    }
    return nativeCrypto;
  };
});

// node_modules/libp2p-crypto/src/ciphers/aes-gcm.browser.js
var require_aes_gcm_browser = __commonJS((exports2, module2) => {
  "use strict";
  var concat = require_concat2();
  var fromString = require_from_string2();
  var webcrypto = require_webcrypto();
  function create({
    algorithm = "AES-GCM",
    nonceLength = 12,
    keyLength = 16,
    digest = "SHA-256",
    saltLength = 16,
    iterations = 32767
  } = {}) {
    const crypto2 = webcrypto.get();
    keyLength *= 8;
    async function encrypt(data, password) {
      const salt = crypto2.getRandomValues(new Uint8Array(saltLength));
      const nonce = crypto2.getRandomValues(new Uint8Array(nonceLength));
      const aesGcm = {name: algorithm, iv: nonce};
      const deriveParams = {name: "PBKDF2", salt, iterations, hash: {name: digest}};
      const rawKey = await crypto2.subtle.importKey("raw", fromString(password), {name: "PBKDF2"}, false, ["deriveKey", "deriveBits"]);
      const cryptoKey = await crypto2.subtle.deriveKey(deriveParams, rawKey, {name: algorithm, length: keyLength}, true, ["encrypt"]);
      const ciphertext = await crypto2.subtle.encrypt(aesGcm, cryptoKey, data);
      return concat([salt, aesGcm.iv, new Uint8Array(ciphertext)]);
    }
    async function decrypt(data, password) {
      const salt = data.slice(0, saltLength);
      const nonce = data.slice(saltLength, saltLength + nonceLength);
      const ciphertext = data.slice(saltLength + nonceLength);
      const aesGcm = {name: algorithm, iv: nonce};
      const deriveParams = {name: "PBKDF2", salt, iterations, hash: {name: digest}};
      const rawKey = await crypto2.subtle.importKey("raw", fromString(password), {name: "PBKDF2"}, false, ["deriveKey", "deriveBits"]);
      const cryptoKey = await crypto2.subtle.deriveKey(deriveParams, rawKey, {name: algorithm, length: keyLength}, true, ["decrypt"]);
      const plaintext = await crypto2.subtle.decrypt(aesGcm, cryptoKey, ciphertext);
      return new Uint8Array(plaintext);
    }
    return {
      encrypt,
      decrypt
    };
  }
  module2.exports = {
    create
  };
});

// node_modules/libp2p-crypto/src/keys/importer.js
var require_importer = __commonJS((exports2, module2) => {
  "use strict";
  var multibase = require_src4();
  var ciphers = require_aes_gcm_browser();
  module2.exports = {
    import: async function(privateKey, password) {
      const base64 = multibase.names.base64;
      const encryptedKey = base64.decode(privateKey);
      const cipher = ciphers.create();
      return await cipher.decrypt(encryptedKey, password);
    }
  };
});

// node_modules/multihashing-async/src/sha.browser.js
var require_sha_browser = __commonJS((exports2, module2) => {
  "use strict";
  var multihash = require_src5();
  var crypto2 = self.crypto || self.msCrypto;
  var digest = async (data, alg) => {
    if (typeof self === "undefined" || !self.crypto && !self.msCrypto) {
      throw new Error("Please use a browser with webcrypto support and ensure the code has been delivered securely via HTTPS/TLS and run within a Secure Context");
    }
    switch (alg) {
      case "sha1":
        return new Uint8Array(await crypto2.subtle.digest({name: "SHA-1"}, data));
      case "sha2-256":
        return new Uint8Array(await crypto2.subtle.digest({name: "SHA-256"}, data));
      case "sha2-512":
        return new Uint8Array(await crypto2.subtle.digest({name: "SHA-512"}, data));
      case "dbl-sha2-256": {
        const d = await crypto2.subtle.digest({name: "SHA-256"}, data);
        return new Uint8Array(await crypto2.subtle.digest({name: "SHA-256"}, d));
      }
      default:
        throw new Error(`${alg} is not a supported algorithm`);
    }
  };
  module2.exports = {
    factory: (alg) => async (data) => {
      return digest(data, alg);
    },
    digest,
    multihashing: async (buf, alg, length) => {
      const h = await digest(buf, alg, length);
      return multihash.encode(h, alg, length);
    }
  };
});

// node_modules/uint8arrays/equals.js
var require_equals2 = __commonJS((exports2, module2) => {
  "use strict";
  function equals(a, b) {
    if (a === b) {
      return true;
    }
    if (a.byteLength !== b.byteLength) {
      return false;
    }
    for (let i = 0; i < a.byteLength; i++) {
      if (a[i] !== b[i]) {
        return false;
      }
    }
    return true;
  }
  module2.exports = equals;
});

// node_modules/node-forge/lib/sha512.js
var require_sha512 = __commonJS((exports2, module2) => {
  var forge = require_forge();
  require_md();
  require_util3();
  var sha512 = module2.exports = forge.sha512 = forge.sha512 || {};
  forge.md.sha512 = forge.md.algorithms.sha512 = sha512;
  var sha384 = forge.sha384 = forge.sha512.sha384 = forge.sha512.sha384 || {};
  sha384.create = function() {
    return sha512.create("SHA-384");
  };
  forge.md.sha384 = forge.md.algorithms.sha384 = sha384;
  forge.sha512.sha256 = forge.sha512.sha256 || {
    create: function() {
      return sha512.create("SHA-512/256");
    }
  };
  forge.md["sha512/256"] = forge.md.algorithms["sha512/256"] = forge.sha512.sha256;
  forge.sha512.sha224 = forge.sha512.sha224 || {
    create: function() {
      return sha512.create("SHA-512/224");
    }
  };
  forge.md["sha512/224"] = forge.md.algorithms["sha512/224"] = forge.sha512.sha224;
  sha512.create = function(algorithm) {
    if (!_initialized) {
      _init();
    }
    if (typeof algorithm === "undefined") {
      algorithm = "SHA-512";
    }
    if (!(algorithm in _states)) {
      throw new Error("Invalid SHA-512 algorithm: " + algorithm);
    }
    var _state = _states[algorithm];
    var _h = null;
    var _input = forge.util.createBuffer();
    var _w = new Array(80);
    for (var wi = 0; wi < 80; ++wi) {
      _w[wi] = new Array(2);
    }
    var digestLength = 64;
    switch (algorithm) {
      case "SHA-384":
        digestLength = 48;
        break;
      case "SHA-512/256":
        digestLength = 32;
        break;
      case "SHA-512/224":
        digestLength = 28;
        break;
    }
    var md = {
      algorithm: algorithm.replace("-", "").toLowerCase(),
      blockLength: 128,
      digestLength,
      messageLength: 0,
      fullMessageLength: null,
      messageLengthSize: 16
    };
    md.start = function() {
      md.messageLength = 0;
      md.fullMessageLength = md.messageLength128 = [];
      var int32s = md.messageLengthSize / 4;
      for (var i = 0; i < int32s; ++i) {
        md.fullMessageLength.push(0);
      }
      _input = forge.util.createBuffer();
      _h = new Array(_state.length);
      for (var i = 0; i < _state.length; ++i) {
        _h[i] = _state[i].slice(0);
      }
      return md;
    };
    md.start();
    md.update = function(msg, encoding) {
      if (encoding === "utf8") {
        msg = forge.util.encodeUtf8(msg);
      }
      var len = msg.length;
      md.messageLength += len;
      len = [len / 4294967296 >>> 0, len >>> 0];
      for (var i = md.fullMessageLength.length - 1; i >= 0; --i) {
        md.fullMessageLength[i] += len[1];
        len[1] = len[0] + (md.fullMessageLength[i] / 4294967296 >>> 0);
        md.fullMessageLength[i] = md.fullMessageLength[i] >>> 0;
        len[0] = len[1] / 4294967296 >>> 0;
      }
      _input.putBytes(msg);
      _update(_h, _w, _input);
      if (_input.read > 2048 || _input.length() === 0) {
        _input.compact();
      }
      return md;
    };
    md.digest = function() {
      var finalBlock = forge.util.createBuffer();
      finalBlock.putBytes(_input.bytes());
      var remaining = md.fullMessageLength[md.fullMessageLength.length - 1] + md.messageLengthSize;
      var overflow = remaining & md.blockLength - 1;
      finalBlock.putBytes(_padding.substr(0, md.blockLength - overflow));
      var next, carry;
      var bits = md.fullMessageLength[0] * 8;
      for (var i = 0; i < md.fullMessageLength.length - 1; ++i) {
        next = md.fullMessageLength[i + 1] * 8;
        carry = next / 4294967296 >>> 0;
        bits += carry;
        finalBlock.putInt32(bits >>> 0);
        bits = next >>> 0;
      }
      finalBlock.putInt32(bits);
      var h = new Array(_h.length);
      for (var i = 0; i < _h.length; ++i) {
        h[i] = _h[i].slice(0);
      }
      _update(h, _w, finalBlock);
      var rval = forge.util.createBuffer();
      var hlen;
      if (algorithm === "SHA-512") {
        hlen = h.length;
      } else if (algorithm === "SHA-384") {
        hlen = h.length - 2;
      } else {
        hlen = h.length - 4;
      }
      for (var i = 0; i < hlen; ++i) {
        rval.putInt32(h[i][0]);
        if (i !== hlen - 1 || algorithm !== "SHA-512/224") {
          rval.putInt32(h[i][1]);
        }
      }
      return rval;
    };
    return md;
  };
  var _padding = null;
  var _initialized = false;
  var _k = null;
  var _states = null;
  function _init() {
    _padding = String.fromCharCode(128);
    _padding += forge.util.fillString(String.fromCharCode(0), 128);
    _k = [
      [1116352408, 3609767458],
      [1899447441, 602891725],
      [3049323471, 3964484399],
      [3921009573, 2173295548],
      [961987163, 4081628472],
      [1508970993, 3053834265],
      [2453635748, 2937671579],
      [2870763221, 3664609560],
      [3624381080, 2734883394],
      [310598401, 1164996542],
      [607225278, 1323610764],
      [1426881987, 3590304994],
      [1925078388, 4068182383],
      [2162078206, 991336113],
      [2614888103, 633803317],
      [3248222580, 3479774868],
      [3835390401, 2666613458],
      [4022224774, 944711139],
      [264347078, 2341262773],
      [604807628, 2007800933],
      [770255983, 1495990901],
      [1249150122, 1856431235],
      [1555081692, 3175218132],
      [1996064986, 2198950837],
      [2554220882, 3999719339],
      [2821834349, 766784016],
      [2952996808, 2566594879],
      [3210313671, 3203337956],
      [3336571891, 1034457026],
      [3584528711, 2466948901],
      [113926993, 3758326383],
      [338241895, 168717936],
      [666307205, 1188179964],
      [773529912, 1546045734],
      [1294757372, 1522805485],
      [1396182291, 2643833823],
      [1695183700, 2343527390],
      [1986661051, 1014477480],
      [2177026350, 1206759142],
      [2456956037, 344077627],
      [2730485921, 1290863460],
      [2820302411, 3158454273],
      [3259730800, 3505952657],
      [3345764771, 106217008],
      [3516065817, 3606008344],
      [3600352804, 1432725776],
      [4094571909, 1467031594],
      [275423344, 851169720],
      [430227734, 3100823752],
      [506948616, 1363258195],
      [659060556, 3750685593],
      [883997877, 3785050280],
      [958139571, 3318307427],
      [1322822218, 3812723403],
      [1537002063, 2003034995],
      [1747873779, 3602036899],
      [1955562222, 1575990012],
      [2024104815, 1125592928],
      [2227730452, 2716904306],
      [2361852424, 442776044],
      [2428436474, 593698344],
      [2756734187, 3733110249],
      [3204031479, 2999351573],
      [3329325298, 3815920427],
      [3391569614, 3928383900],
      [3515267271, 566280711],
      [3940187606, 3454069534],
      [4118630271, 4000239992],
      [116418474, 1914138554],
      [174292421, 2731055270],
      [289380356, 3203993006],
      [460393269, 320620315],
      [685471733, 587496836],
      [852142971, 1086792851],
      [1017036298, 365543100],
      [1126000580, 2618297676],
      [1288033470, 3409855158],
      [1501505948, 4234509866],
      [1607167915, 987167468],
      [1816402316, 1246189591]
    ];
    _states = {};
    _states["SHA-512"] = [
      [1779033703, 4089235720],
      [3144134277, 2227873595],
      [1013904242, 4271175723],
      [2773480762, 1595750129],
      [1359893119, 2917565137],
      [2600822924, 725511199],
      [528734635, 4215389547],
      [1541459225, 327033209]
    ];
    _states["SHA-384"] = [
      [3418070365, 3238371032],
      [1654270250, 914150663],
      [2438529370, 812702999],
      [355462360, 4144912697],
      [1731405415, 4290775857],
      [2394180231, 1750603025],
      [3675008525, 1694076839],
      [1203062813, 3204075428]
    ];
    _states["SHA-512/256"] = [
      [573645204, 4230739756],
      [2673172387, 3360449730],
      [596883563, 1867755857],
      [2520282905, 1497426621],
      [2519219938, 2827943907],
      [3193839141, 1401305490],
      [721525244, 746961066],
      [246885852, 2177182882]
    ];
    _states["SHA-512/224"] = [
      [2352822216, 424955298],
      [1944164710, 2312950998],
      [502970286, 855612546],
      [1738396948, 1479516111],
      [258812777, 2077511080],
      [2011393907, 79989058],
      [1067287976, 1780299464],
      [286451373, 2446758561]
    ];
    _initialized = true;
  }
  function _update(s, w, bytes) {
    var t1_hi, t1_lo;
    var t2_hi, t2_lo;
    var s0_hi, s0_lo;
    var s1_hi, s1_lo;
    var ch_hi, ch_lo;
    var maj_hi, maj_lo;
    var a_hi, a_lo;
    var b_hi, b_lo;
    var c_hi, c_lo;
    var d_hi, d_lo;
    var e_hi, e_lo;
    var f_hi, f_lo;
    var g_hi, g_lo;
    var h_hi, h_lo;
    var i, hi, lo, w2, w7, w15, w16;
    var len = bytes.length();
    while (len >= 128) {
      for (i = 0; i < 16; ++i) {
        w[i][0] = bytes.getInt32() >>> 0;
        w[i][1] = bytes.getInt32() >>> 0;
      }
      for (; i < 80; ++i) {
        w2 = w[i - 2];
        hi = w2[0];
        lo = w2[1];
        t1_hi = ((hi >>> 19 | lo << 13) ^ (lo >>> 29 | hi << 3) ^ hi >>> 6) >>> 0;
        t1_lo = ((hi << 13 | lo >>> 19) ^ (lo << 3 | hi >>> 29) ^ (hi << 26 | lo >>> 6)) >>> 0;
        w15 = w[i - 15];
        hi = w15[0];
        lo = w15[1];
        t2_hi = ((hi >>> 1 | lo << 31) ^ (hi >>> 8 | lo << 24) ^ hi >>> 7) >>> 0;
        t2_lo = ((hi << 31 | lo >>> 1) ^ (hi << 24 | lo >>> 8) ^ (hi << 25 | lo >>> 7)) >>> 0;
        w7 = w[i - 7];
        w16 = w[i - 16];
        lo = t1_lo + w7[1] + t2_lo + w16[1];
        w[i][0] = t1_hi + w7[0] + t2_hi + w16[0] + (lo / 4294967296 >>> 0) >>> 0;
        w[i][1] = lo >>> 0;
      }
      a_hi = s[0][0];
      a_lo = s[0][1];
      b_hi = s[1][0];
      b_lo = s[1][1];
      c_hi = s[2][0];
      c_lo = s[2][1];
      d_hi = s[3][0];
      d_lo = s[3][1];
      e_hi = s[4][0];
      e_lo = s[4][1];
      f_hi = s[5][0];
      f_lo = s[5][1];
      g_hi = s[6][0];
      g_lo = s[6][1];
      h_hi = s[7][0];
      h_lo = s[7][1];
      for (i = 0; i < 80; ++i) {
        s1_hi = ((e_hi >>> 14 | e_lo << 18) ^ (e_hi >>> 18 | e_lo << 14) ^ (e_lo >>> 9 | e_hi << 23)) >>> 0;
        s1_lo = ((e_hi << 18 | e_lo >>> 14) ^ (e_hi << 14 | e_lo >>> 18) ^ (e_lo << 23 | e_hi >>> 9)) >>> 0;
        ch_hi = (g_hi ^ e_hi & (f_hi ^ g_hi)) >>> 0;
        ch_lo = (g_lo ^ e_lo & (f_lo ^ g_lo)) >>> 0;
        s0_hi = ((a_hi >>> 28 | a_lo << 4) ^ (a_lo >>> 2 | a_hi << 30) ^ (a_lo >>> 7 | a_hi << 25)) >>> 0;
        s0_lo = ((a_hi << 4 | a_lo >>> 28) ^ (a_lo << 30 | a_hi >>> 2) ^ (a_lo << 25 | a_hi >>> 7)) >>> 0;
        maj_hi = (a_hi & b_hi | c_hi & (a_hi ^ b_hi)) >>> 0;
        maj_lo = (a_lo & b_lo | c_lo & (a_lo ^ b_lo)) >>> 0;
        lo = h_lo + s1_lo + ch_lo + _k[i][1] + w[i][1];
        t1_hi = h_hi + s1_hi + ch_hi + _k[i][0] + w[i][0] + (lo / 4294967296 >>> 0) >>> 0;
        t1_lo = lo >>> 0;
        lo = s0_lo + maj_lo;
        t2_hi = s0_hi + maj_hi + (lo / 4294967296 >>> 0) >>> 0;
        t2_lo = lo >>> 0;
        h_hi = g_hi;
        h_lo = g_lo;
        g_hi = f_hi;
        g_lo = f_lo;
        f_hi = e_hi;
        f_lo = e_lo;
        lo = d_lo + t1_lo;
        e_hi = d_hi + t1_hi + (lo / 4294967296 >>> 0) >>> 0;
        e_lo = lo >>> 0;
        d_hi = c_hi;
        d_lo = c_lo;
        c_hi = b_hi;
        c_lo = b_lo;
        b_hi = a_hi;
        b_lo = a_lo;
        lo = t1_lo + t2_lo;
        a_hi = t1_hi + t2_hi + (lo / 4294967296 >>> 0) >>> 0;
        a_lo = lo >>> 0;
      }
      lo = s[0][1] + a_lo;
      s[0][0] = s[0][0] + a_hi + (lo / 4294967296 >>> 0) >>> 0;
      s[0][1] = lo >>> 0;
      lo = s[1][1] + b_lo;
      s[1][0] = s[1][0] + b_hi + (lo / 4294967296 >>> 0) >>> 0;
      s[1][1] = lo >>> 0;
      lo = s[2][1] + c_lo;
      s[2][0] = s[2][0] + c_hi + (lo / 4294967296 >>> 0) >>> 0;
      s[2][1] = lo >>> 0;
      lo = s[3][1] + d_lo;
      s[3][0] = s[3][0] + d_hi + (lo / 4294967296 >>> 0) >>> 0;
      s[3][1] = lo >>> 0;
      lo = s[4][1] + e_lo;
      s[4][0] = s[4][0] + e_hi + (lo / 4294967296 >>> 0) >>> 0;
      s[4][1] = lo >>> 0;
      lo = s[5][1] + f_lo;
      s[5][0] = s[5][0] + f_hi + (lo / 4294967296 >>> 0) >>> 0;
      s[5][1] = lo >>> 0;
      lo = s[6][1] + g_lo;
      s[6][0] = s[6][0] + g_hi + (lo / 4294967296 >>> 0) >>> 0;
      s[6][1] = lo >>> 0;
      lo = s[7][1] + h_lo;
      s[7][0] = s[7][0] + h_hi + (lo / 4294967296 >>> 0) >>> 0;
      s[7][1] = lo >>> 0;
      len -= 128;
    }
  }
});

// node_modules/node-forge/lib/asn1-validator.js
var require_asn1_validator = __commonJS((exports2) => {
  var forge = require_forge();
  require_asn1();
  var asn1 = forge.asn1;
  exports2.privateKeyValidator = {
    name: "PrivateKeyInfo",
    tagClass: asn1.Class.UNIVERSAL,
    type: asn1.Type.SEQUENCE,
    constructed: true,
    value: [{
      name: "PrivateKeyInfo.version",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.INTEGER,
      constructed: false,
      capture: "privateKeyVersion"
    }, {
      name: "PrivateKeyInfo.privateKeyAlgorithm",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "AlgorithmIdentifier.algorithm",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.OID,
        constructed: false,
        capture: "privateKeyOid"
      }]
    }, {
      name: "PrivateKeyInfo",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.OCTETSTRING,
      constructed: false,
      capture: "privateKey"
    }]
  };
  exports2.publicKeyValidator = {
    name: "SubjectPublicKeyInfo",
    tagClass: asn1.Class.UNIVERSAL,
    type: asn1.Type.SEQUENCE,
    constructed: true,
    captureAsn1: "subjectPublicKeyInfo",
    value: [
      {
        name: "SubjectPublicKeyInfo.AlgorithmIdentifier",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: "AlgorithmIdentifier.algorithm",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.OID,
          constructed: false,
          capture: "publicKeyOid"
        }]
      },
      {
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.BITSTRING,
        constructed: false,
        composed: true,
        captureBitStringValue: "ed25519PublicKey"
      }
    ]
  };
});

// node_modules/node-forge/lib/ed25519.js
var require_ed25519 = __commonJS((exports2, module2) => {
  var forge = require_forge();
  require_jsbn();
  require_random();
  require_sha512();
  require_util3();
  var asn1Validator = require_asn1_validator();
  var publicKeyValidator = asn1Validator.publicKeyValidator;
  var privateKeyValidator = asn1Validator.privateKeyValidator;
  if (typeof BigInteger === "undefined") {
    BigInteger = forge.jsbn.BigInteger;
  }
  var BigInteger;
  var ByteBuffer = forge.util.ByteBuffer;
  var NativeBuffer = typeof Buffer === "undefined" ? Uint8Array : Buffer;
  forge.pki = forge.pki || {};
  module2.exports = forge.pki.ed25519 = forge.ed25519 = forge.ed25519 || {};
  var ed25519 = forge.ed25519;
  ed25519.constants = {};
  ed25519.constants.PUBLIC_KEY_BYTE_LENGTH = 32;
  ed25519.constants.PRIVATE_KEY_BYTE_LENGTH = 64;
  ed25519.constants.SEED_BYTE_LENGTH = 32;
  ed25519.constants.SIGN_BYTE_LENGTH = 64;
  ed25519.constants.HASH_BYTE_LENGTH = 64;
  ed25519.generateKeyPair = function(options) {
    options = options || {};
    var seed = options.seed;
    if (seed === void 0) {
      seed = forge.random.getBytesSync(ed25519.constants.SEED_BYTE_LENGTH);
    } else if (typeof seed === "string") {
      if (seed.length !== ed25519.constants.SEED_BYTE_LENGTH) {
        throw new TypeError('"seed" must be ' + ed25519.constants.SEED_BYTE_LENGTH + " bytes in length.");
      }
    } else if (!(seed instanceof Uint8Array)) {
      throw new TypeError('"seed" must be a node.js Buffer, Uint8Array, or a binary string.');
    }
    seed = messageToNativeBuffer({message: seed, encoding: "binary"});
    var pk = new NativeBuffer(ed25519.constants.PUBLIC_KEY_BYTE_LENGTH);
    var sk = new NativeBuffer(ed25519.constants.PRIVATE_KEY_BYTE_LENGTH);
    for (var i = 0; i < 32; ++i) {
      sk[i] = seed[i];
    }
    crypto_sign_keypair(pk, sk);
    return {publicKey: pk, privateKey: sk};
  };
  ed25519.privateKeyFromAsn1 = function(obj) {
    var capture = {};
    var errors = [];
    var valid = forge.asn1.validate(obj, privateKeyValidator, capture, errors);
    if (!valid) {
      var error = new Error("Invalid Key.");
      error.errors = errors;
      throw error;
    }
    var oid = forge.asn1.derToOid(capture.privateKeyOid);
    var ed25519Oid = forge.oids.EdDSA25519;
    if (oid !== ed25519Oid) {
      throw new Error('Invalid OID "' + oid + '"; OID must be "' + ed25519Oid + '".');
    }
    var privateKey = capture.privateKey;
    var privateKeyBytes = messageToNativeBuffer({
      message: forge.asn1.fromDer(privateKey).value,
      encoding: "binary"
    });
    return {privateKeyBytes};
  };
  ed25519.publicKeyFromAsn1 = function(obj) {
    var capture = {};
    var errors = [];
    var valid = forge.asn1.validate(obj, publicKeyValidator, capture, errors);
    if (!valid) {
      var error = new Error("Invalid Key.");
      error.errors = errors;
      throw error;
    }
    var oid = forge.asn1.derToOid(capture.publicKeyOid);
    var ed25519Oid = forge.oids.EdDSA25519;
    if (oid !== ed25519Oid) {
      throw new Error('Invalid OID "' + oid + '"; OID must be "' + ed25519Oid + '".');
    }
    var publicKeyBytes = capture.ed25519PublicKey;
    if (publicKeyBytes.length !== ed25519.constants.PUBLIC_KEY_BYTE_LENGTH) {
      throw new Error("Key length is invalid.");
    }
    return messageToNativeBuffer({
      message: publicKeyBytes,
      encoding: "binary"
    });
  };
  ed25519.publicKeyFromPrivateKey = function(options) {
    options = options || {};
    var privateKey = messageToNativeBuffer({
      message: options.privateKey,
      encoding: "binary"
    });
    if (privateKey.length !== ed25519.constants.PRIVATE_KEY_BYTE_LENGTH) {
      throw new TypeError('"options.privateKey" must have a byte length of ' + ed25519.constants.PRIVATE_KEY_BYTE_LENGTH);
    }
    var pk = new NativeBuffer(ed25519.constants.PUBLIC_KEY_BYTE_LENGTH);
    for (var i = 0; i < pk.length; ++i) {
      pk[i] = privateKey[32 + i];
    }
    return pk;
  };
  ed25519.sign = function(options) {
    options = options || {};
    var msg = messageToNativeBuffer(options);
    var privateKey = messageToNativeBuffer({
      message: options.privateKey,
      encoding: "binary"
    });
    if (privateKey.length === ed25519.constants.SEED_BYTE_LENGTH) {
      var keyPair = ed25519.generateKeyPair({seed: privateKey});
      privateKey = keyPair.privateKey;
    } else if (privateKey.length !== ed25519.constants.PRIVATE_KEY_BYTE_LENGTH) {
      throw new TypeError('"options.privateKey" must have a byte length of ' + ed25519.constants.SEED_BYTE_LENGTH + " or " + ed25519.constants.PRIVATE_KEY_BYTE_LENGTH);
    }
    var signedMsg = new NativeBuffer(ed25519.constants.SIGN_BYTE_LENGTH + msg.length);
    crypto_sign(signedMsg, msg, msg.length, privateKey);
    var sig = new NativeBuffer(ed25519.constants.SIGN_BYTE_LENGTH);
    for (var i = 0; i < sig.length; ++i) {
      sig[i] = signedMsg[i];
    }
    return sig;
  };
  ed25519.verify = function(options) {
    options = options || {};
    var msg = messageToNativeBuffer(options);
    if (options.signature === void 0) {
      throw new TypeError('"options.signature" must be a node.js Buffer, a Uint8Array, a forge ByteBuffer, or a binary string.');
    }
    var sig = messageToNativeBuffer({
      message: options.signature,
      encoding: "binary"
    });
    if (sig.length !== ed25519.constants.SIGN_BYTE_LENGTH) {
      throw new TypeError('"options.signature" must have a byte length of ' + ed25519.constants.SIGN_BYTE_LENGTH);
    }
    var publicKey = messageToNativeBuffer({
      message: options.publicKey,
      encoding: "binary"
    });
    if (publicKey.length !== ed25519.constants.PUBLIC_KEY_BYTE_LENGTH) {
      throw new TypeError('"options.publicKey" must have a byte length of ' + ed25519.constants.PUBLIC_KEY_BYTE_LENGTH);
    }
    var sm = new NativeBuffer(ed25519.constants.SIGN_BYTE_LENGTH + msg.length);
    var m = new NativeBuffer(ed25519.constants.SIGN_BYTE_LENGTH + msg.length);
    var i;
    for (i = 0; i < ed25519.constants.SIGN_BYTE_LENGTH; ++i) {
      sm[i] = sig[i];
    }
    for (i = 0; i < msg.length; ++i) {
      sm[i + ed25519.constants.SIGN_BYTE_LENGTH] = msg[i];
    }
    return crypto_sign_open(m, sm, sm.length, publicKey) >= 0;
  };
  function messageToNativeBuffer(options) {
    var message = options.message;
    if (message instanceof Uint8Array || message instanceof NativeBuffer) {
      return message;
    }
    var encoding = options.encoding;
    if (message === void 0) {
      if (options.md) {
        message = options.md.digest().getBytes();
        encoding = "binary";
      } else {
        throw new TypeError('"options.message" or "options.md" not specified.');
      }
    }
    if (typeof message === "string" && !encoding) {
      throw new TypeError('"options.encoding" must be "binary" or "utf8".');
    }
    if (typeof message === "string") {
      if (typeof Buffer !== "undefined") {
        return Buffer.from(message, encoding);
      }
      message = new ByteBuffer(message, encoding);
    } else if (!(message instanceof ByteBuffer)) {
      throw new TypeError('"options.message" must be a node.js Buffer, a Uint8Array, a forge ByteBuffer, or a string with "options.encoding" specifying its encoding.');
    }
    var buffer = new NativeBuffer(message.length());
    for (var i = 0; i < buffer.length; ++i) {
      buffer[i] = message.at(i);
    }
    return buffer;
  }
  var gf0 = gf();
  var gf1 = gf([1]);
  var D = gf([
    30883,
    4953,
    19914,
    30187,
    55467,
    16705,
    2637,
    112,
    59544,
    30585,
    16505,
    36039,
    65139,
    11119,
    27886,
    20995
  ]);
  var D2 = gf([
    61785,
    9906,
    39828,
    60374,
    45398,
    33411,
    5274,
    224,
    53552,
    61171,
    33010,
    6542,
    64743,
    22239,
    55772,
    9222
  ]);
  var X = gf([
    54554,
    36645,
    11616,
    51542,
    42930,
    38181,
    51040,
    26924,
    56412,
    64982,
    57905,
    49316,
    21502,
    52590,
    14035,
    8553
  ]);
  var Y = gf([
    26200,
    26214,
    26214,
    26214,
    26214,
    26214,
    26214,
    26214,
    26214,
    26214,
    26214,
    26214,
    26214,
    26214,
    26214,
    26214
  ]);
  var L = new Float64Array([
    237,
    211,
    245,
    92,
    26,
    99,
    18,
    88,
    214,
    156,
    247,
    162,
    222,
    249,
    222,
    20,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    16
  ]);
  var I = gf([
    41136,
    18958,
    6951,
    50414,
    58488,
    44335,
    6150,
    12099,
    55207,
    15867,
    153,
    11085,
    57099,
    20417,
    9344,
    11139
  ]);
  function sha512(msg, msgLen) {
    var md = forge.md.sha512.create();
    var buffer = new ByteBuffer(msg);
    md.update(buffer.getBytes(msgLen), "binary");
    var hash = md.digest().getBytes();
    if (typeof Buffer !== "undefined") {
      return Buffer.from(hash, "binary");
    }
    var out = new NativeBuffer(ed25519.constants.HASH_BYTE_LENGTH);
    for (var i = 0; i < 64; ++i) {
      out[i] = hash.charCodeAt(i);
    }
    return out;
  }
  function crypto_sign_keypair(pk, sk) {
    var p = [gf(), gf(), gf(), gf()];
    var i;
    var d = sha512(sk, 32);
    d[0] &= 248;
    d[31] &= 127;
    d[31] |= 64;
    scalarbase(p, d);
    pack(pk, p);
    for (i = 0; i < 32; ++i) {
      sk[i + 32] = pk[i];
    }
    return 0;
  }
  function crypto_sign(sm, m, n, sk) {
    var i, j, x = new Float64Array(64);
    var p = [gf(), gf(), gf(), gf()];
    var d = sha512(sk, 32);
    d[0] &= 248;
    d[31] &= 127;
    d[31] |= 64;
    var smlen = n + 64;
    for (i = 0; i < n; ++i) {
      sm[64 + i] = m[i];
    }
    for (i = 0; i < 32; ++i) {
      sm[32 + i] = d[32 + i];
    }
    var r = sha512(sm.subarray(32), n + 32);
    reduce(r);
    scalarbase(p, r);
    pack(sm, p);
    for (i = 32; i < 64; ++i) {
      sm[i] = sk[i];
    }
    var h = sha512(sm, n + 64);
    reduce(h);
    for (i = 32; i < 64; ++i) {
      x[i] = 0;
    }
    for (i = 0; i < 32; ++i) {
      x[i] = r[i];
    }
    for (i = 0; i < 32; ++i) {
      for (j = 0; j < 32; j++) {
        x[i + j] += h[i] * d[j];
      }
    }
    modL(sm.subarray(32), x);
    return smlen;
  }
  function crypto_sign_open(m, sm, n, pk) {
    var i, mlen;
    var t = new NativeBuffer(32);
    var p = [gf(), gf(), gf(), gf()], q = [gf(), gf(), gf(), gf()];
    mlen = -1;
    if (n < 64) {
      return -1;
    }
    if (unpackneg(q, pk)) {
      return -1;
    }
    for (i = 0; i < n; ++i) {
      m[i] = sm[i];
    }
    for (i = 0; i < 32; ++i) {
      m[i + 32] = pk[i];
    }
    var h = sha512(m, n);
    reduce(h);
    scalarmult(p, q, h);
    scalarbase(q, sm.subarray(32));
    add(p, q);
    pack(t, p);
    n -= 64;
    if (crypto_verify_32(sm, 0, t, 0)) {
      for (i = 0; i < n; ++i) {
        m[i] = 0;
      }
      return -1;
    }
    for (i = 0; i < n; ++i) {
      m[i] = sm[i + 64];
    }
    mlen = n;
    return mlen;
  }
  function modL(r, x) {
    var carry, i, j, k;
    for (i = 63; i >= 32; --i) {
      carry = 0;
      for (j = i - 32, k = i - 12; j < k; ++j) {
        x[j] += carry - 16 * x[i] * L[j - (i - 32)];
        carry = x[j] + 128 >> 8;
        x[j] -= carry * 256;
      }
      x[j] += carry;
      x[i] = 0;
    }
    carry = 0;
    for (j = 0; j < 32; ++j) {
      x[j] += carry - (x[31] >> 4) * L[j];
      carry = x[j] >> 8;
      x[j] &= 255;
    }
    for (j = 0; j < 32; ++j) {
      x[j] -= carry * L[j];
    }
    for (i = 0; i < 32; ++i) {
      x[i + 1] += x[i] >> 8;
      r[i] = x[i] & 255;
    }
  }
  function reduce(r) {
    var x = new Float64Array(64);
    for (var i = 0; i < 64; ++i) {
      x[i] = r[i];
      r[i] = 0;
    }
    modL(r, x);
  }
  function add(p, q) {
    var a = gf(), b = gf(), c = gf(), d = gf(), e = gf(), f = gf(), g = gf(), h = gf(), t = gf();
    Z(a, p[1], p[0]);
    Z(t, q[1], q[0]);
    M(a, a, t);
    A(b, p[0], p[1]);
    A(t, q[0], q[1]);
    M(b, b, t);
    M(c, p[3], q[3]);
    M(c, c, D2);
    M(d, p[2], q[2]);
    A(d, d, d);
    Z(e, b, a);
    Z(f, d, c);
    A(g, d, c);
    A(h, b, a);
    M(p[0], e, f);
    M(p[1], h, g);
    M(p[2], g, f);
    M(p[3], e, h);
  }
  function cswap(p, q, b) {
    for (var i = 0; i < 4; ++i) {
      sel25519(p[i], q[i], b);
    }
  }
  function pack(r, p) {
    var tx = gf(), ty = gf(), zi = gf();
    inv25519(zi, p[2]);
    M(tx, p[0], zi);
    M(ty, p[1], zi);
    pack25519(r, ty);
    r[31] ^= par25519(tx) << 7;
  }
  function pack25519(o, n) {
    var i, j, b;
    var m = gf(), t = gf();
    for (i = 0; i < 16; ++i) {
      t[i] = n[i];
    }
    car25519(t);
    car25519(t);
    car25519(t);
    for (j = 0; j < 2; ++j) {
      m[0] = t[0] - 65517;
      for (i = 1; i < 15; ++i) {
        m[i] = t[i] - 65535 - (m[i - 1] >> 16 & 1);
        m[i - 1] &= 65535;
      }
      m[15] = t[15] - 32767 - (m[14] >> 16 & 1);
      b = m[15] >> 16 & 1;
      m[14] &= 65535;
      sel25519(t, m, 1 - b);
    }
    for (i = 0; i < 16; i++) {
      o[2 * i] = t[i] & 255;
      o[2 * i + 1] = t[i] >> 8;
    }
  }
  function unpackneg(r, p) {
    var t = gf(), chk = gf(), num = gf(), den = gf(), den2 = gf(), den4 = gf(), den6 = gf();
    set25519(r[2], gf1);
    unpack25519(r[1], p);
    S(num, r[1]);
    M(den, num, D);
    Z(num, num, r[2]);
    A(den, r[2], den);
    S(den2, den);
    S(den4, den2);
    M(den6, den4, den2);
    M(t, den6, num);
    M(t, t, den);
    pow2523(t, t);
    M(t, t, num);
    M(t, t, den);
    M(t, t, den);
    M(r[0], t, den);
    S(chk, r[0]);
    M(chk, chk, den);
    if (neq25519(chk, num)) {
      M(r[0], r[0], I);
    }
    S(chk, r[0]);
    M(chk, chk, den);
    if (neq25519(chk, num)) {
      return -1;
    }
    if (par25519(r[0]) === p[31] >> 7) {
      Z(r[0], gf0, r[0]);
    }
    M(r[3], r[0], r[1]);
    return 0;
  }
  function unpack25519(o, n) {
    var i;
    for (i = 0; i < 16; ++i) {
      o[i] = n[2 * i] + (n[2 * i + 1] << 8);
    }
    o[15] &= 32767;
  }
  function pow2523(o, i) {
    var c = gf();
    var a;
    for (a = 0; a < 16; ++a) {
      c[a] = i[a];
    }
    for (a = 250; a >= 0; --a) {
      S(c, c);
      if (a !== 1) {
        M(c, c, i);
      }
    }
    for (a = 0; a < 16; ++a) {
      o[a] = c[a];
    }
  }
  function neq25519(a, b) {
    var c = new NativeBuffer(32);
    var d = new NativeBuffer(32);
    pack25519(c, a);
    pack25519(d, b);
    return crypto_verify_32(c, 0, d, 0);
  }
  function crypto_verify_32(x, xi, y, yi) {
    return vn(x, xi, y, yi, 32);
  }
  function vn(x, xi, y, yi, n) {
    var i, d = 0;
    for (i = 0; i < n; ++i) {
      d |= x[xi + i] ^ y[yi + i];
    }
    return (1 & d - 1 >>> 8) - 1;
  }
  function par25519(a) {
    var d = new NativeBuffer(32);
    pack25519(d, a);
    return d[0] & 1;
  }
  function scalarmult(p, q, s) {
    var b, i;
    set25519(p[0], gf0);
    set25519(p[1], gf1);
    set25519(p[2], gf1);
    set25519(p[3], gf0);
    for (i = 255; i >= 0; --i) {
      b = s[i / 8 | 0] >> (i & 7) & 1;
      cswap(p, q, b);
      add(q, p);
      add(p, p);
      cswap(p, q, b);
    }
  }
  function scalarbase(p, s) {
    var q = [gf(), gf(), gf(), gf()];
    set25519(q[0], X);
    set25519(q[1], Y);
    set25519(q[2], gf1);
    M(q[3], X, Y);
    scalarmult(p, q, s);
  }
  function set25519(r, a) {
    var i;
    for (i = 0; i < 16; i++) {
      r[i] = a[i] | 0;
    }
  }
  function inv25519(o, i) {
    var c = gf();
    var a;
    for (a = 0; a < 16; ++a) {
      c[a] = i[a];
    }
    for (a = 253; a >= 0; --a) {
      S(c, c);
      if (a !== 2 && a !== 4) {
        M(c, c, i);
      }
    }
    for (a = 0; a < 16; ++a) {
      o[a] = c[a];
    }
  }
  function car25519(o) {
    var i, v, c = 1;
    for (i = 0; i < 16; ++i) {
      v = o[i] + c + 65535;
      c = Math.floor(v / 65536);
      o[i] = v - c * 65536;
    }
    o[0] += c - 1 + 37 * (c - 1);
  }
  function sel25519(p, q, b) {
    var t, c = ~(b - 1);
    for (var i = 0; i < 16; ++i) {
      t = c & (p[i] ^ q[i]);
      p[i] ^= t;
      q[i] ^= t;
    }
  }
  function gf(init) {
    var i, r = new Float64Array(16);
    if (init) {
      for (i = 0; i < init.length; ++i) {
        r[i] = init[i];
      }
    }
    return r;
  }
  function A(o, a, b) {
    for (var i = 0; i < 16; ++i) {
      o[i] = a[i] + b[i];
    }
  }
  function Z(o, a, b) {
    for (var i = 0; i < 16; ++i) {
      o[i] = a[i] - b[i];
    }
  }
  function S(o, a) {
    M(o, a, a);
  }
  function M(o, a, b) {
    var v, c, t0 = 0, t1 = 0, t2 = 0, t3 = 0, t4 = 0, t5 = 0, t6 = 0, t7 = 0, t8 = 0, t9 = 0, t10 = 0, t11 = 0, t12 = 0, t13 = 0, t14 = 0, t15 = 0, t16 = 0, t17 = 0, t18 = 0, t19 = 0, t20 = 0, t21 = 0, t22 = 0, t23 = 0, t24 = 0, t25 = 0, t26 = 0, t27 = 0, t28 = 0, t29 = 0, t30 = 0, b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3], b4 = b[4], b5 = b[5], b6 = b[6], b7 = b[7], b8 = b[8], b9 = b[9], b10 = b[10], b11 = b[11], b12 = b[12], b13 = b[13], b14 = b[14], b15 = b[15];
    v = a[0];
    t0 += v * b0;
    t1 += v * b1;
    t2 += v * b2;
    t3 += v * b3;
    t4 += v * b4;
    t5 += v * b5;
    t6 += v * b6;
    t7 += v * b7;
    t8 += v * b8;
    t9 += v * b9;
    t10 += v * b10;
    t11 += v * b11;
    t12 += v * b12;
    t13 += v * b13;
    t14 += v * b14;
    t15 += v * b15;
    v = a[1];
    t1 += v * b0;
    t2 += v * b1;
    t3 += v * b2;
    t4 += v * b3;
    t5 += v * b4;
    t6 += v * b5;
    t7 += v * b6;
    t8 += v * b7;
    t9 += v * b8;
    t10 += v * b9;
    t11 += v * b10;
    t12 += v * b11;
    t13 += v * b12;
    t14 += v * b13;
    t15 += v * b14;
    t16 += v * b15;
    v = a[2];
    t2 += v * b0;
    t3 += v * b1;
    t4 += v * b2;
    t5 += v * b3;
    t6 += v * b4;
    t7 += v * b5;
    t8 += v * b6;
    t9 += v * b7;
    t10 += v * b8;
    t11 += v * b9;
    t12 += v * b10;
    t13 += v * b11;
    t14 += v * b12;
    t15 += v * b13;
    t16 += v * b14;
    t17 += v * b15;
    v = a[3];
    t3 += v * b0;
    t4 += v * b1;
    t5 += v * b2;
    t6 += v * b3;
    t7 += v * b4;
    t8 += v * b5;
    t9 += v * b6;
    t10 += v * b7;
    t11 += v * b8;
    t12 += v * b9;
    t13 += v * b10;
    t14 += v * b11;
    t15 += v * b12;
    t16 += v * b13;
    t17 += v * b14;
    t18 += v * b15;
    v = a[4];
    t4 += v * b0;
    t5 += v * b1;
    t6 += v * b2;
    t7 += v * b3;
    t8 += v * b4;
    t9 += v * b5;
    t10 += v * b6;
    t11 += v * b7;
    t12 += v * b8;
    t13 += v * b9;
    t14 += v * b10;
    t15 += v * b11;
    t16 += v * b12;
    t17 += v * b13;
    t18 += v * b14;
    t19 += v * b15;
    v = a[5];
    t5 += v * b0;
    t6 += v * b1;
    t7 += v * b2;
    t8 += v * b3;
    t9 += v * b4;
    t10 += v * b5;
    t11 += v * b6;
    t12 += v * b7;
    t13 += v * b8;
    t14 += v * b9;
    t15 += v * b10;
    t16 += v * b11;
    t17 += v * b12;
    t18 += v * b13;
    t19 += v * b14;
    t20 += v * b15;
    v = a[6];
    t6 += v * b0;
    t7 += v * b1;
    t8 += v * b2;
    t9 += v * b3;
    t10 += v * b4;
    t11 += v * b5;
    t12 += v * b6;
    t13 += v * b7;
    t14 += v * b8;
    t15 += v * b9;
    t16 += v * b10;
    t17 += v * b11;
    t18 += v * b12;
    t19 += v * b13;
    t20 += v * b14;
    t21 += v * b15;
    v = a[7];
    t7 += v * b0;
    t8 += v * b1;
    t9 += v * b2;
    t10 += v * b3;
    t11 += v * b4;
    t12 += v * b5;
    t13 += v * b6;
    t14 += v * b7;
    t15 += v * b8;
    t16 += v * b9;
    t17 += v * b10;
    t18 += v * b11;
    t19 += v * b12;
    t20 += v * b13;
    t21 += v * b14;
    t22 += v * b15;
    v = a[8];
    t8 += v * b0;
    t9 += v * b1;
    t10 += v * b2;
    t11 += v * b3;
    t12 += v * b4;
    t13 += v * b5;
    t14 += v * b6;
    t15 += v * b7;
    t16 += v * b8;
    t17 += v * b9;
    t18 += v * b10;
    t19 += v * b11;
    t20 += v * b12;
    t21 += v * b13;
    t22 += v * b14;
    t23 += v * b15;
    v = a[9];
    t9 += v * b0;
    t10 += v * b1;
    t11 += v * b2;
    t12 += v * b3;
    t13 += v * b4;
    t14 += v * b5;
    t15 += v * b6;
    t16 += v * b7;
    t17 += v * b8;
    t18 += v * b9;
    t19 += v * b10;
    t20 += v * b11;
    t21 += v * b12;
    t22 += v * b13;
    t23 += v * b14;
    t24 += v * b15;
    v = a[10];
    t10 += v * b0;
    t11 += v * b1;
    t12 += v * b2;
    t13 += v * b3;
    t14 += v * b4;
    t15 += v * b5;
    t16 += v * b6;
    t17 += v * b7;
    t18 += v * b8;
    t19 += v * b9;
    t20 += v * b10;
    t21 += v * b11;
    t22 += v * b12;
    t23 += v * b13;
    t24 += v * b14;
    t25 += v * b15;
    v = a[11];
    t11 += v * b0;
    t12 += v * b1;
    t13 += v * b2;
    t14 += v * b3;
    t15 += v * b4;
    t16 += v * b5;
    t17 += v * b6;
    t18 += v * b7;
    t19 += v * b8;
    t20 += v * b9;
    t21 += v * b10;
    t22 += v * b11;
    t23 += v * b12;
    t24 += v * b13;
    t25 += v * b14;
    t26 += v * b15;
    v = a[12];
    t12 += v * b0;
    t13 += v * b1;
    t14 += v * b2;
    t15 += v * b3;
    t16 += v * b4;
    t17 += v * b5;
    t18 += v * b6;
    t19 += v * b7;
    t20 += v * b8;
    t21 += v * b9;
    t22 += v * b10;
    t23 += v * b11;
    t24 += v * b12;
    t25 += v * b13;
    t26 += v * b14;
    t27 += v * b15;
    v = a[13];
    t13 += v * b0;
    t14 += v * b1;
    t15 += v * b2;
    t16 += v * b3;
    t17 += v * b4;
    t18 += v * b5;
    t19 += v * b6;
    t20 += v * b7;
    t21 += v * b8;
    t22 += v * b9;
    t23 += v * b10;
    t24 += v * b11;
    t25 += v * b12;
    t26 += v * b13;
    t27 += v * b14;
    t28 += v * b15;
    v = a[14];
    t14 += v * b0;
    t15 += v * b1;
    t16 += v * b2;
    t17 += v * b3;
    t18 += v * b4;
    t19 += v * b5;
    t20 += v * b6;
    t21 += v * b7;
    t22 += v * b8;
    t23 += v * b9;
    t24 += v * b10;
    t25 += v * b11;
    t26 += v * b12;
    t27 += v * b13;
    t28 += v * b14;
    t29 += v * b15;
    v = a[15];
    t15 += v * b0;
    t16 += v * b1;
    t17 += v * b2;
    t18 += v * b3;
    t19 += v * b4;
    t20 += v * b5;
    t21 += v * b6;
    t22 += v * b7;
    t23 += v * b8;
    t24 += v * b9;
    t25 += v * b10;
    t26 += v * b11;
    t27 += v * b12;
    t28 += v * b13;
    t29 += v * b14;
    t30 += v * b15;
    t0 += 38 * t16;
    t1 += 38 * t17;
    t2 += 38 * t18;
    t3 += 38 * t19;
    t4 += 38 * t20;
    t5 += 38 * t21;
    t6 += 38 * t22;
    t7 += 38 * t23;
    t8 += 38 * t24;
    t9 += 38 * t25;
    t10 += 38 * t26;
    t11 += 38 * t27;
    t12 += 38 * t28;
    t13 += 38 * t29;
    t14 += 38 * t30;
    c = 1;
    v = t0 + c + 65535;
    c = Math.floor(v / 65536);
    t0 = v - c * 65536;
    v = t1 + c + 65535;
    c = Math.floor(v / 65536);
    t1 = v - c * 65536;
    v = t2 + c + 65535;
    c = Math.floor(v / 65536);
    t2 = v - c * 65536;
    v = t3 + c + 65535;
    c = Math.floor(v / 65536);
    t3 = v - c * 65536;
    v = t4 + c + 65535;
    c = Math.floor(v / 65536);
    t4 = v - c * 65536;
    v = t5 + c + 65535;
    c = Math.floor(v / 65536);
    t5 = v - c * 65536;
    v = t6 + c + 65535;
    c = Math.floor(v / 65536);
    t6 = v - c * 65536;
    v = t7 + c + 65535;
    c = Math.floor(v / 65536);
    t7 = v - c * 65536;
    v = t8 + c + 65535;
    c = Math.floor(v / 65536);
    t8 = v - c * 65536;
    v = t9 + c + 65535;
    c = Math.floor(v / 65536);
    t9 = v - c * 65536;
    v = t10 + c + 65535;
    c = Math.floor(v / 65536);
    t10 = v - c * 65536;
    v = t11 + c + 65535;
    c = Math.floor(v / 65536);
    t11 = v - c * 65536;
    v = t12 + c + 65535;
    c = Math.floor(v / 65536);
    t12 = v - c * 65536;
    v = t13 + c + 65535;
    c = Math.floor(v / 65536);
    t13 = v - c * 65536;
    v = t14 + c + 65535;
    c = Math.floor(v / 65536);
    t14 = v - c * 65536;
    v = t15 + c + 65535;
    c = Math.floor(v / 65536);
    t15 = v - c * 65536;
    t0 += c - 1 + 37 * (c - 1);
    c = 1;
    v = t0 + c + 65535;
    c = Math.floor(v / 65536);
    t0 = v - c * 65536;
    v = t1 + c + 65535;
    c = Math.floor(v / 65536);
    t1 = v - c * 65536;
    v = t2 + c + 65535;
    c = Math.floor(v / 65536);
    t2 = v - c * 65536;
    v = t3 + c + 65535;
    c = Math.floor(v / 65536);
    t3 = v - c * 65536;
    v = t4 + c + 65535;
    c = Math.floor(v / 65536);
    t4 = v - c * 65536;
    v = t5 + c + 65535;
    c = Math.floor(v / 65536);
    t5 = v - c * 65536;
    v = t6 + c + 65535;
    c = Math.floor(v / 65536);
    t6 = v - c * 65536;
    v = t7 + c + 65535;
    c = Math.floor(v / 65536);
    t7 = v - c * 65536;
    v = t8 + c + 65535;
    c = Math.floor(v / 65536);
    t8 = v - c * 65536;
    v = t9 + c + 65535;
    c = Math.floor(v / 65536);
    t9 = v - c * 65536;
    v = t10 + c + 65535;
    c = Math.floor(v / 65536);
    t10 = v - c * 65536;
    v = t11 + c + 65535;
    c = Math.floor(v / 65536);
    t11 = v - c * 65536;
    v = t12 + c + 65535;
    c = Math.floor(v / 65536);
    t12 = v - c * 65536;
    v = t13 + c + 65535;
    c = Math.floor(v / 65536);
    t13 = v - c * 65536;
    v = t14 + c + 65535;
    c = Math.floor(v / 65536);
    t14 = v - c * 65536;
    v = t15 + c + 65535;
    c = Math.floor(v / 65536);
    t15 = v - c * 65536;
    t0 += c - 1 + 37 * (c - 1);
    o[0] = t0;
    o[1] = t1;
    o[2] = t2;
    o[3] = t3;
    o[4] = t4;
    o[5] = t5;
    o[6] = t6;
    o[7] = t7;
    o[8] = t8;
    o[9] = t9;
    o[10] = t10;
    o[11] = t11;
    o[12] = t12;
    o[13] = t13;
    o[14] = t14;
    o[15] = t15;
  }
});

// node_modules/iso-random-stream/src/random.browser.js
var require_random_browser = __commonJS((exports2, module2) => {
  "use strict";
  var crypto2 = self.crypto || self.msCrypto;
  var {Buffer: Buffer2} = require_buffer();
  var MAX_BYTES = 65536;
  function oldBrowser() {
    throw new Error("Secure random number generation is not supported by this browser.\nUse Chrome, Firefox or Internet Explorer 11");
  }
  if (crypto2 && crypto2.getRandomValues) {
    module2.exports = randomBytes;
  } else {
    module2.exports = oldBrowser;
  }
  function randomBytes(size) {
    const bytes = new Uint8Array(size);
    let generated = 0;
    if (size > 0) {
      if (size > MAX_BYTES) {
        while (generated < size) {
          if (generated + MAX_BYTES > size) {
            crypto2.getRandomValues(bytes.subarray(generated, generated + (size - generated)));
            generated += size - generated;
          } else {
            crypto2.getRandomValues(bytes.subarray(generated, generated + MAX_BYTES));
            generated += MAX_BYTES;
          }
        }
      } else {
        crypto2.getRandomValues(bytes);
      }
    }
    return Buffer2.from(bytes);
  }
});

// node_modules/libp2p-crypto/src/random-bytes.js
var require_random_bytes = __commonJS((exports2, module2) => {
  "use strict";
  var randomBytes = require_random_browser();
  var errcode = require_err_code();
  module2.exports = function(length) {
    if (isNaN(length) || length <= 0) {
      throw errcode(new Error("random bytes length must be a Number bigger than 0"), "ERR_INVALID_LENGTH");
    }
    return randomBytes(length);
  };
});

// node_modules/libp2p-crypto/src/util.js
var require_util4 = __commonJS((exports2) => {
  "use strict";
  require_util3();
  require_jsbn();
  var forge = require_forge();
  var uint8ArrayFromString = require_from_string2();
  var uint8ArrayToString = require_to_string2();
  var uint8ArrayConcat = require_concat2();
  exports2.bigIntegerToUintBase64url = (num, len) => {
    let buf = Uint8Array.from(num.abs().toByteArray());
    buf = buf[0] === 0 ? buf.slice(1) : buf;
    if (len != null) {
      if (buf.length > len)
        throw new Error("byte array longer than desired length");
      buf = uint8ArrayConcat([new Uint8Array(len - buf.length), buf]);
    }
    return uint8ArrayToString(buf, "base64url");
  };
  exports2.base64urlToBigInteger = (str) => {
    const buf = exports2.base64urlToBuffer(str);
    return new forge.jsbn.BigInteger(uint8ArrayToString(buf, "base16"), 16);
  };
  exports2.base64urlToBuffer = (str, len) => {
    let buf = uint8ArrayFromString(str, "base64urlpad");
    if (len != null) {
      if (buf.length > len)
        throw new Error("byte array longer than desired length");
      buf = uint8ArrayConcat([new Uint8Array(len - buf.length), buf]);
    }
    return buf;
  };
});

// node_modules/libp2p-crypto/src/keys/rsa-utils.js
var require_rsa_utils = __commonJS((exports2) => {
  "use strict";
  require_asn1();
  require_rsa();
  var forge = require_forge();
  var {bigIntegerToUintBase64url, base64urlToBigInteger} = require_util4();
  var uint8ArrayFromString = require_from_string2();
  var uint8ArrayToString = require_to_string2();
  exports2.pkcs1ToJwk = function(bytes) {
    const asn1 = forge.asn1.fromDer(uint8ArrayToString(bytes, "ascii"));
    const privateKey = forge.pki.privateKeyFromAsn1(asn1);
    return {
      kty: "RSA",
      n: bigIntegerToUintBase64url(privateKey.n),
      e: bigIntegerToUintBase64url(privateKey.e),
      d: bigIntegerToUintBase64url(privateKey.d),
      p: bigIntegerToUintBase64url(privateKey.p),
      q: bigIntegerToUintBase64url(privateKey.q),
      dp: bigIntegerToUintBase64url(privateKey.dP),
      dq: bigIntegerToUintBase64url(privateKey.dQ),
      qi: bigIntegerToUintBase64url(privateKey.qInv),
      alg: "RS256",
      kid: "2011-04-29"
    };
  };
  exports2.jwkToPkcs1 = function(jwk) {
    const asn1 = forge.pki.privateKeyToAsn1({
      n: base64urlToBigInteger(jwk.n),
      e: base64urlToBigInteger(jwk.e),
      d: base64urlToBigInteger(jwk.d),
      p: base64urlToBigInteger(jwk.p),
      q: base64urlToBigInteger(jwk.q),
      dP: base64urlToBigInteger(jwk.dp),
      dQ: base64urlToBigInteger(jwk.dq),
      qInv: base64urlToBigInteger(jwk.qi)
    });
    return uint8ArrayFromString(forge.asn1.toDer(asn1).getBytes(), "ascii");
  };
  exports2.pkixToJwk = function(bytes) {
    const asn1 = forge.asn1.fromDer(uint8ArrayToString(bytes, "ascii"));
    const publicKey = forge.pki.publicKeyFromAsn1(asn1);
    return {
      kty: "RSA",
      n: bigIntegerToUintBase64url(publicKey.n),
      e: bigIntegerToUintBase64url(publicKey.e),
      alg: "RS256",
      kid: "2011-04-29"
    };
  };
  exports2.jwkToPkix = function(jwk) {
    const asn1 = forge.pki.publicKeyToAsn1({
      n: base64urlToBigInteger(jwk.n),
      e: base64urlToBigInteger(jwk.e)
    });
    return uint8ArrayFromString(forge.asn1.toDer(asn1).getBytes(), "ascii");
  };
});

// node_modules/libp2p-crypto/src/keys/jwk2pem.js
var require_jwk2pem = __commonJS((exports2, module2) => {
  "use strict";
  require_rsa();
  var forge = require_forge();
  var {base64urlToBigInteger} = require_util4();
  function convert(key, types) {
    return types.map((t) => base64urlToBigInteger(key[t]));
  }
  function jwk2priv(key) {
    return forge.pki.setRsaPrivateKey(...convert(key, ["n", "e", "d", "p", "q", "dp", "dq", "qi"]));
  }
  function jwk2pub(key) {
    return forge.pki.setRsaPublicKey(...convert(key, ["n", "e"]));
  }
  module2.exports = {
    jwk2pub,
    jwk2priv
  };
});

// node_modules/libp2p-crypto/src/keys/rsa-browser.js
var require_rsa_browser = __commonJS((exports2) => {
  "use strict";
  var webcrypto = require_webcrypto();
  var randomBytes = require_random_bytes();
  var uint8ArrayToString = require_to_string2();
  var uint8ArrayFromString = require_from_string2();
  exports2.utils = require_rsa_utils();
  exports2.generateKey = async function(bits) {
    const pair = await webcrypto.get().subtle.generateKey({
      name: "RSASSA-PKCS1-v1_5",
      modulusLength: bits,
      publicExponent: new Uint8Array([1, 0, 1]),
      hash: {name: "SHA-256"}
    }, true, ["sign", "verify"]);
    const keys = await exportKey(pair);
    return {
      privateKey: keys[0],
      publicKey: keys[1]
    };
  };
  exports2.unmarshalPrivateKey = async function(key) {
    const privateKey = await webcrypto.get().subtle.importKey("jwk", key, {
      name: "RSASSA-PKCS1-v1_5",
      hash: {name: "SHA-256"}
    }, true, ["sign"]);
    const pair = [
      privateKey,
      await derivePublicFromPrivate(key)
    ];
    const keys = await exportKey({
      privateKey: pair[0],
      publicKey: pair[1]
    });
    return {
      privateKey: keys[0],
      publicKey: keys[1]
    };
  };
  exports2.getRandomValues = randomBytes;
  exports2.hashAndSign = async function(key, msg) {
    const privateKey = await webcrypto.get().subtle.importKey("jwk", key, {
      name: "RSASSA-PKCS1-v1_5",
      hash: {name: "SHA-256"}
    }, false, ["sign"]);
    const sig = await webcrypto.get().subtle.sign({name: "RSASSA-PKCS1-v1_5"}, privateKey, Uint8Array.from(msg));
    return new Uint8Array(sig, sig.byteOffset, sig.byteLength);
  };
  exports2.hashAndVerify = async function(key, sig, msg) {
    const publicKey = await webcrypto.get().subtle.importKey("jwk", key, {
      name: "RSASSA-PKCS1-v1_5",
      hash: {name: "SHA-256"}
    }, false, ["verify"]);
    return webcrypto.get().subtle.verify({name: "RSASSA-PKCS1-v1_5"}, publicKey, sig, msg);
  };
  function exportKey(pair) {
    return Promise.all([
      webcrypto.get().subtle.exportKey("jwk", pair.privateKey),
      webcrypto.get().subtle.exportKey("jwk", pair.publicKey)
    ]);
  }
  function derivePublicFromPrivate(jwKey) {
    return webcrypto.get().subtle.importKey("jwk", {
      kty: jwKey.kty,
      n: jwKey.n,
      e: jwKey.e
    }, {
      name: "RSASSA-PKCS1-v1_5",
      hash: {name: "SHA-256"}
    }, true, ["verify"]);
  }
  var {jwk2pub, jwk2priv} = require_jwk2pem();
  function convertKey(key, pub, msg, handle) {
    const fkey = pub ? jwk2pub(key) : jwk2priv(key);
    const fmsg = uint8ArrayToString(Uint8Array.from(msg), "ascii");
    const fomsg = handle(fmsg, fkey);
    return uint8ArrayFromString(fomsg, "ascii");
  }
  exports2.encrypt = function(key, msg) {
    return convertKey(key, true, msg, (msg2, key2) => key2.encrypt(msg2));
  };
  exports2.decrypt = function(key, msg) {
    return convertKey(key, false, msg, (msg2, key2) => key2.decrypt(msg2));
  };
});

// node_modules/libp2p-crypto/src/keys/exporter.js
var require_exporter = __commonJS((exports2, module2) => {
  "use strict";
  var multibase = require_src4();
  var ciphers = require_aes_gcm_browser();
  module2.exports = {
    export: async function(privateKey, password) {
      const cipher = ciphers.create();
      const encryptedKey = await cipher.encrypt(privateKey, password);
      const base64 = multibase.names.base64;
      return base64.encode(encryptedKey);
    }
  };
});

// node_modules/libp2p-crypto/src/keys/rsa-class.js
var require_rsa_class = __commonJS((exports2, module2) => {
  "use strict";
  var sha = require_sha_browser();
  var protobuf = require_src8();
  var errcode = require_err_code();
  var uint8ArrayEquals = require_equals2();
  var uint8ArrayToString = require_to_string2();
  require_sha512();
  require_ed25519();
  var forge = require_forge();
  var crypto2 = require_rsa_browser();
  var pbm = protobuf(require_keys_proto());
  var exporter = require_exporter();
  var RsaPublicKey = class {
    constructor(key) {
      this._key = key;
    }
    async verify(data, sig) {
      return crypto2.hashAndVerify(this._key, sig, data);
    }
    marshal() {
      return crypto2.utils.jwkToPkix(this._key);
    }
    get bytes() {
      return pbm.PublicKey.encode({
        Type: pbm.KeyType.RSA,
        Data: this.marshal()
      });
    }
    encrypt(bytes) {
      return crypto2.encrypt(this._key, bytes);
    }
    equals(key) {
      return uint8ArrayEquals(this.bytes, key.bytes);
    }
    async hash() {
      return sha.multihashing(this.bytes, "sha2-256");
    }
  };
  var RsaPrivateKey = class {
    constructor(key, publicKey) {
      this._key = key;
      this._publicKey = publicKey;
    }
    genSecret() {
      return crypto2.getRandomValues(16);
    }
    async sign(message) {
      return crypto2.hashAndSign(this._key, message);
    }
    get public() {
      if (!this._publicKey) {
        throw errcode(new Error("public key not provided"), "ERR_PUBKEY_NOT_PROVIDED");
      }
      return new RsaPublicKey(this._publicKey);
    }
    decrypt(bytes) {
      return crypto2.decrypt(this._key, bytes);
    }
    marshal() {
      return crypto2.utils.jwkToPkcs1(this._key);
    }
    get bytes() {
      return pbm.PrivateKey.encode({
        Type: pbm.KeyType.RSA,
        Data: this.marshal()
      });
    }
    equals(key) {
      return uint8ArrayEquals(this.bytes, key.bytes);
    }
    async hash() {
      return sha.multihashing(this.bytes, "sha2-256");
    }
    async id() {
      const hash = await this.public.hash();
      return uint8ArrayToString(hash, "base58btc");
    }
    async export(password, format = "pkcs-8") {
      if (format === "pkcs-8") {
        const buffer = new forge.util.ByteBuffer(this.marshal());
        const asn1 = forge.asn1.fromDer(buffer);
        const privateKey = forge.pki.privateKeyFromAsn1(asn1);
        const options = {
          algorithm: "aes256",
          count: 1e4,
          saltSize: 128 / 8,
          prfAlgorithm: "sha512"
        };
        return forge.pki.encryptRsaPrivateKey(privateKey, password, options);
      } else if (format === "libp2p-key") {
        return exporter.export(this.bytes, password);
      } else {
        throw errcode(new Error(`export format '${format}' is not supported`), "ERR_INVALID_EXPORT_FORMAT");
      }
    }
  };
  async function unmarshalRsaPrivateKey(bytes) {
    const jwk = crypto2.utils.pkcs1ToJwk(bytes);
    const keys = await crypto2.unmarshalPrivateKey(jwk);
    return new RsaPrivateKey(keys.privateKey, keys.publicKey);
  }
  function unmarshalRsaPublicKey(bytes) {
    const jwk = crypto2.utils.pkixToJwk(bytes);
    return new RsaPublicKey(jwk);
  }
  async function fromJwk(jwk) {
    const keys = await crypto2.unmarshalPrivateKey(jwk);
    return new RsaPrivateKey(keys.privateKey, keys.publicKey);
  }
  async function generateKeyPair(bits) {
    const keys = await crypto2.generateKey(bits);
    return new RsaPrivateKey(keys.privateKey, keys.publicKey);
  }
  module2.exports = {
    RsaPublicKey,
    RsaPrivateKey,
    unmarshalRsaPublicKey,
    unmarshalRsaPrivateKey,
    generateKeyPair,
    fromJwk
  };
});

// node_modules/libp2p-crypto/src/keys/ed25519.js
var require_ed255192 = __commonJS((exports2) => {
  "use strict";
  require_ed25519();
  var forge = require_forge();
  exports2.publicKeyLength = forge.pki.ed25519.constants.PUBLIC_KEY_BYTE_LENGTH;
  exports2.privateKeyLength = forge.pki.ed25519.constants.PRIVATE_KEY_BYTE_LENGTH;
  exports2.generateKey = async function() {
    return forge.pki.ed25519.generateKeyPair();
  };
  exports2.generateKeyFromSeed = async function(seed) {
    return forge.pki.ed25519.generateKeyPair({seed});
  };
  exports2.hashAndSign = async function(key, msg) {
    return forge.pki.ed25519.sign({message: msg, privateKey: key});
  };
  exports2.hashAndVerify = async function(key, sig, msg) {
    return forge.pki.ed25519.verify({signature: sig, message: msg, publicKey: key});
  };
});

// node_modules/libp2p-crypto/src/keys/ed25519-class.js
var require_ed25519_class = __commonJS((exports2, module2) => {
  "use strict";
  var sha = require_sha_browser();
  var protobuf = require_src8();
  var multibase = require_src4();
  var errcode = require_err_code();
  var uint8ArrayEquals = require_equals2();
  var crypto2 = require_ed255192();
  var pbm = protobuf(require_keys_proto());
  var exporter = require_exporter();
  var Ed25519PublicKey = class {
    constructor(key) {
      this._key = ensureKey(key, crypto2.publicKeyLength);
    }
    async verify(data, sig) {
      return crypto2.hashAndVerify(this._key, sig, data);
    }
    marshal() {
      return this._key;
    }
    get bytes() {
      return pbm.PublicKey.encode({
        Type: pbm.KeyType.Ed25519,
        Data: this.marshal()
      });
    }
    equals(key) {
      return uint8ArrayEquals(this.bytes, key.bytes);
    }
    async hash() {
      return sha.multihashing(this.bytes, "sha2-256");
    }
  };
  var Ed25519PrivateKey = class {
    constructor(key, publicKey) {
      this._key = ensureKey(key, crypto2.privateKeyLength);
      this._publicKey = ensureKey(publicKey, crypto2.publicKeyLength);
    }
    async sign(message) {
      return crypto2.hashAndSign(this._key, message);
    }
    get public() {
      return new Ed25519PublicKey(this._publicKey);
    }
    marshal() {
      return this._key;
    }
    get bytes() {
      return pbm.PrivateKey.encode({
        Type: pbm.KeyType.Ed25519,
        Data: this.marshal()
      });
    }
    equals(key) {
      return uint8ArrayEquals(this.bytes, key.bytes);
    }
    async hash() {
      return sha.multihashing(this.bytes, "sha2-256");
    }
    async id() {
      const hash = await this.public.hash();
      return multibase.encode("base58btc", hash).toString().slice(1);
    }
    async export(password, format = "libp2p-key") {
      if (format === "libp2p-key") {
        return exporter.export(this.bytes, password);
      } else {
        throw errcode(new Error(`export format '${format}' is not supported`), "ERR_INVALID_EXPORT_FORMAT");
      }
    }
  };
  function unmarshalEd25519PrivateKey(bytes) {
    if (bytes.length > crypto2.privateKeyLength) {
      bytes = ensureKey(bytes, crypto2.privateKeyLength + crypto2.publicKeyLength);
      const privateKeyBytes2 = bytes.slice(0, crypto2.privateKeyLength);
      const publicKeyBytes2 = bytes.slice(crypto2.privateKeyLength, bytes.length);
      return new Ed25519PrivateKey(privateKeyBytes2, publicKeyBytes2);
    }
    bytes = ensureKey(bytes, crypto2.privateKeyLength);
    const privateKeyBytes = bytes.slice(0, crypto2.privateKeyLength);
    const publicKeyBytes = bytes.slice(crypto2.publicKeyLength);
    return new Ed25519PrivateKey(privateKeyBytes, publicKeyBytes);
  }
  function unmarshalEd25519PublicKey(bytes) {
    bytes = ensureKey(bytes, crypto2.publicKeyLength);
    return new Ed25519PublicKey(bytes);
  }
  async function generateKeyPair() {
    const {privateKey, publicKey} = await crypto2.generateKey();
    return new Ed25519PrivateKey(privateKey, publicKey);
  }
  async function generateKeyPairFromSeed(seed) {
    const {privateKey, publicKey} = await crypto2.generateKeyFromSeed(seed);
    return new Ed25519PrivateKey(privateKey, publicKey);
  }
  function ensureKey(key, length) {
    key = Uint8Array.from(key || []);
    if (key.length !== length) {
      throw errcode(new Error(`Key must be a Uint8Array of length ${length}, got ${key.length}`), "ERR_INVALID_KEY_TYPE");
    }
    return key;
  }
  module2.exports = {
    Ed25519PublicKey,
    Ed25519PrivateKey,
    unmarshalEd25519PrivateKey,
    unmarshalEd25519PublicKey,
    generateKeyPair,
    generateKeyPairFromSeed
  };
});

// node_modules/secp256k1/lib/index.js
var require_lib = __commonJS((exports2, module2) => {
  var errors = {
    IMPOSSIBLE_CASE: "Impossible case. Please create issue.",
    TWEAK_ADD: "The tweak was out of range or the resulted private key is invalid",
    TWEAK_MUL: "The tweak was out of range or equal to zero",
    CONTEXT_RANDOMIZE_UNKNOW: "Unknow error on context randomization",
    SECKEY_INVALID: "Private Key is invalid",
    PUBKEY_PARSE: "Public Key could not be parsed",
    PUBKEY_SERIALIZE: "Public Key serialization error",
    PUBKEY_COMBINE: "The sum of the public keys is not valid",
    SIG_PARSE: "Signature could not be parsed",
    SIGN: "The nonce generation function failed, or the private key was invalid",
    RECOVER: "Public key could not be recover",
    ECDH: "Scalar was invalid (zero or overflow)"
  };
  function assert(cond, msg) {
    if (!cond)
      throw new Error(msg);
  }
  function isUint8Array(name, value, length) {
    assert(value instanceof Uint8Array, `Expected ${name} to be an Uint8Array`);
    if (length !== void 0) {
      if (Array.isArray(length)) {
        const numbers = length.join(", ");
        const msg = `Expected ${name} to be an Uint8Array with length [${numbers}]`;
        assert(length.includes(value.length), msg);
      } else {
        const msg = `Expected ${name} to be an Uint8Array with length ${length}`;
        assert(value.length === length, msg);
      }
    }
  }
  function isCompressed(value) {
    assert(toTypeString(value) === "Boolean", "Expected compressed to be a Boolean");
  }
  function getAssertedOutput(output = (len) => new Uint8Array(len), length) {
    if (typeof output === "function")
      output = output(length);
    isUint8Array("output", output, length);
    return output;
  }
  function toTypeString(value) {
    return Object.prototype.toString.call(value).slice(8, -1);
  }
  module2.exports = (secp256k1) => {
    return {
      contextRandomize(seed) {
        assert(seed === null || seed instanceof Uint8Array, "Expected seed to be an Uint8Array or null");
        if (seed !== null)
          isUint8Array("seed", seed, 32);
        switch (secp256k1.contextRandomize(seed)) {
          case 1:
            throw new Error(errors.CONTEXT_RANDOMIZE_UNKNOW);
        }
      },
      privateKeyVerify(seckey) {
        isUint8Array("private key", seckey, 32);
        return secp256k1.privateKeyVerify(seckey) === 0;
      },
      privateKeyNegate(seckey) {
        isUint8Array("private key", seckey, 32);
        switch (secp256k1.privateKeyNegate(seckey)) {
          case 0:
            return seckey;
          case 1:
            throw new Error(errors.IMPOSSIBLE_CASE);
        }
      },
      privateKeyTweakAdd(seckey, tweak) {
        isUint8Array("private key", seckey, 32);
        isUint8Array("tweak", tweak, 32);
        switch (secp256k1.privateKeyTweakAdd(seckey, tweak)) {
          case 0:
            return seckey;
          case 1:
            throw new Error(errors.TWEAK_ADD);
        }
      },
      privateKeyTweakMul(seckey, tweak) {
        isUint8Array("private key", seckey, 32);
        isUint8Array("tweak", tweak, 32);
        switch (secp256k1.privateKeyTweakMul(seckey, tweak)) {
          case 0:
            return seckey;
          case 1:
            throw new Error(errors.TWEAK_MUL);
        }
      },
      publicKeyVerify(pubkey) {
        isUint8Array("public key", pubkey, [33, 65]);
        return secp256k1.publicKeyVerify(pubkey) === 0;
      },
      publicKeyCreate(seckey, compressed = true, output) {
        isUint8Array("private key", seckey, 32);
        isCompressed(compressed);
        output = getAssertedOutput(output, compressed ? 33 : 65);
        switch (secp256k1.publicKeyCreate(output, seckey)) {
          case 0:
            return output;
          case 1:
            throw new Error(errors.SECKEY_INVALID);
          case 2:
            throw new Error(errors.PUBKEY_SERIALIZE);
        }
      },
      publicKeyConvert(pubkey, compressed = true, output) {
        isUint8Array("public key", pubkey, [33, 65]);
        isCompressed(compressed);
        output = getAssertedOutput(output, compressed ? 33 : 65);
        switch (secp256k1.publicKeyConvert(output, pubkey)) {
          case 0:
            return output;
          case 1:
            throw new Error(errors.PUBKEY_PARSE);
          case 2:
            throw new Error(errors.PUBKEY_SERIALIZE);
        }
      },
      publicKeyNegate(pubkey, compressed = true, output) {
        isUint8Array("public key", pubkey, [33, 65]);
        isCompressed(compressed);
        output = getAssertedOutput(output, compressed ? 33 : 65);
        switch (secp256k1.publicKeyNegate(output, pubkey)) {
          case 0:
            return output;
          case 1:
            throw new Error(errors.PUBKEY_PARSE);
          case 2:
            throw new Error(errors.IMPOSSIBLE_CASE);
          case 3:
            throw new Error(errors.PUBKEY_SERIALIZE);
        }
      },
      publicKeyCombine(pubkeys, compressed = true, output) {
        assert(Array.isArray(pubkeys), "Expected public keys to be an Array");
        assert(pubkeys.length > 0, "Expected public keys array will have more than zero items");
        for (const pubkey of pubkeys) {
          isUint8Array("public key", pubkey, [33, 65]);
        }
        isCompressed(compressed);
        output = getAssertedOutput(output, compressed ? 33 : 65);
        switch (secp256k1.publicKeyCombine(output, pubkeys)) {
          case 0:
            return output;
          case 1:
            throw new Error(errors.PUBKEY_PARSE);
          case 2:
            throw new Error(errors.PUBKEY_COMBINE);
          case 3:
            throw new Error(errors.PUBKEY_SERIALIZE);
        }
      },
      publicKeyTweakAdd(pubkey, tweak, compressed = true, output) {
        isUint8Array("public key", pubkey, [33, 65]);
        isUint8Array("tweak", tweak, 32);
        isCompressed(compressed);
        output = getAssertedOutput(output, compressed ? 33 : 65);
        switch (secp256k1.publicKeyTweakAdd(output, pubkey, tweak)) {
          case 0:
            return output;
          case 1:
            throw new Error(errors.PUBKEY_PARSE);
          case 2:
            throw new Error(errors.TWEAK_ADD);
        }
      },
      publicKeyTweakMul(pubkey, tweak, compressed = true, output) {
        isUint8Array("public key", pubkey, [33, 65]);
        isUint8Array("tweak", tweak, 32);
        isCompressed(compressed);
        output = getAssertedOutput(output, compressed ? 33 : 65);
        switch (secp256k1.publicKeyTweakMul(output, pubkey, tweak)) {
          case 0:
            return output;
          case 1:
            throw new Error(errors.PUBKEY_PARSE);
          case 2:
            throw new Error(errors.TWEAK_MUL);
        }
      },
      signatureNormalize(sig) {
        isUint8Array("signature", sig, 64);
        switch (secp256k1.signatureNormalize(sig)) {
          case 0:
            return sig;
          case 1:
            throw new Error(errors.SIG_PARSE);
        }
      },
      signatureExport(sig, output) {
        isUint8Array("signature", sig, 64);
        output = getAssertedOutput(output, 72);
        const obj = {output, outputlen: 72};
        switch (secp256k1.signatureExport(obj, sig)) {
          case 0:
            return output.slice(0, obj.outputlen);
          case 1:
            throw new Error(errors.SIG_PARSE);
          case 2:
            throw new Error(errors.IMPOSSIBLE_CASE);
        }
      },
      signatureImport(sig, output) {
        isUint8Array("signature", sig);
        output = getAssertedOutput(output, 64);
        switch (secp256k1.signatureImport(output, sig)) {
          case 0:
            return output;
          case 1:
            throw new Error(errors.SIG_PARSE);
          case 2:
            throw new Error(errors.IMPOSSIBLE_CASE);
        }
      },
      ecdsaSign(msg32, seckey, options = {}, output) {
        isUint8Array("message", msg32, 32);
        isUint8Array("private key", seckey, 32);
        assert(toTypeString(options) === "Object", "Expected options to be an Object");
        if (options.data !== void 0)
          isUint8Array("options.data", options.data);
        if (options.noncefn !== void 0)
          assert(toTypeString(options.noncefn) === "Function", "Expected options.noncefn to be a Function");
        output = getAssertedOutput(output, 64);
        const obj = {signature: output, recid: null};
        switch (secp256k1.ecdsaSign(obj, msg32, seckey, options.data, options.noncefn)) {
          case 0:
            return obj;
          case 1:
            throw new Error(errors.SIGN);
          case 2:
            throw new Error(errors.IMPOSSIBLE_CASE);
        }
      },
      ecdsaVerify(sig, msg32, pubkey) {
        isUint8Array("signature", sig, 64);
        isUint8Array("message", msg32, 32);
        isUint8Array("public key", pubkey, [33, 65]);
        switch (secp256k1.ecdsaVerify(sig, msg32, pubkey)) {
          case 0:
            return true;
          case 3:
            return false;
          case 1:
            throw new Error(errors.SIG_PARSE);
          case 2:
            throw new Error(errors.PUBKEY_PARSE);
        }
      },
      ecdsaRecover(sig, recid, msg32, compressed = true, output) {
        isUint8Array("signature", sig, 64);
        assert(toTypeString(recid) === "Number" && recid >= 0 && recid <= 3, "Expected recovery id to be a Number within interval [0, 3]");
        isUint8Array("message", msg32, 32);
        isCompressed(compressed);
        output = getAssertedOutput(output, compressed ? 33 : 65);
        switch (secp256k1.ecdsaRecover(output, sig, recid, msg32)) {
          case 0:
            return output;
          case 1:
            throw new Error(errors.SIG_PARSE);
          case 2:
            throw new Error(errors.RECOVER);
          case 3:
            throw new Error(errors.IMPOSSIBLE_CASE);
        }
      },
      ecdh(pubkey, seckey, options = {}, output) {
        isUint8Array("public key", pubkey, [33, 65]);
        isUint8Array("private key", seckey, 32);
        assert(toTypeString(options) === "Object", "Expected options to be an Object");
        if (options.data !== void 0)
          isUint8Array("options.data", options.data);
        if (options.hashfn !== void 0) {
          assert(toTypeString(options.hashfn) === "Function", "Expected options.hashfn to be a Function");
          if (options.xbuf !== void 0)
            isUint8Array("options.xbuf", options.xbuf, 32);
          if (options.ybuf !== void 0)
            isUint8Array("options.ybuf", options.ybuf, 32);
          isUint8Array("output", output);
        } else {
          output = getAssertedOutput(output, 32);
        }
        switch (secp256k1.ecdh(output, pubkey, seckey, options.data, options.hashfn, options.xbuf, options.ybuf)) {
          case 0:
            return output;
          case 1:
            throw new Error(errors.PUBKEY_PARSE);
          case 2:
            throw new Error(errors.ECDH);
        }
      }
    };
  };
});

// node_modules/elliptic/package.json
var require_package = __commonJS((exports2, module2) => {
  module2.exports = {
    name: "elliptic",
    version: "6.5.3",
    description: "EC cryptography",
    main: "lib/elliptic.js",
    files: [
      "lib"
    ],
    scripts: {
      jscs: "jscs benchmarks/*.js lib/*.js lib/**/*.js lib/**/**/*.js test/index.js",
      jshint: "jscs benchmarks/*.js lib/*.js lib/**/*.js lib/**/**/*.js test/index.js",
      lint: "npm run jscs && npm run jshint",
      unit: "istanbul test _mocha --reporter=spec test/index.js",
      test: "npm run lint && npm run unit",
      version: "grunt dist && git add dist/"
    },
    repository: {
      type: "git",
      url: "git@github.com:indutny/elliptic"
    },
    keywords: [
      "EC",
      "Elliptic",
      "curve",
      "Cryptography"
    ],
    author: "Fedor Indutny <fedor@indutny.com>",
    license: "MIT",
    bugs: {
      url: "https://github.com/indutny/elliptic/issues"
    },
    homepage: "https://github.com/indutny/elliptic",
    devDependencies: {
      brfs: "^1.4.3",
      coveralls: "^3.0.8",
      grunt: "^1.0.4",
      "grunt-browserify": "^5.0.0",
      "grunt-cli": "^1.2.0",
      "grunt-contrib-connect": "^1.0.0",
      "grunt-contrib-copy": "^1.0.0",
      "grunt-contrib-uglify": "^1.0.1",
      "grunt-mocha-istanbul": "^3.0.1",
      "grunt-saucelabs": "^9.0.1",
      istanbul: "^0.4.2",
      jscs: "^3.0.7",
      jshint: "^2.10.3",
      mocha: "^6.2.2"
    },
    dependencies: {
      "bn.js": "^4.4.0",
      brorand: "^1.0.1",
      "hash.js": "^1.0.0",
      "hmac-drbg": "^1.0.0",
      inherits: "^2.0.1",
      "minimalistic-assert": "^1.0.0",
      "minimalistic-crypto-utils": "^1.0.0"
    }
  };
});

// empty:/Users/gozala/Projects/replicator/node_modules/buffer/index.js
var require_buffer2 = __commonJS(() => {
});

// node_modules/bn.js/lib/bn.js
var require_bn = __commonJS((exports2, module2) => {
  (function(module3, exports3) {
    "use strict";
    function assert(val, msg) {
      if (!val)
        throw new Error(msg || "Assertion failed");
    }
    function inherits(ctor, superCtor) {
      ctor.super_ = superCtor;
      var TempCtor = function() {
      };
      TempCtor.prototype = superCtor.prototype;
      ctor.prototype = new TempCtor();
      ctor.prototype.constructor = ctor;
    }
    function BN(number, base, endian) {
      if (BN.isBN(number)) {
        return number;
      }
      this.negative = 0;
      this.words = null;
      this.length = 0;
      this.red = null;
      if (number !== null) {
        if (base === "le" || base === "be") {
          endian = base;
          base = 10;
        }
        this._init(number || 0, base || 10, endian || "be");
      }
    }
    if (typeof module3 === "object") {
      module3.exports = BN;
    } else {
      exports3.BN = BN;
    }
    BN.BN = BN;
    BN.wordSize = 26;
    var Buffer2;
    try {
      Buffer2 = require_buffer2().Buffer;
    } catch (e) {
    }
    BN.isBN = function isBN(num) {
      if (num instanceof BN) {
        return true;
      }
      return num !== null && typeof num === "object" && num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);
    };
    BN.max = function max(left, right) {
      if (left.cmp(right) > 0)
        return left;
      return right;
    };
    BN.min = function min(left, right) {
      if (left.cmp(right) < 0)
        return left;
      return right;
    };
    BN.prototype._init = function init(number, base, endian) {
      if (typeof number === "number") {
        return this._initNumber(number, base, endian);
      }
      if (typeof number === "object") {
        return this._initArray(number, base, endian);
      }
      if (base === "hex") {
        base = 16;
      }
      assert(base === (base | 0) && base >= 2 && base <= 36);
      number = number.toString().replace(/\s+/g, "");
      var start = 0;
      if (number[0] === "-") {
        start++;
      }
      if (base === 16) {
        this._parseHex(number, start);
      } else {
        this._parseBase(number, base, start);
      }
      if (number[0] === "-") {
        this.negative = 1;
      }
      this.strip();
      if (endian !== "le")
        return;
      this._initArray(this.toArray(), base, endian);
    };
    BN.prototype._initNumber = function _initNumber(number, base, endian) {
      if (number < 0) {
        this.negative = 1;
        number = -number;
      }
      if (number < 67108864) {
        this.words = [number & 67108863];
        this.length = 1;
      } else if (number < 4503599627370496) {
        this.words = [
          number & 67108863,
          number / 67108864 & 67108863
        ];
        this.length = 2;
      } else {
        assert(number < 9007199254740992);
        this.words = [
          number & 67108863,
          number / 67108864 & 67108863,
          1
        ];
        this.length = 3;
      }
      if (endian !== "le")
        return;
      this._initArray(this.toArray(), base, endian);
    };
    BN.prototype._initArray = function _initArray(number, base, endian) {
      assert(typeof number.length === "number");
      if (number.length <= 0) {
        this.words = [0];
        this.length = 1;
        return this;
      }
      this.length = Math.ceil(number.length / 3);
      this.words = new Array(this.length);
      for (var i = 0; i < this.length; i++) {
        this.words[i] = 0;
      }
      var j, w;
      var off = 0;
      if (endian === "be") {
        for (i = number.length - 1, j = 0; i >= 0; i -= 3) {
          w = number[i] | number[i - 1] << 8 | number[i - 2] << 16;
          this.words[j] |= w << off & 67108863;
          this.words[j + 1] = w >>> 26 - off & 67108863;
          off += 24;
          if (off >= 26) {
            off -= 26;
            j++;
          }
        }
      } else if (endian === "le") {
        for (i = 0, j = 0; i < number.length; i += 3) {
          w = number[i] | number[i + 1] << 8 | number[i + 2] << 16;
          this.words[j] |= w << off & 67108863;
          this.words[j + 1] = w >>> 26 - off & 67108863;
          off += 24;
          if (off >= 26) {
            off -= 26;
            j++;
          }
        }
      }
      return this.strip();
    };
    function parseHex(str, start, end) {
      var r = 0;
      var len = Math.min(str.length, end);
      for (var i = start; i < len; i++) {
        var c = str.charCodeAt(i) - 48;
        r <<= 4;
        if (c >= 49 && c <= 54) {
          r |= c - 49 + 10;
        } else if (c >= 17 && c <= 22) {
          r |= c - 17 + 10;
        } else {
          r |= c & 15;
        }
      }
      return r;
    }
    BN.prototype._parseHex = function _parseHex(number, start) {
      this.length = Math.ceil((number.length - start) / 6);
      this.words = new Array(this.length);
      for (var i = 0; i < this.length; i++) {
        this.words[i] = 0;
      }
      var j, w;
      var off = 0;
      for (i = number.length - 6, j = 0; i >= start; i -= 6) {
        w = parseHex(number, i, i + 6);
        this.words[j] |= w << off & 67108863;
        this.words[j + 1] |= w >>> 26 - off & 4194303;
        off += 24;
        if (off >= 26) {
          off -= 26;
          j++;
        }
      }
      if (i + 6 !== start) {
        w = parseHex(number, start, i + 6);
        this.words[j] |= w << off & 67108863;
        this.words[j + 1] |= w >>> 26 - off & 4194303;
      }
      this.strip();
    };
    function parseBase(str, start, end, mul) {
      var r = 0;
      var len = Math.min(str.length, end);
      for (var i = start; i < len; i++) {
        var c = str.charCodeAt(i) - 48;
        r *= mul;
        if (c >= 49) {
          r += c - 49 + 10;
        } else if (c >= 17) {
          r += c - 17 + 10;
        } else {
          r += c;
        }
      }
      return r;
    }
    BN.prototype._parseBase = function _parseBase(number, base, start) {
      this.words = [0];
      this.length = 1;
      for (var limbLen = 0, limbPow = 1; limbPow <= 67108863; limbPow *= base) {
        limbLen++;
      }
      limbLen--;
      limbPow = limbPow / base | 0;
      var total = number.length - start;
      var mod = total % limbLen;
      var end = Math.min(total, total - mod) + start;
      var word = 0;
      for (var i = start; i < end; i += limbLen) {
        word = parseBase(number, i, i + limbLen, base);
        this.imuln(limbPow);
        if (this.words[0] + word < 67108864) {
          this.words[0] += word;
        } else {
          this._iaddn(word);
        }
      }
      if (mod !== 0) {
        var pow = 1;
        word = parseBase(number, i, number.length, base);
        for (i = 0; i < mod; i++) {
          pow *= base;
        }
        this.imuln(pow);
        if (this.words[0] + word < 67108864) {
          this.words[0] += word;
        } else {
          this._iaddn(word);
        }
      }
    };
    BN.prototype.copy = function copy(dest) {
      dest.words = new Array(this.length);
      for (var i = 0; i < this.length; i++) {
        dest.words[i] = this.words[i];
      }
      dest.length = this.length;
      dest.negative = this.negative;
      dest.red = this.red;
    };
    BN.prototype.clone = function clone() {
      var r = new BN(null);
      this.copy(r);
      return r;
    };
    BN.prototype._expand = function _expand(size) {
      while (this.length < size) {
        this.words[this.length++] = 0;
      }
      return this;
    };
    BN.prototype.strip = function strip() {
      while (this.length > 1 && this.words[this.length - 1] === 0) {
        this.length--;
      }
      return this._normSign();
    };
    BN.prototype._normSign = function _normSign() {
      if (this.length === 1 && this.words[0] === 0) {
        this.negative = 0;
      }
      return this;
    };
    BN.prototype.inspect = function inspect() {
      return (this.red ? "<BN-R: " : "<BN: ") + this.toString(16) + ">";
    };
    var zeros = [
      "",
      "0",
      "00",
      "000",
      "0000",
      "00000",
      "000000",
      "0000000",
      "00000000",
      "000000000",
      "0000000000",
      "00000000000",
      "000000000000",
      "0000000000000",
      "00000000000000",
      "000000000000000",
      "0000000000000000",
      "00000000000000000",
      "000000000000000000",
      "0000000000000000000",
      "00000000000000000000",
      "000000000000000000000",
      "0000000000000000000000",
      "00000000000000000000000",
      "000000000000000000000000",
      "0000000000000000000000000"
    ];
    var groupSizes = [
      0,
      0,
      25,
      16,
      12,
      11,
      10,
      9,
      8,
      8,
      7,
      7,
      7,
      7,
      6,
      6,
      6,
      6,
      6,
      6,
      6,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5,
      5
    ];
    var groupBases = [
      0,
      0,
      33554432,
      43046721,
      16777216,
      48828125,
      60466176,
      40353607,
      16777216,
      43046721,
      1e7,
      19487171,
      35831808,
      62748517,
      7529536,
      11390625,
      16777216,
      24137569,
      34012224,
      47045881,
      64e6,
      4084101,
      5153632,
      6436343,
      7962624,
      9765625,
      11881376,
      14348907,
      17210368,
      20511149,
      243e5,
      28629151,
      33554432,
      39135393,
      45435424,
      52521875,
      60466176
    ];
    BN.prototype.toString = function toString(base, padding) {
      base = base || 10;
      padding = padding | 0 || 1;
      var out;
      if (base === 16 || base === "hex") {
        out = "";
        var off = 0;
        var carry = 0;
        for (var i = 0; i < this.length; i++) {
          var w = this.words[i];
          var word = ((w << off | carry) & 16777215).toString(16);
          carry = w >>> 24 - off & 16777215;
          if (carry !== 0 || i !== this.length - 1) {
            out = zeros[6 - word.length] + word + out;
          } else {
            out = word + out;
          }
          off += 2;
          if (off >= 26) {
            off -= 26;
            i--;
          }
        }
        if (carry !== 0) {
          out = carry.toString(16) + out;
        }
        while (out.length % padding !== 0) {
          out = "0" + out;
        }
        if (this.negative !== 0) {
          out = "-" + out;
        }
        return out;
      }
      if (base === (base | 0) && base >= 2 && base <= 36) {
        var groupSize = groupSizes[base];
        var groupBase = groupBases[base];
        out = "";
        var c = this.clone();
        c.negative = 0;
        while (!c.isZero()) {
          var r = c.modn(groupBase).toString(base);
          c = c.idivn(groupBase);
          if (!c.isZero()) {
            out = zeros[groupSize - r.length] + r + out;
          } else {
            out = r + out;
          }
        }
        if (this.isZero()) {
          out = "0" + out;
        }
        while (out.length % padding !== 0) {
          out = "0" + out;
        }
        if (this.negative !== 0) {
          out = "-" + out;
        }
        return out;
      }
      assert(false, "Base should be between 2 and 36");
    };
    BN.prototype.toNumber = function toNumber() {
      var ret = this.words[0];
      if (this.length === 2) {
        ret += this.words[1] * 67108864;
      } else if (this.length === 3 && this.words[2] === 1) {
        ret += 4503599627370496 + this.words[1] * 67108864;
      } else if (this.length > 2) {
        assert(false, "Number can only safely store up to 53 bits");
      }
      return this.negative !== 0 ? -ret : ret;
    };
    BN.prototype.toJSON = function toJSON() {
      return this.toString(16);
    };
    BN.prototype.toBuffer = function toBuffer(endian, length) {
      assert(typeof Buffer2 !== "undefined");
      return this.toArrayLike(Buffer2, endian, length);
    };
    BN.prototype.toArray = function toArray(endian, length) {
      return this.toArrayLike(Array, endian, length);
    };
    BN.prototype.toArrayLike = function toArrayLike(ArrayType, endian, length) {
      var byteLength = this.byteLength();
      var reqLength = length || Math.max(1, byteLength);
      assert(byteLength <= reqLength, "byte array longer than desired length");
      assert(reqLength > 0, "Requested array length <= 0");
      this.strip();
      var littleEndian = endian === "le";
      var res = new ArrayType(reqLength);
      var b, i;
      var q = this.clone();
      if (!littleEndian) {
        for (i = 0; i < reqLength - byteLength; i++) {
          res[i] = 0;
        }
        for (i = 0; !q.isZero(); i++) {
          b = q.andln(255);
          q.iushrn(8);
          res[reqLength - i - 1] = b;
        }
      } else {
        for (i = 0; !q.isZero(); i++) {
          b = q.andln(255);
          q.iushrn(8);
          res[i] = b;
        }
        for (; i < reqLength; i++) {
          res[i] = 0;
        }
      }
      return res;
    };
    if (Math.clz32) {
      BN.prototype._countBits = function _countBits(w) {
        return 32 - Math.clz32(w);
      };
    } else {
      BN.prototype._countBits = function _countBits(w) {
        var t = w;
        var r = 0;
        if (t >= 4096) {
          r += 13;
          t >>>= 13;
        }
        if (t >= 64) {
          r += 7;
          t >>>= 7;
        }
        if (t >= 8) {
          r += 4;
          t >>>= 4;
        }
        if (t >= 2) {
          r += 2;
          t >>>= 2;
        }
        return r + t;
      };
    }
    BN.prototype._zeroBits = function _zeroBits(w) {
      if (w === 0)
        return 26;
      var t = w;
      var r = 0;
      if ((t & 8191) === 0) {
        r += 13;
        t >>>= 13;
      }
      if ((t & 127) === 0) {
        r += 7;
        t >>>= 7;
      }
      if ((t & 15) === 0) {
        r += 4;
        t >>>= 4;
      }
      if ((t & 3) === 0) {
        r += 2;
        t >>>= 2;
      }
      if ((t & 1) === 0) {
        r++;
      }
      return r;
    };
    BN.prototype.bitLength = function bitLength() {
      var w = this.words[this.length - 1];
      var hi = this._countBits(w);
      return (this.length - 1) * 26 + hi;
    };
    function toBitArray(num) {
      var w = new Array(num.bitLength());
      for (var bit = 0; bit < w.length; bit++) {
        var off = bit / 26 | 0;
        var wbit = bit % 26;
        w[bit] = (num.words[off] & 1 << wbit) >>> wbit;
      }
      return w;
    }
    BN.prototype.zeroBits = function zeroBits() {
      if (this.isZero())
        return 0;
      var r = 0;
      for (var i = 0; i < this.length; i++) {
        var b = this._zeroBits(this.words[i]);
        r += b;
        if (b !== 26)
          break;
      }
      return r;
    };
    BN.prototype.byteLength = function byteLength() {
      return Math.ceil(this.bitLength() / 8);
    };
    BN.prototype.toTwos = function toTwos(width) {
      if (this.negative !== 0) {
        return this.abs().inotn(width).iaddn(1);
      }
      return this.clone();
    };
    BN.prototype.fromTwos = function fromTwos(width) {
      if (this.testn(width - 1)) {
        return this.notn(width).iaddn(1).ineg();
      }
      return this.clone();
    };
    BN.prototype.isNeg = function isNeg() {
      return this.negative !== 0;
    };
    BN.prototype.neg = function neg() {
      return this.clone().ineg();
    };
    BN.prototype.ineg = function ineg() {
      if (!this.isZero()) {
        this.negative ^= 1;
      }
      return this;
    };
    BN.prototype.iuor = function iuor(num) {
      while (this.length < num.length) {
        this.words[this.length++] = 0;
      }
      for (var i = 0; i < num.length; i++) {
        this.words[i] = this.words[i] | num.words[i];
      }
      return this.strip();
    };
    BN.prototype.ior = function ior(num) {
      assert((this.negative | num.negative) === 0);
      return this.iuor(num);
    };
    BN.prototype.or = function or(num) {
      if (this.length > num.length)
        return this.clone().ior(num);
      return num.clone().ior(this);
    };
    BN.prototype.uor = function uor(num) {
      if (this.length > num.length)
        return this.clone().iuor(num);
      return num.clone().iuor(this);
    };
    BN.prototype.iuand = function iuand(num) {
      var b;
      if (this.length > num.length) {
        b = num;
      } else {
        b = this;
      }
      for (var i = 0; i < b.length; i++) {
        this.words[i] = this.words[i] & num.words[i];
      }
      this.length = b.length;
      return this.strip();
    };
    BN.prototype.iand = function iand(num) {
      assert((this.negative | num.negative) === 0);
      return this.iuand(num);
    };
    BN.prototype.and = function and(num) {
      if (this.length > num.length)
        return this.clone().iand(num);
      return num.clone().iand(this);
    };
    BN.prototype.uand = function uand(num) {
      if (this.length > num.length)
        return this.clone().iuand(num);
      return num.clone().iuand(this);
    };
    BN.prototype.iuxor = function iuxor(num) {
      var a;
      var b;
      if (this.length > num.length) {
        a = this;
        b = num;
      } else {
        a = num;
        b = this;
      }
      for (var i = 0; i < b.length; i++) {
        this.words[i] = a.words[i] ^ b.words[i];
      }
      if (this !== a) {
        for (; i < a.length; i++) {
          this.words[i] = a.words[i];
        }
      }
      this.length = a.length;
      return this.strip();
    };
    BN.prototype.ixor = function ixor(num) {
      assert((this.negative | num.negative) === 0);
      return this.iuxor(num);
    };
    BN.prototype.xor = function xor(num) {
      if (this.length > num.length)
        return this.clone().ixor(num);
      return num.clone().ixor(this);
    };
    BN.prototype.uxor = function uxor(num) {
      if (this.length > num.length)
        return this.clone().iuxor(num);
      return num.clone().iuxor(this);
    };
    BN.prototype.inotn = function inotn(width) {
      assert(typeof width === "number" && width >= 0);
      var bytesNeeded = Math.ceil(width / 26) | 0;
      var bitsLeft = width % 26;
      this._expand(bytesNeeded);
      if (bitsLeft > 0) {
        bytesNeeded--;
      }
      for (var i = 0; i < bytesNeeded; i++) {
        this.words[i] = ~this.words[i] & 67108863;
      }
      if (bitsLeft > 0) {
        this.words[i] = ~this.words[i] & 67108863 >> 26 - bitsLeft;
      }
      return this.strip();
    };
    BN.prototype.notn = function notn(width) {
      return this.clone().inotn(width);
    };
    BN.prototype.setn = function setn(bit, val) {
      assert(typeof bit === "number" && bit >= 0);
      var off = bit / 26 | 0;
      var wbit = bit % 26;
      this._expand(off + 1);
      if (val) {
        this.words[off] = this.words[off] | 1 << wbit;
      } else {
        this.words[off] = this.words[off] & ~(1 << wbit);
      }
      return this.strip();
    };
    BN.prototype.iadd = function iadd(num) {
      var r;
      if (this.negative !== 0 && num.negative === 0) {
        this.negative = 0;
        r = this.isub(num);
        this.negative ^= 1;
        return this._normSign();
      } else if (this.negative === 0 && num.negative !== 0) {
        num.negative = 0;
        r = this.isub(num);
        num.negative = 1;
        return r._normSign();
      }
      var a, b;
      if (this.length > num.length) {
        a = this;
        b = num;
      } else {
        a = num;
        b = this;
      }
      var carry = 0;
      for (var i = 0; i < b.length; i++) {
        r = (a.words[i] | 0) + (b.words[i] | 0) + carry;
        this.words[i] = r & 67108863;
        carry = r >>> 26;
      }
      for (; carry !== 0 && i < a.length; i++) {
        r = (a.words[i] | 0) + carry;
        this.words[i] = r & 67108863;
        carry = r >>> 26;
      }
      this.length = a.length;
      if (carry !== 0) {
        this.words[this.length] = carry;
        this.length++;
      } else if (a !== this) {
        for (; i < a.length; i++) {
          this.words[i] = a.words[i];
        }
      }
      return this;
    };
    BN.prototype.add = function add(num) {
      var res;
      if (num.negative !== 0 && this.negative === 0) {
        num.negative = 0;
        res = this.sub(num);
        num.negative ^= 1;
        return res;
      } else if (num.negative === 0 && this.negative !== 0) {
        this.negative = 0;
        res = num.sub(this);
        this.negative = 1;
        return res;
      }
      if (this.length > num.length)
        return this.clone().iadd(num);
      return num.clone().iadd(this);
    };
    BN.prototype.isub = function isub(num) {
      if (num.negative !== 0) {
        num.negative = 0;
        var r = this.iadd(num);
        num.negative = 1;
        return r._normSign();
      } else if (this.negative !== 0) {
        this.negative = 0;
        this.iadd(num);
        this.negative = 1;
        return this._normSign();
      }
      var cmp = this.cmp(num);
      if (cmp === 0) {
        this.negative = 0;
        this.length = 1;
        this.words[0] = 0;
        return this;
      }
      var a, b;
      if (cmp > 0) {
        a = this;
        b = num;
      } else {
        a = num;
        b = this;
      }
      var carry = 0;
      for (var i = 0; i < b.length; i++) {
        r = (a.words[i] | 0) - (b.words[i] | 0) + carry;
        carry = r >> 26;
        this.words[i] = r & 67108863;
      }
      for (; carry !== 0 && i < a.length; i++) {
        r = (a.words[i] | 0) + carry;
        carry = r >> 26;
        this.words[i] = r & 67108863;
      }
      if (carry === 0 && i < a.length && a !== this) {
        for (; i < a.length; i++) {
          this.words[i] = a.words[i];
        }
      }
      this.length = Math.max(this.length, i);
      if (a !== this) {
        this.negative = 1;
      }
      return this.strip();
    };
    BN.prototype.sub = function sub(num) {
      return this.clone().isub(num);
    };
    function smallMulTo(self2, num, out) {
      out.negative = num.negative ^ self2.negative;
      var len = self2.length + num.length | 0;
      out.length = len;
      len = len - 1 | 0;
      var a = self2.words[0] | 0;
      var b = num.words[0] | 0;
      var r = a * b;
      var lo = r & 67108863;
      var carry = r / 67108864 | 0;
      out.words[0] = lo;
      for (var k = 1; k < len; k++) {
        var ncarry = carry >>> 26;
        var rword = carry & 67108863;
        var maxJ = Math.min(k, num.length - 1);
        for (var j = Math.max(0, k - self2.length + 1); j <= maxJ; j++) {
          var i = k - j | 0;
          a = self2.words[i] | 0;
          b = num.words[j] | 0;
          r = a * b + rword;
          ncarry += r / 67108864 | 0;
          rword = r & 67108863;
        }
        out.words[k] = rword | 0;
        carry = ncarry | 0;
      }
      if (carry !== 0) {
        out.words[k] = carry | 0;
      } else {
        out.length--;
      }
      return out.strip();
    }
    var comb10MulTo = function comb10MulTo2(self2, num, out) {
      var a = self2.words;
      var b = num.words;
      var o = out.words;
      var c = 0;
      var lo;
      var mid;
      var hi;
      var a0 = a[0] | 0;
      var al0 = a0 & 8191;
      var ah0 = a0 >>> 13;
      var a1 = a[1] | 0;
      var al1 = a1 & 8191;
      var ah1 = a1 >>> 13;
      var a2 = a[2] | 0;
      var al2 = a2 & 8191;
      var ah2 = a2 >>> 13;
      var a3 = a[3] | 0;
      var al3 = a3 & 8191;
      var ah3 = a3 >>> 13;
      var a4 = a[4] | 0;
      var al4 = a4 & 8191;
      var ah4 = a4 >>> 13;
      var a5 = a[5] | 0;
      var al5 = a5 & 8191;
      var ah5 = a5 >>> 13;
      var a6 = a[6] | 0;
      var al6 = a6 & 8191;
      var ah6 = a6 >>> 13;
      var a7 = a[7] | 0;
      var al7 = a7 & 8191;
      var ah7 = a7 >>> 13;
      var a8 = a[8] | 0;
      var al8 = a8 & 8191;
      var ah8 = a8 >>> 13;
      var a9 = a[9] | 0;
      var al9 = a9 & 8191;
      var ah9 = a9 >>> 13;
      var b0 = b[0] | 0;
      var bl0 = b0 & 8191;
      var bh0 = b0 >>> 13;
      var b1 = b[1] | 0;
      var bl1 = b1 & 8191;
      var bh1 = b1 >>> 13;
      var b2 = b[2] | 0;
      var bl2 = b2 & 8191;
      var bh2 = b2 >>> 13;
      var b3 = b[3] | 0;
      var bl3 = b3 & 8191;
      var bh3 = b3 >>> 13;
      var b4 = b[4] | 0;
      var bl4 = b4 & 8191;
      var bh4 = b4 >>> 13;
      var b5 = b[5] | 0;
      var bl5 = b5 & 8191;
      var bh5 = b5 >>> 13;
      var b6 = b[6] | 0;
      var bl6 = b6 & 8191;
      var bh6 = b6 >>> 13;
      var b7 = b[7] | 0;
      var bl7 = b7 & 8191;
      var bh7 = b7 >>> 13;
      var b8 = b[8] | 0;
      var bl8 = b8 & 8191;
      var bh8 = b8 >>> 13;
      var b9 = b[9] | 0;
      var bl9 = b9 & 8191;
      var bh9 = b9 >>> 13;
      out.negative = self2.negative ^ num.negative;
      out.length = 19;
      lo = Math.imul(al0, bl0);
      mid = Math.imul(al0, bh0);
      mid = mid + Math.imul(ah0, bl0) | 0;
      hi = Math.imul(ah0, bh0);
      var w0 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w0 >>> 26) | 0;
      w0 &= 67108863;
      lo = Math.imul(al1, bl0);
      mid = Math.imul(al1, bh0);
      mid = mid + Math.imul(ah1, bl0) | 0;
      hi = Math.imul(ah1, bh0);
      lo = lo + Math.imul(al0, bl1) | 0;
      mid = mid + Math.imul(al0, bh1) | 0;
      mid = mid + Math.imul(ah0, bl1) | 0;
      hi = hi + Math.imul(ah0, bh1) | 0;
      var w1 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w1 >>> 26) | 0;
      w1 &= 67108863;
      lo = Math.imul(al2, bl0);
      mid = Math.imul(al2, bh0);
      mid = mid + Math.imul(ah2, bl0) | 0;
      hi = Math.imul(ah2, bh0);
      lo = lo + Math.imul(al1, bl1) | 0;
      mid = mid + Math.imul(al1, bh1) | 0;
      mid = mid + Math.imul(ah1, bl1) | 0;
      hi = hi + Math.imul(ah1, bh1) | 0;
      lo = lo + Math.imul(al0, bl2) | 0;
      mid = mid + Math.imul(al0, bh2) | 0;
      mid = mid + Math.imul(ah0, bl2) | 0;
      hi = hi + Math.imul(ah0, bh2) | 0;
      var w2 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w2 >>> 26) | 0;
      w2 &= 67108863;
      lo = Math.imul(al3, bl0);
      mid = Math.imul(al3, bh0);
      mid = mid + Math.imul(ah3, bl0) | 0;
      hi = Math.imul(ah3, bh0);
      lo = lo + Math.imul(al2, bl1) | 0;
      mid = mid + Math.imul(al2, bh1) | 0;
      mid = mid + Math.imul(ah2, bl1) | 0;
      hi = hi + Math.imul(ah2, bh1) | 0;
      lo = lo + Math.imul(al1, bl2) | 0;
      mid = mid + Math.imul(al1, bh2) | 0;
      mid = mid + Math.imul(ah1, bl2) | 0;
      hi = hi + Math.imul(ah1, bh2) | 0;
      lo = lo + Math.imul(al0, bl3) | 0;
      mid = mid + Math.imul(al0, bh3) | 0;
      mid = mid + Math.imul(ah0, bl3) | 0;
      hi = hi + Math.imul(ah0, bh3) | 0;
      var w3 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w3 >>> 26) | 0;
      w3 &= 67108863;
      lo = Math.imul(al4, bl0);
      mid = Math.imul(al4, bh0);
      mid = mid + Math.imul(ah4, bl0) | 0;
      hi = Math.imul(ah4, bh0);
      lo = lo + Math.imul(al3, bl1) | 0;
      mid = mid + Math.imul(al3, bh1) | 0;
      mid = mid + Math.imul(ah3, bl1) | 0;
      hi = hi + Math.imul(ah3, bh1) | 0;
      lo = lo + Math.imul(al2, bl2) | 0;
      mid = mid + Math.imul(al2, bh2) | 0;
      mid = mid + Math.imul(ah2, bl2) | 0;
      hi = hi + Math.imul(ah2, bh2) | 0;
      lo = lo + Math.imul(al1, bl3) | 0;
      mid = mid + Math.imul(al1, bh3) | 0;
      mid = mid + Math.imul(ah1, bl3) | 0;
      hi = hi + Math.imul(ah1, bh3) | 0;
      lo = lo + Math.imul(al0, bl4) | 0;
      mid = mid + Math.imul(al0, bh4) | 0;
      mid = mid + Math.imul(ah0, bl4) | 0;
      hi = hi + Math.imul(ah0, bh4) | 0;
      var w4 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w4 >>> 26) | 0;
      w4 &= 67108863;
      lo = Math.imul(al5, bl0);
      mid = Math.imul(al5, bh0);
      mid = mid + Math.imul(ah5, bl0) | 0;
      hi = Math.imul(ah5, bh0);
      lo = lo + Math.imul(al4, bl1) | 0;
      mid = mid + Math.imul(al4, bh1) | 0;
      mid = mid + Math.imul(ah4, bl1) | 0;
      hi = hi + Math.imul(ah4, bh1) | 0;
      lo = lo + Math.imul(al3, bl2) | 0;
      mid = mid + Math.imul(al3, bh2) | 0;
      mid = mid + Math.imul(ah3, bl2) | 0;
      hi = hi + Math.imul(ah3, bh2) | 0;
      lo = lo + Math.imul(al2, bl3) | 0;
      mid = mid + Math.imul(al2, bh3) | 0;
      mid = mid + Math.imul(ah2, bl3) | 0;
      hi = hi + Math.imul(ah2, bh3) | 0;
      lo = lo + Math.imul(al1, bl4) | 0;
      mid = mid + Math.imul(al1, bh4) | 0;
      mid = mid + Math.imul(ah1, bl4) | 0;
      hi = hi + Math.imul(ah1, bh4) | 0;
      lo = lo + Math.imul(al0, bl5) | 0;
      mid = mid + Math.imul(al0, bh5) | 0;
      mid = mid + Math.imul(ah0, bl5) | 0;
      hi = hi + Math.imul(ah0, bh5) | 0;
      var w5 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w5 >>> 26) | 0;
      w5 &= 67108863;
      lo = Math.imul(al6, bl0);
      mid = Math.imul(al6, bh0);
      mid = mid + Math.imul(ah6, bl0) | 0;
      hi = Math.imul(ah6, bh0);
      lo = lo + Math.imul(al5, bl1) | 0;
      mid = mid + Math.imul(al5, bh1) | 0;
      mid = mid + Math.imul(ah5, bl1) | 0;
      hi = hi + Math.imul(ah5, bh1) | 0;
      lo = lo + Math.imul(al4, bl2) | 0;
      mid = mid + Math.imul(al4, bh2) | 0;
      mid = mid + Math.imul(ah4, bl2) | 0;
      hi = hi + Math.imul(ah4, bh2) | 0;
      lo = lo + Math.imul(al3, bl3) | 0;
      mid = mid + Math.imul(al3, bh3) | 0;
      mid = mid + Math.imul(ah3, bl3) | 0;
      hi = hi + Math.imul(ah3, bh3) | 0;
      lo = lo + Math.imul(al2, bl4) | 0;
      mid = mid + Math.imul(al2, bh4) | 0;
      mid = mid + Math.imul(ah2, bl4) | 0;
      hi = hi + Math.imul(ah2, bh4) | 0;
      lo = lo + Math.imul(al1, bl5) | 0;
      mid = mid + Math.imul(al1, bh5) | 0;
      mid = mid + Math.imul(ah1, bl5) | 0;
      hi = hi + Math.imul(ah1, bh5) | 0;
      lo = lo + Math.imul(al0, bl6) | 0;
      mid = mid + Math.imul(al0, bh6) | 0;
      mid = mid + Math.imul(ah0, bl6) | 0;
      hi = hi + Math.imul(ah0, bh6) | 0;
      var w6 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w6 >>> 26) | 0;
      w6 &= 67108863;
      lo = Math.imul(al7, bl0);
      mid = Math.imul(al7, bh0);
      mid = mid + Math.imul(ah7, bl0) | 0;
      hi = Math.imul(ah7, bh0);
      lo = lo + Math.imul(al6, bl1) | 0;
      mid = mid + Math.imul(al6, bh1) | 0;
      mid = mid + Math.imul(ah6, bl1) | 0;
      hi = hi + Math.imul(ah6, bh1) | 0;
      lo = lo + Math.imul(al5, bl2) | 0;
      mid = mid + Math.imul(al5, bh2) | 0;
      mid = mid + Math.imul(ah5, bl2) | 0;
      hi = hi + Math.imul(ah5, bh2) | 0;
      lo = lo + Math.imul(al4, bl3) | 0;
      mid = mid + Math.imul(al4, bh3) | 0;
      mid = mid + Math.imul(ah4, bl3) | 0;
      hi = hi + Math.imul(ah4, bh3) | 0;
      lo = lo + Math.imul(al3, bl4) | 0;
      mid = mid + Math.imul(al3, bh4) | 0;
      mid = mid + Math.imul(ah3, bl4) | 0;
      hi = hi + Math.imul(ah3, bh4) | 0;
      lo = lo + Math.imul(al2, bl5) | 0;
      mid = mid + Math.imul(al2, bh5) | 0;
      mid = mid + Math.imul(ah2, bl5) | 0;
      hi = hi + Math.imul(ah2, bh5) | 0;
      lo = lo + Math.imul(al1, bl6) | 0;
      mid = mid + Math.imul(al1, bh6) | 0;
      mid = mid + Math.imul(ah1, bl6) | 0;
      hi = hi + Math.imul(ah1, bh6) | 0;
      lo = lo + Math.imul(al0, bl7) | 0;
      mid = mid + Math.imul(al0, bh7) | 0;
      mid = mid + Math.imul(ah0, bl7) | 0;
      hi = hi + Math.imul(ah0, bh7) | 0;
      var w7 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w7 >>> 26) | 0;
      w7 &= 67108863;
      lo = Math.imul(al8, bl0);
      mid = Math.imul(al8, bh0);
      mid = mid + Math.imul(ah8, bl0) | 0;
      hi = Math.imul(ah8, bh0);
      lo = lo + Math.imul(al7, bl1) | 0;
      mid = mid + Math.imul(al7, bh1) | 0;
      mid = mid + Math.imul(ah7, bl1) | 0;
      hi = hi + Math.imul(ah7, bh1) | 0;
      lo = lo + Math.imul(al6, bl2) | 0;
      mid = mid + Math.imul(al6, bh2) | 0;
      mid = mid + Math.imul(ah6, bl2) | 0;
      hi = hi + Math.imul(ah6, bh2) | 0;
      lo = lo + Math.imul(al5, bl3) | 0;
      mid = mid + Math.imul(al5, bh3) | 0;
      mid = mid + Math.imul(ah5, bl3) | 0;
      hi = hi + Math.imul(ah5, bh3) | 0;
      lo = lo + Math.imul(al4, bl4) | 0;
      mid = mid + Math.imul(al4, bh4) | 0;
      mid = mid + Math.imul(ah4, bl4) | 0;
      hi = hi + Math.imul(ah4, bh4) | 0;
      lo = lo + Math.imul(al3, bl5) | 0;
      mid = mid + Math.imul(al3, bh5) | 0;
      mid = mid + Math.imul(ah3, bl5) | 0;
      hi = hi + Math.imul(ah3, bh5) | 0;
      lo = lo + Math.imul(al2, bl6) | 0;
      mid = mid + Math.imul(al2, bh6) | 0;
      mid = mid + Math.imul(ah2, bl6) | 0;
      hi = hi + Math.imul(ah2, bh6) | 0;
      lo = lo + Math.imul(al1, bl7) | 0;
      mid = mid + Math.imul(al1, bh7) | 0;
      mid = mid + Math.imul(ah1, bl7) | 0;
      hi = hi + Math.imul(ah1, bh7) | 0;
      lo = lo + Math.imul(al0, bl8) | 0;
      mid = mid + Math.imul(al0, bh8) | 0;
      mid = mid + Math.imul(ah0, bl8) | 0;
      hi = hi + Math.imul(ah0, bh8) | 0;
      var w8 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w8 >>> 26) | 0;
      w8 &= 67108863;
      lo = Math.imul(al9, bl0);
      mid = Math.imul(al9, bh0);
      mid = mid + Math.imul(ah9, bl0) | 0;
      hi = Math.imul(ah9, bh0);
      lo = lo + Math.imul(al8, bl1) | 0;
      mid = mid + Math.imul(al8, bh1) | 0;
      mid = mid + Math.imul(ah8, bl1) | 0;
      hi = hi + Math.imul(ah8, bh1) | 0;
      lo = lo + Math.imul(al7, bl2) | 0;
      mid = mid + Math.imul(al7, bh2) | 0;
      mid = mid + Math.imul(ah7, bl2) | 0;
      hi = hi + Math.imul(ah7, bh2) | 0;
      lo = lo + Math.imul(al6, bl3) | 0;
      mid = mid + Math.imul(al6, bh3) | 0;
      mid = mid + Math.imul(ah6, bl3) | 0;
      hi = hi + Math.imul(ah6, bh3) | 0;
      lo = lo + Math.imul(al5, bl4) | 0;
      mid = mid + Math.imul(al5, bh4) | 0;
      mid = mid + Math.imul(ah5, bl4) | 0;
      hi = hi + Math.imul(ah5, bh4) | 0;
      lo = lo + Math.imul(al4, bl5) | 0;
      mid = mid + Math.imul(al4, bh5) | 0;
      mid = mid + Math.imul(ah4, bl5) | 0;
      hi = hi + Math.imul(ah4, bh5) | 0;
      lo = lo + Math.imul(al3, bl6) | 0;
      mid = mid + Math.imul(al3, bh6) | 0;
      mid = mid + Math.imul(ah3, bl6) | 0;
      hi = hi + Math.imul(ah3, bh6) | 0;
      lo = lo + Math.imul(al2, bl7) | 0;
      mid = mid + Math.imul(al2, bh7) | 0;
      mid = mid + Math.imul(ah2, bl7) | 0;
      hi = hi + Math.imul(ah2, bh7) | 0;
      lo = lo + Math.imul(al1, bl8) | 0;
      mid = mid + Math.imul(al1, bh8) | 0;
      mid = mid + Math.imul(ah1, bl8) | 0;
      hi = hi + Math.imul(ah1, bh8) | 0;
      lo = lo + Math.imul(al0, bl9) | 0;
      mid = mid + Math.imul(al0, bh9) | 0;
      mid = mid + Math.imul(ah0, bl9) | 0;
      hi = hi + Math.imul(ah0, bh9) | 0;
      var w9 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w9 >>> 26) | 0;
      w9 &= 67108863;
      lo = Math.imul(al9, bl1);
      mid = Math.imul(al9, bh1);
      mid = mid + Math.imul(ah9, bl1) | 0;
      hi = Math.imul(ah9, bh1);
      lo = lo + Math.imul(al8, bl2) | 0;
      mid = mid + Math.imul(al8, bh2) | 0;
      mid = mid + Math.imul(ah8, bl2) | 0;
      hi = hi + Math.imul(ah8, bh2) | 0;
      lo = lo + Math.imul(al7, bl3) | 0;
      mid = mid + Math.imul(al7, bh3) | 0;
      mid = mid + Math.imul(ah7, bl3) | 0;
      hi = hi + Math.imul(ah7, bh3) | 0;
      lo = lo + Math.imul(al6, bl4) | 0;
      mid = mid + Math.imul(al6, bh4) | 0;
      mid = mid + Math.imul(ah6, bl4) | 0;
      hi = hi + Math.imul(ah6, bh4) | 0;
      lo = lo + Math.imul(al5, bl5) | 0;
      mid = mid + Math.imul(al5, bh5) | 0;
      mid = mid + Math.imul(ah5, bl5) | 0;
      hi = hi + Math.imul(ah5, bh5) | 0;
      lo = lo + Math.imul(al4, bl6) | 0;
      mid = mid + Math.imul(al4, bh6) | 0;
      mid = mid + Math.imul(ah4, bl6) | 0;
      hi = hi + Math.imul(ah4, bh6) | 0;
      lo = lo + Math.imul(al3, bl7) | 0;
      mid = mid + Math.imul(al3, bh7) | 0;
      mid = mid + Math.imul(ah3, bl7) | 0;
      hi = hi + Math.imul(ah3, bh7) | 0;
      lo = lo + Math.imul(al2, bl8) | 0;
      mid = mid + Math.imul(al2, bh8) | 0;
      mid = mid + Math.imul(ah2, bl8) | 0;
      hi = hi + Math.imul(ah2, bh8) | 0;
      lo = lo + Math.imul(al1, bl9) | 0;
      mid = mid + Math.imul(al1, bh9) | 0;
      mid = mid + Math.imul(ah1, bl9) | 0;
      hi = hi + Math.imul(ah1, bh9) | 0;
      var w10 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
      w10 &= 67108863;
      lo = Math.imul(al9, bl2);
      mid = Math.imul(al9, bh2);
      mid = mid + Math.imul(ah9, bl2) | 0;
      hi = Math.imul(ah9, bh2);
      lo = lo + Math.imul(al8, bl3) | 0;
      mid = mid + Math.imul(al8, bh3) | 0;
      mid = mid + Math.imul(ah8, bl3) | 0;
      hi = hi + Math.imul(ah8, bh3) | 0;
      lo = lo + Math.imul(al7, bl4) | 0;
      mid = mid + Math.imul(al7, bh4) | 0;
      mid = mid + Math.imul(ah7, bl4) | 0;
      hi = hi + Math.imul(ah7, bh4) | 0;
      lo = lo + Math.imul(al6, bl5) | 0;
      mid = mid + Math.imul(al6, bh5) | 0;
      mid = mid + Math.imul(ah6, bl5) | 0;
      hi = hi + Math.imul(ah6, bh5) | 0;
      lo = lo + Math.imul(al5, bl6) | 0;
      mid = mid + Math.imul(al5, bh6) | 0;
      mid = mid + Math.imul(ah5, bl6) | 0;
      hi = hi + Math.imul(ah5, bh6) | 0;
      lo = lo + Math.imul(al4, bl7) | 0;
      mid = mid + Math.imul(al4, bh7) | 0;
      mid = mid + Math.imul(ah4, bl7) | 0;
      hi = hi + Math.imul(ah4, bh7) | 0;
      lo = lo + Math.imul(al3, bl8) | 0;
      mid = mid + Math.imul(al3, bh8) | 0;
      mid = mid + Math.imul(ah3, bl8) | 0;
      hi = hi + Math.imul(ah3, bh8) | 0;
      lo = lo + Math.imul(al2, bl9) | 0;
      mid = mid + Math.imul(al2, bh9) | 0;
      mid = mid + Math.imul(ah2, bl9) | 0;
      hi = hi + Math.imul(ah2, bh9) | 0;
      var w11 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
      w11 &= 67108863;
      lo = Math.imul(al9, bl3);
      mid = Math.imul(al9, bh3);
      mid = mid + Math.imul(ah9, bl3) | 0;
      hi = Math.imul(ah9, bh3);
      lo = lo + Math.imul(al8, bl4) | 0;
      mid = mid + Math.imul(al8, bh4) | 0;
      mid = mid + Math.imul(ah8, bl4) | 0;
      hi = hi + Math.imul(ah8, bh4) | 0;
      lo = lo + Math.imul(al7, bl5) | 0;
      mid = mid + Math.imul(al7, bh5) | 0;
      mid = mid + Math.imul(ah7, bl5) | 0;
      hi = hi + Math.imul(ah7, bh5) | 0;
      lo = lo + Math.imul(al6, bl6) | 0;
      mid = mid + Math.imul(al6, bh6) | 0;
      mid = mid + Math.imul(ah6, bl6) | 0;
      hi = hi + Math.imul(ah6, bh6) | 0;
      lo = lo + Math.imul(al5, bl7) | 0;
      mid = mid + Math.imul(al5, bh7) | 0;
      mid = mid + Math.imul(ah5, bl7) | 0;
      hi = hi + Math.imul(ah5, bh7) | 0;
      lo = lo + Math.imul(al4, bl8) | 0;
      mid = mid + Math.imul(al4, bh8) | 0;
      mid = mid + Math.imul(ah4, bl8) | 0;
      hi = hi + Math.imul(ah4, bh8) | 0;
      lo = lo + Math.imul(al3, bl9) | 0;
      mid = mid + Math.imul(al3, bh9) | 0;
      mid = mid + Math.imul(ah3, bl9) | 0;
      hi = hi + Math.imul(ah3, bh9) | 0;
      var w12 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
      w12 &= 67108863;
      lo = Math.imul(al9, bl4);
      mid = Math.imul(al9, bh4);
      mid = mid + Math.imul(ah9, bl4) | 0;
      hi = Math.imul(ah9, bh4);
      lo = lo + Math.imul(al8, bl5) | 0;
      mid = mid + Math.imul(al8, bh5) | 0;
      mid = mid + Math.imul(ah8, bl5) | 0;
      hi = hi + Math.imul(ah8, bh5) | 0;
      lo = lo + Math.imul(al7, bl6) | 0;
      mid = mid + Math.imul(al7, bh6) | 0;
      mid = mid + Math.imul(ah7, bl6) | 0;
      hi = hi + Math.imul(ah7, bh6) | 0;
      lo = lo + Math.imul(al6, bl7) | 0;
      mid = mid + Math.imul(al6, bh7) | 0;
      mid = mid + Math.imul(ah6, bl7) | 0;
      hi = hi + Math.imul(ah6, bh7) | 0;
      lo = lo + Math.imul(al5, bl8) | 0;
      mid = mid + Math.imul(al5, bh8) | 0;
      mid = mid + Math.imul(ah5, bl8) | 0;
      hi = hi + Math.imul(ah5, bh8) | 0;
      lo = lo + Math.imul(al4, bl9) | 0;
      mid = mid + Math.imul(al4, bh9) | 0;
      mid = mid + Math.imul(ah4, bl9) | 0;
      hi = hi + Math.imul(ah4, bh9) | 0;
      var w13 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
      w13 &= 67108863;
      lo = Math.imul(al9, bl5);
      mid = Math.imul(al9, bh5);
      mid = mid + Math.imul(ah9, bl5) | 0;
      hi = Math.imul(ah9, bh5);
      lo = lo + Math.imul(al8, bl6) | 0;
      mid = mid + Math.imul(al8, bh6) | 0;
      mid = mid + Math.imul(ah8, bl6) | 0;
      hi = hi + Math.imul(ah8, bh6) | 0;
      lo = lo + Math.imul(al7, bl7) | 0;
      mid = mid + Math.imul(al7, bh7) | 0;
      mid = mid + Math.imul(ah7, bl7) | 0;
      hi = hi + Math.imul(ah7, bh7) | 0;
      lo = lo + Math.imul(al6, bl8) | 0;
      mid = mid + Math.imul(al6, bh8) | 0;
      mid = mid + Math.imul(ah6, bl8) | 0;
      hi = hi + Math.imul(ah6, bh8) | 0;
      lo = lo + Math.imul(al5, bl9) | 0;
      mid = mid + Math.imul(al5, bh9) | 0;
      mid = mid + Math.imul(ah5, bl9) | 0;
      hi = hi + Math.imul(ah5, bh9) | 0;
      var w14 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
      w14 &= 67108863;
      lo = Math.imul(al9, bl6);
      mid = Math.imul(al9, bh6);
      mid = mid + Math.imul(ah9, bl6) | 0;
      hi = Math.imul(ah9, bh6);
      lo = lo + Math.imul(al8, bl7) | 0;
      mid = mid + Math.imul(al8, bh7) | 0;
      mid = mid + Math.imul(ah8, bl7) | 0;
      hi = hi + Math.imul(ah8, bh7) | 0;
      lo = lo + Math.imul(al7, bl8) | 0;
      mid = mid + Math.imul(al7, bh8) | 0;
      mid = mid + Math.imul(ah7, bl8) | 0;
      hi = hi + Math.imul(ah7, bh8) | 0;
      lo = lo + Math.imul(al6, bl9) | 0;
      mid = mid + Math.imul(al6, bh9) | 0;
      mid = mid + Math.imul(ah6, bl9) | 0;
      hi = hi + Math.imul(ah6, bh9) | 0;
      var w15 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
      w15 &= 67108863;
      lo = Math.imul(al9, bl7);
      mid = Math.imul(al9, bh7);
      mid = mid + Math.imul(ah9, bl7) | 0;
      hi = Math.imul(ah9, bh7);
      lo = lo + Math.imul(al8, bl8) | 0;
      mid = mid + Math.imul(al8, bh8) | 0;
      mid = mid + Math.imul(ah8, bl8) | 0;
      hi = hi + Math.imul(ah8, bh8) | 0;
      lo = lo + Math.imul(al7, bl9) | 0;
      mid = mid + Math.imul(al7, bh9) | 0;
      mid = mid + Math.imul(ah7, bl9) | 0;
      hi = hi + Math.imul(ah7, bh9) | 0;
      var w16 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
      w16 &= 67108863;
      lo = Math.imul(al9, bl8);
      mid = Math.imul(al9, bh8);
      mid = mid + Math.imul(ah9, bl8) | 0;
      hi = Math.imul(ah9, bh8);
      lo = lo + Math.imul(al8, bl9) | 0;
      mid = mid + Math.imul(al8, bh9) | 0;
      mid = mid + Math.imul(ah8, bl9) | 0;
      hi = hi + Math.imul(ah8, bh9) | 0;
      var w17 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
      w17 &= 67108863;
      lo = Math.imul(al9, bl9);
      mid = Math.imul(al9, bh9);
      mid = mid + Math.imul(ah9, bl9) | 0;
      hi = Math.imul(ah9, bh9);
      var w18 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
      c = (hi + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
      w18 &= 67108863;
      o[0] = w0;
      o[1] = w1;
      o[2] = w2;
      o[3] = w3;
      o[4] = w4;
      o[5] = w5;
      o[6] = w6;
      o[7] = w7;
      o[8] = w8;
      o[9] = w9;
      o[10] = w10;
      o[11] = w11;
      o[12] = w12;
      o[13] = w13;
      o[14] = w14;
      o[15] = w15;
      o[16] = w16;
      o[17] = w17;
      o[18] = w18;
      if (c !== 0) {
        o[19] = c;
        out.length++;
      }
      return out;
    };
    if (!Math.imul) {
      comb10MulTo = smallMulTo;
    }
    function bigMulTo(self2, num, out) {
      out.negative = num.negative ^ self2.negative;
      out.length = self2.length + num.length;
      var carry = 0;
      var hncarry = 0;
      for (var k = 0; k < out.length - 1; k++) {
        var ncarry = hncarry;
        hncarry = 0;
        var rword = carry & 67108863;
        var maxJ = Math.min(k, num.length - 1);
        for (var j = Math.max(0, k - self2.length + 1); j <= maxJ; j++) {
          var i = k - j;
          var a = self2.words[i] | 0;
          var b = num.words[j] | 0;
          var r = a * b;
          var lo = r & 67108863;
          ncarry = ncarry + (r / 67108864 | 0) | 0;
          lo = lo + rword | 0;
          rword = lo & 67108863;
          ncarry = ncarry + (lo >>> 26) | 0;
          hncarry += ncarry >>> 26;
          ncarry &= 67108863;
        }
        out.words[k] = rword;
        carry = ncarry;
        ncarry = hncarry;
      }
      if (carry !== 0) {
        out.words[k] = carry;
      } else {
        out.length--;
      }
      return out.strip();
    }
    function jumboMulTo(self2, num, out) {
      var fftm = new FFTM();
      return fftm.mulp(self2, num, out);
    }
    BN.prototype.mulTo = function mulTo(num, out) {
      var res;
      var len = this.length + num.length;
      if (this.length === 10 && num.length === 10) {
        res = comb10MulTo(this, num, out);
      } else if (len < 63) {
        res = smallMulTo(this, num, out);
      } else if (len < 1024) {
        res = bigMulTo(this, num, out);
      } else {
        res = jumboMulTo(this, num, out);
      }
      return res;
    };
    function FFTM(x, y) {
      this.x = x;
      this.y = y;
    }
    FFTM.prototype.makeRBT = function makeRBT(N) {
      var t = new Array(N);
      var l = BN.prototype._countBits(N) - 1;
      for (var i = 0; i < N; i++) {
        t[i] = this.revBin(i, l, N);
      }
      return t;
    };
    FFTM.prototype.revBin = function revBin(x, l, N) {
      if (x === 0 || x === N - 1)
        return x;
      var rb = 0;
      for (var i = 0; i < l; i++) {
        rb |= (x & 1) << l - i - 1;
        x >>= 1;
      }
      return rb;
    };
    FFTM.prototype.permute = function permute(rbt, rws, iws, rtws, itws, N) {
      for (var i = 0; i < N; i++) {
        rtws[i] = rws[rbt[i]];
        itws[i] = iws[rbt[i]];
      }
    };
    FFTM.prototype.transform = function transform(rws, iws, rtws, itws, N, rbt) {
      this.permute(rbt, rws, iws, rtws, itws, N);
      for (var s = 1; s < N; s <<= 1) {
        var l = s << 1;
        var rtwdf = Math.cos(2 * Math.PI / l);
        var itwdf = Math.sin(2 * Math.PI / l);
        for (var p = 0; p < N; p += l) {
          var rtwdf_ = rtwdf;
          var itwdf_ = itwdf;
          for (var j = 0; j < s; j++) {
            var re = rtws[p + j];
            var ie = itws[p + j];
            var ro = rtws[p + j + s];
            var io = itws[p + j + s];
            var rx = rtwdf_ * ro - itwdf_ * io;
            io = rtwdf_ * io + itwdf_ * ro;
            ro = rx;
            rtws[p + j] = re + ro;
            itws[p + j] = ie + io;
            rtws[p + j + s] = re - ro;
            itws[p + j + s] = ie - io;
            if (j !== l) {
              rx = rtwdf * rtwdf_ - itwdf * itwdf_;
              itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
              rtwdf_ = rx;
            }
          }
        }
      }
    };
    FFTM.prototype.guessLen13b = function guessLen13b(n, m) {
      var N = Math.max(m, n) | 1;
      var odd = N & 1;
      var i = 0;
      for (N = N / 2 | 0; N; N = N >>> 1) {
        i++;
      }
      return 1 << i + 1 + odd;
    };
    FFTM.prototype.conjugate = function conjugate(rws, iws, N) {
      if (N <= 1)
        return;
      for (var i = 0; i < N / 2; i++) {
        var t = rws[i];
        rws[i] = rws[N - i - 1];
        rws[N - i - 1] = t;
        t = iws[i];
        iws[i] = -iws[N - i - 1];
        iws[N - i - 1] = -t;
      }
    };
    FFTM.prototype.normalize13b = function normalize13b(ws, N) {
      var carry = 0;
      for (var i = 0; i < N / 2; i++) {
        var w = Math.round(ws[2 * i + 1] / N) * 8192 + Math.round(ws[2 * i] / N) + carry;
        ws[i] = w & 67108863;
        if (w < 67108864) {
          carry = 0;
        } else {
          carry = w / 67108864 | 0;
        }
      }
      return ws;
    };
    FFTM.prototype.convert13b = function convert13b(ws, len, rws, N) {
      var carry = 0;
      for (var i = 0; i < len; i++) {
        carry = carry + (ws[i] | 0);
        rws[2 * i] = carry & 8191;
        carry = carry >>> 13;
        rws[2 * i + 1] = carry & 8191;
        carry = carry >>> 13;
      }
      for (i = 2 * len; i < N; ++i) {
        rws[i] = 0;
      }
      assert(carry === 0);
      assert((carry & ~8191) === 0);
    };
    FFTM.prototype.stub = function stub(N) {
      var ph = new Array(N);
      for (var i = 0; i < N; i++) {
        ph[i] = 0;
      }
      return ph;
    };
    FFTM.prototype.mulp = function mulp(x, y, out) {
      var N = 2 * this.guessLen13b(x.length, y.length);
      var rbt = this.makeRBT(N);
      var _ = this.stub(N);
      var rws = new Array(N);
      var rwst = new Array(N);
      var iwst = new Array(N);
      var nrws = new Array(N);
      var nrwst = new Array(N);
      var niwst = new Array(N);
      var rmws = out.words;
      rmws.length = N;
      this.convert13b(x.words, x.length, rws, N);
      this.convert13b(y.words, y.length, nrws, N);
      this.transform(rws, _, rwst, iwst, N, rbt);
      this.transform(nrws, _, nrwst, niwst, N, rbt);
      for (var i = 0; i < N; i++) {
        var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];
        iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];
        rwst[i] = rx;
      }
      this.conjugate(rwst, iwst, N);
      this.transform(rwst, iwst, rmws, _, N, rbt);
      this.conjugate(rmws, _, N);
      this.normalize13b(rmws, N);
      out.negative = x.negative ^ y.negative;
      out.length = x.length + y.length;
      return out.strip();
    };
    BN.prototype.mul = function mul(num) {
      var out = new BN(null);
      out.words = new Array(this.length + num.length);
      return this.mulTo(num, out);
    };
    BN.prototype.mulf = function mulf(num) {
      var out = new BN(null);
      out.words = new Array(this.length + num.length);
      return jumboMulTo(this, num, out);
    };
    BN.prototype.imul = function imul(num) {
      return this.clone().mulTo(num, this);
    };
    BN.prototype.imuln = function imuln(num) {
      assert(typeof num === "number");
      assert(num < 67108864);
      var carry = 0;
      for (var i = 0; i < this.length; i++) {
        var w = (this.words[i] | 0) * num;
        var lo = (w & 67108863) + (carry & 67108863);
        carry >>= 26;
        carry += w / 67108864 | 0;
        carry += lo >>> 26;
        this.words[i] = lo & 67108863;
      }
      if (carry !== 0) {
        this.words[i] = carry;
        this.length++;
      }
      return this;
    };
    BN.prototype.muln = function muln(num) {
      return this.clone().imuln(num);
    };
    BN.prototype.sqr = function sqr() {
      return this.mul(this);
    };
    BN.prototype.isqr = function isqr() {
      return this.imul(this.clone());
    };
    BN.prototype.pow = function pow(num) {
      var w = toBitArray(num);
      if (w.length === 0)
        return new BN(1);
      var res = this;
      for (var i = 0; i < w.length; i++, res = res.sqr()) {
        if (w[i] !== 0)
          break;
      }
      if (++i < w.length) {
        for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {
          if (w[i] === 0)
            continue;
          res = res.mul(q);
        }
      }
      return res;
    };
    BN.prototype.iushln = function iushln(bits) {
      assert(typeof bits === "number" && bits >= 0);
      var r = bits % 26;
      var s = (bits - r) / 26;
      var carryMask = 67108863 >>> 26 - r << 26 - r;
      var i;
      if (r !== 0) {
        var carry = 0;
        for (i = 0; i < this.length; i++) {
          var newCarry = this.words[i] & carryMask;
          var c = (this.words[i] | 0) - newCarry << r;
          this.words[i] = c | carry;
          carry = newCarry >>> 26 - r;
        }
        if (carry) {
          this.words[i] = carry;
          this.length++;
        }
      }
      if (s !== 0) {
        for (i = this.length - 1; i >= 0; i--) {
          this.words[i + s] = this.words[i];
        }
        for (i = 0; i < s; i++) {
          this.words[i] = 0;
        }
        this.length += s;
      }
      return this.strip();
    };
    BN.prototype.ishln = function ishln(bits) {
      assert(this.negative === 0);
      return this.iushln(bits);
    };
    BN.prototype.iushrn = function iushrn(bits, hint, extended) {
      assert(typeof bits === "number" && bits >= 0);
      var h;
      if (hint) {
        h = (hint - hint % 26) / 26;
      } else {
        h = 0;
      }
      var r = bits % 26;
      var s = Math.min((bits - r) / 26, this.length);
      var mask = 67108863 ^ 67108863 >>> r << r;
      var maskedWords = extended;
      h -= s;
      h = Math.max(0, h);
      if (maskedWords) {
        for (var i = 0; i < s; i++) {
          maskedWords.words[i] = this.words[i];
        }
        maskedWords.length = s;
      }
      if (s === 0) {
      } else if (this.length > s) {
        this.length -= s;
        for (i = 0; i < this.length; i++) {
          this.words[i] = this.words[i + s];
        }
      } else {
        this.words[0] = 0;
        this.length = 1;
      }
      var carry = 0;
      for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {
        var word = this.words[i] | 0;
        this.words[i] = carry << 26 - r | word >>> r;
        carry = word & mask;
      }
      if (maskedWords && carry !== 0) {
        maskedWords.words[maskedWords.length++] = carry;
      }
      if (this.length === 0) {
        this.words[0] = 0;
        this.length = 1;
      }
      return this.strip();
    };
    BN.prototype.ishrn = function ishrn(bits, hint, extended) {
      assert(this.negative === 0);
      return this.iushrn(bits, hint, extended);
    };
    BN.prototype.shln = function shln(bits) {
      return this.clone().ishln(bits);
    };
    BN.prototype.ushln = function ushln(bits) {
      return this.clone().iushln(bits);
    };
    BN.prototype.shrn = function shrn(bits) {
      return this.clone().ishrn(bits);
    };
    BN.prototype.ushrn = function ushrn(bits) {
      return this.clone().iushrn(bits);
    };
    BN.prototype.testn = function testn(bit) {
      assert(typeof bit === "number" && bit >= 0);
      var r = bit % 26;
      var s = (bit - r) / 26;
      var q = 1 << r;
      if (this.length <= s)
        return false;
      var w = this.words[s];
      return !!(w & q);
    };
    BN.prototype.imaskn = function imaskn(bits) {
      assert(typeof bits === "number" && bits >= 0);
      var r = bits % 26;
      var s = (bits - r) / 26;
      assert(this.negative === 0, "imaskn works only with positive numbers");
      if (this.length <= s) {
        return this;
      }
      if (r !== 0) {
        s++;
      }
      this.length = Math.min(s, this.length);
      if (r !== 0) {
        var mask = 67108863 ^ 67108863 >>> r << r;
        this.words[this.length - 1] &= mask;
      }
      return this.strip();
    };
    BN.prototype.maskn = function maskn(bits) {
      return this.clone().imaskn(bits);
    };
    BN.prototype.iaddn = function iaddn(num) {
      assert(typeof num === "number");
      assert(num < 67108864);
      if (num < 0)
        return this.isubn(-num);
      if (this.negative !== 0) {
        if (this.length === 1 && (this.words[0] | 0) < num) {
          this.words[0] = num - (this.words[0] | 0);
          this.negative = 0;
          return this;
        }
        this.negative = 0;
        this.isubn(num);
        this.negative = 1;
        return this;
      }
      return this._iaddn(num);
    };
    BN.prototype._iaddn = function _iaddn(num) {
      this.words[0] += num;
      for (var i = 0; i < this.length && this.words[i] >= 67108864; i++) {
        this.words[i] -= 67108864;
        if (i === this.length - 1) {
          this.words[i + 1] = 1;
        } else {
          this.words[i + 1]++;
        }
      }
      this.length = Math.max(this.length, i + 1);
      return this;
    };
    BN.prototype.isubn = function isubn(num) {
      assert(typeof num === "number");
      assert(num < 67108864);
      if (num < 0)
        return this.iaddn(-num);
      if (this.negative !== 0) {
        this.negative = 0;
        this.iaddn(num);
        this.negative = 1;
        return this;
      }
      this.words[0] -= num;
      if (this.length === 1 && this.words[0] < 0) {
        this.words[0] = -this.words[0];
        this.negative = 1;
      } else {
        for (var i = 0; i < this.length && this.words[i] < 0; i++) {
          this.words[i] += 67108864;
          this.words[i + 1] -= 1;
        }
      }
      return this.strip();
    };
    BN.prototype.addn = function addn(num) {
      return this.clone().iaddn(num);
    };
    BN.prototype.subn = function subn(num) {
      return this.clone().isubn(num);
    };
    BN.prototype.iabs = function iabs() {
      this.negative = 0;
      return this;
    };
    BN.prototype.abs = function abs() {
      return this.clone().iabs();
    };
    BN.prototype._ishlnsubmul = function _ishlnsubmul(num, mul, shift) {
      var len = num.length + shift;
      var i;
      this._expand(len);
      var w;
      var carry = 0;
      for (i = 0; i < num.length; i++) {
        w = (this.words[i + shift] | 0) + carry;
        var right = (num.words[i] | 0) * mul;
        w -= right & 67108863;
        carry = (w >> 26) - (right / 67108864 | 0);
        this.words[i + shift] = w & 67108863;
      }
      for (; i < this.length - shift; i++) {
        w = (this.words[i + shift] | 0) + carry;
        carry = w >> 26;
        this.words[i + shift] = w & 67108863;
      }
      if (carry === 0)
        return this.strip();
      assert(carry === -1);
      carry = 0;
      for (i = 0; i < this.length; i++) {
        w = -(this.words[i] | 0) + carry;
        carry = w >> 26;
        this.words[i] = w & 67108863;
      }
      this.negative = 1;
      return this.strip();
    };
    BN.prototype._wordDiv = function _wordDiv(num, mode) {
      var shift = this.length - num.length;
      var a = this.clone();
      var b = num;
      var bhi = b.words[b.length - 1] | 0;
      var bhiBits = this._countBits(bhi);
      shift = 26 - bhiBits;
      if (shift !== 0) {
        b = b.ushln(shift);
        a.iushln(shift);
        bhi = b.words[b.length - 1] | 0;
      }
      var m = a.length - b.length;
      var q;
      if (mode !== "mod") {
        q = new BN(null);
        q.length = m + 1;
        q.words = new Array(q.length);
        for (var i = 0; i < q.length; i++) {
          q.words[i] = 0;
        }
      }
      var diff = a.clone()._ishlnsubmul(b, 1, m);
      if (diff.negative === 0) {
        a = diff;
        if (q) {
          q.words[m] = 1;
        }
      }
      for (var j = m - 1; j >= 0; j--) {
        var qj = (a.words[b.length + j] | 0) * 67108864 + (a.words[b.length + j - 1] | 0);
        qj = Math.min(qj / bhi | 0, 67108863);
        a._ishlnsubmul(b, qj, j);
        while (a.negative !== 0) {
          qj--;
          a.negative = 0;
          a._ishlnsubmul(b, 1, j);
          if (!a.isZero()) {
            a.negative ^= 1;
          }
        }
        if (q) {
          q.words[j] = qj;
        }
      }
      if (q) {
        q.strip();
      }
      a.strip();
      if (mode !== "div" && shift !== 0) {
        a.iushrn(shift);
      }
      return {
        div: q || null,
        mod: a
      };
    };
    BN.prototype.divmod = function divmod(num, mode, positive) {
      assert(!num.isZero());
      if (this.isZero()) {
        return {
          div: new BN(0),
          mod: new BN(0)
        };
      }
      var div, mod, res;
      if (this.negative !== 0 && num.negative === 0) {
        res = this.neg().divmod(num, mode);
        if (mode !== "mod") {
          div = res.div.neg();
        }
        if (mode !== "div") {
          mod = res.mod.neg();
          if (positive && mod.negative !== 0) {
            mod.iadd(num);
          }
        }
        return {
          div,
          mod
        };
      }
      if (this.negative === 0 && num.negative !== 0) {
        res = this.divmod(num.neg(), mode);
        if (mode !== "mod") {
          div = res.div.neg();
        }
        return {
          div,
          mod: res.mod
        };
      }
      if ((this.negative & num.negative) !== 0) {
        res = this.neg().divmod(num.neg(), mode);
        if (mode !== "div") {
          mod = res.mod.neg();
          if (positive && mod.negative !== 0) {
            mod.isub(num);
          }
        }
        return {
          div: res.div,
          mod
        };
      }
      if (num.length > this.length || this.cmp(num) < 0) {
        return {
          div: new BN(0),
          mod: this
        };
      }
      if (num.length === 1) {
        if (mode === "div") {
          return {
            div: this.divn(num.words[0]),
            mod: null
          };
        }
        if (mode === "mod") {
          return {
            div: null,
            mod: new BN(this.modn(num.words[0]))
          };
        }
        return {
          div: this.divn(num.words[0]),
          mod: new BN(this.modn(num.words[0]))
        };
      }
      return this._wordDiv(num, mode);
    };
    BN.prototype.div = function div(num) {
      return this.divmod(num, "div", false).div;
    };
    BN.prototype.mod = function mod(num) {
      return this.divmod(num, "mod", false).mod;
    };
    BN.prototype.umod = function umod(num) {
      return this.divmod(num, "mod", true).mod;
    };
    BN.prototype.divRound = function divRound(num) {
      var dm = this.divmod(num);
      if (dm.mod.isZero())
        return dm.div;
      var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;
      var half = num.ushrn(1);
      var r2 = num.andln(1);
      var cmp = mod.cmp(half);
      if (cmp < 0 || r2 === 1 && cmp === 0)
        return dm.div;
      return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
    };
    BN.prototype.modn = function modn(num) {
      assert(num <= 67108863);
      var p = (1 << 26) % num;
      var acc = 0;
      for (var i = this.length - 1; i >= 0; i--) {
        acc = (p * acc + (this.words[i] | 0)) % num;
      }
      return acc;
    };
    BN.prototype.idivn = function idivn(num) {
      assert(num <= 67108863);
      var carry = 0;
      for (var i = this.length - 1; i >= 0; i--) {
        var w = (this.words[i] | 0) + carry * 67108864;
        this.words[i] = w / num | 0;
        carry = w % num;
      }
      return this.strip();
    };
    BN.prototype.divn = function divn(num) {
      return this.clone().idivn(num);
    };
    BN.prototype.egcd = function egcd(p) {
      assert(p.negative === 0);
      assert(!p.isZero());
      var x = this;
      var y = p.clone();
      if (x.negative !== 0) {
        x = x.umod(p);
      } else {
        x = x.clone();
      }
      var A = new BN(1);
      var B = new BN(0);
      var C = new BN(0);
      var D = new BN(1);
      var g = 0;
      while (x.isEven() && y.isEven()) {
        x.iushrn(1);
        y.iushrn(1);
        ++g;
      }
      var yp = y.clone();
      var xp = x.clone();
      while (!x.isZero()) {
        for (var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1)
          ;
        if (i > 0) {
          x.iushrn(i);
          while (i-- > 0) {
            if (A.isOdd() || B.isOdd()) {
              A.iadd(yp);
              B.isub(xp);
            }
            A.iushrn(1);
            B.iushrn(1);
          }
        }
        for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1)
          ;
        if (j > 0) {
          y.iushrn(j);
          while (j-- > 0) {
            if (C.isOdd() || D.isOdd()) {
              C.iadd(yp);
              D.isub(xp);
            }
            C.iushrn(1);
            D.iushrn(1);
          }
        }
        if (x.cmp(y) >= 0) {
          x.isub(y);
          A.isub(C);
          B.isub(D);
        } else {
          y.isub(x);
          C.isub(A);
          D.isub(B);
        }
      }
      return {
        a: C,
        b: D,
        gcd: y.iushln(g)
      };
    };
    BN.prototype._invmp = function _invmp(p) {
      assert(p.negative === 0);
      assert(!p.isZero());
      var a = this;
      var b = p.clone();
      if (a.negative !== 0) {
        a = a.umod(p);
      } else {
        a = a.clone();
      }
      var x1 = new BN(1);
      var x2 = new BN(0);
      var delta = b.clone();
      while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
        for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1)
          ;
        if (i > 0) {
          a.iushrn(i);
          while (i-- > 0) {
            if (x1.isOdd()) {
              x1.iadd(delta);
            }
            x1.iushrn(1);
          }
        }
        for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1)
          ;
        if (j > 0) {
          b.iushrn(j);
          while (j-- > 0) {
            if (x2.isOdd()) {
              x2.iadd(delta);
            }
            x2.iushrn(1);
          }
        }
        if (a.cmp(b) >= 0) {
          a.isub(b);
          x1.isub(x2);
        } else {
          b.isub(a);
          x2.isub(x1);
        }
      }
      var res;
      if (a.cmpn(1) === 0) {
        res = x1;
      } else {
        res = x2;
      }
      if (res.cmpn(0) < 0) {
        res.iadd(p);
      }
      return res;
    };
    BN.prototype.gcd = function gcd(num) {
      if (this.isZero())
        return num.abs();
      if (num.isZero())
        return this.abs();
      var a = this.clone();
      var b = num.clone();
      a.negative = 0;
      b.negative = 0;
      for (var shift = 0; a.isEven() && b.isEven(); shift++) {
        a.iushrn(1);
        b.iushrn(1);
      }
      do {
        while (a.isEven()) {
          a.iushrn(1);
        }
        while (b.isEven()) {
          b.iushrn(1);
        }
        var r = a.cmp(b);
        if (r < 0) {
          var t = a;
          a = b;
          b = t;
        } else if (r === 0 || b.cmpn(1) === 0) {
          break;
        }
        a.isub(b);
      } while (true);
      return b.iushln(shift);
    };
    BN.prototype.invm = function invm(num) {
      return this.egcd(num).a.umod(num);
    };
    BN.prototype.isEven = function isEven() {
      return (this.words[0] & 1) === 0;
    };
    BN.prototype.isOdd = function isOdd() {
      return (this.words[0] & 1) === 1;
    };
    BN.prototype.andln = function andln(num) {
      return this.words[0] & num;
    };
    BN.prototype.bincn = function bincn(bit) {
      assert(typeof bit === "number");
      var r = bit % 26;
      var s = (bit - r) / 26;
      var q = 1 << r;
      if (this.length <= s) {
        this._expand(s + 1);
        this.words[s] |= q;
        return this;
      }
      var carry = q;
      for (var i = s; carry !== 0 && i < this.length; i++) {
        var w = this.words[i] | 0;
        w += carry;
        carry = w >>> 26;
        w &= 67108863;
        this.words[i] = w;
      }
      if (carry !== 0) {
        this.words[i] = carry;
        this.length++;
      }
      return this;
    };
    BN.prototype.isZero = function isZero() {
      return this.length === 1 && this.words[0] === 0;
    };
    BN.prototype.cmpn = function cmpn(num) {
      var negative = num < 0;
      if (this.negative !== 0 && !negative)
        return -1;
      if (this.negative === 0 && negative)
        return 1;
      this.strip();
      var res;
      if (this.length > 1) {
        res = 1;
      } else {
        if (negative) {
          num = -num;
        }
        assert(num <= 67108863, "Number is too big");
        var w = this.words[0] | 0;
        res = w === num ? 0 : w < num ? -1 : 1;
      }
      if (this.negative !== 0)
        return -res | 0;
      return res;
    };
    BN.prototype.cmp = function cmp(num) {
      if (this.negative !== 0 && num.negative === 0)
        return -1;
      if (this.negative === 0 && num.negative !== 0)
        return 1;
      var res = this.ucmp(num);
      if (this.negative !== 0)
        return -res | 0;
      return res;
    };
    BN.prototype.ucmp = function ucmp(num) {
      if (this.length > num.length)
        return 1;
      if (this.length < num.length)
        return -1;
      var res = 0;
      for (var i = this.length - 1; i >= 0; i--) {
        var a = this.words[i] | 0;
        var b = num.words[i] | 0;
        if (a === b)
          continue;
        if (a < b) {
          res = -1;
        } else if (a > b) {
          res = 1;
        }
        break;
      }
      return res;
    };
    BN.prototype.gtn = function gtn(num) {
      return this.cmpn(num) === 1;
    };
    BN.prototype.gt = function gt(num) {
      return this.cmp(num) === 1;
    };
    BN.prototype.gten = function gten(num) {
      return this.cmpn(num) >= 0;
    };
    BN.prototype.gte = function gte(num) {
      return this.cmp(num) >= 0;
    };
    BN.prototype.ltn = function ltn(num) {
      return this.cmpn(num) === -1;
    };
    BN.prototype.lt = function lt(num) {
      return this.cmp(num) === -1;
    };
    BN.prototype.lten = function lten(num) {
      return this.cmpn(num) <= 0;
    };
    BN.prototype.lte = function lte(num) {
      return this.cmp(num) <= 0;
    };
    BN.prototype.eqn = function eqn(num) {
      return this.cmpn(num) === 0;
    };
    BN.prototype.eq = function eq(num) {
      return this.cmp(num) === 0;
    };
    BN.red = function red(num) {
      return new Red(num);
    };
    BN.prototype.toRed = function toRed(ctx) {
      assert(!this.red, "Already a number in reduction context");
      assert(this.negative === 0, "red works only with positives");
      return ctx.convertTo(this)._forceRed(ctx);
    };
    BN.prototype.fromRed = function fromRed() {
      assert(this.red, "fromRed works only with numbers in reduction context");
      return this.red.convertFrom(this);
    };
    BN.prototype._forceRed = function _forceRed(ctx) {
      this.red = ctx;
      return this;
    };
    BN.prototype.forceRed = function forceRed(ctx) {
      assert(!this.red, "Already a number in reduction context");
      return this._forceRed(ctx);
    };
    BN.prototype.redAdd = function redAdd(num) {
      assert(this.red, "redAdd works only with red numbers");
      return this.red.add(this, num);
    };
    BN.prototype.redIAdd = function redIAdd(num) {
      assert(this.red, "redIAdd works only with red numbers");
      return this.red.iadd(this, num);
    };
    BN.prototype.redSub = function redSub(num) {
      assert(this.red, "redSub works only with red numbers");
      return this.red.sub(this, num);
    };
    BN.prototype.redISub = function redISub(num) {
      assert(this.red, "redISub works only with red numbers");
      return this.red.isub(this, num);
    };
    BN.prototype.redShl = function redShl(num) {
      assert(this.red, "redShl works only with red numbers");
      return this.red.shl(this, num);
    };
    BN.prototype.redMul = function redMul(num) {
      assert(this.red, "redMul works only with red numbers");
      this.red._verify2(this, num);
      return this.red.mul(this, num);
    };
    BN.prototype.redIMul = function redIMul(num) {
      assert(this.red, "redMul works only with red numbers");
      this.red._verify2(this, num);
      return this.red.imul(this, num);
    };
    BN.prototype.redSqr = function redSqr() {
      assert(this.red, "redSqr works only with red numbers");
      this.red._verify1(this);
      return this.red.sqr(this);
    };
    BN.prototype.redISqr = function redISqr() {
      assert(this.red, "redISqr works only with red numbers");
      this.red._verify1(this);
      return this.red.isqr(this);
    };
    BN.prototype.redSqrt = function redSqrt() {
      assert(this.red, "redSqrt works only with red numbers");
      this.red._verify1(this);
      return this.red.sqrt(this);
    };
    BN.prototype.redInvm = function redInvm() {
      assert(this.red, "redInvm works only with red numbers");
      this.red._verify1(this);
      return this.red.invm(this);
    };
    BN.prototype.redNeg = function redNeg() {
      assert(this.red, "redNeg works only with red numbers");
      this.red._verify1(this);
      return this.red.neg(this);
    };
    BN.prototype.redPow = function redPow(num) {
      assert(this.red && !num.red, "redPow(normalNum)");
      this.red._verify1(this);
      return this.red.pow(this, num);
    };
    var primes = {
      k256: null,
      p224: null,
      p192: null,
      p25519: null
    };
    function MPrime(name, p) {
      this.name = name;
      this.p = new BN(p, 16);
      this.n = this.p.bitLength();
      this.k = new BN(1).iushln(this.n).isub(this.p);
      this.tmp = this._tmp();
    }
    MPrime.prototype._tmp = function _tmp() {
      var tmp = new BN(null);
      tmp.words = new Array(Math.ceil(this.n / 13));
      return tmp;
    };
    MPrime.prototype.ireduce = function ireduce(num) {
      var r = num;
      var rlen;
      do {
        this.split(r, this.tmp);
        r = this.imulK(r);
        r = r.iadd(this.tmp);
        rlen = r.bitLength();
      } while (rlen > this.n);
      var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
      if (cmp === 0) {
        r.words[0] = 0;
        r.length = 1;
      } else if (cmp > 0) {
        r.isub(this.p);
      } else {
        if (r.strip !== void 0) {
          r.strip();
        } else {
          r._strip();
        }
      }
      return r;
    };
    MPrime.prototype.split = function split(input, out) {
      input.iushrn(this.n, 0, out);
    };
    MPrime.prototype.imulK = function imulK(num) {
      return num.imul(this.k);
    };
    function K256() {
      MPrime.call(this, "k256", "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f");
    }
    inherits(K256, MPrime);
    K256.prototype.split = function split(input, output) {
      var mask = 4194303;
      var outLen = Math.min(input.length, 9);
      for (var i = 0; i < outLen; i++) {
        output.words[i] = input.words[i];
      }
      output.length = outLen;
      if (input.length <= 9) {
        input.words[0] = 0;
        input.length = 1;
        return;
      }
      var prev = input.words[9];
      output.words[output.length++] = prev & mask;
      for (i = 10; i < input.length; i++) {
        var next = input.words[i] | 0;
        input.words[i - 10] = (next & mask) << 4 | prev >>> 22;
        prev = next;
      }
      prev >>>= 22;
      input.words[i - 10] = prev;
      if (prev === 0 && input.length > 10) {
        input.length -= 10;
      } else {
        input.length -= 9;
      }
    };
    K256.prototype.imulK = function imulK(num) {
      num.words[num.length] = 0;
      num.words[num.length + 1] = 0;
      num.length += 2;
      var lo = 0;
      for (var i = 0; i < num.length; i++) {
        var w = num.words[i] | 0;
        lo += w * 977;
        num.words[i] = lo & 67108863;
        lo = w * 64 + (lo / 67108864 | 0);
      }
      if (num.words[num.length - 1] === 0) {
        num.length--;
        if (num.words[num.length - 1] === 0) {
          num.length--;
        }
      }
      return num;
    };
    function P224() {
      MPrime.call(this, "p224", "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001");
    }
    inherits(P224, MPrime);
    function P192() {
      MPrime.call(this, "p192", "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff");
    }
    inherits(P192, MPrime);
    function P25519() {
      MPrime.call(this, "25519", "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed");
    }
    inherits(P25519, MPrime);
    P25519.prototype.imulK = function imulK(num) {
      var carry = 0;
      for (var i = 0; i < num.length; i++) {
        var hi = (num.words[i] | 0) * 19 + carry;
        var lo = hi & 67108863;
        hi >>>= 26;
        num.words[i] = lo;
        carry = hi;
      }
      if (carry !== 0) {
        num.words[num.length++] = carry;
      }
      return num;
    };
    BN._prime = function prime(name) {
      if (primes[name])
        return primes[name];
      var prime2;
      if (name === "k256") {
        prime2 = new K256();
      } else if (name === "p224") {
        prime2 = new P224();
      } else if (name === "p192") {
        prime2 = new P192();
      } else if (name === "p25519") {
        prime2 = new P25519();
      } else {
        throw new Error("Unknown prime " + name);
      }
      primes[name] = prime2;
      return prime2;
    };
    function Red(m) {
      if (typeof m === "string") {
        var prime = BN._prime(m);
        this.m = prime.p;
        this.prime = prime;
      } else {
        assert(m.gtn(1), "modulus must be greater than 1");
        this.m = m;
        this.prime = null;
      }
    }
    Red.prototype._verify1 = function _verify1(a) {
      assert(a.negative === 0, "red works only with positives");
      assert(a.red, "red works only with red numbers");
    };
    Red.prototype._verify2 = function _verify2(a, b) {
      assert((a.negative | b.negative) === 0, "red works only with positives");
      assert(a.red && a.red === b.red, "red works only with red numbers");
    };
    Red.prototype.imod = function imod(a) {
      if (this.prime)
        return this.prime.ireduce(a)._forceRed(this);
      return a.umod(this.m)._forceRed(this);
    };
    Red.prototype.neg = function neg(a) {
      if (a.isZero()) {
        return a.clone();
      }
      return this.m.sub(a)._forceRed(this);
    };
    Red.prototype.add = function add(a, b) {
      this._verify2(a, b);
      var res = a.add(b);
      if (res.cmp(this.m) >= 0) {
        res.isub(this.m);
      }
      return res._forceRed(this);
    };
    Red.prototype.iadd = function iadd(a, b) {
      this._verify2(a, b);
      var res = a.iadd(b);
      if (res.cmp(this.m) >= 0) {
        res.isub(this.m);
      }
      return res;
    };
    Red.prototype.sub = function sub(a, b) {
      this._verify2(a, b);
      var res = a.sub(b);
      if (res.cmpn(0) < 0) {
        res.iadd(this.m);
      }
      return res._forceRed(this);
    };
    Red.prototype.isub = function isub(a, b) {
      this._verify2(a, b);
      var res = a.isub(b);
      if (res.cmpn(0) < 0) {
        res.iadd(this.m);
      }
      return res;
    };
    Red.prototype.shl = function shl(a, num) {
      this._verify1(a);
      return this.imod(a.ushln(num));
    };
    Red.prototype.imul = function imul(a, b) {
      this._verify2(a, b);
      return this.imod(a.imul(b));
    };
    Red.prototype.mul = function mul(a, b) {
      this._verify2(a, b);
      return this.imod(a.mul(b));
    };
    Red.prototype.isqr = function isqr(a) {
      return this.imul(a, a.clone());
    };
    Red.prototype.sqr = function sqr(a) {
      return this.mul(a, a);
    };
    Red.prototype.sqrt = function sqrt(a) {
      if (a.isZero())
        return a.clone();
      var mod3 = this.m.andln(3);
      assert(mod3 % 2 === 1);
      if (mod3 === 3) {
        var pow = this.m.add(new BN(1)).iushrn(2);
        return this.pow(a, pow);
      }
      var q = this.m.subn(1);
      var s = 0;
      while (!q.isZero() && q.andln(1) === 0) {
        s++;
        q.iushrn(1);
      }
      assert(!q.isZero());
      var one = new BN(1).toRed(this);
      var nOne = one.redNeg();
      var lpow = this.m.subn(1).iushrn(1);
      var z = this.m.bitLength();
      z = new BN(2 * z * z).toRed(this);
      while (this.pow(z, lpow).cmp(nOne) !== 0) {
        z.redIAdd(nOne);
      }
      var c = this.pow(z, q);
      var r = this.pow(a, q.addn(1).iushrn(1));
      var t = this.pow(a, q);
      var m = s;
      while (t.cmp(one) !== 0) {
        var tmp = t;
        for (var i = 0; tmp.cmp(one) !== 0; i++) {
          tmp = tmp.redSqr();
        }
        assert(i < m);
        var b = this.pow(c, new BN(1).iushln(m - i - 1));
        r = r.redMul(b);
        c = b.redSqr();
        t = t.redMul(c);
        m = i;
      }
      return r;
    };
    Red.prototype.invm = function invm(a) {
      var inv = a._invmp(this.m);
      if (inv.negative !== 0) {
        inv.negative = 0;
        return this.imod(inv).redNeg();
      } else {
        return this.imod(inv);
      }
    };
    Red.prototype.pow = function pow(a, num) {
      if (num.isZero())
        return new BN(1).toRed(this);
      if (num.cmpn(1) === 0)
        return a.clone();
      var windowSize = 4;
      var wnd = new Array(1 << windowSize);
      wnd[0] = new BN(1).toRed(this);
      wnd[1] = a;
      for (var i = 2; i < wnd.length; i++) {
        wnd[i] = this.mul(wnd[i - 1], a);
      }
      var res = wnd[0];
      var current = 0;
      var currentLen = 0;
      var start = num.bitLength() % 26;
      if (start === 0) {
        start = 26;
      }
      for (i = num.length - 1; i >= 0; i--) {
        var word = num.words[i];
        for (var j = start - 1; j >= 0; j--) {
          var bit = word >> j & 1;
          if (res !== wnd[0]) {
            res = this.sqr(res);
          }
          if (bit === 0 && current === 0) {
            currentLen = 0;
            continue;
          }
          current <<= 1;
          current |= bit;
          currentLen++;
          if (currentLen !== windowSize && (i !== 0 || j !== 0))
            continue;
          res = this.mul(res, wnd[current]);
          currentLen = 0;
          current = 0;
        }
        start = 26;
      }
      return res;
    };
    Red.prototype.convertTo = function convertTo(num) {
      var r = num.umod(this.m);
      return r === num ? r.clone() : r;
    };
    Red.prototype.convertFrom = function convertFrom(num) {
      var res = num.clone();
      res.red = null;
      return res;
    };
    BN.mont = function mont(num) {
      return new Mont(num);
    };
    function Mont(m) {
      Red.call(this, m);
      this.shift = this.m.bitLength();
      if (this.shift % 26 !== 0) {
        this.shift += 26 - this.shift % 26;
      }
      this.r = new BN(1).iushln(this.shift);
      this.r2 = this.imod(this.r.sqr());
      this.rinv = this.r._invmp(this.m);
      this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
      this.minv = this.minv.umod(this.r);
      this.minv = this.r.sub(this.minv);
    }
    inherits(Mont, Red);
    Mont.prototype.convertTo = function convertTo(num) {
      return this.imod(num.ushln(this.shift));
    };
    Mont.prototype.convertFrom = function convertFrom(num) {
      var r = this.imod(num.mul(this.rinv));
      r.red = null;
      return r;
    };
    Mont.prototype.imul = function imul(a, b) {
      if (a.isZero() || b.isZero()) {
        a.words[0] = 0;
        a.length = 1;
        return a;
      }
      var t = a.imul(b);
      var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
      var u = t.isub(c).iushrn(this.shift);
      var res = u;
      if (u.cmp(this.m) >= 0) {
        res = u.isub(this.m);
      } else if (u.cmpn(0) < 0) {
        res = u.iadd(this.m);
      }
      return res._forceRed(this);
    };
    Mont.prototype.mul = function mul(a, b) {
      if (a.isZero() || b.isZero())
        return new BN(0)._forceRed(this);
      var t = a.mul(b);
      var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
      var u = t.isub(c).iushrn(this.shift);
      var res = u;
      if (u.cmp(this.m) >= 0) {
        res = u.isub(this.m);
      } else if (u.cmpn(0) < 0) {
        res = u.iadd(this.m);
      }
      return res._forceRed(this);
    };
    Mont.prototype.invm = function invm(a) {
      var res = this.imod(a._invmp(this.m).mul(this.r2));
      return res._forceRed(this);
    };
  })(typeof module2 === "undefined" || module2, exports2);
});

// node_modules/minimalistic-assert/index.js
var require_minimalistic_assert = __commonJS((exports2, module2) => {
  module2.exports = assert;
  function assert(val, msg) {
    if (!val)
      throw new Error(msg || "Assertion failed");
  }
  assert.equal = function assertEqual(l, r, msg) {
    if (l != r)
      throw new Error(msg || "Assertion failed: " + l + " != " + r);
  };
});

// node_modules/minimalistic-crypto-utils/lib/utils.js
var require_utils2 = __commonJS((exports2) => {
  "use strict";
  var utils = exports2;
  function toArray(msg, enc) {
    if (Array.isArray(msg))
      return msg.slice();
    if (!msg)
      return [];
    var res = [];
    if (typeof msg !== "string") {
      for (var i = 0; i < msg.length; i++)
        res[i] = msg[i] | 0;
      return res;
    }
    if (enc === "hex") {
      msg = msg.replace(/[^a-z0-9]+/ig, "");
      if (msg.length % 2 !== 0)
        msg = "0" + msg;
      for (var i = 0; i < msg.length; i += 2)
        res.push(parseInt(msg[i] + msg[i + 1], 16));
    } else {
      for (var i = 0; i < msg.length; i++) {
        var c = msg.charCodeAt(i);
        var hi = c >> 8;
        var lo = c & 255;
        if (hi)
          res.push(hi, lo);
        else
          res.push(lo);
      }
    }
    return res;
  }
  utils.toArray = toArray;
  function zero2(word) {
    if (word.length === 1)
      return "0" + word;
    else
      return word;
  }
  utils.zero2 = zero2;
  function toHex(msg) {
    var res = "";
    for (var i = 0; i < msg.length; i++)
      res += zero2(msg[i].toString(16));
    return res;
  }
  utils.toHex = toHex;
  utils.encode = function encode(arr, enc) {
    if (enc === "hex")
      return toHex(arr);
    else
      return arr;
  };
});

// node_modules/elliptic/lib/elliptic/utils.js
var require_utils3 = __commonJS((exports2) => {
  "use strict";
  var utils = exports2;
  var BN = require_bn();
  var minAssert = require_minimalistic_assert();
  var minUtils = require_utils2();
  utils.assert = minAssert;
  utils.toArray = minUtils.toArray;
  utils.zero2 = minUtils.zero2;
  utils.toHex = minUtils.toHex;
  utils.encode = minUtils.encode;
  function getNAF(num, w, bits) {
    var naf = new Array(Math.max(num.bitLength(), bits) + 1);
    naf.fill(0);
    var ws = 1 << w + 1;
    var k = num.clone();
    for (var i = 0; i < naf.length; i++) {
      var z;
      var mod = k.andln(ws - 1);
      if (k.isOdd()) {
        if (mod > (ws >> 1) - 1)
          z = (ws >> 1) - mod;
        else
          z = mod;
        k.isubn(z);
      } else {
        z = 0;
      }
      naf[i] = z;
      k.iushrn(1);
    }
    return naf;
  }
  utils.getNAF = getNAF;
  function getJSF(k1, k2) {
    var jsf = [
      [],
      []
    ];
    k1 = k1.clone();
    k2 = k2.clone();
    var d1 = 0;
    var d2 = 0;
    while (k1.cmpn(-d1) > 0 || k2.cmpn(-d2) > 0) {
      var m14 = k1.andln(3) + d1 & 3;
      var m24 = k2.andln(3) + d2 & 3;
      if (m14 === 3)
        m14 = -1;
      if (m24 === 3)
        m24 = -1;
      var u1;
      if ((m14 & 1) === 0) {
        u1 = 0;
      } else {
        var m8 = k1.andln(7) + d1 & 7;
        if ((m8 === 3 || m8 === 5) && m24 === 2)
          u1 = -m14;
        else
          u1 = m14;
      }
      jsf[0].push(u1);
      var u2;
      if ((m24 & 1) === 0) {
        u2 = 0;
      } else {
        var m8 = k2.andln(7) + d2 & 7;
        if ((m8 === 3 || m8 === 5) && m14 === 2)
          u2 = -m24;
        else
          u2 = m24;
      }
      jsf[1].push(u2);
      if (2 * d1 === u1 + 1)
        d1 = 1 - d1;
      if (2 * d2 === u2 + 1)
        d2 = 1 - d2;
      k1.iushrn(1);
      k2.iushrn(1);
    }
    return jsf;
  }
  utils.getJSF = getJSF;
  function cachedProperty(obj, name, computer) {
    var key = "_" + name;
    obj.prototype[name] = function cachedProperty2() {
      return this[key] !== void 0 ? this[key] : this[key] = computer.call(this);
    };
  }
  utils.cachedProperty = cachedProperty;
  function parseBytes(bytes) {
    return typeof bytes === "string" ? utils.toArray(bytes, "hex") : bytes;
  }
  utils.parseBytes = parseBytes;
  function intFromLE(bytes) {
    return new BN(bytes, "hex", "le");
  }
  utils.intFromLE = intFromLE;
});

// node_modules/brorand/index.js
var require_brorand = __commonJS((exports2, module2) => {
  var r;
  module2.exports = function rand(len) {
    if (!r)
      r = new Rand(null);
    return r.generate(len);
  };
  function Rand(rand) {
    this.rand = rand;
  }
  module2.exports.Rand = Rand;
  Rand.prototype.generate = function generate(len) {
    return this._rand(len);
  };
  Rand.prototype._rand = function _rand(n) {
    if (this.rand.getBytes)
      return this.rand.getBytes(n);
    var res = new Uint8Array(n);
    for (var i = 0; i < res.length; i++)
      res[i] = this.rand.getByte();
    return res;
  };
  if (typeof self === "object") {
    if (self.crypto && self.crypto.getRandomValues) {
      Rand.prototype._rand = function _rand(n) {
        var arr = new Uint8Array(n);
        self.crypto.getRandomValues(arr);
        return arr;
      };
    } else if (self.msCrypto && self.msCrypto.getRandomValues) {
      Rand.prototype._rand = function _rand(n) {
        var arr = new Uint8Array(n);
        self.msCrypto.getRandomValues(arr);
        return arr;
      };
    } else if (typeof window === "object") {
      Rand.prototype._rand = function() {
        throw new Error("Not implemented yet");
      };
    }
  } else {
    try {
      crypto2 = require_crypto();
      if (typeof crypto2.randomBytes !== "function")
        throw new Error("Not supported");
      Rand.prototype._rand = function _rand(n) {
        return crypto2.randomBytes(n);
      };
    } catch (e) {
    }
  }
  var crypto2;
});

// node_modules/elliptic/lib/elliptic/curve/base.js
var require_base2 = __commonJS((exports2, module2) => {
  "use strict";
  var BN = require_bn();
  var utils = require_utils3();
  var getNAF = utils.getNAF;
  var getJSF = utils.getJSF;
  var assert = utils.assert;
  function BaseCurve(type, conf) {
    this.type = type;
    this.p = new BN(conf.p, 16);
    this.red = conf.prime ? BN.red(conf.prime) : BN.mont(this.p);
    this.zero = new BN(0).toRed(this.red);
    this.one = new BN(1).toRed(this.red);
    this.two = new BN(2).toRed(this.red);
    this.n = conf.n && new BN(conf.n, 16);
    this.g = conf.g && this.pointFromJSON(conf.g, conf.gRed);
    this._wnafT1 = new Array(4);
    this._wnafT2 = new Array(4);
    this._wnafT3 = new Array(4);
    this._wnafT4 = new Array(4);
    this._bitLength = this.n ? this.n.bitLength() : 0;
    var adjustCount = this.n && this.p.div(this.n);
    if (!adjustCount || adjustCount.cmpn(100) > 0) {
      this.redN = null;
    } else {
      this._maxwellTrick = true;
      this.redN = this.n.toRed(this.red);
    }
  }
  module2.exports = BaseCurve;
  BaseCurve.prototype.point = function point() {
    throw new Error("Not implemented");
  };
  BaseCurve.prototype.validate = function validate() {
    throw new Error("Not implemented");
  };
  BaseCurve.prototype._fixedNafMul = function _fixedNafMul(p, k) {
    assert(p.precomputed);
    var doubles = p._getDoubles();
    var naf = getNAF(k, 1, this._bitLength);
    var I = (1 << doubles.step + 1) - (doubles.step % 2 === 0 ? 2 : 1);
    I /= 3;
    var repr = [];
    for (var j = 0; j < naf.length; j += doubles.step) {
      var nafW = 0;
      for (var k = j + doubles.step - 1; k >= j; k--)
        nafW = (nafW << 1) + naf[k];
      repr.push(nafW);
    }
    var a = this.jpoint(null, null, null);
    var b = this.jpoint(null, null, null);
    for (var i = I; i > 0; i--) {
      for (var j = 0; j < repr.length; j++) {
        var nafW = repr[j];
        if (nafW === i)
          b = b.mixedAdd(doubles.points[j]);
        else if (nafW === -i)
          b = b.mixedAdd(doubles.points[j].neg());
      }
      a = a.add(b);
    }
    return a.toP();
  };
  BaseCurve.prototype._wnafMul = function _wnafMul(p, k) {
    var w = 4;
    var nafPoints = p._getNAFPoints(w);
    w = nafPoints.wnd;
    var wnd = nafPoints.points;
    var naf = getNAF(k, w, this._bitLength);
    var acc = this.jpoint(null, null, null);
    for (var i = naf.length - 1; i >= 0; i--) {
      for (var k = 0; i >= 0 && naf[i] === 0; i--)
        k++;
      if (i >= 0)
        k++;
      acc = acc.dblp(k);
      if (i < 0)
        break;
      var z = naf[i];
      assert(z !== 0);
      if (p.type === "affine") {
        if (z > 0)
          acc = acc.mixedAdd(wnd[z - 1 >> 1]);
        else
          acc = acc.mixedAdd(wnd[-z - 1 >> 1].neg());
      } else {
        if (z > 0)
          acc = acc.add(wnd[z - 1 >> 1]);
        else
          acc = acc.add(wnd[-z - 1 >> 1].neg());
      }
    }
    return p.type === "affine" ? acc.toP() : acc;
  };
  BaseCurve.prototype._wnafMulAdd = function _wnafMulAdd(defW, points, coeffs, len, jacobianResult) {
    var wndWidth = this._wnafT1;
    var wnd = this._wnafT2;
    var naf = this._wnafT3;
    var max = 0;
    for (var i = 0; i < len; i++) {
      var p = points[i];
      var nafPoints = p._getNAFPoints(defW);
      wndWidth[i] = nafPoints.wnd;
      wnd[i] = nafPoints.points;
    }
    for (var i = len - 1; i >= 1; i -= 2) {
      var a = i - 1;
      var b = i;
      if (wndWidth[a] !== 1 || wndWidth[b] !== 1) {
        naf[a] = getNAF(coeffs[a], wndWidth[a], this._bitLength);
        naf[b] = getNAF(coeffs[b], wndWidth[b], this._bitLength);
        max = Math.max(naf[a].length, max);
        max = Math.max(naf[b].length, max);
        continue;
      }
      var comb = [
        points[a],
        null,
        null,
        points[b]
      ];
      if (points[a].y.cmp(points[b].y) === 0) {
        comb[1] = points[a].add(points[b]);
        comb[2] = points[a].toJ().mixedAdd(points[b].neg());
      } else if (points[a].y.cmp(points[b].y.redNeg()) === 0) {
        comb[1] = points[a].toJ().mixedAdd(points[b]);
        comb[2] = points[a].add(points[b].neg());
      } else {
        comb[1] = points[a].toJ().mixedAdd(points[b]);
        comb[2] = points[a].toJ().mixedAdd(points[b].neg());
      }
      var index = [
        -3,
        -1,
        -5,
        -7,
        0,
        7,
        5,
        1,
        3
      ];
      var jsf = getJSF(coeffs[a], coeffs[b]);
      max = Math.max(jsf[0].length, max);
      naf[a] = new Array(max);
      naf[b] = new Array(max);
      for (var j = 0; j < max; j++) {
        var ja = jsf[0][j] | 0;
        var jb = jsf[1][j] | 0;
        naf[a][j] = index[(ja + 1) * 3 + (jb + 1)];
        naf[b][j] = 0;
        wnd[a] = comb;
      }
    }
    var acc = this.jpoint(null, null, null);
    var tmp = this._wnafT4;
    for (var i = max; i >= 0; i--) {
      var k = 0;
      while (i >= 0) {
        var zero = true;
        for (var j = 0; j < len; j++) {
          tmp[j] = naf[j][i] | 0;
          if (tmp[j] !== 0)
            zero = false;
        }
        if (!zero)
          break;
        k++;
        i--;
      }
      if (i >= 0)
        k++;
      acc = acc.dblp(k);
      if (i < 0)
        break;
      for (var j = 0; j < len; j++) {
        var z = tmp[j];
        var p;
        if (z === 0)
          continue;
        else if (z > 0)
          p = wnd[j][z - 1 >> 1];
        else if (z < 0)
          p = wnd[j][-z - 1 >> 1].neg();
        if (p.type === "affine")
          acc = acc.mixedAdd(p);
        else
          acc = acc.add(p);
      }
    }
    for (var i = 0; i < len; i++)
      wnd[i] = null;
    if (jacobianResult)
      return acc;
    else
      return acc.toP();
  };
  function BasePoint(curve, type) {
    this.curve = curve;
    this.type = type;
    this.precomputed = null;
  }
  BaseCurve.BasePoint = BasePoint;
  BasePoint.prototype.eq = function eq() {
    throw new Error("Not implemented");
  };
  BasePoint.prototype.validate = function validate() {
    return this.curve.validate(this);
  };
  BaseCurve.prototype.decodePoint = function decodePoint(bytes, enc) {
    bytes = utils.toArray(bytes, enc);
    var len = this.p.byteLength();
    if ((bytes[0] === 4 || bytes[0] === 6 || bytes[0] === 7) && bytes.length - 1 === 2 * len) {
      if (bytes[0] === 6)
        assert(bytes[bytes.length - 1] % 2 === 0);
      else if (bytes[0] === 7)
        assert(bytes[bytes.length - 1] % 2 === 1);
      var res = this.point(bytes.slice(1, 1 + len), bytes.slice(1 + len, 1 + 2 * len));
      return res;
    } else if ((bytes[0] === 2 || bytes[0] === 3) && bytes.length - 1 === len) {
      return this.pointFromX(bytes.slice(1, 1 + len), bytes[0] === 3);
    }
    throw new Error("Unknown point format");
  };
  BasePoint.prototype.encodeCompressed = function encodeCompressed(enc) {
    return this.encode(enc, true);
  };
  BasePoint.prototype._encode = function _encode(compact) {
    var len = this.curve.p.byteLength();
    var x = this.getX().toArray("be", len);
    if (compact)
      return [this.getY().isEven() ? 2 : 3].concat(x);
    return [4].concat(x, this.getY().toArray("be", len));
  };
  BasePoint.prototype.encode = function encode(enc, compact) {
    return utils.encode(this._encode(compact), enc);
  };
  BasePoint.prototype.precompute = function precompute(power) {
    if (this.precomputed)
      return this;
    var precomputed = {
      doubles: null,
      naf: null,
      beta: null
    };
    precomputed.naf = this._getNAFPoints(8);
    precomputed.doubles = this._getDoubles(4, power);
    precomputed.beta = this._getBeta();
    this.precomputed = precomputed;
    return this;
  };
  BasePoint.prototype._hasDoubles = function _hasDoubles(k) {
    if (!this.precomputed)
      return false;
    var doubles = this.precomputed.doubles;
    if (!doubles)
      return false;
    return doubles.points.length >= Math.ceil((k.bitLength() + 1) / doubles.step);
  };
  BasePoint.prototype._getDoubles = function _getDoubles(step, power) {
    if (this.precomputed && this.precomputed.doubles)
      return this.precomputed.doubles;
    var doubles = [this];
    var acc = this;
    for (var i = 0; i < power; i += step) {
      for (var j = 0; j < step; j++)
        acc = acc.dbl();
      doubles.push(acc);
    }
    return {
      step,
      points: doubles
    };
  };
  BasePoint.prototype._getNAFPoints = function _getNAFPoints(wnd) {
    if (this.precomputed && this.precomputed.naf)
      return this.precomputed.naf;
    var res = [this];
    var max = (1 << wnd) - 1;
    var dbl = max === 1 ? null : this.dbl();
    for (var i = 1; i < max; i++)
      res[i] = res[i - 1].add(dbl);
    return {
      wnd,
      points: res
    };
  };
  BasePoint.prototype._getBeta = function _getBeta() {
    return null;
  };
  BasePoint.prototype.dblp = function dblp(k) {
    var r = this;
    for (var i = 0; i < k; i++)
      r = r.dbl();
    return r;
  };
});

// node_modules/inherits/inherits_browser.js
var require_inherits_browser = __commonJS((exports2, module2) => {
  if (typeof Object.create === "function") {
    module2.exports = function inherits(ctor, superCtor) {
      if (superCtor) {
        ctor.super_ = superCtor;
        ctor.prototype = Object.create(superCtor.prototype, {
          constructor: {
            value: ctor,
            enumerable: false,
            writable: true,
            configurable: true
          }
        });
      }
    };
  } else {
    module2.exports = function inherits(ctor, superCtor) {
      if (superCtor) {
        ctor.super_ = superCtor;
        var TempCtor = function() {
        };
        TempCtor.prototype = superCtor.prototype;
        ctor.prototype = new TempCtor();
        ctor.prototype.constructor = ctor;
      }
    };
  }
});

// node_modules/elliptic/lib/elliptic/curve/short.js
var require_short = __commonJS((exports2, module2) => {
  "use strict";
  var utils = require_utils3();
  var BN = require_bn();
  var inherits = require_inherits_browser();
  var Base = require_base2();
  var assert = utils.assert;
  function ShortCurve(conf) {
    Base.call(this, "short", conf);
    this.a = new BN(conf.a, 16).toRed(this.red);
    this.b = new BN(conf.b, 16).toRed(this.red);
    this.tinv = this.two.redInvm();
    this.zeroA = this.a.fromRed().cmpn(0) === 0;
    this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0;
    this.endo = this._getEndomorphism(conf);
    this._endoWnafT1 = new Array(4);
    this._endoWnafT2 = new Array(4);
  }
  inherits(ShortCurve, Base);
  module2.exports = ShortCurve;
  ShortCurve.prototype._getEndomorphism = function _getEndomorphism(conf) {
    if (!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)
      return;
    var beta;
    var lambda;
    if (conf.beta) {
      beta = new BN(conf.beta, 16).toRed(this.red);
    } else {
      var betas = this._getEndoRoots(this.p);
      beta = betas[0].cmp(betas[1]) < 0 ? betas[0] : betas[1];
      beta = beta.toRed(this.red);
    }
    if (conf.lambda) {
      lambda = new BN(conf.lambda, 16);
    } else {
      var lambdas = this._getEndoRoots(this.n);
      if (this.g.mul(lambdas[0]).x.cmp(this.g.x.redMul(beta)) === 0) {
        lambda = lambdas[0];
      } else {
        lambda = lambdas[1];
        assert(this.g.mul(lambda).x.cmp(this.g.x.redMul(beta)) === 0);
      }
    }
    var basis;
    if (conf.basis) {
      basis = conf.basis.map(function(vec) {
        return {
          a: new BN(vec.a, 16),
          b: new BN(vec.b, 16)
        };
      });
    } else {
      basis = this._getEndoBasis(lambda);
    }
    return {
      beta,
      lambda,
      basis
    };
  };
  ShortCurve.prototype._getEndoRoots = function _getEndoRoots(num) {
    var red = num === this.p ? this.red : BN.mont(num);
    var tinv = new BN(2).toRed(red).redInvm();
    var ntinv = tinv.redNeg();
    var s = new BN(3).toRed(red).redNeg().redSqrt().redMul(tinv);
    var l1 = ntinv.redAdd(s).fromRed();
    var l2 = ntinv.redSub(s).fromRed();
    return [l1, l2];
  };
  ShortCurve.prototype._getEndoBasis = function _getEndoBasis(lambda) {
    var aprxSqrt = this.n.ushrn(Math.floor(this.n.bitLength() / 2));
    var u = lambda;
    var v = this.n.clone();
    var x1 = new BN(1);
    var y1 = new BN(0);
    var x2 = new BN(0);
    var y2 = new BN(1);
    var a0;
    var b0;
    var a1;
    var b1;
    var a2;
    var b2;
    var prevR;
    var i = 0;
    var r;
    var x;
    while (u.cmpn(0) !== 0) {
      var q = v.div(u);
      r = v.sub(q.mul(u));
      x = x2.sub(q.mul(x1));
      var y = y2.sub(q.mul(y1));
      if (!a1 && r.cmp(aprxSqrt) < 0) {
        a0 = prevR.neg();
        b0 = x1;
        a1 = r.neg();
        b1 = x;
      } else if (a1 && ++i === 2) {
        break;
      }
      prevR = r;
      v = u;
      u = r;
      x2 = x1;
      x1 = x;
      y2 = y1;
      y1 = y;
    }
    a2 = r.neg();
    b2 = x;
    var len1 = a1.sqr().add(b1.sqr());
    var len2 = a2.sqr().add(b2.sqr());
    if (len2.cmp(len1) >= 0) {
      a2 = a0;
      b2 = b0;
    }
    if (a1.negative) {
      a1 = a1.neg();
      b1 = b1.neg();
    }
    if (a2.negative) {
      a2 = a2.neg();
      b2 = b2.neg();
    }
    return [
      {a: a1, b: b1},
      {a: a2, b: b2}
    ];
  };
  ShortCurve.prototype._endoSplit = function _endoSplit(k) {
    var basis = this.endo.basis;
    var v1 = basis[0];
    var v2 = basis[1];
    var c1 = v2.b.mul(k).divRound(this.n);
    var c2 = v1.b.neg().mul(k).divRound(this.n);
    var p1 = c1.mul(v1.a);
    var p2 = c2.mul(v2.a);
    var q1 = c1.mul(v1.b);
    var q2 = c2.mul(v2.b);
    var k1 = k.sub(p1).sub(p2);
    var k2 = q1.add(q2).neg();
    return {k1, k2};
  };
  ShortCurve.prototype.pointFromX = function pointFromX(x, odd) {
    x = new BN(x, 16);
    if (!x.red)
      x = x.toRed(this.red);
    var y2 = x.redSqr().redMul(x).redIAdd(x.redMul(this.a)).redIAdd(this.b);
    var y = y2.redSqrt();
    if (y.redSqr().redSub(y2).cmp(this.zero) !== 0)
      throw new Error("invalid point");
    var isOdd = y.fromRed().isOdd();
    if (odd && !isOdd || !odd && isOdd)
      y = y.redNeg();
    return this.point(x, y);
  };
  ShortCurve.prototype.validate = function validate(point) {
    if (point.inf)
      return true;
    var x = point.x;
    var y = point.y;
    var ax = this.a.redMul(x);
    var rhs = x.redSqr().redMul(x).redIAdd(ax).redIAdd(this.b);
    return y.redSqr().redISub(rhs).cmpn(0) === 0;
  };
  ShortCurve.prototype._endoWnafMulAdd = function _endoWnafMulAdd(points, coeffs, jacobianResult) {
    var npoints = this._endoWnafT1;
    var ncoeffs = this._endoWnafT2;
    for (var i = 0; i < points.length; i++) {
      var split = this._endoSplit(coeffs[i]);
      var p = points[i];
      var beta = p._getBeta();
      if (split.k1.negative) {
        split.k1.ineg();
        p = p.neg(true);
      }
      if (split.k2.negative) {
        split.k2.ineg();
        beta = beta.neg(true);
      }
      npoints[i * 2] = p;
      npoints[i * 2 + 1] = beta;
      ncoeffs[i * 2] = split.k1;
      ncoeffs[i * 2 + 1] = split.k2;
    }
    var res = this._wnafMulAdd(1, npoints, ncoeffs, i * 2, jacobianResult);
    for (var j = 0; j < i * 2; j++) {
      npoints[j] = null;
      ncoeffs[j] = null;
    }
    return res;
  };
  function Point(curve, x, y, isRed) {
    Base.BasePoint.call(this, curve, "affine");
    if (x === null && y === null) {
      this.x = null;
      this.y = null;
      this.inf = true;
    } else {
      this.x = new BN(x, 16);
      this.y = new BN(y, 16);
      if (isRed) {
        this.x.forceRed(this.curve.red);
        this.y.forceRed(this.curve.red);
      }
      if (!this.x.red)
        this.x = this.x.toRed(this.curve.red);
      if (!this.y.red)
        this.y = this.y.toRed(this.curve.red);
      this.inf = false;
    }
  }
  inherits(Point, Base.BasePoint);
  ShortCurve.prototype.point = function point(x, y, isRed) {
    return new Point(this, x, y, isRed);
  };
  ShortCurve.prototype.pointFromJSON = function pointFromJSON(obj, red) {
    return Point.fromJSON(this, obj, red);
  };
  Point.prototype._getBeta = function _getBeta() {
    if (!this.curve.endo)
      return;
    var pre = this.precomputed;
    if (pre && pre.beta)
      return pre.beta;
    var beta = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
    if (pre) {
      var curve = this.curve;
      var endoMul = function(p) {
        return curve.point(p.x.redMul(curve.endo.beta), p.y);
      };
      pre.beta = beta;
      beta.precomputed = {
        beta: null,
        naf: pre.naf && {
          wnd: pre.naf.wnd,
          points: pre.naf.points.map(endoMul)
        },
        doubles: pre.doubles && {
          step: pre.doubles.step,
          points: pre.doubles.points.map(endoMul)
        }
      };
    }
    return beta;
  };
  Point.prototype.toJSON = function toJSON() {
    if (!this.precomputed)
      return [this.x, this.y];
    return [this.x, this.y, this.precomputed && {
      doubles: this.precomputed.doubles && {
        step: this.precomputed.doubles.step,
        points: this.precomputed.doubles.points.slice(1)
      },
      naf: this.precomputed.naf && {
        wnd: this.precomputed.naf.wnd,
        points: this.precomputed.naf.points.slice(1)
      }
    }];
  };
  Point.fromJSON = function fromJSON(curve, obj, red) {
    if (typeof obj === "string")
      obj = JSON.parse(obj);
    var res = curve.point(obj[0], obj[1], red);
    if (!obj[2])
      return res;
    function obj2point(obj2) {
      return curve.point(obj2[0], obj2[1], red);
    }
    var pre = obj[2];
    res.precomputed = {
      beta: null,
      doubles: pre.doubles && {
        step: pre.doubles.step,
        points: [res].concat(pre.doubles.points.map(obj2point))
      },
      naf: pre.naf && {
        wnd: pre.naf.wnd,
        points: [res].concat(pre.naf.points.map(obj2point))
      }
    };
    return res;
  };
  Point.prototype.inspect = function inspect() {
    if (this.isInfinity())
      return "<EC Point Infinity>";
    return "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + ">";
  };
  Point.prototype.isInfinity = function isInfinity() {
    return this.inf;
  };
  Point.prototype.add = function add(p) {
    if (this.inf)
      return p;
    if (p.inf)
      return this;
    if (this.eq(p))
      return this.dbl();
    if (this.neg().eq(p))
      return this.curve.point(null, null);
    if (this.x.cmp(p.x) === 0)
      return this.curve.point(null, null);
    var c = this.y.redSub(p.y);
    if (c.cmpn(0) !== 0)
      c = c.redMul(this.x.redSub(p.x).redInvm());
    var nx = c.redSqr().redISub(this.x).redISub(p.x);
    var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);
    return this.curve.point(nx, ny);
  };
  Point.prototype.dbl = function dbl() {
    if (this.inf)
      return this;
    var ys1 = this.y.redAdd(this.y);
    if (ys1.cmpn(0) === 0)
      return this.curve.point(null, null);
    var a = this.curve.a;
    var x2 = this.x.redSqr();
    var dyinv = ys1.redInvm();
    var c = x2.redAdd(x2).redIAdd(x2).redIAdd(a).redMul(dyinv);
    var nx = c.redSqr().redISub(this.x.redAdd(this.x));
    var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);
    return this.curve.point(nx, ny);
  };
  Point.prototype.getX = function getX() {
    return this.x.fromRed();
  };
  Point.prototype.getY = function getY() {
    return this.y.fromRed();
  };
  Point.prototype.mul = function mul(k) {
    k = new BN(k, 16);
    if (this.isInfinity())
      return this;
    else if (this._hasDoubles(k))
      return this.curve._fixedNafMul(this, k);
    else if (this.curve.endo)
      return this.curve._endoWnafMulAdd([this], [k]);
    else
      return this.curve._wnafMul(this, k);
  };
  Point.prototype.mulAdd = function mulAdd(k1, p2, k2) {
    var points = [this, p2];
    var coeffs = [k1, k2];
    if (this.curve.endo)
      return this.curve._endoWnafMulAdd(points, coeffs);
    else
      return this.curve._wnafMulAdd(1, points, coeffs, 2);
  };
  Point.prototype.jmulAdd = function jmulAdd(k1, p2, k2) {
    var points = [this, p2];
    var coeffs = [k1, k2];
    if (this.curve.endo)
      return this.curve._endoWnafMulAdd(points, coeffs, true);
    else
      return this.curve._wnafMulAdd(1, points, coeffs, 2, true);
  };
  Point.prototype.eq = function eq(p) {
    return this === p || this.inf === p.inf && (this.inf || this.x.cmp(p.x) === 0 && this.y.cmp(p.y) === 0);
  };
  Point.prototype.neg = function neg(_precompute) {
    if (this.inf)
      return this;
    var res = this.curve.point(this.x, this.y.redNeg());
    if (_precompute && this.precomputed) {
      var pre = this.precomputed;
      var negate = function(p) {
        return p.neg();
      };
      res.precomputed = {
        naf: pre.naf && {
          wnd: pre.naf.wnd,
          points: pre.naf.points.map(negate)
        },
        doubles: pre.doubles && {
          step: pre.doubles.step,
          points: pre.doubles.points.map(negate)
        }
      };
    }
    return res;
  };
  Point.prototype.toJ = function toJ() {
    if (this.inf)
      return this.curve.jpoint(null, null, null);
    var res = this.curve.jpoint(this.x, this.y, this.curve.one);
    return res;
  };
  function JPoint(curve, x, y, z) {
    Base.BasePoint.call(this, curve, "jacobian");
    if (x === null && y === null && z === null) {
      this.x = this.curve.one;
      this.y = this.curve.one;
      this.z = new BN(0);
    } else {
      this.x = new BN(x, 16);
      this.y = new BN(y, 16);
      this.z = new BN(z, 16);
    }
    if (!this.x.red)
      this.x = this.x.toRed(this.curve.red);
    if (!this.y.red)
      this.y = this.y.toRed(this.curve.red);
    if (!this.z.red)
      this.z = this.z.toRed(this.curve.red);
    this.zOne = this.z === this.curve.one;
  }
  inherits(JPoint, Base.BasePoint);
  ShortCurve.prototype.jpoint = function jpoint(x, y, z) {
    return new JPoint(this, x, y, z);
  };
  JPoint.prototype.toP = function toP() {
    if (this.isInfinity())
      return this.curve.point(null, null);
    var zinv = this.z.redInvm();
    var zinv2 = zinv.redSqr();
    var ax = this.x.redMul(zinv2);
    var ay = this.y.redMul(zinv2).redMul(zinv);
    return this.curve.point(ax, ay);
  };
  JPoint.prototype.neg = function neg() {
    return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
  };
  JPoint.prototype.add = function add(p) {
    if (this.isInfinity())
      return p;
    if (p.isInfinity())
      return this;
    var pz2 = p.z.redSqr();
    var z2 = this.z.redSqr();
    var u1 = this.x.redMul(pz2);
    var u2 = p.x.redMul(z2);
    var s1 = this.y.redMul(pz2.redMul(p.z));
    var s2 = p.y.redMul(z2.redMul(this.z));
    var h = u1.redSub(u2);
    var r = s1.redSub(s2);
    if (h.cmpn(0) === 0) {
      if (r.cmpn(0) !== 0)
        return this.curve.jpoint(null, null, null);
      else
        return this.dbl();
    }
    var h2 = h.redSqr();
    var h3 = h2.redMul(h);
    var v = u1.redMul(h2);
    var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);
    var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));
    var nz = this.z.redMul(p.z).redMul(h);
    return this.curve.jpoint(nx, ny, nz);
  };
  JPoint.prototype.mixedAdd = function mixedAdd(p) {
    if (this.isInfinity())
      return p.toJ();
    if (p.isInfinity())
      return this;
    var z2 = this.z.redSqr();
    var u1 = this.x;
    var u2 = p.x.redMul(z2);
    var s1 = this.y;
    var s2 = p.y.redMul(z2).redMul(this.z);
    var h = u1.redSub(u2);
    var r = s1.redSub(s2);
    if (h.cmpn(0) === 0) {
      if (r.cmpn(0) !== 0)
        return this.curve.jpoint(null, null, null);
      else
        return this.dbl();
    }
    var h2 = h.redSqr();
    var h3 = h2.redMul(h);
    var v = u1.redMul(h2);
    var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);
    var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));
    var nz = this.z.redMul(h);
    return this.curve.jpoint(nx, ny, nz);
  };
  JPoint.prototype.dblp = function dblp(pow) {
    if (pow === 0)
      return this;
    if (this.isInfinity())
      return this;
    if (!pow)
      return this.dbl();
    if (this.curve.zeroA || this.curve.threeA) {
      var r = this;
      for (var i = 0; i < pow; i++)
        r = r.dbl();
      return r;
    }
    var a = this.curve.a;
    var tinv = this.curve.tinv;
    var jx = this.x;
    var jy = this.y;
    var jz = this.z;
    var jz4 = jz.redSqr().redSqr();
    var jyd = jy.redAdd(jy);
    for (var i = 0; i < pow; i++) {
      var jx2 = jx.redSqr();
      var jyd2 = jyd.redSqr();
      var jyd4 = jyd2.redSqr();
      var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));
      var t1 = jx.redMul(jyd2);
      var nx = c.redSqr().redISub(t1.redAdd(t1));
      var t2 = t1.redISub(nx);
      var dny = c.redMul(t2);
      dny = dny.redIAdd(dny).redISub(jyd4);
      var nz = jyd.redMul(jz);
      if (i + 1 < pow)
        jz4 = jz4.redMul(jyd4);
      jx = nx;
      jz = nz;
      jyd = dny;
    }
    return this.curve.jpoint(jx, jyd.redMul(tinv), jz);
  };
  JPoint.prototype.dbl = function dbl() {
    if (this.isInfinity())
      return this;
    if (this.curve.zeroA)
      return this._zeroDbl();
    else if (this.curve.threeA)
      return this._threeDbl();
    else
      return this._dbl();
  };
  JPoint.prototype._zeroDbl = function _zeroDbl() {
    var nx;
    var ny;
    var nz;
    if (this.zOne) {
      var xx = this.x.redSqr();
      var yy = this.y.redSqr();
      var yyyy = yy.redSqr();
      var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
      s = s.redIAdd(s);
      var m = xx.redAdd(xx).redIAdd(xx);
      var t = m.redSqr().redISub(s).redISub(s);
      var yyyy8 = yyyy.redIAdd(yyyy);
      yyyy8 = yyyy8.redIAdd(yyyy8);
      yyyy8 = yyyy8.redIAdd(yyyy8);
      nx = t;
      ny = m.redMul(s.redISub(t)).redISub(yyyy8);
      nz = this.y.redAdd(this.y);
    } else {
      var a = this.x.redSqr();
      var b = this.y.redSqr();
      var c = b.redSqr();
      var d = this.x.redAdd(b).redSqr().redISub(a).redISub(c);
      d = d.redIAdd(d);
      var e = a.redAdd(a).redIAdd(a);
      var f = e.redSqr();
      var c8 = c.redIAdd(c);
      c8 = c8.redIAdd(c8);
      c8 = c8.redIAdd(c8);
      nx = f.redISub(d).redISub(d);
      ny = e.redMul(d.redISub(nx)).redISub(c8);
      nz = this.y.redMul(this.z);
      nz = nz.redIAdd(nz);
    }
    return this.curve.jpoint(nx, ny, nz);
  };
  JPoint.prototype._threeDbl = function _threeDbl() {
    var nx;
    var ny;
    var nz;
    if (this.zOne) {
      var xx = this.x.redSqr();
      var yy = this.y.redSqr();
      var yyyy = yy.redSqr();
      var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
      s = s.redIAdd(s);
      var m = xx.redAdd(xx).redIAdd(xx).redIAdd(this.curve.a);
      var t = m.redSqr().redISub(s).redISub(s);
      nx = t;
      var yyyy8 = yyyy.redIAdd(yyyy);
      yyyy8 = yyyy8.redIAdd(yyyy8);
      yyyy8 = yyyy8.redIAdd(yyyy8);
      ny = m.redMul(s.redISub(t)).redISub(yyyy8);
      nz = this.y.redAdd(this.y);
    } else {
      var delta = this.z.redSqr();
      var gamma = this.y.redSqr();
      var beta = this.x.redMul(gamma);
      var alpha = this.x.redSub(delta).redMul(this.x.redAdd(delta));
      alpha = alpha.redAdd(alpha).redIAdd(alpha);
      var beta4 = beta.redIAdd(beta);
      beta4 = beta4.redIAdd(beta4);
      var beta8 = beta4.redAdd(beta4);
      nx = alpha.redSqr().redISub(beta8);
      nz = this.y.redAdd(this.z).redSqr().redISub(gamma).redISub(delta);
      var ggamma8 = gamma.redSqr();
      ggamma8 = ggamma8.redIAdd(ggamma8);
      ggamma8 = ggamma8.redIAdd(ggamma8);
      ggamma8 = ggamma8.redIAdd(ggamma8);
      ny = alpha.redMul(beta4.redISub(nx)).redISub(ggamma8);
    }
    return this.curve.jpoint(nx, ny, nz);
  };
  JPoint.prototype._dbl = function _dbl() {
    var a = this.curve.a;
    var jx = this.x;
    var jy = this.y;
    var jz = this.z;
    var jz4 = jz.redSqr().redSqr();
    var jx2 = jx.redSqr();
    var jy2 = jy.redSqr();
    var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));
    var jxd4 = jx.redAdd(jx);
    jxd4 = jxd4.redIAdd(jxd4);
    var t1 = jxd4.redMul(jy2);
    var nx = c.redSqr().redISub(t1.redAdd(t1));
    var t2 = t1.redISub(nx);
    var jyd8 = jy2.redSqr();
    jyd8 = jyd8.redIAdd(jyd8);
    jyd8 = jyd8.redIAdd(jyd8);
    jyd8 = jyd8.redIAdd(jyd8);
    var ny = c.redMul(t2).redISub(jyd8);
    var nz = jy.redAdd(jy).redMul(jz);
    return this.curve.jpoint(nx, ny, nz);
  };
  JPoint.prototype.trpl = function trpl() {
    if (!this.curve.zeroA)
      return this.dbl().add(this);
    var xx = this.x.redSqr();
    var yy = this.y.redSqr();
    var zz = this.z.redSqr();
    var yyyy = yy.redSqr();
    var m = xx.redAdd(xx).redIAdd(xx);
    var mm = m.redSqr();
    var e = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
    e = e.redIAdd(e);
    e = e.redAdd(e).redIAdd(e);
    e = e.redISub(mm);
    var ee = e.redSqr();
    var t = yyyy.redIAdd(yyyy);
    t = t.redIAdd(t);
    t = t.redIAdd(t);
    t = t.redIAdd(t);
    var u = m.redIAdd(e).redSqr().redISub(mm).redISub(ee).redISub(t);
    var yyu4 = yy.redMul(u);
    yyu4 = yyu4.redIAdd(yyu4);
    yyu4 = yyu4.redIAdd(yyu4);
    var nx = this.x.redMul(ee).redISub(yyu4);
    nx = nx.redIAdd(nx);
    nx = nx.redIAdd(nx);
    var ny = this.y.redMul(u.redMul(t.redISub(u)).redISub(e.redMul(ee)));
    ny = ny.redIAdd(ny);
    ny = ny.redIAdd(ny);
    ny = ny.redIAdd(ny);
    var nz = this.z.redAdd(e).redSqr().redISub(zz).redISub(ee);
    return this.curve.jpoint(nx, ny, nz);
  };
  JPoint.prototype.mul = function mul(k, kbase) {
    k = new BN(k, kbase);
    return this.curve._wnafMul(this, k);
  };
  JPoint.prototype.eq = function eq(p) {
    if (p.type === "affine")
      return this.eq(p.toJ());
    if (this === p)
      return true;
    var z2 = this.z.redSqr();
    var pz2 = p.z.redSqr();
    if (this.x.redMul(pz2).redISub(p.x.redMul(z2)).cmpn(0) !== 0)
      return false;
    var z3 = z2.redMul(this.z);
    var pz3 = pz2.redMul(p.z);
    return this.y.redMul(pz3).redISub(p.y.redMul(z3)).cmpn(0) === 0;
  };
  JPoint.prototype.eqXToP = function eqXToP(x) {
    var zs = this.z.redSqr();
    var rx = x.toRed(this.curve.red).redMul(zs);
    if (this.x.cmp(rx) === 0)
      return true;
    var xc = x.clone();
    var t = this.curve.redN.redMul(zs);
    for (; ; ) {
      xc.iadd(this.curve.n);
      if (xc.cmp(this.curve.p) >= 0)
        return false;
      rx.redIAdd(t);
      if (this.x.cmp(rx) === 0)
        return true;
    }
  };
  JPoint.prototype.inspect = function inspect() {
    if (this.isInfinity())
      return "<EC JPoint Infinity>";
    return "<EC JPoint x: " + this.x.toString(16, 2) + " y: " + this.y.toString(16, 2) + " z: " + this.z.toString(16, 2) + ">";
  };
  JPoint.prototype.isInfinity = function isInfinity() {
    return this.z.cmpn(0) === 0;
  };
});

// node_modules/elliptic/lib/elliptic/curve/mont.js
var require_mont = __commonJS((exports2, module2) => {
  "use strict";
  var BN = require_bn();
  var inherits = require_inherits_browser();
  var Base = require_base2();
  var utils = require_utils3();
  function MontCurve(conf) {
    Base.call(this, "mont", conf);
    this.a = new BN(conf.a, 16).toRed(this.red);
    this.b = new BN(conf.b, 16).toRed(this.red);
    this.i4 = new BN(4).toRed(this.red).redInvm();
    this.two = new BN(2).toRed(this.red);
    this.a24 = this.i4.redMul(this.a.redAdd(this.two));
  }
  inherits(MontCurve, Base);
  module2.exports = MontCurve;
  MontCurve.prototype.validate = function validate(point) {
    var x = point.normalize().x;
    var x2 = x.redSqr();
    var rhs = x2.redMul(x).redAdd(x2.redMul(this.a)).redAdd(x);
    var y = rhs.redSqrt();
    return y.redSqr().cmp(rhs) === 0;
  };
  function Point(curve, x, z) {
    Base.BasePoint.call(this, curve, "projective");
    if (x === null && z === null) {
      this.x = this.curve.one;
      this.z = this.curve.zero;
    } else {
      this.x = new BN(x, 16);
      this.z = new BN(z, 16);
      if (!this.x.red)
        this.x = this.x.toRed(this.curve.red);
      if (!this.z.red)
        this.z = this.z.toRed(this.curve.red);
    }
  }
  inherits(Point, Base.BasePoint);
  MontCurve.prototype.decodePoint = function decodePoint(bytes, enc) {
    return this.point(utils.toArray(bytes, enc), 1);
  };
  MontCurve.prototype.point = function point(x, z) {
    return new Point(this, x, z);
  };
  MontCurve.prototype.pointFromJSON = function pointFromJSON(obj) {
    return Point.fromJSON(this, obj);
  };
  Point.prototype.precompute = function precompute() {
  };
  Point.prototype._encode = function _encode() {
    return this.getX().toArray("be", this.curve.p.byteLength());
  };
  Point.fromJSON = function fromJSON(curve, obj) {
    return new Point(curve, obj[0], obj[1] || curve.one);
  };
  Point.prototype.inspect = function inspect() {
    if (this.isInfinity())
      return "<EC Point Infinity>";
    return "<EC Point x: " + this.x.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
  };
  Point.prototype.isInfinity = function isInfinity() {
    return this.z.cmpn(0) === 0;
  };
  Point.prototype.dbl = function dbl() {
    var a = this.x.redAdd(this.z);
    var aa = a.redSqr();
    var b = this.x.redSub(this.z);
    var bb = b.redSqr();
    var c = aa.redSub(bb);
    var nx = aa.redMul(bb);
    var nz = c.redMul(bb.redAdd(this.curve.a24.redMul(c)));
    return this.curve.point(nx, nz);
  };
  Point.prototype.add = function add() {
    throw new Error("Not supported on Montgomery curve");
  };
  Point.prototype.diffAdd = function diffAdd(p, diff) {
    var a = this.x.redAdd(this.z);
    var b = this.x.redSub(this.z);
    var c = p.x.redAdd(p.z);
    var d = p.x.redSub(p.z);
    var da = d.redMul(a);
    var cb = c.redMul(b);
    var nx = diff.z.redMul(da.redAdd(cb).redSqr());
    var nz = diff.x.redMul(da.redISub(cb).redSqr());
    return this.curve.point(nx, nz);
  };
  Point.prototype.mul = function mul(k) {
    var t = k.clone();
    var a = this;
    var b = this.curve.point(null, null);
    var c = this;
    for (var bits = []; t.cmpn(0) !== 0; t.iushrn(1))
      bits.push(t.andln(1));
    for (var i = bits.length - 1; i >= 0; i--) {
      if (bits[i] === 0) {
        a = a.diffAdd(b, c);
        b = b.dbl();
      } else {
        b = a.diffAdd(b, c);
        a = a.dbl();
      }
    }
    return b;
  };
  Point.prototype.mulAdd = function mulAdd() {
    throw new Error("Not supported on Montgomery curve");
  };
  Point.prototype.jumlAdd = function jumlAdd() {
    throw new Error("Not supported on Montgomery curve");
  };
  Point.prototype.eq = function eq(other) {
    return this.getX().cmp(other.getX()) === 0;
  };
  Point.prototype.normalize = function normalize() {
    this.x = this.x.redMul(this.z.redInvm());
    this.z = this.curve.one;
    return this;
  };
  Point.prototype.getX = function getX() {
    this.normalize();
    return this.x.fromRed();
  };
});

// node_modules/elliptic/lib/elliptic/curve/edwards.js
var require_edwards = __commonJS((exports2, module2) => {
  "use strict";
  var utils = require_utils3();
  var BN = require_bn();
  var inherits = require_inherits_browser();
  var Base = require_base2();
  var assert = utils.assert;
  function EdwardsCurve(conf) {
    this.twisted = (conf.a | 0) !== 1;
    this.mOneA = this.twisted && (conf.a | 0) === -1;
    this.extended = this.mOneA;
    Base.call(this, "edwards", conf);
    this.a = new BN(conf.a, 16).umod(this.red.m);
    this.a = this.a.toRed(this.red);
    this.c = new BN(conf.c, 16).toRed(this.red);
    this.c2 = this.c.redSqr();
    this.d = new BN(conf.d, 16).toRed(this.red);
    this.dd = this.d.redAdd(this.d);
    assert(!this.twisted || this.c.fromRed().cmpn(1) === 0);
    this.oneC = (conf.c | 0) === 1;
  }
  inherits(EdwardsCurve, Base);
  module2.exports = EdwardsCurve;
  EdwardsCurve.prototype._mulA = function _mulA(num) {
    if (this.mOneA)
      return num.redNeg();
    else
      return this.a.redMul(num);
  };
  EdwardsCurve.prototype._mulC = function _mulC(num) {
    if (this.oneC)
      return num;
    else
      return this.c.redMul(num);
  };
  EdwardsCurve.prototype.jpoint = function jpoint(x, y, z, t) {
    return this.point(x, y, z, t);
  };
  EdwardsCurve.prototype.pointFromX = function pointFromX(x, odd) {
    x = new BN(x, 16);
    if (!x.red)
      x = x.toRed(this.red);
    var x2 = x.redSqr();
    var rhs = this.c2.redSub(this.a.redMul(x2));
    var lhs = this.one.redSub(this.c2.redMul(this.d).redMul(x2));
    var y2 = rhs.redMul(lhs.redInvm());
    var y = y2.redSqrt();
    if (y.redSqr().redSub(y2).cmp(this.zero) !== 0)
      throw new Error("invalid point");
    var isOdd = y.fromRed().isOdd();
    if (odd && !isOdd || !odd && isOdd)
      y = y.redNeg();
    return this.point(x, y);
  };
  EdwardsCurve.prototype.pointFromY = function pointFromY(y, odd) {
    y = new BN(y, 16);
    if (!y.red)
      y = y.toRed(this.red);
    var y2 = y.redSqr();
    var lhs = y2.redSub(this.c2);
    var rhs = y2.redMul(this.d).redMul(this.c2).redSub(this.a);
    var x2 = lhs.redMul(rhs.redInvm());
    if (x2.cmp(this.zero) === 0) {
      if (odd)
        throw new Error("invalid point");
      else
        return this.point(this.zero, y);
    }
    var x = x2.redSqrt();
    if (x.redSqr().redSub(x2).cmp(this.zero) !== 0)
      throw new Error("invalid point");
    if (x.fromRed().isOdd() !== odd)
      x = x.redNeg();
    return this.point(x, y);
  };
  EdwardsCurve.prototype.validate = function validate(point) {
    if (point.isInfinity())
      return true;
    point.normalize();
    var x2 = point.x.redSqr();
    var y2 = point.y.redSqr();
    var lhs = x2.redMul(this.a).redAdd(y2);
    var rhs = this.c2.redMul(this.one.redAdd(this.d.redMul(x2).redMul(y2)));
    return lhs.cmp(rhs) === 0;
  };
  function Point(curve, x, y, z, t) {
    Base.BasePoint.call(this, curve, "projective");
    if (x === null && y === null && z === null) {
      this.x = this.curve.zero;
      this.y = this.curve.one;
      this.z = this.curve.one;
      this.t = this.curve.zero;
      this.zOne = true;
    } else {
      this.x = new BN(x, 16);
      this.y = new BN(y, 16);
      this.z = z ? new BN(z, 16) : this.curve.one;
      this.t = t && new BN(t, 16);
      if (!this.x.red)
        this.x = this.x.toRed(this.curve.red);
      if (!this.y.red)
        this.y = this.y.toRed(this.curve.red);
      if (!this.z.red)
        this.z = this.z.toRed(this.curve.red);
      if (this.t && !this.t.red)
        this.t = this.t.toRed(this.curve.red);
      this.zOne = this.z === this.curve.one;
      if (this.curve.extended && !this.t) {
        this.t = this.x.redMul(this.y);
        if (!this.zOne)
          this.t = this.t.redMul(this.z.redInvm());
      }
    }
  }
  inherits(Point, Base.BasePoint);
  EdwardsCurve.prototype.pointFromJSON = function pointFromJSON(obj) {
    return Point.fromJSON(this, obj);
  };
  EdwardsCurve.prototype.point = function point(x, y, z, t) {
    return new Point(this, x, y, z, t);
  };
  Point.fromJSON = function fromJSON(curve, obj) {
    return new Point(curve, obj[0], obj[1], obj[2]);
  };
  Point.prototype.inspect = function inspect() {
    if (this.isInfinity())
      return "<EC Point Infinity>";
    return "<EC Point x: " + this.x.fromRed().toString(16, 2) + " y: " + this.y.fromRed().toString(16, 2) + " z: " + this.z.fromRed().toString(16, 2) + ">";
  };
  Point.prototype.isInfinity = function isInfinity() {
    return this.x.cmpn(0) === 0 && (this.y.cmp(this.z) === 0 || this.zOne && this.y.cmp(this.curve.c) === 0);
  };
  Point.prototype._extDbl = function _extDbl() {
    var a = this.x.redSqr();
    var b = this.y.redSqr();
    var c = this.z.redSqr();
    c = c.redIAdd(c);
    var d = this.curve._mulA(a);
    var e = this.x.redAdd(this.y).redSqr().redISub(a).redISub(b);
    var g = d.redAdd(b);
    var f = g.redSub(c);
    var h = d.redSub(b);
    var nx = e.redMul(f);
    var ny = g.redMul(h);
    var nt = e.redMul(h);
    var nz = f.redMul(g);
    return this.curve.point(nx, ny, nz, nt);
  };
  Point.prototype._projDbl = function _projDbl() {
    var b = this.x.redAdd(this.y).redSqr();
    var c = this.x.redSqr();
    var d = this.y.redSqr();
    var nx;
    var ny;
    var nz;
    if (this.curve.twisted) {
      var e = this.curve._mulA(c);
      var f = e.redAdd(d);
      if (this.zOne) {
        nx = b.redSub(c).redSub(d).redMul(f.redSub(this.curve.two));
        ny = f.redMul(e.redSub(d));
        nz = f.redSqr().redSub(f).redSub(f);
      } else {
        var h = this.z.redSqr();
        var j = f.redSub(h).redISub(h);
        nx = b.redSub(c).redISub(d).redMul(j);
        ny = f.redMul(e.redSub(d));
        nz = f.redMul(j);
      }
    } else {
      var e = c.redAdd(d);
      var h = this.curve._mulC(this.z).redSqr();
      var j = e.redSub(h).redSub(h);
      nx = this.curve._mulC(b.redISub(e)).redMul(j);
      ny = this.curve._mulC(e).redMul(c.redISub(d));
      nz = e.redMul(j);
    }
    return this.curve.point(nx, ny, nz);
  };
  Point.prototype.dbl = function dbl() {
    if (this.isInfinity())
      return this;
    if (this.curve.extended)
      return this._extDbl();
    else
      return this._projDbl();
  };
  Point.prototype._extAdd = function _extAdd(p) {
    var a = this.y.redSub(this.x).redMul(p.y.redSub(p.x));
    var b = this.y.redAdd(this.x).redMul(p.y.redAdd(p.x));
    var c = this.t.redMul(this.curve.dd).redMul(p.t);
    var d = this.z.redMul(p.z.redAdd(p.z));
    var e = b.redSub(a);
    var f = d.redSub(c);
    var g = d.redAdd(c);
    var h = b.redAdd(a);
    var nx = e.redMul(f);
    var ny = g.redMul(h);
    var nt = e.redMul(h);
    var nz = f.redMul(g);
    return this.curve.point(nx, ny, nz, nt);
  };
  Point.prototype._projAdd = function _projAdd(p) {
    var a = this.z.redMul(p.z);
    var b = a.redSqr();
    var c = this.x.redMul(p.x);
    var d = this.y.redMul(p.y);
    var e = this.curve.d.redMul(c).redMul(d);
    var f = b.redSub(e);
    var g = b.redAdd(e);
    var tmp = this.x.redAdd(this.y).redMul(p.x.redAdd(p.y)).redISub(c).redISub(d);
    var nx = a.redMul(f).redMul(tmp);
    var ny;
    var nz;
    if (this.curve.twisted) {
      ny = a.redMul(g).redMul(d.redSub(this.curve._mulA(c)));
      nz = f.redMul(g);
    } else {
      ny = a.redMul(g).redMul(d.redSub(c));
      nz = this.curve._mulC(f).redMul(g);
    }
    return this.curve.point(nx, ny, nz);
  };
  Point.prototype.add = function add(p) {
    if (this.isInfinity())
      return p;
    if (p.isInfinity())
      return this;
    if (this.curve.extended)
      return this._extAdd(p);
    else
      return this._projAdd(p);
  };
  Point.prototype.mul = function mul(k) {
    if (this._hasDoubles(k))
      return this.curve._fixedNafMul(this, k);
    else
      return this.curve._wnafMul(this, k);
  };
  Point.prototype.mulAdd = function mulAdd(k1, p, k2) {
    return this.curve._wnafMulAdd(1, [this, p], [k1, k2], 2, false);
  };
  Point.prototype.jmulAdd = function jmulAdd(k1, p, k2) {
    return this.curve._wnafMulAdd(1, [this, p], [k1, k2], 2, true);
  };
  Point.prototype.normalize = function normalize() {
    if (this.zOne)
      return this;
    var zi = this.z.redInvm();
    this.x = this.x.redMul(zi);
    this.y = this.y.redMul(zi);
    if (this.t)
      this.t = this.t.redMul(zi);
    this.z = this.curve.one;
    this.zOne = true;
    return this;
  };
  Point.prototype.neg = function neg() {
    return this.curve.point(this.x.redNeg(), this.y, this.z, this.t && this.t.redNeg());
  };
  Point.prototype.getX = function getX() {
    this.normalize();
    return this.x.fromRed();
  };
  Point.prototype.getY = function getY() {
    this.normalize();
    return this.y.fromRed();
  };
  Point.prototype.eq = function eq(other) {
    return this === other || this.getX().cmp(other.getX()) === 0 && this.getY().cmp(other.getY()) === 0;
  };
  Point.prototype.eqXToP = function eqXToP(x) {
    var rx = x.toRed(this.curve.red).redMul(this.z);
    if (this.x.cmp(rx) === 0)
      return true;
    var xc = x.clone();
    var t = this.curve.redN.redMul(this.z);
    for (; ; ) {
      xc.iadd(this.curve.n);
      if (xc.cmp(this.curve.p) >= 0)
        return false;
      rx.redIAdd(t);
      if (this.x.cmp(rx) === 0)
        return true;
    }
  };
  Point.prototype.toP = Point.prototype.normalize;
  Point.prototype.mixedAdd = Point.prototype.add;
});

// node_modules/elliptic/lib/elliptic/curve/index.js
var require_curve = __commonJS((exports2) => {
  "use strict";
  var curve = exports2;
  curve.base = require_base2();
  curve.short = require_short();
  curve.mont = require_mont();
  curve.edwards = require_edwards();
});

// node_modules/hash.js/lib/hash/utils.js
var require_utils4 = __commonJS((exports2) => {
  "use strict";
  var assert = require_minimalistic_assert();
  var inherits = require_inherits_browser();
  exports2.inherits = inherits;
  function isSurrogatePair(msg, i) {
    if ((msg.charCodeAt(i) & 64512) !== 55296) {
      return false;
    }
    if (i < 0 || i + 1 >= msg.length) {
      return false;
    }
    return (msg.charCodeAt(i + 1) & 64512) === 56320;
  }
  function toArray(msg, enc) {
    if (Array.isArray(msg))
      return msg.slice();
    if (!msg)
      return [];
    var res = [];
    if (typeof msg === "string") {
      if (!enc) {
        var p = 0;
        for (var i = 0; i < msg.length; i++) {
          var c = msg.charCodeAt(i);
          if (c < 128) {
            res[p++] = c;
          } else if (c < 2048) {
            res[p++] = c >> 6 | 192;
            res[p++] = c & 63 | 128;
          } else if (isSurrogatePair(msg, i)) {
            c = 65536 + ((c & 1023) << 10) + (msg.charCodeAt(++i) & 1023);
            res[p++] = c >> 18 | 240;
            res[p++] = c >> 12 & 63 | 128;
            res[p++] = c >> 6 & 63 | 128;
            res[p++] = c & 63 | 128;
          } else {
            res[p++] = c >> 12 | 224;
            res[p++] = c >> 6 & 63 | 128;
            res[p++] = c & 63 | 128;
          }
        }
      } else if (enc === "hex") {
        msg = msg.replace(/[^a-z0-9]+/ig, "");
        if (msg.length % 2 !== 0)
          msg = "0" + msg;
        for (i = 0; i < msg.length; i += 2)
          res.push(parseInt(msg[i] + msg[i + 1], 16));
      }
    } else {
      for (i = 0; i < msg.length; i++)
        res[i] = msg[i] | 0;
    }
    return res;
  }
  exports2.toArray = toArray;
  function toHex(msg) {
    var res = "";
    for (var i = 0; i < msg.length; i++)
      res += zero2(msg[i].toString(16));
    return res;
  }
  exports2.toHex = toHex;
  function htonl(w) {
    var res = w >>> 24 | w >>> 8 & 65280 | w << 8 & 16711680 | (w & 255) << 24;
    return res >>> 0;
  }
  exports2.htonl = htonl;
  function toHex32(msg, endian) {
    var res = "";
    for (var i = 0; i < msg.length; i++) {
      var w = msg[i];
      if (endian === "little")
        w = htonl(w);
      res += zero8(w.toString(16));
    }
    return res;
  }
  exports2.toHex32 = toHex32;
  function zero2(word) {
    if (word.length === 1)
      return "0" + word;
    else
      return word;
  }
  exports2.zero2 = zero2;
  function zero8(word) {
    if (word.length === 7)
      return "0" + word;
    else if (word.length === 6)
      return "00" + word;
    else if (word.length === 5)
      return "000" + word;
    else if (word.length === 4)
      return "0000" + word;
    else if (word.length === 3)
      return "00000" + word;
    else if (word.length === 2)
      return "000000" + word;
    else if (word.length === 1)
      return "0000000" + word;
    else
      return word;
  }
  exports2.zero8 = zero8;
  function join32(msg, start, end, endian) {
    var len = end - start;
    assert(len % 4 === 0);
    var res = new Array(len / 4);
    for (var i = 0, k = start; i < res.length; i++, k += 4) {
      var w;
      if (endian === "big")
        w = msg[k] << 24 | msg[k + 1] << 16 | msg[k + 2] << 8 | msg[k + 3];
      else
        w = msg[k + 3] << 24 | msg[k + 2] << 16 | msg[k + 1] << 8 | msg[k];
      res[i] = w >>> 0;
    }
    return res;
  }
  exports2.join32 = join32;
  function split32(msg, endian) {
    var res = new Array(msg.length * 4);
    for (var i = 0, k = 0; i < msg.length; i++, k += 4) {
      var m = msg[i];
      if (endian === "big") {
        res[k] = m >>> 24;
        res[k + 1] = m >>> 16 & 255;
        res[k + 2] = m >>> 8 & 255;
        res[k + 3] = m & 255;
      } else {
        res[k + 3] = m >>> 24;
        res[k + 2] = m >>> 16 & 255;
        res[k + 1] = m >>> 8 & 255;
        res[k] = m & 255;
      }
    }
    return res;
  }
  exports2.split32 = split32;
  function rotr32(w, b) {
    return w >>> b | w << 32 - b;
  }
  exports2.rotr32 = rotr32;
  function rotl32(w, b) {
    return w << b | w >>> 32 - b;
  }
  exports2.rotl32 = rotl32;
  function sum32(a, b) {
    return a + b >>> 0;
  }
  exports2.sum32 = sum32;
  function sum32_3(a, b, c) {
    return a + b + c >>> 0;
  }
  exports2.sum32_3 = sum32_3;
  function sum32_4(a, b, c, d) {
    return a + b + c + d >>> 0;
  }
  exports2.sum32_4 = sum32_4;
  function sum32_5(a, b, c, d, e) {
    return a + b + c + d + e >>> 0;
  }
  exports2.sum32_5 = sum32_5;
  function sum64(buf, pos, ah, al) {
    var bh = buf[pos];
    var bl = buf[pos + 1];
    var lo = al + bl >>> 0;
    var hi = (lo < al ? 1 : 0) + ah + bh;
    buf[pos] = hi >>> 0;
    buf[pos + 1] = lo;
  }
  exports2.sum64 = sum64;
  function sum64_hi(ah, al, bh, bl) {
    var lo = al + bl >>> 0;
    var hi = (lo < al ? 1 : 0) + ah + bh;
    return hi >>> 0;
  }
  exports2.sum64_hi = sum64_hi;
  function sum64_lo(ah, al, bh, bl) {
    var lo = al + bl;
    return lo >>> 0;
  }
  exports2.sum64_lo = sum64_lo;
  function sum64_4_hi(ah, al, bh, bl, ch, cl, dh, dl) {
    var carry = 0;
    var lo = al;
    lo = lo + bl >>> 0;
    carry += lo < al ? 1 : 0;
    lo = lo + cl >>> 0;
    carry += lo < cl ? 1 : 0;
    lo = lo + dl >>> 0;
    carry += lo < dl ? 1 : 0;
    var hi = ah + bh + ch + dh + carry;
    return hi >>> 0;
  }
  exports2.sum64_4_hi = sum64_4_hi;
  function sum64_4_lo(ah, al, bh, bl, ch, cl, dh, dl) {
    var lo = al + bl + cl + dl;
    return lo >>> 0;
  }
  exports2.sum64_4_lo = sum64_4_lo;
  function sum64_5_hi(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
    var carry = 0;
    var lo = al;
    lo = lo + bl >>> 0;
    carry += lo < al ? 1 : 0;
    lo = lo + cl >>> 0;
    carry += lo < cl ? 1 : 0;
    lo = lo + dl >>> 0;
    carry += lo < dl ? 1 : 0;
    lo = lo + el >>> 0;
    carry += lo < el ? 1 : 0;
    var hi = ah + bh + ch + dh + eh + carry;
    return hi >>> 0;
  }
  exports2.sum64_5_hi = sum64_5_hi;
  function sum64_5_lo(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
    var lo = al + bl + cl + dl + el;
    return lo >>> 0;
  }
  exports2.sum64_5_lo = sum64_5_lo;
  function rotr64_hi(ah, al, num) {
    var r = al << 32 - num | ah >>> num;
    return r >>> 0;
  }
  exports2.rotr64_hi = rotr64_hi;
  function rotr64_lo(ah, al, num) {
    var r = ah << 32 - num | al >>> num;
    return r >>> 0;
  }
  exports2.rotr64_lo = rotr64_lo;
  function shr64_hi(ah, al, num) {
    return ah >>> num;
  }
  exports2.shr64_hi = shr64_hi;
  function shr64_lo(ah, al, num) {
    var r = ah << 32 - num | al >>> num;
    return r >>> 0;
  }
  exports2.shr64_lo = shr64_lo;
});

// node_modules/hash.js/lib/hash/common.js
var require_common = __commonJS((exports2) => {
  "use strict";
  var utils = require_utils4();
  var assert = require_minimalistic_assert();
  function BlockHash() {
    this.pending = null;
    this.pendingTotal = 0;
    this.blockSize = this.constructor.blockSize;
    this.outSize = this.constructor.outSize;
    this.hmacStrength = this.constructor.hmacStrength;
    this.padLength = this.constructor.padLength / 8;
    this.endian = "big";
    this._delta8 = this.blockSize / 8;
    this._delta32 = this.blockSize / 32;
  }
  exports2.BlockHash = BlockHash;
  BlockHash.prototype.update = function update(msg, enc) {
    msg = utils.toArray(msg, enc);
    if (!this.pending)
      this.pending = msg;
    else
      this.pending = this.pending.concat(msg);
    this.pendingTotal += msg.length;
    if (this.pending.length >= this._delta8) {
      msg = this.pending;
      var r = msg.length % this._delta8;
      this.pending = msg.slice(msg.length - r, msg.length);
      if (this.pending.length === 0)
        this.pending = null;
      msg = utils.join32(msg, 0, msg.length - r, this.endian);
      for (var i = 0; i < msg.length; i += this._delta32)
        this._update(msg, i, i + this._delta32);
    }
    return this;
  };
  BlockHash.prototype.digest = function digest(enc) {
    this.update(this._pad());
    assert(this.pending === null);
    return this._digest(enc);
  };
  BlockHash.prototype._pad = function pad() {
    var len = this.pendingTotal;
    var bytes = this._delta8;
    var k = bytes - (len + this.padLength) % bytes;
    var res = new Array(k + this.padLength);
    res[0] = 128;
    for (var i = 1; i < k; i++)
      res[i] = 0;
    len <<= 3;
    if (this.endian === "big") {
      for (var t = 8; t < this.padLength; t++)
        res[i++] = 0;
      res[i++] = 0;
      res[i++] = 0;
      res[i++] = 0;
      res[i++] = 0;
      res[i++] = len >>> 24 & 255;
      res[i++] = len >>> 16 & 255;
      res[i++] = len >>> 8 & 255;
      res[i++] = len & 255;
    } else {
      res[i++] = len & 255;
      res[i++] = len >>> 8 & 255;
      res[i++] = len >>> 16 & 255;
      res[i++] = len >>> 24 & 255;
      res[i++] = 0;
      res[i++] = 0;
      res[i++] = 0;
      res[i++] = 0;
      for (t = 8; t < this.padLength; t++)
        res[i++] = 0;
    }
    return res;
  };
});

// node_modules/hash.js/lib/hash/sha/common.js
var require_common2 = __commonJS((exports2) => {
  "use strict";
  var utils = require_utils4();
  var rotr32 = utils.rotr32;
  function ft_1(s, x, y, z) {
    if (s === 0)
      return ch32(x, y, z);
    if (s === 1 || s === 3)
      return p32(x, y, z);
    if (s === 2)
      return maj32(x, y, z);
  }
  exports2.ft_1 = ft_1;
  function ch32(x, y, z) {
    return x & y ^ ~x & z;
  }
  exports2.ch32 = ch32;
  function maj32(x, y, z) {
    return x & y ^ x & z ^ y & z;
  }
  exports2.maj32 = maj32;
  function p32(x, y, z) {
    return x ^ y ^ z;
  }
  exports2.p32 = p32;
  function s0_256(x) {
    return rotr32(x, 2) ^ rotr32(x, 13) ^ rotr32(x, 22);
  }
  exports2.s0_256 = s0_256;
  function s1_256(x) {
    return rotr32(x, 6) ^ rotr32(x, 11) ^ rotr32(x, 25);
  }
  exports2.s1_256 = s1_256;
  function g0_256(x) {
    return rotr32(x, 7) ^ rotr32(x, 18) ^ x >>> 3;
  }
  exports2.g0_256 = g0_256;
  function g1_256(x) {
    return rotr32(x, 17) ^ rotr32(x, 19) ^ x >>> 10;
  }
  exports2.g1_256 = g1_256;
});

// node_modules/hash.js/lib/hash/sha/1.js
var require__ = __commonJS((exports2, module2) => {
  "use strict";
  var utils = require_utils4();
  var common = require_common();
  var shaCommon = require_common2();
  var rotl32 = utils.rotl32;
  var sum32 = utils.sum32;
  var sum32_5 = utils.sum32_5;
  var ft_1 = shaCommon.ft_1;
  var BlockHash = common.BlockHash;
  var sha1_K = [
    1518500249,
    1859775393,
    2400959708,
    3395469782
  ];
  function SHA1() {
    if (!(this instanceof SHA1))
      return new SHA1();
    BlockHash.call(this);
    this.h = [
      1732584193,
      4023233417,
      2562383102,
      271733878,
      3285377520
    ];
    this.W = new Array(80);
  }
  utils.inherits(SHA1, BlockHash);
  module2.exports = SHA1;
  SHA1.blockSize = 512;
  SHA1.outSize = 160;
  SHA1.hmacStrength = 80;
  SHA1.padLength = 64;
  SHA1.prototype._update = function _update(msg, start) {
    var W = this.W;
    for (var i = 0; i < 16; i++)
      W[i] = msg[start + i];
    for (; i < W.length; i++)
      W[i] = rotl32(W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16], 1);
    var a = this.h[0];
    var b = this.h[1];
    var c = this.h[2];
    var d = this.h[3];
    var e = this.h[4];
    for (i = 0; i < W.length; i++) {
      var s = ~~(i / 20);
      var t = sum32_5(rotl32(a, 5), ft_1(s, b, c, d), e, W[i], sha1_K[s]);
      e = d;
      d = c;
      c = rotl32(b, 30);
      b = a;
      a = t;
    }
    this.h[0] = sum32(this.h[0], a);
    this.h[1] = sum32(this.h[1], b);
    this.h[2] = sum32(this.h[2], c);
    this.h[3] = sum32(this.h[3], d);
    this.h[4] = sum32(this.h[4], e);
  };
  SHA1.prototype._digest = function digest(enc) {
    if (enc === "hex")
      return utils.toHex32(this.h, "big");
    else
      return utils.split32(this.h, "big");
  };
});

// node_modules/hash.js/lib/hash/sha/256.js
var require__2 = __commonJS((exports2, module2) => {
  "use strict";
  var utils = require_utils4();
  var common = require_common();
  var shaCommon = require_common2();
  var assert = require_minimalistic_assert();
  var sum32 = utils.sum32;
  var sum32_4 = utils.sum32_4;
  var sum32_5 = utils.sum32_5;
  var ch32 = shaCommon.ch32;
  var maj32 = shaCommon.maj32;
  var s0_256 = shaCommon.s0_256;
  var s1_256 = shaCommon.s1_256;
  var g0_256 = shaCommon.g0_256;
  var g1_256 = shaCommon.g1_256;
  var BlockHash = common.BlockHash;
  var sha256_K = [
    1116352408,
    1899447441,
    3049323471,
    3921009573,
    961987163,
    1508970993,
    2453635748,
    2870763221,
    3624381080,
    310598401,
    607225278,
    1426881987,
    1925078388,
    2162078206,
    2614888103,
    3248222580,
    3835390401,
    4022224774,
    264347078,
    604807628,
    770255983,
    1249150122,
    1555081692,
    1996064986,
    2554220882,
    2821834349,
    2952996808,
    3210313671,
    3336571891,
    3584528711,
    113926993,
    338241895,
    666307205,
    773529912,
    1294757372,
    1396182291,
    1695183700,
    1986661051,
    2177026350,
    2456956037,
    2730485921,
    2820302411,
    3259730800,
    3345764771,
    3516065817,
    3600352804,
    4094571909,
    275423344,
    430227734,
    506948616,
    659060556,
    883997877,
    958139571,
    1322822218,
    1537002063,
    1747873779,
    1955562222,
    2024104815,
    2227730452,
    2361852424,
    2428436474,
    2756734187,
    3204031479,
    3329325298
  ];
  function SHA256() {
    if (!(this instanceof SHA256))
      return new SHA256();
    BlockHash.call(this);
    this.h = [
      1779033703,
      3144134277,
      1013904242,
      2773480762,
      1359893119,
      2600822924,
      528734635,
      1541459225
    ];
    this.k = sha256_K;
    this.W = new Array(64);
  }
  utils.inherits(SHA256, BlockHash);
  module2.exports = SHA256;
  SHA256.blockSize = 512;
  SHA256.outSize = 256;
  SHA256.hmacStrength = 192;
  SHA256.padLength = 64;
  SHA256.prototype._update = function _update(msg, start) {
    var W = this.W;
    for (var i = 0; i < 16; i++)
      W[i] = msg[start + i];
    for (; i < W.length; i++)
      W[i] = sum32_4(g1_256(W[i - 2]), W[i - 7], g0_256(W[i - 15]), W[i - 16]);
    var a = this.h[0];
    var b = this.h[1];
    var c = this.h[2];
    var d = this.h[3];
    var e = this.h[4];
    var f = this.h[5];
    var g = this.h[6];
    var h = this.h[7];
    assert(this.k.length === W.length);
    for (i = 0; i < W.length; i++) {
      var T1 = sum32_5(h, s1_256(e), ch32(e, f, g), this.k[i], W[i]);
      var T2 = sum32(s0_256(a), maj32(a, b, c));
      h = g;
      g = f;
      f = e;
      e = sum32(d, T1);
      d = c;
      c = b;
      b = a;
      a = sum32(T1, T2);
    }
    this.h[0] = sum32(this.h[0], a);
    this.h[1] = sum32(this.h[1], b);
    this.h[2] = sum32(this.h[2], c);
    this.h[3] = sum32(this.h[3], d);
    this.h[4] = sum32(this.h[4], e);
    this.h[5] = sum32(this.h[5], f);
    this.h[6] = sum32(this.h[6], g);
    this.h[7] = sum32(this.h[7], h);
  };
  SHA256.prototype._digest = function digest(enc) {
    if (enc === "hex")
      return utils.toHex32(this.h, "big");
    else
      return utils.split32(this.h, "big");
  };
});

// node_modules/hash.js/lib/hash/sha/224.js
var require__3 = __commonJS((exports2, module2) => {
  "use strict";
  var utils = require_utils4();
  var SHA256 = require__2();
  function SHA224() {
    if (!(this instanceof SHA224))
      return new SHA224();
    SHA256.call(this);
    this.h = [
      3238371032,
      914150663,
      812702999,
      4144912697,
      4290775857,
      1750603025,
      1694076839,
      3204075428
    ];
  }
  utils.inherits(SHA224, SHA256);
  module2.exports = SHA224;
  SHA224.blockSize = 512;
  SHA224.outSize = 224;
  SHA224.hmacStrength = 192;
  SHA224.padLength = 64;
  SHA224.prototype._digest = function digest(enc) {
    if (enc === "hex")
      return utils.toHex32(this.h.slice(0, 7), "big");
    else
      return utils.split32(this.h.slice(0, 7), "big");
  };
});

// node_modules/hash.js/lib/hash/sha/512.js
var require__4 = __commonJS((exports2, module2) => {
  "use strict";
  var utils = require_utils4();
  var common = require_common();
  var assert = require_minimalistic_assert();
  var rotr64_hi = utils.rotr64_hi;
  var rotr64_lo = utils.rotr64_lo;
  var shr64_hi = utils.shr64_hi;
  var shr64_lo = utils.shr64_lo;
  var sum64 = utils.sum64;
  var sum64_hi = utils.sum64_hi;
  var sum64_lo = utils.sum64_lo;
  var sum64_4_hi = utils.sum64_4_hi;
  var sum64_4_lo = utils.sum64_4_lo;
  var sum64_5_hi = utils.sum64_5_hi;
  var sum64_5_lo = utils.sum64_5_lo;
  var BlockHash = common.BlockHash;
  var sha512_K = [
    1116352408,
    3609767458,
    1899447441,
    602891725,
    3049323471,
    3964484399,
    3921009573,
    2173295548,
    961987163,
    4081628472,
    1508970993,
    3053834265,
    2453635748,
    2937671579,
    2870763221,
    3664609560,
    3624381080,
    2734883394,
    310598401,
    1164996542,
    607225278,
    1323610764,
    1426881987,
    3590304994,
    1925078388,
    4068182383,
    2162078206,
    991336113,
    2614888103,
    633803317,
    3248222580,
    3479774868,
    3835390401,
    2666613458,
    4022224774,
    944711139,
    264347078,
    2341262773,
    604807628,
    2007800933,
    770255983,
    1495990901,
    1249150122,
    1856431235,
    1555081692,
    3175218132,
    1996064986,
    2198950837,
    2554220882,
    3999719339,
    2821834349,
    766784016,
    2952996808,
    2566594879,
    3210313671,
    3203337956,
    3336571891,
    1034457026,
    3584528711,
    2466948901,
    113926993,
    3758326383,
    338241895,
    168717936,
    666307205,
    1188179964,
    773529912,
    1546045734,
    1294757372,
    1522805485,
    1396182291,
    2643833823,
    1695183700,
    2343527390,
    1986661051,
    1014477480,
    2177026350,
    1206759142,
    2456956037,
    344077627,
    2730485921,
    1290863460,
    2820302411,
    3158454273,
    3259730800,
    3505952657,
    3345764771,
    106217008,
    3516065817,
    3606008344,
    3600352804,
    1432725776,
    4094571909,
    1467031594,
    275423344,
    851169720,
    430227734,
    3100823752,
    506948616,
    1363258195,
    659060556,
    3750685593,
    883997877,
    3785050280,
    958139571,
    3318307427,
    1322822218,
    3812723403,
    1537002063,
    2003034995,
    1747873779,
    3602036899,
    1955562222,
    1575990012,
    2024104815,
    1125592928,
    2227730452,
    2716904306,
    2361852424,
    442776044,
    2428436474,
    593698344,
    2756734187,
    3733110249,
    3204031479,
    2999351573,
    3329325298,
    3815920427,
    3391569614,
    3928383900,
    3515267271,
    566280711,
    3940187606,
    3454069534,
    4118630271,
    4000239992,
    116418474,
    1914138554,
    174292421,
    2731055270,
    289380356,
    3203993006,
    460393269,
    320620315,
    685471733,
    587496836,
    852142971,
    1086792851,
    1017036298,
    365543100,
    1126000580,
    2618297676,
    1288033470,
    3409855158,
    1501505948,
    4234509866,
    1607167915,
    987167468,
    1816402316,
    1246189591
  ];
  function SHA512() {
    if (!(this instanceof SHA512))
      return new SHA512();
    BlockHash.call(this);
    this.h = [
      1779033703,
      4089235720,
      3144134277,
      2227873595,
      1013904242,
      4271175723,
      2773480762,
      1595750129,
      1359893119,
      2917565137,
      2600822924,
      725511199,
      528734635,
      4215389547,
      1541459225,
      327033209
    ];
    this.k = sha512_K;
    this.W = new Array(160);
  }
  utils.inherits(SHA512, BlockHash);
  module2.exports = SHA512;
  SHA512.blockSize = 1024;
  SHA512.outSize = 512;
  SHA512.hmacStrength = 192;
  SHA512.padLength = 128;
  SHA512.prototype._prepareBlock = function _prepareBlock(msg, start) {
    var W = this.W;
    for (var i = 0; i < 32; i++)
      W[i] = msg[start + i];
    for (; i < W.length; i += 2) {
      var c0_hi = g1_512_hi(W[i - 4], W[i - 3]);
      var c0_lo = g1_512_lo(W[i - 4], W[i - 3]);
      var c1_hi = W[i - 14];
      var c1_lo = W[i - 13];
      var c2_hi = g0_512_hi(W[i - 30], W[i - 29]);
      var c2_lo = g0_512_lo(W[i - 30], W[i - 29]);
      var c3_hi = W[i - 32];
      var c3_lo = W[i - 31];
      W[i] = sum64_4_hi(c0_hi, c0_lo, c1_hi, c1_lo, c2_hi, c2_lo, c3_hi, c3_lo);
      W[i + 1] = sum64_4_lo(c0_hi, c0_lo, c1_hi, c1_lo, c2_hi, c2_lo, c3_hi, c3_lo);
    }
  };
  SHA512.prototype._update = function _update(msg, start) {
    this._prepareBlock(msg, start);
    var W = this.W;
    var ah = this.h[0];
    var al = this.h[1];
    var bh = this.h[2];
    var bl = this.h[3];
    var ch = this.h[4];
    var cl = this.h[5];
    var dh = this.h[6];
    var dl = this.h[7];
    var eh = this.h[8];
    var el = this.h[9];
    var fh = this.h[10];
    var fl = this.h[11];
    var gh = this.h[12];
    var gl = this.h[13];
    var hh = this.h[14];
    var hl = this.h[15];
    assert(this.k.length === W.length);
    for (var i = 0; i < W.length; i += 2) {
      var c0_hi = hh;
      var c0_lo = hl;
      var c1_hi = s1_512_hi(eh, el);
      var c1_lo = s1_512_lo(eh, el);
      var c2_hi = ch64_hi(eh, el, fh, fl, gh, gl);
      var c2_lo = ch64_lo(eh, el, fh, fl, gh, gl);
      var c3_hi = this.k[i];
      var c3_lo = this.k[i + 1];
      var c4_hi = W[i];
      var c4_lo = W[i + 1];
      var T1_hi = sum64_5_hi(c0_hi, c0_lo, c1_hi, c1_lo, c2_hi, c2_lo, c3_hi, c3_lo, c4_hi, c4_lo);
      var T1_lo = sum64_5_lo(c0_hi, c0_lo, c1_hi, c1_lo, c2_hi, c2_lo, c3_hi, c3_lo, c4_hi, c4_lo);
      c0_hi = s0_512_hi(ah, al);
      c0_lo = s0_512_lo(ah, al);
      c1_hi = maj64_hi(ah, al, bh, bl, ch, cl);
      c1_lo = maj64_lo(ah, al, bh, bl, ch, cl);
      var T2_hi = sum64_hi(c0_hi, c0_lo, c1_hi, c1_lo);
      var T2_lo = sum64_lo(c0_hi, c0_lo, c1_hi, c1_lo);
      hh = gh;
      hl = gl;
      gh = fh;
      gl = fl;
      fh = eh;
      fl = el;
      eh = sum64_hi(dh, dl, T1_hi, T1_lo);
      el = sum64_lo(dl, dl, T1_hi, T1_lo);
      dh = ch;
      dl = cl;
      ch = bh;
      cl = bl;
      bh = ah;
      bl = al;
      ah = sum64_hi(T1_hi, T1_lo, T2_hi, T2_lo);
      al = sum64_lo(T1_hi, T1_lo, T2_hi, T2_lo);
    }
    sum64(this.h, 0, ah, al);
    sum64(this.h, 2, bh, bl);
    sum64(this.h, 4, ch, cl);
    sum64(this.h, 6, dh, dl);
    sum64(this.h, 8, eh, el);
    sum64(this.h, 10, fh, fl);
    sum64(this.h, 12, gh, gl);
    sum64(this.h, 14, hh, hl);
  };
  SHA512.prototype._digest = function digest(enc) {
    if (enc === "hex")
      return utils.toHex32(this.h, "big");
    else
      return utils.split32(this.h, "big");
  };
  function ch64_hi(xh, xl, yh, yl, zh) {
    var r = xh & yh ^ ~xh & zh;
    if (r < 0)
      r += 4294967296;
    return r;
  }
  function ch64_lo(xh, xl, yh, yl, zh, zl) {
    var r = xl & yl ^ ~xl & zl;
    if (r < 0)
      r += 4294967296;
    return r;
  }
  function maj64_hi(xh, xl, yh, yl, zh) {
    var r = xh & yh ^ xh & zh ^ yh & zh;
    if (r < 0)
      r += 4294967296;
    return r;
  }
  function maj64_lo(xh, xl, yh, yl, zh, zl) {
    var r = xl & yl ^ xl & zl ^ yl & zl;
    if (r < 0)
      r += 4294967296;
    return r;
  }
  function s0_512_hi(xh, xl) {
    var c0_hi = rotr64_hi(xh, xl, 28);
    var c1_hi = rotr64_hi(xl, xh, 2);
    var c2_hi = rotr64_hi(xl, xh, 7);
    var r = c0_hi ^ c1_hi ^ c2_hi;
    if (r < 0)
      r += 4294967296;
    return r;
  }
  function s0_512_lo(xh, xl) {
    var c0_lo = rotr64_lo(xh, xl, 28);
    var c1_lo = rotr64_lo(xl, xh, 2);
    var c2_lo = rotr64_lo(xl, xh, 7);
    var r = c0_lo ^ c1_lo ^ c2_lo;
    if (r < 0)
      r += 4294967296;
    return r;
  }
  function s1_512_hi(xh, xl) {
    var c0_hi = rotr64_hi(xh, xl, 14);
    var c1_hi = rotr64_hi(xh, xl, 18);
    var c2_hi = rotr64_hi(xl, xh, 9);
    var r = c0_hi ^ c1_hi ^ c2_hi;
    if (r < 0)
      r += 4294967296;
    return r;
  }
  function s1_512_lo(xh, xl) {
    var c0_lo = rotr64_lo(xh, xl, 14);
    var c1_lo = rotr64_lo(xh, xl, 18);
    var c2_lo = rotr64_lo(xl, xh, 9);
    var r = c0_lo ^ c1_lo ^ c2_lo;
    if (r < 0)
      r += 4294967296;
    return r;
  }
  function g0_512_hi(xh, xl) {
    var c0_hi = rotr64_hi(xh, xl, 1);
    var c1_hi = rotr64_hi(xh, xl, 8);
    var c2_hi = shr64_hi(xh, xl, 7);
    var r = c0_hi ^ c1_hi ^ c2_hi;
    if (r < 0)
      r += 4294967296;
    return r;
  }
  function g0_512_lo(xh, xl) {
    var c0_lo = rotr64_lo(xh, xl, 1);
    var c1_lo = rotr64_lo(xh, xl, 8);
    var c2_lo = shr64_lo(xh, xl, 7);
    var r = c0_lo ^ c1_lo ^ c2_lo;
    if (r < 0)
      r += 4294967296;
    return r;
  }
  function g1_512_hi(xh, xl) {
    var c0_hi = rotr64_hi(xh, xl, 19);
    var c1_hi = rotr64_hi(xl, xh, 29);
    var c2_hi = shr64_hi(xh, xl, 6);
    var r = c0_hi ^ c1_hi ^ c2_hi;
    if (r < 0)
      r += 4294967296;
    return r;
  }
  function g1_512_lo(xh, xl) {
    var c0_lo = rotr64_lo(xh, xl, 19);
    var c1_lo = rotr64_lo(xl, xh, 29);
    var c2_lo = shr64_lo(xh, xl, 6);
    var r = c0_lo ^ c1_lo ^ c2_lo;
    if (r < 0)
      r += 4294967296;
    return r;
  }
});

// node_modules/hash.js/lib/hash/sha/384.js
var require__5 = __commonJS((exports2, module2) => {
  "use strict";
  var utils = require_utils4();
  var SHA512 = require__4();
  function SHA384() {
    if (!(this instanceof SHA384))
      return new SHA384();
    SHA512.call(this);
    this.h = [
      3418070365,
      3238371032,
      1654270250,
      914150663,
      2438529370,
      812702999,
      355462360,
      4144912697,
      1731405415,
      4290775857,
      2394180231,
      1750603025,
      3675008525,
      1694076839,
      1203062813,
      3204075428
    ];
  }
  utils.inherits(SHA384, SHA512);
  module2.exports = SHA384;
  SHA384.blockSize = 1024;
  SHA384.outSize = 384;
  SHA384.hmacStrength = 192;
  SHA384.padLength = 128;
  SHA384.prototype._digest = function digest(enc) {
    if (enc === "hex")
      return utils.toHex32(this.h.slice(0, 12), "big");
    else
      return utils.split32(this.h.slice(0, 12), "big");
  };
});

// node_modules/hash.js/lib/hash/sha.js
var require_sha = __commonJS((exports2) => {
  "use strict";
  exports2.sha1 = require__();
  exports2.sha224 = require__3();
  exports2.sha256 = require__2();
  exports2.sha384 = require__5();
  exports2.sha512 = require__4();
});

// node_modules/hash.js/lib/hash/ripemd.js
var require_ripemd = __commonJS((exports2) => {
  "use strict";
  var utils = require_utils4();
  var common = require_common();
  var rotl32 = utils.rotl32;
  var sum32 = utils.sum32;
  var sum32_3 = utils.sum32_3;
  var sum32_4 = utils.sum32_4;
  var BlockHash = common.BlockHash;
  function RIPEMD160() {
    if (!(this instanceof RIPEMD160))
      return new RIPEMD160();
    BlockHash.call(this);
    this.h = [1732584193, 4023233417, 2562383102, 271733878, 3285377520];
    this.endian = "little";
  }
  utils.inherits(RIPEMD160, BlockHash);
  exports2.ripemd160 = RIPEMD160;
  RIPEMD160.blockSize = 512;
  RIPEMD160.outSize = 160;
  RIPEMD160.hmacStrength = 192;
  RIPEMD160.padLength = 64;
  RIPEMD160.prototype._update = function update(msg, start) {
    var A = this.h[0];
    var B = this.h[1];
    var C = this.h[2];
    var D = this.h[3];
    var E = this.h[4];
    var Ah = A;
    var Bh = B;
    var Ch = C;
    var Dh = D;
    var Eh = E;
    for (var j = 0; j < 80; j++) {
      var T = sum32(rotl32(sum32_4(A, f(j, B, C, D), msg[r[j] + start], K(j)), s[j]), E);
      A = E;
      E = D;
      D = rotl32(C, 10);
      C = B;
      B = T;
      T = sum32(rotl32(sum32_4(Ah, f(79 - j, Bh, Ch, Dh), msg[rh[j] + start], Kh(j)), sh[j]), Eh);
      Ah = Eh;
      Eh = Dh;
      Dh = rotl32(Ch, 10);
      Ch = Bh;
      Bh = T;
    }
    T = sum32_3(this.h[1], C, Dh);
    this.h[1] = sum32_3(this.h[2], D, Eh);
    this.h[2] = sum32_3(this.h[3], E, Ah);
    this.h[3] = sum32_3(this.h[4], A, Bh);
    this.h[4] = sum32_3(this.h[0], B, Ch);
    this.h[0] = T;
  };
  RIPEMD160.prototype._digest = function digest(enc) {
    if (enc === "hex")
      return utils.toHex32(this.h, "little");
    else
      return utils.split32(this.h, "little");
  };
  function f(j, x, y, z) {
    if (j <= 15)
      return x ^ y ^ z;
    else if (j <= 31)
      return x & y | ~x & z;
    else if (j <= 47)
      return (x | ~y) ^ z;
    else if (j <= 63)
      return x & z | y & ~z;
    else
      return x ^ (y | ~z);
  }
  function K(j) {
    if (j <= 15)
      return 0;
    else if (j <= 31)
      return 1518500249;
    else if (j <= 47)
      return 1859775393;
    else if (j <= 63)
      return 2400959708;
    else
      return 2840853838;
  }
  function Kh(j) {
    if (j <= 15)
      return 1352829926;
    else if (j <= 31)
      return 1548603684;
    else if (j <= 47)
      return 1836072691;
    else if (j <= 63)
      return 2053994217;
    else
      return 0;
  }
  var r = [
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    12,
    13,
    14,
    15,
    7,
    4,
    13,
    1,
    10,
    6,
    15,
    3,
    12,
    0,
    9,
    5,
    2,
    14,
    11,
    8,
    3,
    10,
    14,
    4,
    9,
    15,
    8,
    1,
    2,
    7,
    0,
    6,
    13,
    11,
    5,
    12,
    1,
    9,
    11,
    10,
    0,
    8,
    12,
    4,
    13,
    3,
    7,
    15,
    14,
    5,
    6,
    2,
    4,
    0,
    5,
    9,
    7,
    12,
    2,
    10,
    14,
    1,
    3,
    8,
    11,
    6,
    15,
    13
  ];
  var rh = [
    5,
    14,
    7,
    0,
    9,
    2,
    11,
    4,
    13,
    6,
    15,
    8,
    1,
    10,
    3,
    12,
    6,
    11,
    3,
    7,
    0,
    13,
    5,
    10,
    14,
    15,
    8,
    12,
    4,
    9,
    1,
    2,
    15,
    5,
    1,
    3,
    7,
    14,
    6,
    9,
    11,
    8,
    12,
    2,
    10,
    0,
    4,
    13,
    8,
    6,
    4,
    1,
    3,
    11,
    15,
    0,
    5,
    12,
    2,
    13,
    9,
    7,
    10,
    14,
    12,
    15,
    10,
    4,
    1,
    5,
    8,
    7,
    6,
    2,
    13,
    14,
    0,
    3,
    9,
    11
  ];
  var s = [
    11,
    14,
    15,
    12,
    5,
    8,
    7,
    9,
    11,
    13,
    14,
    15,
    6,
    7,
    9,
    8,
    7,
    6,
    8,
    13,
    11,
    9,
    7,
    15,
    7,
    12,
    15,
    9,
    11,
    7,
    13,
    12,
    11,
    13,
    6,
    7,
    14,
    9,
    13,
    15,
    14,
    8,
    13,
    6,
    5,
    12,
    7,
    5,
    11,
    12,
    14,
    15,
    14,
    15,
    9,
    8,
    9,
    14,
    5,
    6,
    8,
    6,
    5,
    12,
    9,
    15,
    5,
    11,
    6,
    8,
    13,
    12,
    5,
    12,
    13,
    14,
    11,
    8,
    5,
    6
  ];
  var sh = [
    8,
    9,
    9,
    11,
    13,
    15,
    15,
    5,
    7,
    7,
    8,
    11,
    14,
    14,
    12,
    6,
    9,
    13,
    15,
    7,
    12,
    8,
    9,
    11,
    7,
    7,
    12,
    7,
    6,
    15,
    13,
    11,
    9,
    7,
    15,
    11,
    8,
    6,
    6,
    14,
    12,
    13,
    5,
    14,
    13,
    13,
    7,
    5,
    15,
    5,
    8,
    11,
    14,
    14,
    6,
    14,
    6,
    9,
    12,
    9,
    12,
    5,
    15,
    8,
    8,
    5,
    12,
    9,
    12,
    5,
    14,
    6,
    8,
    13,
    6,
    5,
    15,
    13,
    11,
    11
  ];
});

// node_modules/hash.js/lib/hash/hmac.js
var require_hmac2 = __commonJS((exports2, module2) => {
  "use strict";
  var utils = require_utils4();
  var assert = require_minimalistic_assert();
  function Hmac(hash, key, enc) {
    if (!(this instanceof Hmac))
      return new Hmac(hash, key, enc);
    this.Hash = hash;
    this.blockSize = hash.blockSize / 8;
    this.outSize = hash.outSize / 8;
    this.inner = null;
    this.outer = null;
    this._init(utils.toArray(key, enc));
  }
  module2.exports = Hmac;
  Hmac.prototype._init = function init(key) {
    if (key.length > this.blockSize)
      key = new this.Hash().update(key).digest();
    assert(key.length <= this.blockSize);
    for (var i = key.length; i < this.blockSize; i++)
      key.push(0);
    for (i = 0; i < key.length; i++)
      key[i] ^= 54;
    this.inner = new this.Hash().update(key);
    for (i = 0; i < key.length; i++)
      key[i] ^= 106;
    this.outer = new this.Hash().update(key);
  };
  Hmac.prototype.update = function update(msg, enc) {
    this.inner.update(msg, enc);
    return this;
  };
  Hmac.prototype.digest = function digest(enc) {
    this.outer.update(this.inner.digest());
    return this.outer.digest(enc);
  };
});

// node_modules/hash.js/lib/hash.js
var require_hash = __commonJS((exports2) => {
  var hash = exports2;
  hash.utils = require_utils4();
  hash.common = require_common();
  hash.sha = require_sha();
  hash.ripemd = require_ripemd();
  hash.hmac = require_hmac2();
  hash.sha1 = hash.sha.sha1;
  hash.sha256 = hash.sha.sha256;
  hash.sha224 = hash.sha.sha224;
  hash.sha384 = hash.sha.sha384;
  hash.sha512 = hash.sha.sha512;
  hash.ripemd160 = hash.ripemd.ripemd160;
});

// node_modules/elliptic/lib/elliptic/precomputed/secp256k1.js
var require_secp256k1 = __commonJS((exports2, module2) => {
  module2.exports = {
    doubles: {
      step: 4,
      points: [
        [
          "e60fce93b59e9ec53011aabc21c23e97b2a31369b87a5ae9c44ee89e2a6dec0a",
          "f7e3507399e595929db99f34f57937101296891e44d23f0be1f32cce69616821"
        ],
        [
          "8282263212c609d9ea2a6e3e172de238d8c39cabd5ac1ca10646e23fd5f51508",
          "11f8a8098557dfe45e8256e830b60ace62d613ac2f7b17bed31b6eaff6e26caf"
        ],
        [
          "175e159f728b865a72f99cc6c6fc846de0b93833fd2222ed73fce5b551e5b739",
          "d3506e0d9e3c79eba4ef97a51ff71f5eacb5955add24345c6efa6ffee9fed695"
        ],
        [
          "363d90d447b00c9c99ceac05b6262ee053441c7e55552ffe526bad8f83ff4640",
          "4e273adfc732221953b445397f3363145b9a89008199ecb62003c7f3bee9de9"
        ],
        [
          "8b4b5f165df3c2be8c6244b5b745638843e4a781a15bcd1b69f79a55dffdf80c",
          "4aad0a6f68d308b4b3fbd7813ab0da04f9e336546162ee56b3eff0c65fd4fd36"
        ],
        [
          "723cbaa6e5db996d6bf771c00bd548c7b700dbffa6c0e77bcb6115925232fcda",
          "96e867b5595cc498a921137488824d6e2660a0653779494801dc069d9eb39f5f"
        ],
        [
          "eebfa4d493bebf98ba5feec812c2d3b50947961237a919839a533eca0e7dd7fa",
          "5d9a8ca3970ef0f269ee7edaf178089d9ae4cdc3a711f712ddfd4fdae1de8999"
        ],
        [
          "100f44da696e71672791d0a09b7bde459f1215a29b3c03bfefd7835b39a48db0",
          "cdd9e13192a00b772ec8f3300c090666b7ff4a18ff5195ac0fbd5cd62bc65a09"
        ],
        [
          "e1031be262c7ed1b1dc9227a4a04c017a77f8d4464f3b3852c8acde6e534fd2d",
          "9d7061928940405e6bb6a4176597535af292dd419e1ced79a44f18f29456a00d"
        ],
        [
          "feea6cae46d55b530ac2839f143bd7ec5cf8b266a41d6af52d5e688d9094696d",
          "e57c6b6c97dce1bab06e4e12bf3ecd5c981c8957cc41442d3155debf18090088"
        ],
        [
          "da67a91d91049cdcb367be4be6ffca3cfeed657d808583de33fa978bc1ec6cb1",
          "9bacaa35481642bc41f463f7ec9780e5dec7adc508f740a17e9ea8e27a68be1d"
        ],
        [
          "53904faa0b334cdda6e000935ef22151ec08d0f7bb11069f57545ccc1a37b7c0",
          "5bc087d0bc80106d88c9eccac20d3c1c13999981e14434699dcb096b022771c8"
        ],
        [
          "8e7bcd0bd35983a7719cca7764ca906779b53a043a9b8bcaeff959f43ad86047",
          "10b7770b2a3da4b3940310420ca9514579e88e2e47fd68b3ea10047e8460372a"
        ],
        [
          "385eed34c1cdff21e6d0818689b81bde71a7f4f18397e6690a841e1599c43862",
          "283bebc3e8ea23f56701de19e9ebf4576b304eec2086dc8cc0458fe5542e5453"
        ],
        [
          "6f9d9b803ecf191637c73a4413dfa180fddf84a5947fbc9c606ed86c3fac3a7",
          "7c80c68e603059ba69b8e2a30e45c4d47ea4dd2f5c281002d86890603a842160"
        ],
        [
          "3322d401243c4e2582a2147c104d6ecbf774d163db0f5e5313b7e0e742d0e6bd",
          "56e70797e9664ef5bfb019bc4ddaf9b72805f63ea2873af624f3a2e96c28b2a0"
        ],
        [
          "85672c7d2de0b7da2bd1770d89665868741b3f9af7643397721d74d28134ab83",
          "7c481b9b5b43b2eb6374049bfa62c2e5e77f17fcc5298f44c8e3094f790313a6"
        ],
        [
          "948bf809b1988a46b06c9f1919413b10f9226c60f668832ffd959af60c82a0a",
          "53a562856dcb6646dc6b74c5d1c3418c6d4dff08c97cd2bed4cb7f88d8c8e589"
        ],
        [
          "6260ce7f461801c34f067ce0f02873a8f1b0e44dfc69752accecd819f38fd8e8",
          "bc2da82b6fa5b571a7f09049776a1ef7ecd292238051c198c1a84e95b2b4ae17"
        ],
        [
          "e5037de0afc1d8d43d8348414bbf4103043ec8f575bfdc432953cc8d2037fa2d",
          "4571534baa94d3b5f9f98d09fb990bddbd5f5b03ec481f10e0e5dc841d755bda"
        ],
        [
          "e06372b0f4a207adf5ea905e8f1771b4e7e8dbd1c6a6c5b725866a0ae4fce725",
          "7a908974bce18cfe12a27bb2ad5a488cd7484a7787104870b27034f94eee31dd"
        ],
        [
          "213c7a715cd5d45358d0bbf9dc0ce02204b10bdde2a3f58540ad6908d0559754",
          "4b6dad0b5ae462507013ad06245ba190bb4850f5f36a7eeddff2c27534b458f2"
        ],
        [
          "4e7c272a7af4b34e8dbb9352a5419a87e2838c70adc62cddf0cc3a3b08fbd53c",
          "17749c766c9d0b18e16fd09f6def681b530b9614bff7dd33e0b3941817dcaae6"
        ],
        [
          "fea74e3dbe778b1b10f238ad61686aa5c76e3db2be43057632427e2840fb27b6",
          "6e0568db9b0b13297cf674deccb6af93126b596b973f7b77701d3db7f23cb96f"
        ],
        [
          "76e64113f677cf0e10a2570d599968d31544e179b760432952c02a4417bdde39",
          "c90ddf8dee4e95cf577066d70681f0d35e2a33d2b56d2032b4b1752d1901ac01"
        ],
        [
          "c738c56b03b2abe1e8281baa743f8f9a8f7cc643df26cbee3ab150242bcbb891",
          "893fb578951ad2537f718f2eacbfbbbb82314eef7880cfe917e735d9699a84c3"
        ],
        [
          "d895626548b65b81e264c7637c972877d1d72e5f3a925014372e9f6588f6c14b",
          "febfaa38f2bc7eae728ec60818c340eb03428d632bb067e179363ed75d7d991f"
        ],
        [
          "b8da94032a957518eb0f6433571e8761ceffc73693e84edd49150a564f676e03",
          "2804dfa44805a1e4d7c99cc9762808b092cc584d95ff3b511488e4e74efdf6e7"
        ],
        [
          "e80fea14441fb33a7d8adab9475d7fab2019effb5156a792f1a11778e3c0df5d",
          "eed1de7f638e00771e89768ca3ca94472d155e80af322ea9fcb4291b6ac9ec78"
        ],
        [
          "a301697bdfcd704313ba48e51d567543f2a182031efd6915ddc07bbcc4e16070",
          "7370f91cfb67e4f5081809fa25d40f9b1735dbf7c0a11a130c0d1a041e177ea1"
        ],
        [
          "90ad85b389d6b936463f9d0512678de208cc330b11307fffab7ac63e3fb04ed4",
          "e507a3620a38261affdcbd9427222b839aefabe1582894d991d4d48cb6ef150"
        ],
        [
          "8f68b9d2f63b5f339239c1ad981f162ee88c5678723ea3351b7b444c9ec4c0da",
          "662a9f2dba063986de1d90c2b6be215dbbea2cfe95510bfdf23cbf79501fff82"
        ],
        [
          "e4f3fb0176af85d65ff99ff9198c36091f48e86503681e3e6686fd5053231e11",
          "1e63633ad0ef4f1c1661a6d0ea02b7286cc7e74ec951d1c9822c38576feb73bc"
        ],
        [
          "8c00fa9b18ebf331eb961537a45a4266c7034f2f0d4e1d0716fb6eae20eae29e",
          "efa47267fea521a1a9dc343a3736c974c2fadafa81e36c54e7d2a4c66702414b"
        ],
        [
          "e7a26ce69dd4829f3e10cec0a9e98ed3143d084f308b92c0997fddfc60cb3e41",
          "2a758e300fa7984b471b006a1aafbb18d0a6b2c0420e83e20e8a9421cf2cfd51"
        ],
        [
          "b6459e0ee3662ec8d23540c223bcbdc571cbcb967d79424f3cf29eb3de6b80ef",
          "67c876d06f3e06de1dadf16e5661db3c4b3ae6d48e35b2ff30bf0b61a71ba45"
        ],
        [
          "d68a80c8280bb840793234aa118f06231d6f1fc67e73c5a5deda0f5b496943e8",
          "db8ba9fff4b586d00c4b1f9177b0e28b5b0e7b8f7845295a294c84266b133120"
        ],
        [
          "324aed7df65c804252dc0270907a30b09612aeb973449cea4095980fc28d3d5d",
          "648a365774b61f2ff130c0c35aec1f4f19213b0c7e332843967224af96ab7c84"
        ],
        [
          "4df9c14919cde61f6d51dfdbe5fee5dceec4143ba8d1ca888e8bd373fd054c96",
          "35ec51092d8728050974c23a1d85d4b5d506cdc288490192ebac06cad10d5d"
        ],
        [
          "9c3919a84a474870faed8a9c1cc66021523489054d7f0308cbfc99c8ac1f98cd",
          "ddb84f0f4a4ddd57584f044bf260e641905326f76c64c8e6be7e5e03d4fc599d"
        ],
        [
          "6057170b1dd12fdf8de05f281d8e06bb91e1493a8b91d4cc5a21382120a959e5",
          "9a1af0b26a6a4807add9a2daf71df262465152bc3ee24c65e899be932385a2a8"
        ],
        [
          "a576df8e23a08411421439a4518da31880cef0fba7d4df12b1a6973eecb94266",
          "40a6bf20e76640b2c92b97afe58cd82c432e10a7f514d9f3ee8be11ae1b28ec8"
        ],
        [
          "7778a78c28dec3e30a05fe9629de8c38bb30d1f5cf9a3a208f763889be58ad71",
          "34626d9ab5a5b22ff7098e12f2ff580087b38411ff24ac563b513fc1fd9f43ac"
        ],
        [
          "928955ee637a84463729fd30e7afd2ed5f96274e5ad7e5cb09eda9c06d903ac",
          "c25621003d3f42a827b78a13093a95eeac3d26efa8a8d83fc5180e935bcd091f"
        ],
        [
          "85d0fef3ec6db109399064f3a0e3b2855645b4a907ad354527aae75163d82751",
          "1f03648413a38c0be29d496e582cf5663e8751e96877331582c237a24eb1f962"
        ],
        [
          "ff2b0dce97eece97c1c9b6041798b85dfdfb6d8882da20308f5404824526087e",
          "493d13fef524ba188af4c4dc54d07936c7b7ed6fb90e2ceb2c951e01f0c29907"
        ],
        [
          "827fbbe4b1e880ea9ed2b2e6301b212b57f1ee148cd6dd28780e5e2cf856e241",
          "c60f9c923c727b0b71bef2c67d1d12687ff7a63186903166d605b68baec293ec"
        ],
        [
          "eaa649f21f51bdbae7be4ae34ce6e5217a58fdce7f47f9aa7f3b58fa2120e2b3",
          "be3279ed5bbbb03ac69a80f89879aa5a01a6b965f13f7e59d47a5305ba5ad93d"
        ],
        [
          "e4a42d43c5cf169d9391df6decf42ee541b6d8f0c9a137401e23632dda34d24f",
          "4d9f92e716d1c73526fc99ccfb8ad34ce886eedfa8d8e4f13a7f7131deba9414"
        ],
        [
          "1ec80fef360cbdd954160fadab352b6b92b53576a88fea4947173b9d4300bf19",
          "aeefe93756b5340d2f3a4958a7abbf5e0146e77f6295a07b671cdc1cc107cefd"
        ],
        [
          "146a778c04670c2f91b00af4680dfa8bce3490717d58ba889ddb5928366642be",
          "b318e0ec3354028add669827f9d4b2870aaa971d2f7e5ed1d0b297483d83efd0"
        ],
        [
          "fa50c0f61d22e5f07e3acebb1aa07b128d0012209a28b9776d76a8793180eef9",
          "6b84c6922397eba9b72cd2872281a68a5e683293a57a213b38cd8d7d3f4f2811"
        ],
        [
          "da1d61d0ca721a11b1a5bf6b7d88e8421a288ab5d5bba5220e53d32b5f067ec2",
          "8157f55a7c99306c79c0766161c91e2966a73899d279b48a655fba0f1ad836f1"
        ],
        [
          "a8e282ff0c9706907215ff98e8fd416615311de0446f1e062a73b0610d064e13",
          "7f97355b8db81c09abfb7f3c5b2515888b679a3e50dd6bd6cef7c73111f4cc0c"
        ],
        [
          "174a53b9c9a285872d39e56e6913cab15d59b1fa512508c022f382de8319497c",
          "ccc9dc37abfc9c1657b4155f2c47f9e6646b3a1d8cb9854383da13ac079afa73"
        ],
        [
          "959396981943785c3d3e57edf5018cdbe039e730e4918b3d884fdff09475b7ba",
          "2e7e552888c331dd8ba0386a4b9cd6849c653f64c8709385e9b8abf87524f2fd"
        ],
        [
          "d2a63a50ae401e56d645a1153b109a8fcca0a43d561fba2dbb51340c9d82b151",
          "e82d86fb6443fcb7565aee58b2948220a70f750af484ca52d4142174dcf89405"
        ],
        [
          "64587e2335471eb890ee7896d7cfdc866bacbdbd3839317b3436f9b45617e073",
          "d99fcdd5bf6902e2ae96dd6447c299a185b90a39133aeab358299e5e9faf6589"
        ],
        [
          "8481bde0e4e4d885b3a546d3e549de042f0aa6cea250e7fd358d6c86dd45e458",
          "38ee7b8cba5404dd84a25bf39cecb2ca900a79c42b262e556d64b1b59779057e"
        ],
        [
          "13464a57a78102aa62b6979ae817f4637ffcfed3c4b1ce30bcd6303f6caf666b",
          "69be159004614580ef7e433453ccb0ca48f300a81d0942e13f495a907f6ecc27"
        ],
        [
          "bc4a9df5b713fe2e9aef430bcc1dc97a0cd9ccede2f28588cada3a0d2d83f366",
          "d3a81ca6e785c06383937adf4b798caa6e8a9fbfa547b16d758d666581f33c1"
        ],
        [
          "8c28a97bf8298bc0d23d8c749452a32e694b65e30a9472a3954ab30fe5324caa",
          "40a30463a3305193378fedf31f7cc0eb7ae784f0451cb9459e71dc73cbef9482"
        ],
        [
          "8ea9666139527a8c1dd94ce4f071fd23c8b350c5a4bb33748c4ba111faccae0",
          "620efabbc8ee2782e24e7c0cfb95c5d735b783be9cf0f8e955af34a30e62b945"
        ],
        [
          "dd3625faef5ba06074669716bbd3788d89bdde815959968092f76cc4eb9a9787",
          "7a188fa3520e30d461da2501045731ca941461982883395937f68d00c644a573"
        ],
        [
          "f710d79d9eb962297e4f6232b40e8f7feb2bc63814614d692c12de752408221e",
          "ea98e67232d3b3295d3b535532115ccac8612c721851617526ae47a9c77bfc82"
        ]
      ]
    },
    naf: {
      wnd: 7,
      points: [
        [
          "f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9",
          "388f7b0f632de8140fe337e62a37f3566500a99934c2231b6cb9fd7584b8e672"
        ],
        [
          "2f8bde4d1a07209355b4a7250a5c5128e88b84bddc619ab7cba8d569b240efe4",
          "d8ac222636e5e3d6d4dba9dda6c9c426f788271bab0d6840dca87d3aa6ac62d6"
        ],
        [
          "5cbdf0646e5db4eaa398f365f2ea7a0e3d419b7e0330e39ce92bddedcac4f9bc",
          "6aebca40ba255960a3178d6d861a54dba813d0b813fde7b5a5082628087264da"
        ],
        [
          "acd484e2f0c7f65309ad178a9f559abde09796974c57e714c35f110dfc27ccbe",
          "cc338921b0a7d9fd64380971763b61e9add888a4375f8e0f05cc262ac64f9c37"
        ],
        [
          "774ae7f858a9411e5ef4246b70c65aac5649980be5c17891bbec17895da008cb",
          "d984a032eb6b5e190243dd56d7b7b365372db1e2dff9d6a8301d74c9c953c61b"
        ],
        [
          "f28773c2d975288bc7d1d205c3748651b075fbc6610e58cddeeddf8f19405aa8",
          "ab0902e8d880a89758212eb65cdaf473a1a06da521fa91f29b5cb52db03ed81"
        ],
        [
          "d7924d4f7d43ea965a465ae3095ff41131e5946f3c85f79e44adbcf8e27e080e",
          "581e2872a86c72a683842ec228cc6defea40af2bd896d3a5c504dc9ff6a26b58"
        ],
        [
          "defdea4cdb677750a420fee807eacf21eb9898ae79b9768766e4faa04a2d4a34",
          "4211ab0694635168e997b0ead2a93daeced1f4a04a95c0f6cfb199f69e56eb77"
        ],
        [
          "2b4ea0a797a443d293ef5cff444f4979f06acfebd7e86d277475656138385b6c",
          "85e89bc037945d93b343083b5a1c86131a01f60c50269763b570c854e5c09b7a"
        ],
        [
          "352bbf4a4cdd12564f93fa332ce333301d9ad40271f8107181340aef25be59d5",
          "321eb4075348f534d59c18259dda3e1f4a1b3b2e71b1039c67bd3d8bcf81998c"
        ],
        [
          "2fa2104d6b38d11b0230010559879124e42ab8dfeff5ff29dc9cdadd4ecacc3f",
          "2de1068295dd865b64569335bd5dd80181d70ecfc882648423ba76b532b7d67"
        ],
        [
          "9248279b09b4d68dab21a9b066edda83263c3d84e09572e269ca0cd7f5453714",
          "73016f7bf234aade5d1aa71bdea2b1ff3fc0de2a887912ffe54a32ce97cb3402"
        ],
        [
          "daed4f2be3a8bf278e70132fb0beb7522f570e144bf615c07e996d443dee8729",
          "a69dce4a7d6c98e8d4a1aca87ef8d7003f83c230f3afa726ab40e52290be1c55"
        ],
        [
          "c44d12c7065d812e8acf28d7cbb19f9011ecd9e9fdf281b0e6a3b5e87d22e7db",
          "2119a460ce326cdc76c45926c982fdac0e106e861edf61c5a039063f0e0e6482"
        ],
        [
          "6a245bf6dc698504c89a20cfded60853152b695336c28063b61c65cbd269e6b4",
          "e022cf42c2bd4a708b3f5126f16a24ad8b33ba48d0423b6efd5e6348100d8a82"
        ],
        [
          "1697ffa6fd9de627c077e3d2fe541084ce13300b0bec1146f95ae57f0d0bd6a5",
          "b9c398f186806f5d27561506e4557433a2cf15009e498ae7adee9d63d01b2396"
        ],
        [
          "605bdb019981718b986d0f07e834cb0d9deb8360ffb7f61df982345ef27a7479",
          "2972d2de4f8d20681a78d93ec96fe23c26bfae84fb14db43b01e1e9056b8c49"
        ],
        [
          "62d14dab4150bf497402fdc45a215e10dcb01c354959b10cfe31c7e9d87ff33d",
          "80fc06bd8cc5b01098088a1950eed0db01aa132967ab472235f5642483b25eaf"
        ],
        [
          "80c60ad0040f27dade5b4b06c408e56b2c50e9f56b9b8b425e555c2f86308b6f",
          "1c38303f1cc5c30f26e66bad7fe72f70a65eed4cbe7024eb1aa01f56430bd57a"
        ],
        [
          "7a9375ad6167ad54aa74c6348cc54d344cc5dc9487d847049d5eabb0fa03c8fb",
          "d0e3fa9eca8726909559e0d79269046bdc59ea10c70ce2b02d499ec224dc7f7"
        ],
        [
          "d528ecd9b696b54c907a9ed045447a79bb408ec39b68df504bb51f459bc3ffc9",
          "eecf41253136e5f99966f21881fd656ebc4345405c520dbc063465b521409933"
        ],
        [
          "49370a4b5f43412ea25f514e8ecdad05266115e4a7ecb1387231808f8b45963",
          "758f3f41afd6ed428b3081b0512fd62a54c3f3afbb5b6764b653052a12949c9a"
        ],
        [
          "77f230936ee88cbbd73df930d64702ef881d811e0e1498e2f1c13eb1fc345d74",
          "958ef42a7886b6400a08266e9ba1b37896c95330d97077cbbe8eb3c7671c60d6"
        ],
        [
          "f2dac991cc4ce4b9ea44887e5c7c0bce58c80074ab9d4dbaeb28531b7739f530",
          "e0dedc9b3b2f8dad4da1f32dec2531df9eb5fbeb0598e4fd1a117dba703a3c37"
        ],
        [
          "463b3d9f662621fb1b4be8fbbe2520125a216cdfc9dae3debcba4850c690d45b",
          "5ed430d78c296c3543114306dd8622d7c622e27c970a1de31cb377b01af7307e"
        ],
        [
          "f16f804244e46e2a09232d4aff3b59976b98fac14328a2d1a32496b49998f247",
          "cedabd9b82203f7e13d206fcdf4e33d92a6c53c26e5cce26d6579962c4e31df6"
        ],
        [
          "caf754272dc84563b0352b7a14311af55d245315ace27c65369e15f7151d41d1",
          "cb474660ef35f5f2a41b643fa5e460575f4fa9b7962232a5c32f908318a04476"
        ],
        [
          "2600ca4b282cb986f85d0f1709979d8b44a09c07cb86d7c124497bc86f082120",
          "4119b88753c15bd6a693b03fcddbb45d5ac6be74ab5f0ef44b0be9475a7e4b40"
        ],
        [
          "7635ca72d7e8432c338ec53cd12220bc01c48685e24f7dc8c602a7746998e435",
          "91b649609489d613d1d5e590f78e6d74ecfc061d57048bad9e76f302c5b9c61"
        ],
        [
          "754e3239f325570cdbbf4a87deee8a66b7f2b33479d468fbc1a50743bf56cc18",
          "673fb86e5bda30fb3cd0ed304ea49a023ee33d0197a695d0c5d98093c536683"
        ],
        [
          "e3e6bd1071a1e96aff57859c82d570f0330800661d1c952f9fe2694691d9b9e8",
          "59c9e0bba394e76f40c0aa58379a3cb6a5a2283993e90c4167002af4920e37f5"
        ],
        [
          "186b483d056a033826ae73d88f732985c4ccb1f32ba35f4b4cc47fdcf04aa6eb",
          "3b952d32c67cf77e2e17446e204180ab21fb8090895138b4a4a797f86e80888b"
        ],
        [
          "df9d70a6b9876ce544c98561f4be4f725442e6d2b737d9c91a8321724ce0963f",
          "55eb2dafd84d6ccd5f862b785dc39d4ab157222720ef9da217b8c45cf2ba2417"
        ],
        [
          "5edd5cc23c51e87a497ca815d5dce0f8ab52554f849ed8995de64c5f34ce7143",
          "efae9c8dbc14130661e8cec030c89ad0c13c66c0d17a2905cdc706ab7399a868"
        ],
        [
          "290798c2b6476830da12fe02287e9e777aa3fba1c355b17a722d362f84614fba",
          "e38da76dcd440621988d00bcf79af25d5b29c094db2a23146d003afd41943e7a"
        ],
        [
          "af3c423a95d9f5b3054754efa150ac39cd29552fe360257362dfdecef4053b45",
          "f98a3fd831eb2b749a93b0e6f35cfb40c8cd5aa667a15581bc2feded498fd9c6"
        ],
        [
          "766dbb24d134e745cccaa28c99bf274906bb66b26dcf98df8d2fed50d884249a",
          "744b1152eacbe5e38dcc887980da38b897584a65fa06cedd2c924f97cbac5996"
        ],
        [
          "59dbf46f8c94759ba21277c33784f41645f7b44f6c596a58ce92e666191abe3e",
          "c534ad44175fbc300f4ea6ce648309a042ce739a7919798cd85e216c4a307f6e"
        ],
        [
          "f13ada95103c4537305e691e74e9a4a8dd647e711a95e73cb62dc6018cfd87b8",
          "e13817b44ee14de663bf4bc808341f326949e21a6a75c2570778419bdaf5733d"
        ],
        [
          "7754b4fa0e8aced06d4167a2c59cca4cda1869c06ebadfb6488550015a88522c",
          "30e93e864e669d82224b967c3020b8fa8d1e4e350b6cbcc537a48b57841163a2"
        ],
        [
          "948dcadf5990e048aa3874d46abef9d701858f95de8041d2a6828c99e2262519",
          "e491a42537f6e597d5d28a3224b1bc25df9154efbd2ef1d2cbba2cae5347d57e"
        ],
        [
          "7962414450c76c1689c7b48f8202ec37fb224cf5ac0bfa1570328a8a3d7c77ab",
          "100b610ec4ffb4760d5c1fc133ef6f6b12507a051f04ac5760afa5b29db83437"
        ],
        [
          "3514087834964b54b15b160644d915485a16977225b8847bb0dd085137ec47ca",
          "ef0afbb2056205448e1652c48e8127fc6039e77c15c2378b7e7d15a0de293311"
        ],
        [
          "d3cc30ad6b483e4bc79ce2c9dd8bc54993e947eb8df787b442943d3f7b527eaf",
          "8b378a22d827278d89c5e9be8f9508ae3c2ad46290358630afb34db04eede0a4"
        ],
        [
          "1624d84780732860ce1c78fcbfefe08b2b29823db913f6493975ba0ff4847610",
          "68651cf9b6da903e0914448c6cd9d4ca896878f5282be4c8cc06e2a404078575"
        ],
        [
          "733ce80da955a8a26902c95633e62a985192474b5af207da6df7b4fd5fc61cd4",
          "f5435a2bd2badf7d485a4d8b8db9fcce3e1ef8e0201e4578c54673bc1dc5ea1d"
        ],
        [
          "15d9441254945064cf1a1c33bbd3b49f8966c5092171e699ef258dfab81c045c",
          "d56eb30b69463e7234f5137b73b84177434800bacebfc685fc37bbe9efe4070d"
        ],
        [
          "a1d0fcf2ec9de675b612136e5ce70d271c21417c9d2b8aaaac138599d0717940",
          "edd77f50bcb5a3cab2e90737309667f2641462a54070f3d519212d39c197a629"
        ],
        [
          "e22fbe15c0af8ccc5780c0735f84dbe9a790badee8245c06c7ca37331cb36980",
          "a855babad5cd60c88b430a69f53a1a7a38289154964799be43d06d77d31da06"
        ],
        [
          "311091dd9860e8e20ee13473c1155f5f69635e394704eaa74009452246cfa9b3",
          "66db656f87d1f04fffd1f04788c06830871ec5a64feee685bd80f0b1286d8374"
        ],
        [
          "34c1fd04d301be89b31c0442d3e6ac24883928b45a9340781867d4232ec2dbdf",
          "9414685e97b1b5954bd46f730174136d57f1ceeb487443dc5321857ba73abee"
        ],
        [
          "f219ea5d6b54701c1c14de5b557eb42a8d13f3abbcd08affcc2a5e6b049b8d63",
          "4cb95957e83d40b0f73af4544cccf6b1f4b08d3c07b27fb8d8c2962a400766d1"
        ],
        [
          "d7b8740f74a8fbaab1f683db8f45de26543a5490bca627087236912469a0b448",
          "fa77968128d9c92ee1010f337ad4717eff15db5ed3c049b3411e0315eaa4593b"
        ],
        [
          "32d31c222f8f6f0ef86f7c98d3a3335ead5bcd32abdd94289fe4d3091aa824bf",
          "5f3032f5892156e39ccd3d7915b9e1da2e6dac9e6f26e961118d14b8462e1661"
        ],
        [
          "7461f371914ab32671045a155d9831ea8793d77cd59592c4340f86cbc18347b5",
          "8ec0ba238b96bec0cbdddcae0aa442542eee1ff50c986ea6b39847b3cc092ff6"
        ],
        [
          "ee079adb1df1860074356a25aa38206a6d716b2c3e67453d287698bad7b2b2d6",
          "8dc2412aafe3be5c4c5f37e0ecc5f9f6a446989af04c4e25ebaac479ec1c8c1e"
        ],
        [
          "16ec93e447ec83f0467b18302ee620f7e65de331874c9dc72bfd8616ba9da6b5",
          "5e4631150e62fb40d0e8c2a7ca5804a39d58186a50e497139626778e25b0674d"
        ],
        [
          "eaa5f980c245f6f038978290afa70b6bd8855897f98b6aa485b96065d537bd99",
          "f65f5d3e292c2e0819a528391c994624d784869d7e6ea67fb18041024edc07dc"
        ],
        [
          "78c9407544ac132692ee1910a02439958ae04877151342ea96c4b6b35a49f51",
          "f3e0319169eb9b85d5404795539a5e68fa1fbd583c064d2462b675f194a3ddb4"
        ],
        [
          "494f4be219a1a77016dcd838431aea0001cdc8ae7a6fc688726578d9702857a5",
          "42242a969283a5f339ba7f075e36ba2af925ce30d767ed6e55f4b031880d562c"
        ],
        [
          "a598a8030da6d86c6bc7f2f5144ea549d28211ea58faa70ebf4c1e665c1fe9b5",
          "204b5d6f84822c307e4b4a7140737aec23fc63b65b35f86a10026dbd2d864e6b"
        ],
        [
          "c41916365abb2b5d09192f5f2dbeafec208f020f12570a184dbadc3e58595997",
          "4f14351d0087efa49d245b328984989d5caf9450f34bfc0ed16e96b58fa9913"
        ],
        [
          "841d6063a586fa475a724604da03bc5b92a2e0d2e0a36acfe4c73a5514742881",
          "73867f59c0659e81904f9a1c7543698e62562d6744c169ce7a36de01a8d6154"
        ],
        [
          "5e95bb399a6971d376026947f89bde2f282b33810928be4ded112ac4d70e20d5",
          "39f23f366809085beebfc71181313775a99c9aed7d8ba38b161384c746012865"
        ],
        [
          "36e4641a53948fd476c39f8a99fd974e5ec07564b5315d8bf99471bca0ef2f66",
          "d2424b1b1abe4eb8164227b085c9aa9456ea13493fd563e06fd51cf5694c78fc"
        ],
        [
          "336581ea7bfbbb290c191a2f507a41cf5643842170e914faeab27c2c579f726",
          "ead12168595fe1be99252129b6e56b3391f7ab1410cd1e0ef3dcdcabd2fda224"
        ],
        [
          "8ab89816dadfd6b6a1f2634fcf00ec8403781025ed6890c4849742706bd43ede",
          "6fdcef09f2f6d0a044e654aef624136f503d459c3e89845858a47a9129cdd24e"
        ],
        [
          "1e33f1a746c9c5778133344d9299fcaa20b0938e8acff2544bb40284b8c5fb94",
          "60660257dd11b3aa9c8ed618d24edff2306d320f1d03010e33a7d2057f3b3b6"
        ],
        [
          "85b7c1dcb3cec1b7ee7f30ded79dd20a0ed1f4cc18cbcfcfa410361fd8f08f31",
          "3d98a9cdd026dd43f39048f25a8847f4fcafad1895d7a633c6fed3c35e999511"
        ],
        [
          "29df9fbd8d9e46509275f4b125d6d45d7fbe9a3b878a7af872a2800661ac5f51",
          "b4c4fe99c775a606e2d8862179139ffda61dc861c019e55cd2876eb2a27d84b"
        ],
        [
          "a0b1cae06b0a847a3fea6e671aaf8adfdfe58ca2f768105c8082b2e449fce252",
          "ae434102edde0958ec4b19d917a6a28e6b72da1834aff0e650f049503a296cf2"
        ],
        [
          "4e8ceafb9b3e9a136dc7ff67e840295b499dfb3b2133e4ba113f2e4c0e121e5",
          "cf2174118c8b6d7a4b48f6d534ce5c79422c086a63460502b827ce62a326683c"
        ],
        [
          "d24a44e047e19b6f5afb81c7ca2f69080a5076689a010919f42725c2b789a33b",
          "6fb8d5591b466f8fc63db50f1c0f1c69013f996887b8244d2cdec417afea8fa3"
        ],
        [
          "ea01606a7a6c9cdd249fdfcfacb99584001edd28abbab77b5104e98e8e3b35d4",
          "322af4908c7312b0cfbfe369f7a7b3cdb7d4494bc2823700cfd652188a3ea98d"
        ],
        [
          "af8addbf2b661c8a6c6328655eb96651252007d8c5ea31be4ad196de8ce2131f",
          "6749e67c029b85f52a034eafd096836b2520818680e26ac8f3dfbcdb71749700"
        ],
        [
          "e3ae1974566ca06cc516d47e0fb165a674a3dabcfca15e722f0e3450f45889",
          "2aeabe7e4531510116217f07bf4d07300de97e4874f81f533420a72eeb0bd6a4"
        ],
        [
          "591ee355313d99721cf6993ffed1e3e301993ff3ed258802075ea8ced397e246",
          "b0ea558a113c30bea60fc4775460c7901ff0b053d25ca2bdeee98f1a4be5d196"
        ],
        [
          "11396d55fda54c49f19aa97318d8da61fa8584e47b084945077cf03255b52984",
          "998c74a8cd45ac01289d5833a7beb4744ff536b01b257be4c5767bea93ea57a4"
        ],
        [
          "3c5d2a1ba39c5a1790000738c9e0c40b8dcdfd5468754b6405540157e017aa7a",
          "b2284279995a34e2f9d4de7396fc18b80f9b8b9fdd270f6661f79ca4c81bd257"
        ],
        [
          "cc8704b8a60a0defa3a99a7299f2e9c3fbc395afb04ac078425ef8a1793cc030",
          "bdd46039feed17881d1e0862db347f8cf395b74fc4bcdc4e940b74e3ac1f1b13"
        ],
        [
          "c533e4f7ea8555aacd9777ac5cad29b97dd4defccc53ee7ea204119b2889b197",
          "6f0a256bc5efdf429a2fb6242f1a43a2d9b925bb4a4b3a26bb8e0f45eb596096"
        ],
        [
          "c14f8f2ccb27d6f109f6d08d03cc96a69ba8c34eec07bbcf566d48e33da6593",
          "c359d6923bb398f7fd4473e16fe1c28475b740dd098075e6c0e8649113dc3a38"
        ],
        [
          "a6cbc3046bc6a450bac24789fa17115a4c9739ed75f8f21ce441f72e0b90e6ef",
          "21ae7f4680e889bb130619e2c0f95a360ceb573c70603139862afd617fa9b9f"
        ],
        [
          "347d6d9a02c48927ebfb86c1359b1caf130a3c0267d11ce6344b39f99d43cc38",
          "60ea7f61a353524d1c987f6ecec92f086d565ab687870cb12689ff1e31c74448"
        ],
        [
          "da6545d2181db8d983f7dcb375ef5866d47c67b1bf31c8cf855ef7437b72656a",
          "49b96715ab6878a79e78f07ce5680c5d6673051b4935bd897fea824b77dc208a"
        ],
        [
          "c40747cc9d012cb1a13b8148309c6de7ec25d6945d657146b9d5994b8feb1111",
          "5ca560753be2a12fc6de6caf2cb489565db936156b9514e1bb5e83037e0fa2d4"
        ],
        [
          "4e42c8ec82c99798ccf3a610be870e78338c7f713348bd34c8203ef4037f3502",
          "7571d74ee5e0fb92a7a8b33a07783341a5492144cc54bcc40a94473693606437"
        ],
        [
          "3775ab7089bc6af823aba2e1af70b236d251cadb0c86743287522a1b3b0dedea",
          "be52d107bcfa09d8bcb9736a828cfa7fac8db17bf7a76a2c42ad961409018cf7"
        ],
        [
          "cee31cbf7e34ec379d94fb814d3d775ad954595d1314ba8846959e3e82f74e26",
          "8fd64a14c06b589c26b947ae2bcf6bfa0149ef0be14ed4d80f448a01c43b1c6d"
        ],
        [
          "b4f9eaea09b6917619f6ea6a4eb5464efddb58fd45b1ebefcdc1a01d08b47986",
          "39e5c9925b5a54b07433a4f18c61726f8bb131c012ca542eb24a8ac07200682a"
        ],
        [
          "d4263dfc3d2df923a0179a48966d30ce84e2515afc3dccc1b77907792ebcc60e",
          "62dfaf07a0f78feb30e30d6295853ce189e127760ad6cf7fae164e122a208d54"
        ],
        [
          "48457524820fa65a4f8d35eb6930857c0032acc0a4a2de422233eeda897612c4",
          "25a748ab367979d98733c38a1fa1c2e7dc6cc07db2d60a9ae7a76aaa49bd0f77"
        ],
        [
          "dfeeef1881101f2cb11644f3a2afdfc2045e19919152923f367a1767c11cceda",
          "ecfb7056cf1de042f9420bab396793c0c390bde74b4bbdff16a83ae09a9a7517"
        ],
        [
          "6d7ef6b17543f8373c573f44e1f389835d89bcbc6062ced36c82df83b8fae859",
          "cd450ec335438986dfefa10c57fea9bcc521a0959b2d80bbf74b190dca712d10"
        ],
        [
          "e75605d59102a5a2684500d3b991f2e3f3c88b93225547035af25af66e04541f",
          "f5c54754a8f71ee540b9b48728473e314f729ac5308b06938360990e2bfad125"
        ],
        [
          "eb98660f4c4dfaa06a2be453d5020bc99a0c2e60abe388457dd43fefb1ed620c",
          "6cb9a8876d9cb8520609af3add26cd20a0a7cd8a9411131ce85f44100099223e"
        ],
        [
          "13e87b027d8514d35939f2e6892b19922154596941888336dc3563e3b8dba942",
          "fef5a3c68059a6dec5d624114bf1e91aac2b9da568d6abeb2570d55646b8adf1"
        ],
        [
          "ee163026e9fd6fe017c38f06a5be6fc125424b371ce2708e7bf4491691e5764a",
          "1acb250f255dd61c43d94ccc670d0f58f49ae3fa15b96623e5430da0ad6c62b2"
        ],
        [
          "b268f5ef9ad51e4d78de3a750c2dc89b1e626d43505867999932e5db33af3d80",
          "5f310d4b3c99b9ebb19f77d41c1dee018cf0d34fd4191614003e945a1216e423"
        ],
        [
          "ff07f3118a9df035e9fad85eb6c7bfe42b02f01ca99ceea3bf7ffdba93c4750d",
          "438136d603e858a3a5c440c38eccbaddc1d2942114e2eddd4740d098ced1f0d8"
        ],
        [
          "8d8b9855c7c052a34146fd20ffb658bea4b9f69e0d825ebec16e8c3ce2b526a1",
          "cdb559eedc2d79f926baf44fb84ea4d44bcf50fee51d7ceb30e2e7f463036758"
        ],
        [
          "52db0b5384dfbf05bfa9d472d7ae26dfe4b851ceca91b1eba54263180da32b63",
          "c3b997d050ee5d423ebaf66a6db9f57b3180c902875679de924b69d84a7b375"
        ],
        [
          "e62f9490d3d51da6395efd24e80919cc7d0f29c3f3fa48c6fff543becbd43352",
          "6d89ad7ba4876b0b22c2ca280c682862f342c8591f1daf5170e07bfd9ccafa7d"
        ],
        [
          "7f30ea2476b399b4957509c88f77d0191afa2ff5cb7b14fd6d8e7d65aaab1193",
          "ca5ef7d4b231c94c3b15389a5f6311e9daff7bb67b103e9880ef4bff637acaec"
        ],
        [
          "5098ff1e1d9f14fb46a210fada6c903fef0fb7b4a1dd1d9ac60a0361800b7a00",
          "9731141d81fc8f8084d37c6e7542006b3ee1b40d60dfe5362a5b132fd17ddc0"
        ],
        [
          "32b78c7de9ee512a72895be6b9cbefa6e2f3c4ccce445c96b9f2c81e2778ad58",
          "ee1849f513df71e32efc3896ee28260c73bb80547ae2275ba497237794c8753c"
        ],
        [
          "e2cb74fddc8e9fbcd076eef2a7c72b0ce37d50f08269dfc074b581550547a4f7",
          "d3aa2ed71c9dd2247a62df062736eb0baddea9e36122d2be8641abcb005cc4a4"
        ],
        [
          "8438447566d4d7bedadc299496ab357426009a35f235cb141be0d99cd10ae3a8",
          "c4e1020916980a4da5d01ac5e6ad330734ef0d7906631c4f2390426b2edd791f"
        ],
        [
          "4162d488b89402039b584c6fc6c308870587d9c46f660b878ab65c82c711d67e",
          "67163e903236289f776f22c25fb8a3afc1732f2b84b4e95dbda47ae5a0852649"
        ],
        [
          "3fad3fa84caf0f34f0f89bfd2dcf54fc175d767aec3e50684f3ba4a4bf5f683d",
          "cd1bc7cb6cc407bb2f0ca647c718a730cf71872e7d0d2a53fa20efcdfe61826"
        ],
        [
          "674f2600a3007a00568c1a7ce05d0816c1fb84bf1370798f1c69532faeb1a86b",
          "299d21f9413f33b3edf43b257004580b70db57da0b182259e09eecc69e0d38a5"
        ],
        [
          "d32f4da54ade74abb81b815ad1fb3b263d82d6c692714bcff87d29bd5ee9f08f",
          "f9429e738b8e53b968e99016c059707782e14f4535359d582fc416910b3eea87"
        ],
        [
          "30e4e670435385556e593657135845d36fbb6931f72b08cb1ed954f1e3ce3ff6",
          "462f9bce619898638499350113bbc9b10a878d35da70740dc695a559eb88db7b"
        ],
        [
          "be2062003c51cc3004682904330e4dee7f3dcd10b01e580bf1971b04d4cad297",
          "62188bc49d61e5428573d48a74e1c655b1c61090905682a0d5558ed72dccb9bc"
        ],
        [
          "93144423ace3451ed29e0fb9ac2af211cb6e84a601df5993c419859fff5df04a",
          "7c10dfb164c3425f5c71a3f9d7992038f1065224f72bb9d1d902a6d13037b47c"
        ],
        [
          "b015f8044f5fcbdcf21ca26d6c34fb8197829205c7b7d2a7cb66418c157b112c",
          "ab8c1e086d04e813744a655b2df8d5f83b3cdc6faa3088c1d3aea1454e3a1d5f"
        ],
        [
          "d5e9e1da649d97d89e4868117a465a3a4f8a18de57a140d36b3f2af341a21b52",
          "4cb04437f391ed73111a13cc1d4dd0db1693465c2240480d8955e8592f27447a"
        ],
        [
          "d3ae41047dd7ca065dbf8ed77b992439983005cd72e16d6f996a5316d36966bb",
          "bd1aeb21ad22ebb22a10f0303417c6d964f8cdd7df0aca614b10dc14d125ac46"
        ],
        [
          "463e2763d885f958fc66cdd22800f0a487197d0a82e377b49f80af87c897b065",
          "bfefacdb0e5d0fd7df3a311a94de062b26b80c61fbc97508b79992671ef7ca7f"
        ],
        [
          "7985fdfd127c0567c6f53ec1bb63ec3158e597c40bfe747c83cddfc910641917",
          "603c12daf3d9862ef2b25fe1de289aed24ed291e0ec6708703a5bd567f32ed03"
        ],
        [
          "74a1ad6b5f76e39db2dd249410eac7f99e74c59cb83d2d0ed5ff1543da7703e9",
          "cc6157ef18c9c63cd6193d83631bbea0093e0968942e8c33d5737fd790e0db08"
        ],
        [
          "30682a50703375f602d416664ba19b7fc9bab42c72747463a71d0896b22f6da3",
          "553e04f6b018b4fa6c8f39e7f311d3176290d0e0f19ca73f17714d9977a22ff8"
        ],
        [
          "9e2158f0d7c0d5f26c3791efefa79597654e7a2b2464f52b1ee6c1347769ef57",
          "712fcdd1b9053f09003a3481fa7762e9ffd7c8ef35a38509e2fbf2629008373"
        ],
        [
          "176e26989a43c9cfeba4029c202538c28172e566e3c4fce7322857f3be327d66",
          "ed8cc9d04b29eb877d270b4878dc43c19aefd31f4eee09ee7b47834c1fa4b1c3"
        ],
        [
          "75d46efea3771e6e68abb89a13ad747ecf1892393dfc4f1b7004788c50374da8",
          "9852390a99507679fd0b86fd2b39a868d7efc22151346e1a3ca4726586a6bed8"
        ],
        [
          "809a20c67d64900ffb698c4c825f6d5f2310fb0451c869345b7319f645605721",
          "9e994980d9917e22b76b061927fa04143d096ccc54963e6a5ebfa5f3f8e286c1"
        ],
        [
          "1b38903a43f7f114ed4500b4eac7083fdefece1cf29c63528d563446f972c180",
          "4036edc931a60ae889353f77fd53de4a2708b26b6f5da72ad3394119daf408f9"
        ]
      ]
    }
  };
});

// node_modules/elliptic/lib/elliptic/curves.js
var require_curves = __commonJS((exports2) => {
  "use strict";
  var curves = exports2;
  var hash = require_hash();
  var curve = require_curve();
  var utils = require_utils3();
  var assert = utils.assert;
  function PresetCurve(options) {
    if (options.type === "short")
      this.curve = new curve.short(options);
    else if (options.type === "edwards")
      this.curve = new curve.edwards(options);
    else
      this.curve = new curve.mont(options);
    this.g = this.curve.g;
    this.n = this.curve.n;
    this.hash = options.hash;
    assert(this.g.validate(), "Invalid curve");
    assert(this.g.mul(this.n).isInfinity(), "Invalid curve, G*N != O");
  }
  curves.PresetCurve = PresetCurve;
  function defineCurve(name, options) {
    Object.defineProperty(curves, name, {
      configurable: true,
      enumerable: true,
      get: function() {
        var curve2 = new PresetCurve(options);
        Object.defineProperty(curves, name, {
          configurable: true,
          enumerable: true,
          value: curve2
        });
        return curve2;
      }
    });
  }
  defineCurve("p192", {
    type: "short",
    prime: "p192",
    p: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff",
    a: "ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc",
    b: "64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1",
    n: "ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831",
    hash: hash.sha256,
    gRed: false,
    g: [
      "188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012",
      "07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811"
    ]
  });
  defineCurve("p224", {
    type: "short",
    prime: "p224",
    p: "ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001",
    a: "ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe",
    b: "b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4",
    n: "ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d",
    hash: hash.sha256,
    gRed: false,
    g: [
      "b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21",
      "bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34"
    ]
  });
  defineCurve("p256", {
    type: "short",
    prime: null,
    p: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff",
    a: "ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc",
    b: "5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b",
    n: "ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551",
    hash: hash.sha256,
    gRed: false,
    g: [
      "6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296",
      "4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5"
    ]
  });
  defineCurve("p384", {
    type: "short",
    prime: null,
    p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 ffffffff",
    a: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe ffffffff 00000000 00000000 fffffffc",
    b: "b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f 5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef",
    n: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 f4372ddf 581a0db2 48b0a77a ecec196a ccc52973",
    hash: hash.sha384,
    gRed: false,
    g: [
      "aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 5502f25d bf55296c 3a545e38 72760ab7",
      "3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 0a60b1ce 1d7e819d 7a431d7c 90ea0e5f"
    ]
  });
  defineCurve("p521", {
    type: "short",
    prime: null,
    p: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff",
    a: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffc",
    b: "00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b 99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd 3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00",
    n: "000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409",
    hash: hash.sha512,
    gRed: false,
    g: [
      "000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66",
      "00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 3fad0761 353c7086 a272c240 88be9476 9fd16650"
    ]
  });
  defineCurve("curve25519", {
    type: "mont",
    prime: "p25519",
    p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
    a: "76d06",
    b: "1",
    n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
    hash: hash.sha256,
    gRed: false,
    g: [
      "9"
    ]
  });
  defineCurve("ed25519", {
    type: "edwards",
    prime: "p25519",
    p: "7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed",
    a: "-1",
    c: "1",
    d: "52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3",
    n: "1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed",
    hash: hash.sha256,
    gRed: false,
    g: [
      "216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a",
      "6666666666666666666666666666666666666666666666666666666666666658"
    ]
  });
  var pre;
  try {
    pre = require_secp256k1();
  } catch (e) {
    pre = void 0;
  }
  defineCurve("secp256k1", {
    type: "short",
    prime: "k256",
    p: "ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f",
    a: "0",
    b: "7",
    n: "ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141",
    h: "1",
    hash: hash.sha256,
    beta: "7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee",
    lambda: "5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72",
    basis: [
      {
        a: "3086d221a7d46bcde86c90e49284eb15",
        b: "-e4437ed6010e88286f547fa90abfe4c3"
      },
      {
        a: "114ca50f7a8e2f3f657c1108d9d44cfd8",
        b: "3086d221a7d46bcde86c90e49284eb15"
      }
    ],
    gRed: false,
    g: [
      "79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798",
      "483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8",
      pre
    ]
  });
});

// node_modules/hmac-drbg/lib/hmac-drbg.js
var require_hmac_drbg = __commonJS((exports2, module2) => {
  "use strict";
  var hash = require_hash();
  var utils = require_utils2();
  var assert = require_minimalistic_assert();
  function HmacDRBG(options) {
    if (!(this instanceof HmacDRBG))
      return new HmacDRBG(options);
    this.hash = options.hash;
    this.predResist = !!options.predResist;
    this.outLen = this.hash.outSize;
    this.minEntropy = options.minEntropy || this.hash.hmacStrength;
    this._reseed = null;
    this.reseedInterval = null;
    this.K = null;
    this.V = null;
    var entropy = utils.toArray(options.entropy, options.entropyEnc || "hex");
    var nonce = utils.toArray(options.nonce, options.nonceEnc || "hex");
    var pers = utils.toArray(options.pers, options.persEnc || "hex");
    assert(entropy.length >= this.minEntropy / 8, "Not enough entropy. Minimum is: " + this.minEntropy + " bits");
    this._init(entropy, nonce, pers);
  }
  module2.exports = HmacDRBG;
  HmacDRBG.prototype._init = function init(entropy, nonce, pers) {
    var seed = entropy.concat(nonce).concat(pers);
    this.K = new Array(this.outLen / 8);
    this.V = new Array(this.outLen / 8);
    for (var i = 0; i < this.V.length; i++) {
      this.K[i] = 0;
      this.V[i] = 1;
    }
    this._update(seed);
    this._reseed = 1;
    this.reseedInterval = 281474976710656;
  };
  HmacDRBG.prototype._hmac = function hmac() {
    return new hash.hmac(this.hash, this.K);
  };
  HmacDRBG.prototype._update = function update(seed) {
    var kmac = this._hmac().update(this.V).update([0]);
    if (seed)
      kmac = kmac.update(seed);
    this.K = kmac.digest();
    this.V = this._hmac().update(this.V).digest();
    if (!seed)
      return;
    this.K = this._hmac().update(this.V).update([1]).update(seed).digest();
    this.V = this._hmac().update(this.V).digest();
  };
  HmacDRBG.prototype.reseed = function reseed(entropy, entropyEnc, add, addEnc) {
    if (typeof entropyEnc !== "string") {
      addEnc = add;
      add = entropyEnc;
      entropyEnc = null;
    }
    entropy = utils.toArray(entropy, entropyEnc);
    add = utils.toArray(add, addEnc);
    assert(entropy.length >= this.minEntropy / 8, "Not enough entropy. Minimum is: " + this.minEntropy + " bits");
    this._update(entropy.concat(add || []));
    this._reseed = 1;
  };
  HmacDRBG.prototype.generate = function generate(len, enc, add, addEnc) {
    if (this._reseed > this.reseedInterval)
      throw new Error("Reseed is required");
    if (typeof enc !== "string") {
      addEnc = add;
      add = enc;
      enc = null;
    }
    if (add) {
      add = utils.toArray(add, addEnc || "hex");
      this._update(add);
    }
    var temp = [];
    while (temp.length < len) {
      this.V = this._hmac().update(this.V).digest();
      temp = temp.concat(this.V);
    }
    var res = temp.slice(0, len);
    this._update(add);
    this._reseed++;
    return utils.encode(res, enc);
  };
});

// node_modules/elliptic/lib/elliptic/ec/key.js
var require_key = __commonJS((exports2, module2) => {
  "use strict";
  var BN = require_bn();
  var utils = require_utils3();
  var assert = utils.assert;
  function KeyPair(ec, options) {
    this.ec = ec;
    this.priv = null;
    this.pub = null;
    if (options.priv)
      this._importPrivate(options.priv, options.privEnc);
    if (options.pub)
      this._importPublic(options.pub, options.pubEnc);
  }
  module2.exports = KeyPair;
  KeyPair.fromPublic = function fromPublic(ec, pub, enc) {
    if (pub instanceof KeyPair)
      return pub;
    return new KeyPair(ec, {
      pub,
      pubEnc: enc
    });
  };
  KeyPair.fromPrivate = function fromPrivate(ec, priv, enc) {
    if (priv instanceof KeyPair)
      return priv;
    return new KeyPair(ec, {
      priv,
      privEnc: enc
    });
  };
  KeyPair.prototype.validate = function validate() {
    var pub = this.getPublic();
    if (pub.isInfinity())
      return {result: false, reason: "Invalid public key"};
    if (!pub.validate())
      return {result: false, reason: "Public key is not a point"};
    if (!pub.mul(this.ec.curve.n).isInfinity())
      return {result: false, reason: "Public key * N != O"};
    return {result: true, reason: null};
  };
  KeyPair.prototype.getPublic = function getPublic(compact, enc) {
    if (typeof compact === "string") {
      enc = compact;
      compact = null;
    }
    if (!this.pub)
      this.pub = this.ec.g.mul(this.priv);
    if (!enc)
      return this.pub;
    return this.pub.encode(enc, compact);
  };
  KeyPair.prototype.getPrivate = function getPrivate(enc) {
    if (enc === "hex")
      return this.priv.toString(16, 2);
    else
      return this.priv;
  };
  KeyPair.prototype._importPrivate = function _importPrivate(key, enc) {
    this.priv = new BN(key, enc || 16);
    this.priv = this.priv.umod(this.ec.curve.n);
  };
  KeyPair.prototype._importPublic = function _importPublic(key, enc) {
    if (key.x || key.y) {
      if (this.ec.curve.type === "mont") {
        assert(key.x, "Need x coordinate");
      } else if (this.ec.curve.type === "short" || this.ec.curve.type === "edwards") {
        assert(key.x && key.y, "Need both x and y coordinate");
      }
      this.pub = this.ec.curve.point(key.x, key.y);
      return;
    }
    this.pub = this.ec.curve.decodePoint(key, enc);
  };
  KeyPair.prototype.derive = function derive(pub) {
    return pub.mul(this.priv).getX();
  };
  KeyPair.prototype.sign = function sign(msg, enc, options) {
    return this.ec.sign(msg, this, enc, options);
  };
  KeyPair.prototype.verify = function verify(msg, signature) {
    return this.ec.verify(msg, signature, this);
  };
  KeyPair.prototype.inspect = function inspect() {
    return "<Key priv: " + (this.priv && this.priv.toString(16, 2)) + " pub: " + (this.pub && this.pub.inspect()) + " >";
  };
});

// node_modules/elliptic/lib/elliptic/ec/signature.js
var require_signature = __commonJS((exports2, module2) => {
  "use strict";
  var BN = require_bn();
  var utils = require_utils3();
  var assert = utils.assert;
  function Signature(options, enc) {
    if (options instanceof Signature)
      return options;
    if (this._importDER(options, enc))
      return;
    assert(options.r && options.s, "Signature without r or s");
    this.r = new BN(options.r, 16);
    this.s = new BN(options.s, 16);
    if (options.recoveryParam === void 0)
      this.recoveryParam = null;
    else
      this.recoveryParam = options.recoveryParam;
  }
  module2.exports = Signature;
  function Position() {
    this.place = 0;
  }
  function getLength(buf, p) {
    var initial = buf[p.place++];
    if (!(initial & 128)) {
      return initial;
    }
    var octetLen = initial & 15;
    if (octetLen === 0 || octetLen > 4) {
      return false;
    }
    var val = 0;
    for (var i = 0, off = p.place; i < octetLen; i++, off++) {
      val <<= 8;
      val |= buf[off];
      val >>>= 0;
    }
    if (val <= 127) {
      return false;
    }
    p.place = off;
    return val;
  }
  function rmPadding(buf) {
    var i = 0;
    var len = buf.length - 1;
    while (!buf[i] && !(buf[i + 1] & 128) && i < len) {
      i++;
    }
    if (i === 0) {
      return buf;
    }
    return buf.slice(i);
  }
  Signature.prototype._importDER = function _importDER(data, enc) {
    data = utils.toArray(data, enc);
    var p = new Position();
    if (data[p.place++] !== 48) {
      return false;
    }
    var len = getLength(data, p);
    if (len === false) {
      return false;
    }
    if (len + p.place !== data.length) {
      return false;
    }
    if (data[p.place++] !== 2) {
      return false;
    }
    var rlen = getLength(data, p);
    if (rlen === false) {
      return false;
    }
    var r = data.slice(p.place, rlen + p.place);
    p.place += rlen;
    if (data[p.place++] !== 2) {
      return false;
    }
    var slen = getLength(data, p);
    if (slen === false) {
      return false;
    }
    if (data.length !== slen + p.place) {
      return false;
    }
    var s = data.slice(p.place, slen + p.place);
    if (r[0] === 0) {
      if (r[1] & 128) {
        r = r.slice(1);
      } else {
        return false;
      }
    }
    if (s[0] === 0) {
      if (s[1] & 128) {
        s = s.slice(1);
      } else {
        return false;
      }
    }
    this.r = new BN(r);
    this.s = new BN(s);
    this.recoveryParam = null;
    return true;
  };
  function constructLength(arr, len) {
    if (len < 128) {
      arr.push(len);
      return;
    }
    var octets = 1 + (Math.log(len) / Math.LN2 >>> 3);
    arr.push(octets | 128);
    while (--octets) {
      arr.push(len >>> (octets << 3) & 255);
    }
    arr.push(len);
  }
  Signature.prototype.toDER = function toDER(enc) {
    var r = this.r.toArray();
    var s = this.s.toArray();
    if (r[0] & 128)
      r = [0].concat(r);
    if (s[0] & 128)
      s = [0].concat(s);
    r = rmPadding(r);
    s = rmPadding(s);
    while (!s[0] && !(s[1] & 128)) {
      s = s.slice(1);
    }
    var arr = [2];
    constructLength(arr, r.length);
    arr = arr.concat(r);
    arr.push(2);
    constructLength(arr, s.length);
    var backHalf = arr.concat(s);
    var res = [48];
    constructLength(res, backHalf.length);
    res = res.concat(backHalf);
    return utils.encode(res, enc);
  };
});

// node_modules/elliptic/lib/elliptic/ec/index.js
var require_ec = __commonJS((exports2, module2) => {
  "use strict";
  var BN = require_bn();
  var HmacDRBG = require_hmac_drbg();
  var utils = require_utils3();
  var curves = require_curves();
  var rand = require_brorand();
  var assert = utils.assert;
  var KeyPair = require_key();
  var Signature = require_signature();
  function EC(options) {
    if (!(this instanceof EC))
      return new EC(options);
    if (typeof options === "string") {
      assert(curves.hasOwnProperty(options), "Unknown curve " + options);
      options = curves[options];
    }
    if (options instanceof curves.PresetCurve)
      options = {curve: options};
    this.curve = options.curve.curve;
    this.n = this.curve.n;
    this.nh = this.n.ushrn(1);
    this.g = this.curve.g;
    this.g = options.curve.g;
    this.g.precompute(options.curve.n.bitLength() + 1);
    this.hash = options.hash || options.curve.hash;
  }
  module2.exports = EC;
  EC.prototype.keyPair = function keyPair(options) {
    return new KeyPair(this, options);
  };
  EC.prototype.keyFromPrivate = function keyFromPrivate(priv, enc) {
    return KeyPair.fromPrivate(this, priv, enc);
  };
  EC.prototype.keyFromPublic = function keyFromPublic(pub, enc) {
    return KeyPair.fromPublic(this, pub, enc);
  };
  EC.prototype.genKeyPair = function genKeyPair(options) {
    if (!options)
      options = {};
    var drbg = new HmacDRBG({
      hash: this.hash,
      pers: options.pers,
      persEnc: options.persEnc || "utf8",
      entropy: options.entropy || rand(this.hash.hmacStrength),
      entropyEnc: options.entropy && options.entropyEnc || "utf8",
      nonce: this.n.toArray()
    });
    var bytes = this.n.byteLength();
    var ns2 = this.n.sub(new BN(2));
    do {
      var priv = new BN(drbg.generate(bytes));
      if (priv.cmp(ns2) > 0)
        continue;
      priv.iaddn(1);
      return this.keyFromPrivate(priv);
    } while (true);
  };
  EC.prototype._truncateToN = function truncateToN(msg, truncOnly) {
    var delta = msg.byteLength() * 8 - this.n.bitLength();
    if (delta > 0)
      msg = msg.ushrn(delta);
    if (!truncOnly && msg.cmp(this.n) >= 0)
      return msg.sub(this.n);
    else
      return msg;
  };
  EC.prototype.sign = function sign(msg, key, enc, options) {
    if (typeof enc === "object") {
      options = enc;
      enc = null;
    }
    if (!options)
      options = {};
    key = this.keyFromPrivate(key, enc);
    msg = this._truncateToN(new BN(msg, 16));
    var bytes = this.n.byteLength();
    var bkey = key.getPrivate().toArray("be", bytes);
    var nonce = msg.toArray("be", bytes);
    var drbg = new HmacDRBG({
      hash: this.hash,
      entropy: bkey,
      nonce,
      pers: options.pers,
      persEnc: options.persEnc || "utf8"
    });
    var ns1 = this.n.sub(new BN(1));
    for (var iter = 0; true; iter++) {
      var k = options.k ? options.k(iter) : new BN(drbg.generate(this.n.byteLength()));
      k = this._truncateToN(k, true);
      if (k.cmpn(1) <= 0 || k.cmp(ns1) >= 0)
        continue;
      var kp = this.g.mul(k);
      if (kp.isInfinity())
        continue;
      var kpX = kp.getX();
      var r = kpX.umod(this.n);
      if (r.cmpn(0) === 0)
        continue;
      var s = k.invm(this.n).mul(r.mul(key.getPrivate()).iadd(msg));
      s = s.umod(this.n);
      if (s.cmpn(0) === 0)
        continue;
      var recoveryParam = (kp.getY().isOdd() ? 1 : 0) | (kpX.cmp(r) !== 0 ? 2 : 0);
      if (options.canonical && s.cmp(this.nh) > 0) {
        s = this.n.sub(s);
        recoveryParam ^= 1;
      }
      return new Signature({r, s, recoveryParam});
    }
  };
  EC.prototype.verify = function verify(msg, signature, key, enc) {
    msg = this._truncateToN(new BN(msg, 16));
    key = this.keyFromPublic(key, enc);
    signature = new Signature(signature, "hex");
    var r = signature.r;
    var s = signature.s;
    if (r.cmpn(1) < 0 || r.cmp(this.n) >= 0)
      return false;
    if (s.cmpn(1) < 0 || s.cmp(this.n) >= 0)
      return false;
    var sinv = s.invm(this.n);
    var u1 = sinv.mul(msg).umod(this.n);
    var u2 = sinv.mul(r).umod(this.n);
    if (!this.curve._maxwellTrick) {
      var p = this.g.mulAdd(u1, key.getPublic(), u2);
      if (p.isInfinity())
        return false;
      return p.getX().umod(this.n).cmp(r) === 0;
    }
    var p = this.g.jmulAdd(u1, key.getPublic(), u2);
    if (p.isInfinity())
      return false;
    return p.eqXToP(r);
  };
  EC.prototype.recoverPubKey = function(msg, signature, j, enc) {
    assert((3 & j) === j, "The recovery param is more than two bits");
    signature = new Signature(signature, enc);
    var n = this.n;
    var e = new BN(msg);
    var r = signature.r;
    var s = signature.s;
    var isYOdd = j & 1;
    var isSecondKey = j >> 1;
    if (r.cmp(this.curve.p.umod(this.curve.n)) >= 0 && isSecondKey)
      throw new Error("Unable to find sencond key candinate");
    if (isSecondKey)
      r = this.curve.pointFromX(r.add(this.curve.n), isYOdd);
    else
      r = this.curve.pointFromX(r, isYOdd);
    var rInv = signature.r.invm(n);
    var s1 = n.sub(e).mul(rInv).umod(n);
    var s2 = s.mul(rInv).umod(n);
    return this.g.mulAdd(s1, r, s2);
  };
  EC.prototype.getKeyRecoveryParam = function(e, signature, Q, enc) {
    signature = new Signature(signature, enc);
    if (signature.recoveryParam !== null)
      return signature.recoveryParam;
    for (var i = 0; i < 4; i++) {
      var Qprime;
      try {
        Qprime = this.recoverPubKey(e, signature, i);
      } catch (e2) {
        continue;
      }
      if (Qprime.eq(Q))
        return i;
    }
    throw new Error("Unable to find valid recovery factor");
  };
});

// node_modules/elliptic/lib/elliptic/eddsa/key.js
var require_key2 = __commonJS((exports2, module2) => {
  "use strict";
  var utils = require_utils3();
  var assert = utils.assert;
  var parseBytes = utils.parseBytes;
  var cachedProperty = utils.cachedProperty;
  function KeyPair(eddsa, params) {
    this.eddsa = eddsa;
    this._secret = parseBytes(params.secret);
    if (eddsa.isPoint(params.pub))
      this._pub = params.pub;
    else
      this._pubBytes = parseBytes(params.pub);
  }
  KeyPair.fromPublic = function fromPublic(eddsa, pub) {
    if (pub instanceof KeyPair)
      return pub;
    return new KeyPair(eddsa, {pub});
  };
  KeyPair.fromSecret = function fromSecret(eddsa, secret) {
    if (secret instanceof KeyPair)
      return secret;
    return new KeyPair(eddsa, {secret});
  };
  KeyPair.prototype.secret = function secret() {
    return this._secret;
  };
  cachedProperty(KeyPair, "pubBytes", function pubBytes() {
    return this.eddsa.encodePoint(this.pub());
  });
  cachedProperty(KeyPair, "pub", function pub() {
    if (this._pubBytes)
      return this.eddsa.decodePoint(this._pubBytes);
    return this.eddsa.g.mul(this.priv());
  });
  cachedProperty(KeyPair, "privBytes", function privBytes() {
    var eddsa = this.eddsa;
    var hash = this.hash();
    var lastIx = eddsa.encodingLength - 1;
    var a = hash.slice(0, eddsa.encodingLength);
    a[0] &= 248;
    a[lastIx] &= 127;
    a[lastIx] |= 64;
    return a;
  });
  cachedProperty(KeyPair, "priv", function priv() {
    return this.eddsa.decodeInt(this.privBytes());
  });
  cachedProperty(KeyPair, "hash", function hash() {
    return this.eddsa.hash().update(this.secret()).digest();
  });
  cachedProperty(KeyPair, "messagePrefix", function messagePrefix() {
    return this.hash().slice(this.eddsa.encodingLength);
  });
  KeyPair.prototype.sign = function sign(message) {
    assert(this._secret, "KeyPair can only verify");
    return this.eddsa.sign(message, this);
  };
  KeyPair.prototype.verify = function verify(message, sig) {
    return this.eddsa.verify(message, sig, this);
  };
  KeyPair.prototype.getSecret = function getSecret(enc) {
    assert(this._secret, "KeyPair is public only");
    return utils.encode(this.secret(), enc);
  };
  KeyPair.prototype.getPublic = function getPublic(enc) {
    return utils.encode(this.pubBytes(), enc);
  };
  module2.exports = KeyPair;
});

// node_modules/elliptic/lib/elliptic/eddsa/signature.js
var require_signature2 = __commonJS((exports2, module2) => {
  "use strict";
  var BN = require_bn();
  var utils = require_utils3();
  var assert = utils.assert;
  var cachedProperty = utils.cachedProperty;
  var parseBytes = utils.parseBytes;
  function Signature(eddsa, sig) {
    this.eddsa = eddsa;
    if (typeof sig !== "object")
      sig = parseBytes(sig);
    if (Array.isArray(sig)) {
      sig = {
        R: sig.slice(0, eddsa.encodingLength),
        S: sig.slice(eddsa.encodingLength)
      };
    }
    assert(sig.R && sig.S, "Signature without R or S");
    if (eddsa.isPoint(sig.R))
      this._R = sig.R;
    if (sig.S instanceof BN)
      this._S = sig.S;
    this._Rencoded = Array.isArray(sig.R) ? sig.R : sig.Rencoded;
    this._Sencoded = Array.isArray(sig.S) ? sig.S : sig.Sencoded;
  }
  cachedProperty(Signature, "S", function S() {
    return this.eddsa.decodeInt(this.Sencoded());
  });
  cachedProperty(Signature, "R", function R() {
    return this.eddsa.decodePoint(this.Rencoded());
  });
  cachedProperty(Signature, "Rencoded", function Rencoded() {
    return this.eddsa.encodePoint(this.R());
  });
  cachedProperty(Signature, "Sencoded", function Sencoded() {
    return this.eddsa.encodeInt(this.S());
  });
  Signature.prototype.toBytes = function toBytes() {
    return this.Rencoded().concat(this.Sencoded());
  };
  Signature.prototype.toHex = function toHex() {
    return utils.encode(this.toBytes(), "hex").toUpperCase();
  };
  module2.exports = Signature;
});

// node_modules/elliptic/lib/elliptic/eddsa/index.js
var require_eddsa = __commonJS((exports2, module2) => {
  "use strict";
  var hash = require_hash();
  var curves = require_curves();
  var utils = require_utils3();
  var assert = utils.assert;
  var parseBytes = utils.parseBytes;
  var KeyPair = require_key2();
  var Signature = require_signature2();
  function EDDSA(curve) {
    assert(curve === "ed25519", "only tested with ed25519 so far");
    if (!(this instanceof EDDSA))
      return new EDDSA(curve);
    var curve = curves[curve].curve;
    this.curve = curve;
    this.g = curve.g;
    this.g.precompute(curve.n.bitLength() + 1);
    this.pointClass = curve.point().constructor;
    this.encodingLength = Math.ceil(curve.n.bitLength() / 8);
    this.hash = hash.sha512;
  }
  module2.exports = EDDSA;
  EDDSA.prototype.sign = function sign(message, secret) {
    message = parseBytes(message);
    var key = this.keyFromSecret(secret);
    var r = this.hashInt(key.messagePrefix(), message);
    var R = this.g.mul(r);
    var Rencoded = this.encodePoint(R);
    var s_ = this.hashInt(Rencoded, key.pubBytes(), message).mul(key.priv());
    var S = r.add(s_).umod(this.curve.n);
    return this.makeSignature({R, S, Rencoded});
  };
  EDDSA.prototype.verify = function verify(message, sig, pub) {
    message = parseBytes(message);
    sig = this.makeSignature(sig);
    var key = this.keyFromPublic(pub);
    var h = this.hashInt(sig.Rencoded(), key.pubBytes(), message);
    var SG = this.g.mul(sig.S());
    var RplusAh = sig.R().add(key.pub().mul(h));
    return RplusAh.eq(SG);
  };
  EDDSA.prototype.hashInt = function hashInt() {
    var hash2 = this.hash();
    for (var i = 0; i < arguments.length; i++)
      hash2.update(arguments[i]);
    return utils.intFromLE(hash2.digest()).umod(this.curve.n);
  };
  EDDSA.prototype.keyFromPublic = function keyFromPublic(pub) {
    return KeyPair.fromPublic(this, pub);
  };
  EDDSA.prototype.keyFromSecret = function keyFromSecret(secret) {
    return KeyPair.fromSecret(this, secret);
  };
  EDDSA.prototype.makeSignature = function makeSignature(sig) {
    if (sig instanceof Signature)
      return sig;
    return new Signature(this, sig);
  };
  EDDSA.prototype.encodePoint = function encodePoint(point) {
    var enc = point.getY().toArray("le", this.encodingLength);
    enc[this.encodingLength - 1] |= point.getX().isOdd() ? 128 : 0;
    return enc;
  };
  EDDSA.prototype.decodePoint = function decodePoint(bytes) {
    bytes = utils.parseBytes(bytes);
    var lastIx = bytes.length - 1;
    var normed = bytes.slice(0, lastIx).concat(bytes[lastIx] & ~128);
    var xIsOdd = (bytes[lastIx] & 128) !== 0;
    var y = utils.intFromLE(normed);
    return this.curve.pointFromY(y, xIsOdd);
  };
  EDDSA.prototype.encodeInt = function encodeInt(num) {
    return num.toArray("le", this.encodingLength);
  };
  EDDSA.prototype.decodeInt = function decodeInt(bytes) {
    return utils.intFromLE(bytes);
  };
  EDDSA.prototype.isPoint = function isPoint(val) {
    return val instanceof this.pointClass;
  };
});

// node_modules/elliptic/lib/elliptic.js
var require_elliptic = __commonJS((exports2) => {
  "use strict";
  var elliptic = exports2;
  elliptic.version = require_package().version;
  elliptic.utils = require_utils3();
  elliptic.rand = require_brorand();
  elliptic.curve = require_curve();
  elliptic.curves = require_curves();
  elliptic.ec = require_ec();
  elliptic.eddsa = require_eddsa();
});

// node_modules/secp256k1/lib/elliptic.js
var require_elliptic2 = __commonJS((exports2, module2) => {
  var EC = require_elliptic().ec;
  var ec = new EC("secp256k1");
  var ecparams = ec.curve;
  var BN = ecparams.n.constructor;
  function loadCompressedPublicKey(first, xbuf) {
    let x = new BN(xbuf);
    if (x.cmp(ecparams.p) >= 0)
      return null;
    x = x.toRed(ecparams.red);
    let y = x.redSqr().redIMul(x).redIAdd(ecparams.b).redSqrt();
    if (first === 3 !== y.isOdd())
      y = y.redNeg();
    return ec.keyPair({pub: {x, y}});
  }
  function loadUncompressedPublicKey(first, xbuf, ybuf) {
    let x = new BN(xbuf);
    let y = new BN(ybuf);
    if (x.cmp(ecparams.p) >= 0 || y.cmp(ecparams.p) >= 0)
      return null;
    x = x.toRed(ecparams.red);
    y = y.toRed(ecparams.red);
    if ((first === 6 || first === 7) && y.isOdd() !== (first === 7))
      return null;
    const x3 = x.redSqr().redIMul(x);
    if (!y.redSqr().redISub(x3.redIAdd(ecparams.b)).isZero())
      return null;
    return ec.keyPair({pub: {x, y}});
  }
  function loadPublicKey(pubkey) {
    const first = pubkey[0];
    switch (first) {
      case 2:
      case 3:
        if (pubkey.length !== 33)
          return null;
        return loadCompressedPublicKey(first, pubkey.subarray(1, 33));
      case 4:
      case 6:
      case 7:
        if (pubkey.length !== 65)
          return null;
        return loadUncompressedPublicKey(first, pubkey.subarray(1, 33), pubkey.subarray(33, 65));
      default:
        return null;
    }
  }
  function savePublicKey(output, point) {
    const pubkey = point.encode(null, output.length === 33);
    for (let i = 0; i < output.length; ++i)
      output[i] = pubkey[i];
  }
  module2.exports = {
    contextRandomize() {
      return 0;
    },
    privateKeyVerify(seckey) {
      const bn = new BN(seckey);
      return bn.cmp(ecparams.n) < 0 && !bn.isZero() ? 0 : 1;
    },
    privateKeyNegate(seckey) {
      const bn = new BN(seckey);
      const negate = ecparams.n.sub(bn).umod(ecparams.n).toArrayLike(Uint8Array, "be", 32);
      seckey.set(negate);
      return 0;
    },
    privateKeyTweakAdd(seckey, tweak) {
      const bn = new BN(tweak);
      if (bn.cmp(ecparams.n) >= 0)
        return 1;
      bn.iadd(new BN(seckey));
      if (bn.cmp(ecparams.n) >= 0)
        bn.isub(ecparams.n);
      if (bn.isZero())
        return 1;
      const tweaked = bn.toArrayLike(Uint8Array, "be", 32);
      seckey.set(tweaked);
      return 0;
    },
    privateKeyTweakMul(seckey, tweak) {
      let bn = new BN(tweak);
      if (bn.cmp(ecparams.n) >= 0 || bn.isZero())
        return 1;
      bn.imul(new BN(seckey));
      if (bn.cmp(ecparams.n) >= 0)
        bn = bn.umod(ecparams.n);
      const tweaked = bn.toArrayLike(Uint8Array, "be", 32);
      seckey.set(tweaked);
      return 0;
    },
    publicKeyVerify(pubkey) {
      const pair = loadPublicKey(pubkey);
      return pair === null ? 1 : 0;
    },
    publicKeyCreate(output, seckey) {
      const bn = new BN(seckey);
      if (bn.cmp(ecparams.n) >= 0 || bn.isZero())
        return 1;
      const point = ec.keyFromPrivate(seckey).getPublic();
      savePublicKey(output, point);
      return 0;
    },
    publicKeyConvert(output, pubkey) {
      const pair = loadPublicKey(pubkey);
      if (pair === null)
        return 1;
      const point = pair.getPublic();
      savePublicKey(output, point);
      return 0;
    },
    publicKeyNegate(output, pubkey) {
      const pair = loadPublicKey(pubkey);
      if (pair === null)
        return 1;
      const point = pair.getPublic();
      point.y = point.y.redNeg();
      savePublicKey(output, point);
      return 0;
    },
    publicKeyCombine(output, pubkeys) {
      const pairs = new Array(pubkeys.length);
      for (let i = 0; i < pubkeys.length; ++i) {
        pairs[i] = loadPublicKey(pubkeys[i]);
        if (pairs[i] === null)
          return 1;
      }
      let point = pairs[0].getPublic();
      for (let i = 1; i < pairs.length; ++i)
        point = point.add(pairs[i].pub);
      if (point.isInfinity())
        return 2;
      savePublicKey(output, point);
      return 0;
    },
    publicKeyTweakAdd(output, pubkey, tweak) {
      const pair = loadPublicKey(pubkey);
      if (pair === null)
        return 1;
      tweak = new BN(tweak);
      if (tweak.cmp(ecparams.n) >= 0)
        return 2;
      const point = pair.getPublic().add(ecparams.g.mul(tweak));
      if (point.isInfinity())
        return 2;
      savePublicKey(output, point);
      return 0;
    },
    publicKeyTweakMul(output, pubkey, tweak) {
      const pair = loadPublicKey(pubkey);
      if (pair === null)
        return 1;
      tweak = new BN(tweak);
      if (tweak.cmp(ecparams.n) >= 0 || tweak.isZero())
        return 2;
      const point = pair.getPublic().mul(tweak);
      savePublicKey(output, point);
      return 0;
    },
    signatureNormalize(sig) {
      const r = new BN(sig.subarray(0, 32));
      const s = new BN(sig.subarray(32, 64));
      if (r.cmp(ecparams.n) >= 0 || s.cmp(ecparams.n) >= 0)
        return 1;
      if (s.cmp(ec.nh) === 1) {
        sig.set(ecparams.n.sub(s).toArrayLike(Uint8Array, "be", 32), 32);
      }
      return 0;
    },
    signatureExport(obj, sig) {
      const sigR = sig.subarray(0, 32);
      const sigS = sig.subarray(32, 64);
      if (new BN(sigR).cmp(ecparams.n) >= 0)
        return 1;
      if (new BN(sigS).cmp(ecparams.n) >= 0)
        return 1;
      const {output} = obj;
      let r = output.subarray(4, 4 + 33);
      r[0] = 0;
      r.set(sigR, 1);
      let lenR = 33;
      let posR = 0;
      for (; lenR > 1 && r[posR] === 0 && !(r[posR + 1] & 128); --lenR, ++posR)
        ;
      r = r.subarray(posR);
      if (r[0] & 128)
        return 1;
      if (lenR > 1 && r[0] === 0 && !(r[1] & 128))
        return 1;
      let s = output.subarray(6 + 33, 6 + 33 + 33);
      s[0] = 0;
      s.set(sigS, 1);
      let lenS = 33;
      let posS = 0;
      for (; lenS > 1 && s[posS] === 0 && !(s[posS + 1] & 128); --lenS, ++posS)
        ;
      s = s.subarray(posS);
      if (s[0] & 128)
        return 1;
      if (lenS > 1 && s[0] === 0 && !(s[1] & 128))
        return 1;
      obj.outputlen = 6 + lenR + lenS;
      output[0] = 48;
      output[1] = obj.outputlen - 2;
      output[2] = 2;
      output[3] = r.length;
      output.set(r, 4);
      output[4 + lenR] = 2;
      output[5 + lenR] = s.length;
      output.set(s, 6 + lenR);
      return 0;
    },
    signatureImport(output, sig) {
      if (sig.length < 8)
        return 1;
      if (sig.length > 72)
        return 1;
      if (sig[0] !== 48)
        return 1;
      if (sig[1] !== sig.length - 2)
        return 1;
      if (sig[2] !== 2)
        return 1;
      const lenR = sig[3];
      if (lenR === 0)
        return 1;
      if (5 + lenR >= sig.length)
        return 1;
      if (sig[4 + lenR] !== 2)
        return 1;
      const lenS = sig[5 + lenR];
      if (lenS === 0)
        return 1;
      if (6 + lenR + lenS !== sig.length)
        return 1;
      if (sig[4] & 128)
        return 1;
      if (lenR > 1 && sig[4] === 0 && !(sig[5] & 128))
        return 1;
      if (sig[lenR + 6] & 128)
        return 1;
      if (lenS > 1 && sig[lenR + 6] === 0 && !(sig[lenR + 7] & 128))
        return 1;
      let sigR = sig.subarray(4, 4 + lenR);
      if (sigR.length === 33 && sigR[0] === 0)
        sigR = sigR.subarray(1);
      if (sigR.length > 32)
        return 1;
      let sigS = sig.subarray(6 + lenR);
      if (sigS.length === 33 && sigS[0] === 0)
        sigS = sigS.slice(1);
      if (sigS.length > 32)
        throw new Error("S length is too long");
      let r = new BN(sigR);
      if (r.cmp(ecparams.n) >= 0)
        r = new BN(0);
      let s = new BN(sig.subarray(6 + lenR));
      if (s.cmp(ecparams.n) >= 0)
        s = new BN(0);
      output.set(r.toArrayLike(Uint8Array, "be", 32), 0);
      output.set(s.toArrayLike(Uint8Array, "be", 32), 32);
      return 0;
    },
    ecdsaSign(obj, message, seckey, data, noncefn) {
      if (noncefn) {
        const _noncefn = noncefn;
        noncefn = (counter) => {
          const nonce = _noncefn(message, seckey, null, data, counter);
          const isValid = nonce instanceof Uint8Array && nonce.length === 32;
          if (!isValid)
            throw new Error("This is the way");
          return new BN(nonce);
        };
      }
      const d = new BN(seckey);
      if (d.cmp(ecparams.n) >= 0 || d.isZero())
        return 1;
      let sig;
      try {
        sig = ec.sign(message, seckey, {canonical: true, k: noncefn, pers: data});
      } catch (err) {
        return 1;
      }
      obj.signature.set(sig.r.toArrayLike(Uint8Array, "be", 32), 0);
      obj.signature.set(sig.s.toArrayLike(Uint8Array, "be", 32), 32);
      obj.recid = sig.recoveryParam;
      return 0;
    },
    ecdsaVerify(sig, msg32, pubkey) {
      const sigObj = {r: sig.subarray(0, 32), s: sig.subarray(32, 64)};
      const sigr = new BN(sigObj.r);
      const sigs = new BN(sigObj.s);
      if (sigr.cmp(ecparams.n) >= 0 || sigs.cmp(ecparams.n) >= 0)
        return 1;
      if (sigs.cmp(ec.nh) === 1 || sigr.isZero() || sigs.isZero())
        return 3;
      const pair = loadPublicKey(pubkey);
      if (pair === null)
        return 2;
      const point = pair.getPublic();
      const isValid = ec.verify(msg32, sigObj, point);
      return isValid ? 0 : 3;
    },
    ecdsaRecover(output, sig, recid, msg32) {
      const sigObj = {r: sig.slice(0, 32), s: sig.slice(32, 64)};
      const sigr = new BN(sigObj.r);
      const sigs = new BN(sigObj.s);
      if (sigr.cmp(ecparams.n) >= 0 || sigs.cmp(ecparams.n) >= 0)
        return 1;
      if (sigr.isZero() || sigs.isZero())
        return 2;
      let point;
      try {
        point = ec.recoverPubKey(msg32, sigObj, recid);
      } catch (err) {
        return 2;
      }
      savePublicKey(output, point);
      return 0;
    },
    ecdh(output, pubkey, seckey, data, hashfn, xbuf, ybuf) {
      const pair = loadPublicKey(pubkey);
      if (pair === null)
        return 1;
      const scalar = new BN(seckey);
      if (scalar.cmp(ecparams.n) >= 0 || scalar.isZero())
        return 2;
      const point = pair.getPublic().mul(scalar);
      if (hashfn === void 0) {
        const data2 = point.encode(null, true);
        const sha256 = ec.hash().update(data2).digest();
        for (let i = 0; i < 32; ++i)
          output[i] = sha256[i];
      } else {
        if (!xbuf)
          xbuf = new Uint8Array(32);
        const x = point.getX().toArray("be", 32);
        for (let i = 0; i < 32; ++i)
          xbuf[i] = x[i];
        if (!ybuf)
          ybuf = new Uint8Array(32);
        const y = point.getY().toArray("be", 32);
        for (let i = 0; i < 32; ++i)
          ybuf[i] = y[i];
        const hash = hashfn(xbuf, ybuf, data);
        const isValid = hash instanceof Uint8Array && hash.length === output.length;
        if (!isValid)
          return 2;
        output.set(hash);
      }
      return 0;
    }
  };
});

// node_modules/secp256k1/elliptic.js
var require_elliptic3 = __commonJS((exports2, module2) => {
  module2.exports = require_lib()(require_elliptic2());
});

// node_modules/libp2p-crypto/src/keys/secp256k1.js
var require_secp256k12 = __commonJS((exports2, module2) => {
  "use strict";
  var secp256k1 = require_elliptic3();
  var sha = require_sha_browser();
  var HASH_ALGORITHM = "sha2-256";
  module2.exports = (randomBytes) => {
    const privateKeyLength = 32;
    function generateKey() {
      let privateKey;
      do {
        privateKey = randomBytes(32);
      } while (!secp256k1.privateKeyVerify(privateKey));
      return privateKey;
    }
    async function hashAndSign(key, msg) {
      const digest = await sha.digest(msg, HASH_ALGORITHM);
      const sig = secp256k1.ecdsaSign(digest, key);
      return secp256k1.signatureExport(sig.signature);
    }
    async function hashAndVerify(key, sig, msg) {
      const digest = await sha.digest(msg, HASH_ALGORITHM);
      sig = secp256k1.signatureImport(sig);
      return secp256k1.ecdsaVerify(sig, digest, key);
    }
    function compressPublicKey(key) {
      if (!secp256k1.publicKeyVerify(key)) {
        throw new Error("Invalid public key");
      }
      return secp256k1.publicKeyConvert(key, true);
    }
    function decompressPublicKey(key) {
      return secp256k1.publicKeyConvert(key, false);
    }
    function validatePrivateKey(key) {
      if (!secp256k1.privateKeyVerify(key)) {
        throw new Error("Invalid private key");
      }
    }
    function validatePublicKey(key) {
      if (!secp256k1.publicKeyVerify(key)) {
        throw new Error("Invalid public key");
      }
    }
    function computePublicKey(privateKey) {
      validatePrivateKey(privateKey);
      return secp256k1.publicKeyCreate(privateKey);
    }
    return {
      generateKey,
      privateKeyLength,
      hashAndSign,
      hashAndVerify,
      compressPublicKey,
      decompressPublicKey,
      validatePrivateKey,
      validatePublicKey,
      computePublicKey
    };
  };
});

// node_modules/libp2p-crypto/src/keys/secp256k1-class.js
var require_secp256k1_class = __commonJS((exports2, module2) => {
  "use strict";
  var sha = require_sha_browser();
  var errcode = require_err_code();
  var uint8ArrayEquals = require_equals2();
  var uint8ArrayToString = require_to_string2();
  var exporter = require_exporter();
  module2.exports = (keysProtobuf, randomBytes, crypto2) => {
    crypto2 = crypto2 || require_secp256k12()(randomBytes);
    class Secp256k1PublicKey {
      constructor(key) {
        crypto2.validatePublicKey(key);
        this._key = key;
      }
      verify(data, sig) {
        return crypto2.hashAndVerify(this._key, sig, data);
      }
      marshal() {
        return crypto2.compressPublicKey(this._key);
      }
      get bytes() {
        return keysProtobuf.PublicKey.encode({
          Type: keysProtobuf.KeyType.Secp256k1,
          Data: this.marshal()
        });
      }
      equals(key) {
        return uint8ArrayEquals(this.bytes, key.bytes);
      }
      hash() {
        return sha.multihashing(this.bytes, "sha2-256");
      }
    }
    class Secp256k1PrivateKey {
      constructor(key, publicKey) {
        this._key = key;
        this._publicKey = publicKey || crypto2.computePublicKey(key);
        crypto2.validatePrivateKey(this._key);
        crypto2.validatePublicKey(this._publicKey);
      }
      sign(message) {
        return crypto2.hashAndSign(this._key, message);
      }
      get public() {
        return new Secp256k1PublicKey(this._publicKey);
      }
      marshal() {
        return this._key;
      }
      get bytes() {
        return keysProtobuf.PrivateKey.encode({
          Type: keysProtobuf.KeyType.Secp256k1,
          Data: this.marshal()
        });
      }
      equals(key) {
        return uint8ArrayEquals(this.bytes, key.bytes);
      }
      hash() {
        return sha.multihashing(this.bytes, "sha2-256");
      }
      async id() {
        const hash = await this.public.hash();
        return uint8ArrayToString(hash, "base58btc");
      }
      async export(password, format = "libp2p-key") {
        if (format === "libp2p-key") {
          return exporter.export(this.bytes, password);
        } else {
          throw errcode(new Error(`export format '${format}' is not supported`), "ERR_INVALID_EXPORT_FORMAT");
        }
      }
    }
    function unmarshalSecp256k1PrivateKey(bytes) {
      return new Secp256k1PrivateKey(bytes);
    }
    function unmarshalSecp256k1PublicKey(bytes) {
      return new Secp256k1PublicKey(bytes);
    }
    async function generateKeyPair() {
      const privateKeyBytes = await crypto2.generateKey();
      return new Secp256k1PrivateKey(privateKeyBytes);
    }
    return {
      Secp256k1PublicKey,
      Secp256k1PrivateKey,
      unmarshalSecp256k1PrivateKey,
      unmarshalSecp256k1PublicKey,
      generateKeyPair
    };
  };
});

// node_modules/libp2p-crypto/src/hmac/lengths.js
var require_lengths = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = {
    SHA1: 20,
    SHA256: 32,
    SHA512: 64
  };
});

// node_modules/libp2p-crypto/src/hmac/index-browser.js
var require_index_browser = __commonJS((exports2) => {
  "use strict";
  var webcrypto = require_webcrypto();
  var lengths = require_lengths();
  var hashTypes = {
    SHA1: "SHA-1",
    SHA256: "SHA-256",
    SHA512: "SHA-512"
  };
  var sign = async (key, data) => {
    const buf = await webcrypto.get().subtle.sign({name: "HMAC"}, key, data);
    return new Uint8Array(buf, buf.byteOffset, buf.byteLength);
  };
  exports2.create = async function(hashType, secret) {
    const hash = hashTypes[hashType];
    const key = await webcrypto.get().subtle.importKey("raw", secret, {
      name: "HMAC",
      hash: {name: hash}
    }, false, ["sign"]);
    return {
      async digest(data) {
        return sign(key, data);
      },
      length: lengths[hashType]
    };
  };
});

// node_modules/libp2p-crypto/src/keys/key-stretcher.js
var require_key_stretcher = __commonJS((exports2, module2) => {
  "use strict";
  var errcode = require_err_code();
  var uint8ArrayConcat = require_concat2();
  var uint8ArrayFromString = require_from_string2();
  var hmac = require_index_browser();
  var cipherMap = {
    "AES-128": {
      ivSize: 16,
      keySize: 16
    },
    "AES-256": {
      ivSize: 16,
      keySize: 32
    },
    Blowfish: {
      ivSize: 8,
      cipherKeySize: 32
    }
  };
  module2.exports = async (cipherType, hash, secret) => {
    const cipher = cipherMap[cipherType];
    if (!cipher) {
      const allowed = Object.keys(cipherMap).join(" / ");
      throw errcode(new Error(`unknown cipher type '${cipherType}'. Must be ${allowed}`), "ERR_INVALID_CIPHER_TYPE");
    }
    if (!hash) {
      throw errcode(new Error("missing hash type"), "ERR_MISSING_HASH_TYPE");
    }
    const cipherKeySize = cipher.keySize;
    const ivSize = cipher.ivSize;
    const hmacKeySize = 20;
    const seed = uint8ArrayFromString("key expansion");
    const resultLength = 2 * (ivSize + cipherKeySize + hmacKeySize);
    const m = await hmac.create(hash, secret);
    let a = await m.digest(seed);
    const result = [];
    let j = 0;
    while (j < resultLength) {
      const b = await m.digest(uint8ArrayConcat([a, seed]));
      let todo = b.length;
      if (j + todo > resultLength) {
        todo = resultLength - j;
      }
      result.push(b);
      j += todo;
      a = await m.digest(a);
    }
    const half = resultLength / 2;
    const resultBuffer = uint8ArrayConcat(result);
    const r1 = resultBuffer.slice(0, half);
    const r2 = resultBuffer.slice(half, resultLength);
    const createKey = (res) => ({
      iv: res.slice(0, ivSize),
      cipherKey: res.slice(ivSize, ivSize + cipherKeySize),
      macKey: res.slice(ivSize + cipherKeySize)
    });
    return {
      k1: createKey(r1),
      k2: createKey(r2)
    };
  };
});

// node_modules/libp2p-crypto/src/keys/validate-curve-type.js
var require_validate_curve_type = __commonJS((exports2, module2) => {
  "use strict";
  var errcode = require_err_code();
  module2.exports = function(curveTypes, type) {
    if (!curveTypes.includes(type)) {
      const names = curveTypes.join(" / ");
      throw errcode(new Error(`Unknown curve: ${type}. Must be ${names}`), "ERR_INVALID_CURVE");
    }
  };
});

// node_modules/libp2p-crypto/src/keys/ecdh-browser.js
var require_ecdh_browser = __commonJS((exports2) => {
  "use strict";
  var errcode = require_err_code();
  var webcrypto = require_webcrypto();
  var {base64urlToBuffer} = require_util4();
  var validateCurveType = require_validate_curve_type();
  var uint8ArrayToString = require_to_string2();
  var uint8ArrayConcat = require_concat2();
  var uint8ArrayEquals = require_equals2();
  var bits = {
    "P-256": 256,
    "P-384": 384,
    "P-521": 521
  };
  exports2.generateEphmeralKeyPair = async function(curve) {
    validateCurveType(Object.keys(bits), curve);
    const pair = await webcrypto.get().subtle.generateKey({
      name: "ECDH",
      namedCurve: curve
    }, true, ["deriveBits"]);
    const genSharedKey = async (theirPub, forcePrivate) => {
      let privateKey;
      if (forcePrivate) {
        privateKey = await webcrypto.get().subtle.importKey("jwk", unmarshalPrivateKey(curve, forcePrivate), {
          name: "ECDH",
          namedCurve: curve
        }, false, ["deriveBits"]);
      } else {
        privateKey = pair.privateKey;
      }
      const keys = [
        await webcrypto.get().subtle.importKey("jwk", unmarshalPublicKey(curve, theirPub), {
          name: "ECDH",
          namedCurve: curve
        }, false, []),
        privateKey
      ];
      const buffer = await webcrypto.get().subtle.deriveBits({
        name: "ECDH",
        namedCurve: curve,
        public: keys[0]
      }, keys[1], bits[curve]);
      return new Uint8Array(buffer, buffer.byteOffset, buffer.byteLength);
    };
    const publicKey = await webcrypto.get().subtle.exportKey("jwk", pair.publicKey);
    return {
      key: marshalPublicKey(publicKey),
      genSharedKey
    };
  };
  var curveLengths = {
    "P-256": 32,
    "P-384": 48,
    "P-521": 66
  };
  function marshalPublicKey(jwk) {
    const byteLen = curveLengths[jwk.crv];
    return uint8ArrayConcat([
      Uint8Array.from([4]),
      base64urlToBuffer(jwk.x, byteLen),
      base64urlToBuffer(jwk.y, byteLen)
    ], 1 + byteLen * 2);
  }
  function unmarshalPublicKey(curve, key) {
    const byteLen = curveLengths[curve];
    if (uint8ArrayEquals(!key.slice(0, 1), Uint8Array.from([4]))) {
      throw errcode(new Error("Cannot unmarshal public key - invalid key format"), "ERR_INVALID_KEY_FORMAT");
    }
    return {
      kty: "EC",
      crv: curve,
      x: uint8ArrayToString(key.slice(1, byteLen + 1), "base64url"),
      y: uint8ArrayToString(key.slice(1 + byteLen), "base64url"),
      ext: true
    };
  }
  var unmarshalPrivateKey = (curve, key) => ({
    ...unmarshalPublicKey(curve, key.public),
    d: uint8ArrayToString(key.private, "base64url")
  });
});

// node_modules/libp2p-crypto/src/keys/ephemeral-keys.js
var require_ephemeral_keys = __commonJS((exports2, module2) => {
  "use strict";
  var ecdh = require_ecdh_browser();
  module2.exports = async (curve) => ecdh.generateEphmeralKeyPair(curve);
});

// node_modules/libp2p-crypto/src/keys/index.js
var require_keys = __commonJS((exports2, module2) => {
  "use strict";
  var protobuf = require_src8();
  var keysPBM = protobuf(require_keys_proto());
  require_asn1();
  require_pbe();
  var forge = require_forge();
  var errcode = require_err_code();
  var uint8ArrayFromString = require_from_string2();
  var importer = require_importer();
  exports2 = module2.exports;
  var supportedKeys = {
    rsa: require_rsa_class(),
    ed25519: require_ed25519_class(),
    secp256k1: require_secp256k1_class()(keysPBM, require_random_bytes())
  };
  exports2.supportedKeys = supportedKeys;
  exports2.keysPBM = keysPBM;
  var ErrMissingSecp256K1 = {
    message: "secp256k1 support requires libp2p-crypto-secp256k1 package",
    code: "ERR_MISSING_PACKAGE"
  };
  function typeToKey(type) {
    const key = supportedKeys[type.toLowerCase()];
    if (!key) {
      const supported = Object.keys(supportedKeys).join(" / ");
      throw errcode(new Error(`invalid or unsupported key type ${type}. Must be ${supported}`), "ERR_UNSUPPORTED_KEY_TYPE");
    }
    return key;
  }
  exports2.keyStretcher = require_key_stretcher();
  exports2.generateEphemeralKeyPair = require_ephemeral_keys();
  exports2.generateKeyPair = async (type, bits) => {
    return typeToKey(type).generateKeyPair(bits);
  };
  exports2.generateKeyPairFromSeed = async (type, seed, bits) => {
    const key = typeToKey(type);
    if (type.toLowerCase() !== "ed25519") {
      throw errcode(new Error("Seed key derivation is unimplemented for RSA or secp256k1"), "ERR_UNSUPPORTED_KEY_DERIVATION_TYPE");
    }
    return key.generateKeyPairFromSeed(seed, bits);
  };
  exports2.unmarshalPublicKey = (buf) => {
    const decoded = keysPBM.PublicKey.decode(buf);
    const data = decoded.Data;
    switch (decoded.Type) {
      case keysPBM.KeyType.RSA:
        return supportedKeys.rsa.unmarshalRsaPublicKey(data);
      case keysPBM.KeyType.Ed25519:
        return supportedKeys.ed25519.unmarshalEd25519PublicKey(data);
      case keysPBM.KeyType.Secp256k1:
        if (supportedKeys.secp256k1) {
          return supportedKeys.secp256k1.unmarshalSecp256k1PublicKey(data);
        } else {
          throw errcode(new Error(ErrMissingSecp256K1.message), ErrMissingSecp256K1.code);
        }
      default:
        typeToKey(decoded.Type);
    }
  };
  exports2.marshalPublicKey = (key, type) => {
    type = (type || "rsa").toLowerCase();
    typeToKey(type);
    return key.bytes;
  };
  exports2.unmarshalPrivateKey = async (buf) => {
    const decoded = keysPBM.PrivateKey.decode(buf);
    const data = decoded.Data;
    switch (decoded.Type) {
      case keysPBM.KeyType.RSA:
        return supportedKeys.rsa.unmarshalRsaPrivateKey(data);
      case keysPBM.KeyType.Ed25519:
        return supportedKeys.ed25519.unmarshalEd25519PrivateKey(data);
      case keysPBM.KeyType.Secp256k1:
        if (supportedKeys.secp256k1) {
          return supportedKeys.secp256k1.unmarshalSecp256k1PrivateKey(data);
        } else {
          throw errcode(new Error(ErrMissingSecp256K1.message), ErrMissingSecp256K1.code);
        }
      default:
        typeToKey(decoded.Type);
    }
  };
  exports2.marshalPrivateKey = (key, type) => {
    type = (type || "rsa").toLowerCase();
    typeToKey(type);
    return key.bytes;
  };
  exports2.import = async (encryptedKey, password) => {
    try {
      const key2 = await importer.import(encryptedKey, password);
      return exports2.unmarshalPrivateKey(key2);
    } catch (_) {
    }
    const key = forge.pki.decryptRsaPrivateKey(encryptedKey, password);
    if (key === null) {
      throw errcode(new Error("Cannot read the key, most likely the password is wrong or not a RSA key"), "ERR_CANNOT_DECRYPT_PEM");
    }
    let der = forge.asn1.toDer(forge.pki.privateKeyToAsn1(key));
    der = uint8ArrayFromString(der.getBytes(), "ascii");
    return supportedKeys.rsa.unmarshalRsaPrivateKey(der);
  };
});

// node_modules/class-is/index.js
var require_class_is = __commonJS((exports2, module2) => {
  "use strict";
  function withIs(Class, {className, symbolName}) {
    const symbol = Symbol.for(symbolName);
    const ClassIsWrapper = {
      [className]: class extends Class {
        constructor(...args) {
          super(...args);
          Object.defineProperty(this, symbol, {value: true});
        }
        get [Symbol.toStringTag]() {
          return className;
        }
      }
    }[className];
    ClassIsWrapper[`is${className}`] = (obj) => !!(obj && obj[symbol]);
    return ClassIsWrapper;
  }
  function withIsProto(Class, {className, symbolName, withoutNew}) {
    const symbol = Symbol.for(symbolName);
    const ClassIsWrapper = {
      [className]: function(...args) {
        if (withoutNew && !(this instanceof ClassIsWrapper)) {
          return new ClassIsWrapper(...args);
        }
        const _this = Class.call(this, ...args) || this;
        if (_this && !_this[symbol]) {
          Object.defineProperty(_this, symbol, {value: true});
        }
        return _this;
      }
    }[className];
    ClassIsWrapper.prototype = Object.create(Class.prototype);
    ClassIsWrapper.prototype.constructor = ClassIsWrapper;
    Object.defineProperty(ClassIsWrapper.prototype, Symbol.toStringTag, {
      get() {
        return className;
      }
    });
    ClassIsWrapper[`is${className}`] = (obj) => !!(obj && obj[symbol]);
    return ClassIsWrapper;
  }
  module2.exports = withIs;
  module2.exports.proto = withIsProto;
});

// node_modules/peer-id/src/proto.js
var require_proto = __commonJS((exports2, module2) => {
  "use strict";
  var protons = require_src8();
  module2.exports = protons(`

message PeerIdProto {
  required bytes id = 1;
  bytes pubKey = 2;
  bytes privKey = 3;
}

`);
});

// node_modules/peer-id/node_modules/uint8arrays/equals.js
var require_equals3 = __commonJS((exports2, module2) => {
  "use strict";
  function equals(a, b) {
    if (a === b) {
      return true;
    }
    if (a.byteLength !== b.byteLength) {
      return false;
    }
    for (let i = 0; i < a.byteLength; i++) {
      if (a[i] !== b[i]) {
        return false;
      }
    }
    return true;
  }
  module2.exports = equals;
});

// node_modules/peer-id/node_modules/uint8arrays/from-string.js
var require_from_string3 = __commonJS((exports2, module2) => {
  "use strict";
  var {encoding: getCodec} = require_src4();
  var {TextEncoder: TextEncoder2} = require_lib_browser();
  var utf8Encoder = new TextEncoder2();
  function asciiStringToUint8Array(string) {
    const array = new Uint8Array(string.length);
    for (let i = 0; i < string.length; i++) {
      array[i] = string.charCodeAt(i);
    }
    return array;
  }
  function fromString(string, encoding = "utf8") {
    if (encoding === "utf8" || encoding === "utf-8") {
      return utf8Encoder.encode(string);
    }
    if (encoding === "ascii") {
      return asciiStringToUint8Array(string);
    }
    return getCodec(encoding).decode(string);
  }
  module2.exports = fromString;
});

// node_modules/peer-id/node_modules/uint8arrays/to-string.js
var require_to_string4 = __commonJS((exports2, module2) => {
  "use strict";
  var {encoding: getCodec} = require_src4();
  var {TextDecoder: TextDecoder2} = require_lib_browser();
  var utf8Decoder = new TextDecoder2("utf8");
  function uint8ArrayToAsciiString(array) {
    let string = "";
    for (let i = 0; i < array.length; i++) {
      string += String.fromCharCode(array[i]);
    }
    return string;
  }
  function toString(array, encoding = "utf8") {
    if (encoding === "utf8" || encoding === "utf-8") {
      return utf8Decoder.decode(array);
    }
    if (encoding === "ascii") {
      return uint8ArrayToAsciiString(array);
    }
    return getCodec(encoding).encode(array);
  }
  module2.exports = toString;
});

// node_modules/peer-id/src/index.js
var require_src9 = __commonJS((exports2, module2) => {
  "use strict";
  var mh = require_src5();
  var CID = require_src7();
  var cryptoKeys = require_keys();
  var withIs = require_class_is();
  var {PeerIdProto} = require_proto();
  var uint8ArrayEquals = require_equals3();
  var uint8ArrayFromString = require_from_string3();
  var uint8ArrayToString = require_to_string4();
  var PeerId = class {
    constructor(id, privKey, pubKey) {
      if (!(id instanceof Uint8Array)) {
        throw new Error("invalid id provided");
      }
      if (privKey && pubKey && !uint8ArrayEquals(privKey.public.bytes, pubKey.bytes)) {
        throw new Error("inconsistent arguments");
      }
      this._id = id;
      this._idB58String = mh.toB58String(this.id);
      this._privKey = privKey;
      this._pubKey = pubKey;
    }
    get id() {
      return this._id;
    }
    set id(val) {
      throw new Error("Id is immutable");
    }
    get privKey() {
      return this._privKey;
    }
    set privKey(privKey) {
      this._privKey = privKey;
    }
    get pubKey() {
      if (this._pubKey) {
        return this._pubKey;
      }
      if (this._privKey) {
        return this._privKey.public;
      }
      try {
        const decoded = mh.decode(this.id);
        if (decoded.name === "identity") {
          this._pubKey = cryptoKeys.unmarshalPublicKey(decoded.digest);
        }
      } catch (_) {
      }
      return this._pubKey;
    }
    set pubKey(pubKey) {
      this._pubKey = pubKey;
    }
    marshalPubKey() {
      if (this.pubKey) {
        return cryptoKeys.marshalPublicKey(this.pubKey);
      }
    }
    marshalPrivKey() {
      if (this.privKey) {
        return cryptoKeys.marshalPrivateKey(this.privKey);
      }
    }
    marshal(excludePriv) {
      return PeerIdProto.encode({
        id: this.toBytes(),
        pubKey: this.marshalPubKey(),
        privKey: excludePriv ? null : this.marshalPrivKey()
      });
    }
    toPrint() {
      let pid = this.toB58String();
      if (pid.startsWith("Qm")) {
        pid = pid.slice(2);
      }
      let maxRunes = 6;
      if (pid.length < maxRunes) {
        maxRunes = pid.length;
      }
      return "<peer.ID " + pid.substr(0, maxRunes) + ">";
    }
    toJSON() {
      return {
        id: this.toB58String(),
        privKey: toB64Opt(this.marshalPrivKey()),
        pubKey: toB64Opt(this.marshalPubKey())
      };
    }
    toHexString() {
      return mh.toHexString(this.id);
    }
    toBytes() {
      return this.id;
    }
    toB58String() {
      return this._idB58String;
    }
    toString() {
      if (!this._idCIDString) {
        const cid = new CID(1, "libp2p-key", this.id, "base32");
        this._idCIDString = cid.toBaseEncodedString("base32");
      }
      return this._idCIDString;
    }
    equals(id) {
      if (id instanceof Uint8Array) {
        return uint8ArrayEquals(this.id, id);
      } else if (id.id) {
        return uint8ArrayEquals(this.id, id.id);
      } else {
        throw new Error("not valid Id");
      }
    }
    isEqual(id) {
      return this.equals(id);
    }
    isValid() {
      return Boolean(this.privKey && this.privKey.public && this.privKey.public.bytes && this.pubKey.bytes instanceof Uint8Array && uint8ArrayEquals(this.privKey.public.bytes, this.pubKey.bytes));
    }
    hasInlinePublicKey() {
      try {
        const decoded = mh.decode(this.id);
        if (decoded.name === "identity") {
          return true;
        }
      } catch (_) {
      }
      return false;
    }
  };
  var PeerIdWithIs = withIs(PeerId, {
    className: "PeerId",
    symbolName: "@libp2p/js-peer-id/PeerId"
  });
  exports2 = module2.exports = PeerIdWithIs;
  var computeDigest = (pubKey) => {
    if (pubKey.bytes.length <= 42) {
      return mh.encode(pubKey.bytes, "identity");
    } else {
      return pubKey.hash();
    }
  };
  var computePeerId = async (privKey, pubKey) => {
    const digest = await computeDigest(pubKey);
    return new PeerIdWithIs(digest, privKey, pubKey);
  };
  exports2.create = async (opts) => {
    opts = opts || {};
    opts.bits = opts.bits || 2048;
    opts.keyType = opts.keyType || "RSA";
    const key = await cryptoKeys.generateKeyPair(opts.keyType, opts.bits);
    return computePeerId(key, key.public);
  };
  exports2.createFromHexString = (str) => {
    return new PeerIdWithIs(mh.fromHexString(str));
  };
  exports2.createFromBytes = (buf) => {
    return new PeerIdWithIs(buf);
  };
  exports2.createFromB58String = (str) => {
    return exports2.createFromCID(str);
  };
  var validMulticodec = (cid) => {
    return cid.codec === "libp2p-key" || cid.codec === "dag-pb";
  };
  exports2.createFromCID = (cid) => {
    cid = CID.isCID(cid) ? cid : new CID(cid);
    if (!validMulticodec(cid))
      throw new Error("Supplied PeerID CID has invalid multicodec: " + cid.codec);
    return new PeerIdWithIs(cid.multihash);
  };
  exports2.createFromPubKey = async (key) => {
    let buf = key;
    if (typeof buf === "string") {
      buf = uint8ArrayFromString(key, "base64pad");
    }
    if (!(buf instanceof Uint8Array)) {
      throw new Error("Supplied key is neither a base64 string nor a Uint8Array");
    }
    const pubKey = await cryptoKeys.unmarshalPublicKey(buf);
    return computePeerId(null, pubKey);
  };
  exports2.createFromPrivKey = async (key) => {
    if (typeof key === "string") {
      key = uint8ArrayFromString(key, "base64pad");
    }
    if (!(key instanceof Uint8Array)) {
      throw new Error("Supplied key is neither a base64 string nor a Uint8Array");
    }
    const privKey = await cryptoKeys.unmarshalPrivateKey(key);
    return computePeerId(privKey, privKey.public);
  };
  exports2.createFromJSON = async (obj) => {
    const id = mh.fromB58String(obj.id);
    const rawPrivKey = obj.privKey && uint8ArrayFromString(obj.privKey, "base64pad");
    const rawPubKey = obj.pubKey && uint8ArrayFromString(obj.pubKey, "base64pad");
    const pub = rawPubKey && await cryptoKeys.unmarshalPublicKey(rawPubKey);
    if (!rawPrivKey) {
      return new PeerIdWithIs(id, null, pub);
    }
    const privKey = await cryptoKeys.unmarshalPrivateKey(rawPrivKey);
    const privDigest = await computeDigest(privKey.public);
    let pubDigest;
    if (pub) {
      pubDigest = await computeDigest(pub);
    }
    if (pub && !uint8ArrayEquals(privDigest, pubDigest)) {
      throw new Error("Public and private key do not match");
    }
    if (id && !uint8ArrayEquals(privDigest, id)) {
      throw new Error("Id and private key do not match");
    }
    return new PeerIdWithIs(id, privKey, pub);
  };
  exports2.createFromProtobuf = async (buf) => {
    if (typeof buf === "string") {
      buf = uint8ArrayFromString(buf, "base16");
    }
    let {id, privKey, pubKey} = PeerIdProto.decode(buf);
    privKey = privKey ? await cryptoKeys.unmarshalPrivateKey(privKey) : false;
    pubKey = pubKey ? await cryptoKeys.unmarshalPublicKey(pubKey) : false;
    let pubDigest;
    let privDigest;
    if (privKey) {
      privDigest = await computeDigest(privKey.public);
    }
    if (pubKey) {
      pubDigest = await computeDigest(pubKey);
    }
    if (privKey) {
      if (pubKey) {
        if (!uint8ArrayEquals(privDigest, pubDigest)) {
          throw new Error("Public and private key do not match");
        }
      }
      return new PeerIdWithIs(privDigest, privKey, privKey.public);
    }
    if (pubKey) {
      return new PeerIdWithIs(pubDigest, null, pubKey);
    }
    if (id) {
      return new PeerIdWithIs(id);
    }
    throw new Error("Protobuf did not contain any usable key material");
  };
  exports2.isPeerId = (peerId) => {
    return Boolean(typeof peerId === "object" && peerId._id && peerId._idB58String);
  };
  function toB64Opt(val) {
    if (val) {
      return uint8ArrayToString(val, "base64pad");
    }
  }
});

// node_modules/libp2p-crypto/src/aes/ciphers-browser.js
var require_ciphers_browser = __commonJS((exports2, module2) => {
  "use strict";
  require_aes();
  var forge = require_forge();
  var uint8ArrayToString = require_to_string2();
  var uint8ArrayFromString = require_from_string2();
  module2.exports = {
    createCipheriv: (mode, key, iv) => {
      const cipher2 = forge.cipher.createCipher("AES-CTR", uint8ArrayToString(key, "ascii"));
      cipher2.start({iv: uint8ArrayToString(iv, "ascii")});
      return {
        update: (data) => {
          cipher2.update(forge.util.createBuffer(uint8ArrayToString(data, "ascii")));
          return uint8ArrayFromString(cipher2.output.getBytes(), "ascii");
        }
      };
    },
    createDecipheriv: (mode, key, iv) => {
      const cipher2 = forge.cipher.createDecipher("AES-CTR", uint8ArrayToString(key, "ascii"));
      cipher2.start({iv: uint8ArrayToString(iv, "ascii")});
      return {
        update: (data) => {
          cipher2.update(forge.util.createBuffer(uint8ArrayToString(data, "ascii")));
          return uint8ArrayFromString(cipher2.output.getBytes(), "ascii");
        }
      };
    }
  };
});

// node_modules/libp2p-crypto/src/aes/cipher-mode.js
var require_cipher_mode = __commonJS((exports2, module2) => {
  "use strict";
  var errcode = require_err_code();
  var CIPHER_MODES = {
    16: "aes-128-ctr",
    32: "aes-256-ctr"
  };
  module2.exports = function(key) {
    const mode = CIPHER_MODES[key.length];
    if (!mode) {
      const modes = Object.entries(CIPHER_MODES).map(([k, v]) => `${k} (${v})`).join(" / ");
      throw errcode(new Error(`Invalid key length ${key.length} bytes. Must be ${modes}`), "ERR_INVALID_KEY_LENGTH");
    }
    return mode;
  };
});

// node_modules/libp2p-crypto/src/aes/index.js
var require_aes2 = __commonJS((exports2) => {
  "use strict";
  var ciphers = require_ciphers_browser();
  var cipherMode = require_cipher_mode();
  exports2.create = async function(key, iv) {
    const mode = cipherMode(key);
    const cipher = ciphers.createCipheriv(mode, key, iv);
    const decipher = ciphers.createDecipheriv(mode, key, iv);
    const res = {
      async encrypt(data) {
        return cipher.update(data);
      },
      async decrypt(data) {
        return decipher.update(data);
      }
    };
    return res;
  };
});

// node_modules/libp2p-crypto/src/pbkdf2.js
var require_pbkdf22 = __commonJS((exports2, module2) => {
  "use strict";
  var forgePbkdf2 = require_pbkdf2();
  var forgeUtil = require_util3();
  var errcode = require_err_code();
  var hashName = {
    sha1: "sha1",
    "sha2-256": "sha256",
    "sha2-512": "sha512"
  };
  function pbkdf2(password, salt, iterations, keySize, hash) {
    const hasher = hashName[hash];
    if (!hasher) {
      const types = Object.keys(hashName).join(" / ");
      throw errcode(new Error(`Hash '${hash}' is unknown or not supported. Must be ${types}`), "ERR_UNSUPPORTED_HASH_TYPE");
    }
    const dek = forgePbkdf2(password, salt, iterations, keySize, hasher);
    return forgeUtil.encode64(dek);
  }
  module2.exports = pbkdf2;
});

// node_modules/libp2p-crypto/src/index.js
var require_src10 = __commonJS((exports2) => {
  "use strict";
  var hmac = require_index_browser();
  var aes = require_aes2();
  var keys = require_keys();
  exports2.aes = aes;
  exports2.hmac = hmac;
  exports2.keys = keys;
  exports2.randomBytes = require_random_bytes();
  exports2.pbkdf2 = require_pbkdf22();
});

// node_modules/ip-regex/index.js
var require_ip_regex = __commonJS((exports2, module2) => {
  "use strict";
  var word = "[a-fA-F\\d:]";
  var b = (options) => options && options.includeBoundaries ? `(?:(?<=\\s|^)(?=${word})|(?<=${word})(?=\\s|$))` : "";
  var v4 = "(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}";
  var v6seg = "[a-fA-F\\d]{1,4}";
  var v6 = `
(?:
(?:${v6seg}:){7}(?:${v6seg}|:)|                                    // 1:2:3:4:5:6:7::  1:2:3:4:5:6:7:8
(?:${v6seg}:){6}(?:${v4}|:${v6seg}|:)|                             // 1:2:3:4:5:6::    1:2:3:4:5:6::8   1:2:3:4:5:6::8  1:2:3:4:5:6::1.2.3.4
(?:${v6seg}:){5}(?::${v4}|(?::${v6seg}){1,2}|:)|                   // 1:2:3:4:5::      1:2:3:4:5::7:8   1:2:3:4:5::8    1:2:3:4:5::7:1.2.3.4
(?:${v6seg}:){4}(?:(?::${v6seg}){0,1}:${v4}|(?::${v6seg}){1,3}|:)| // 1:2:3:4::        1:2:3:4::6:7:8   1:2:3:4::8      1:2:3:4::6:7:1.2.3.4
(?:${v6seg}:){3}(?:(?::${v6seg}){0,2}:${v4}|(?::${v6seg}){1,4}|:)| // 1:2:3::          1:2:3::5:6:7:8   1:2:3::8        1:2:3::5:6:7:1.2.3.4
(?:${v6seg}:){2}(?:(?::${v6seg}){0,3}:${v4}|(?::${v6seg}){1,5}|:)| // 1:2::            1:2::4:5:6:7:8   1:2::8          1:2::4:5:6:7:1.2.3.4
(?:${v6seg}:){1}(?:(?::${v6seg}){0,4}:${v4}|(?::${v6seg}){1,6}|:)| // 1::              1::3:4:5:6:7:8   1::8            1::3:4:5:6:7:1.2.3.4
(?::(?:(?::${v6seg}){0,5}:${v4}|(?::${v6seg}){1,7}|:))             // ::2:3:4:5:6:7:8  ::2:3:4:5:6:7:8  ::8             ::1.2.3.4
)(?:%[0-9a-zA-Z]{1,})?                                             // %eth0            %1
`.replace(/\s*\/\/.*$/gm, "").replace(/\n/g, "").trim();
  var v46Exact = new RegExp(`(?:^${v4}$)|(?:^${v6}$)`);
  var v4exact = new RegExp(`^${v4}$`);
  var v6exact = new RegExp(`^${v6}$`);
  var ip = (options) => options && options.exact ? v46Exact : new RegExp(`(?:${b(options)}${v4}${b(options)})|(?:${b(options)}${v6}${b(options)})`, "g");
  ip.v4 = (options) => options && options.exact ? v4exact : new RegExp(`${b(options)}${v4}${b(options)}`, "g");
  ip.v6 = (options) => options && options.exact ? v6exact : new RegExp(`${b(options)}${v6}${b(options)}`, "g");
  module2.exports = ip;
});

// node_modules/is-ip/index.js
var require_is_ip = __commonJS((exports2, module2) => {
  "use strict";
  var ipRegex = require_ip_regex();
  var isIp = (string) => ipRegex({exact: true}).test(string);
  isIp.v4 = (string) => ipRegex.v4({exact: true}).test(string);
  isIp.v6 = (string) => ipRegex.v6({exact: true}).test(string);
  isIp.version = (string) => isIp(string) ? isIp.v4(string) ? 4 : 6 : void 0;
  module2.exports = isIp;
});

// node_modules/multiaddr/src/ip.js
var require_ip = __commonJS((exports2, module2) => {
  "use strict";
  var isIp = require_is_ip();
  var uint8ArrayToString = require_to_string2();
  var isIP = isIp;
  var isV4 = isIp.v4;
  var isV6 = isIp.v6;
  var toBytes = function(ip, buff, offset) {
    offset = ~~offset;
    var result;
    if (isV4(ip)) {
      result = buff || new Uint8Array(offset + 4);
      ip.split(/\./g).map(function(byte) {
        result[offset++] = parseInt(byte, 10) & 255;
      });
    } else if (isV6(ip)) {
      var sections = ip.split(":", 8);
      var i;
      for (i = 0; i < sections.length; i++) {
        var isv4 = isV4(sections[i]);
        var v4Buffer;
        if (isv4) {
          v4Buffer = toBytes(sections[i]);
          sections[i] = uint8ArrayToString(v4Buffer.slice(0, 2), "base16");
        }
        if (v4Buffer && ++i < 8) {
          sections.splice(i, 0, uint8ArrayToString(v4Buffer.slice(2, 4), "base16"));
        }
      }
      if (sections[0] === "") {
        while (sections.length < 8)
          sections.unshift("0");
      } else if (sections[sections.length - 1] === "") {
        while (sections.length < 8)
          sections.push("0");
      } else if (sections.length < 8) {
        for (i = 0; i < sections.length && sections[i] !== ""; i++)
          ;
        var argv = [i, "1"];
        for (i = 9 - sections.length; i > 0; i--) {
          argv.push("0");
        }
        sections.splice.apply(sections, argv);
      }
      result = buff || new Uint8Array(offset + 16);
      for (i = 0; i < sections.length; i++) {
        var word = parseInt(sections[i], 16);
        result[offset++] = word >> 8 & 255;
        result[offset++] = word & 255;
      }
    }
    if (!result) {
      throw Error("Invalid ip address: " + ip);
    }
    return result;
  };
  var toString = function(buff, offset, length) {
    offset = ~~offset;
    length = length || buff.length - offset;
    var result = [];
    var string;
    const view = new DataView(buff.buffer);
    if (length === 4) {
      for (let i = 0; i < length; i++) {
        result.push(buff[offset + i]);
      }
      string = result.join(".");
    } else if (length === 16) {
      for (let i = 0; i < length; i += 2) {
        result.push(view.getUint16(offset + i).toString(16));
      }
      string = result.join(":");
      string = string.replace(/(^|:)0(:0)*:0(:|$)/, "$1::$3");
      string = string.replace(/:{3,4}/, "::");
    }
    return string;
  };
  module2.exports = {
    isIP,
    isV4,
    isV6,
    toBytes,
    toString
  };
});

// node_modules/multiaddr/src/protocols-table.js
var require_protocols_table = __commonJS((exports2, module2) => {
  "use strict";
  function Protocols(proto) {
    if (typeof proto === "number") {
      if (Protocols.codes[proto]) {
        return Protocols.codes[proto];
      }
      throw new Error("no protocol with code: " + proto);
    } else if (typeof proto === "string" || proto instanceof String) {
      if (Protocols.names[proto]) {
        return Protocols.names[proto];
      }
      throw new Error("no protocol with name: " + proto);
    }
    throw new Error("invalid protocol id type: " + proto);
  }
  var V = -1;
  Protocols.lengthPrefixedVarSize = V;
  Protocols.V = V;
  Protocols.table = [
    [4, 32, "ip4"],
    [6, 16, "tcp"],
    [33, 16, "dccp"],
    [41, 128, "ip6"],
    [42, V, "ip6zone"],
    [53, V, "dns", "resolvable"],
    [54, V, "dns4", "resolvable"],
    [55, V, "dns6", "resolvable"],
    [56, V, "dnsaddr", "resolvable"],
    [132, 16, "sctp"],
    [273, 16, "udp"],
    [275, 0, "p2p-webrtc-star"],
    [276, 0, "p2p-webrtc-direct"],
    [277, 0, "p2p-stardust"],
    [290, 0, "p2p-circuit"],
    [301, 0, "udt"],
    [302, 0, "utp"],
    [400, V, "unix", false, "path"],
    [421, V, "ipfs"],
    [421, V, "p2p"],
    [443, 0, "https"],
    [444, 96, "onion"],
    [445, 296, "onion3"],
    [446, V, "garlic64"],
    [460, 0, "quic"],
    [477, 0, "ws"],
    [478, 0, "wss"],
    [479, 0, "p2p-websocket-star"],
    [480, 0, "http"],
    [777, V, "memory"]
  ];
  Protocols.names = {};
  Protocols.codes = {};
  Protocols.table.map((row) => {
    const proto = p.apply(null, row);
    Protocols.codes[proto.code] = proto;
    Protocols.names[proto.name] = proto;
  });
  Protocols.object = p;
  function p(code, size, name, resolvable, path) {
    return {
      code,
      size,
      name,
      resolvable: Boolean(resolvable),
      path: Boolean(path)
    };
  }
  module2.exports = Protocols;
});

// node_modules/multiaddr/src/convert.js
var require_convert = __commonJS((exports2, module2) => {
  "use strict";
  var ip = require_ip();
  var protocols = require_protocols_table();
  var CID = require_src7();
  var multibase = require_src4();
  var varint = require_varint3();
  var uint8ArrayToString = require_to_string2();
  var uint8ArrayFromString = require_from_string2();
  var uint8ArrayConcat = require_concat2();
  module2.exports = Convert;
  function Convert(proto, a) {
    if (a instanceof Uint8Array) {
      return Convert.toString(proto, a);
    } else {
      return Convert.toBytes(proto, a);
    }
  }
  Convert.toString = function convertToString(proto, buf) {
    proto = protocols(proto);
    switch (proto.code) {
      case 4:
      case 41:
        return bytes2ip(buf);
      case 6:
      case 273:
      case 33:
      case 132:
        return bytes2port(buf);
      case 53:
      case 54:
      case 55:
      case 56:
      case 400:
      case 777:
        return bytes2str(buf);
      case 421:
        return bytes2mh(buf);
      case 444:
        return bytes2onion(buf);
      case 445:
        return bytes2onion(buf);
      default:
        return uint8ArrayToString(buf, "base16");
    }
  };
  Convert.toBytes = function convertToBytes(proto, str) {
    proto = protocols(proto);
    switch (proto.code) {
      case 4:
        return ip2bytes(str);
      case 41:
        return ip2bytes(str);
      case 6:
      case 273:
      case 33:
      case 132:
        return port2bytes(parseInt(str, 10));
      case 53:
      case 54:
      case 55:
      case 56:
      case 400:
      case 777:
        return str2bytes(str);
      case 421:
        return mh2bytes(str);
      case 444:
        return onion2bytes(str);
      case 445:
        return onion32bytes(str);
      default:
        return uint8ArrayFromString(str, "base16");
    }
  };
  function ip2bytes(ipString) {
    if (!ip.isIP(ipString)) {
      throw new Error("invalid ip address");
    }
    return ip.toBytes(ipString);
  }
  function bytes2ip(ipBuff) {
    const ipString = ip.toString(ipBuff);
    if (!ipString || !ip.isIP(ipString)) {
      throw new Error("invalid ip address");
    }
    return ipString;
  }
  function port2bytes(port) {
    const buf = new ArrayBuffer(2);
    const view = new DataView(buf);
    view.setUint16(0, port);
    return new Uint8Array(buf);
  }
  function bytes2port(buf) {
    const view = new DataView(buf.buffer);
    return view.getUint16(0);
  }
  function str2bytes(str) {
    const buf = uint8ArrayFromString(str);
    const size = Uint8Array.from(varint.encode(buf.length));
    return uint8ArrayConcat([size, buf], size.length + buf.length);
  }
  function bytes2str(buf) {
    const size = varint.decode(buf);
    buf = buf.slice(varint.decode.bytes);
    if (buf.length !== size) {
      throw new Error("inconsistent lengths");
    }
    return uint8ArrayToString(buf);
  }
  function mh2bytes(hash) {
    const mh = new CID(hash).multihash;
    const size = Uint8Array.from(varint.encode(mh.length));
    return uint8ArrayConcat([size, mh], size.length + mh.length);
  }
  function bytes2mh(buf) {
    const size = varint.decode(buf);
    const address = buf.slice(varint.decode.bytes);
    if (address.length !== size) {
      throw new Error("inconsistent lengths");
    }
    return uint8ArrayToString(address, "base58btc");
  }
  function onion2bytes(str) {
    const addr = str.split(":");
    if (addr.length !== 2) {
      throw new Error("failed to parse onion addr: " + addr + " does not contain a port number");
    }
    if (addr[0].length !== 16) {
      throw new Error("failed to parse onion addr: " + addr[0] + " not a Tor onion address.");
    }
    const buf = multibase.decode("b" + addr[0]);
    const port = parseInt(addr[1], 10);
    if (port < 1 || port > 65536) {
      throw new Error("Port number is not in range(1, 65536)");
    }
    const portBuf = port2bytes(port);
    return uint8ArrayConcat([buf, portBuf], buf.length + portBuf.length);
  }
  function onion32bytes(str) {
    const addr = str.split(":");
    if (addr.length !== 2) {
      throw new Error("failed to parse onion addr: " + addr + " does not contain a port number");
    }
    if (addr[0].length !== 56) {
      throw new Error("failed to parse onion addr: " + addr[0] + " not a Tor onion3 address.");
    }
    const buf = multibase.decode("b" + addr[0]);
    const port = parseInt(addr[1], 10);
    if (port < 1 || port > 65536) {
      throw new Error("Port number is not in range(1, 65536)");
    }
    const portBuf = port2bytes(port);
    return uint8ArrayConcat([buf, portBuf], buf.length + portBuf.length);
  }
  function bytes2onion(buf) {
    const addrBytes = buf.slice(0, buf.length - 2);
    const portBytes = buf.slice(buf.length - 2);
    const addr = uint8ArrayToString(addrBytes, "base32");
    const port = bytes2port(portBytes);
    return addr + ":" + port;
  }
});

// node_modules/multiaddr/src/codec.js
var require_codec = __commonJS((exports2, module2) => {
  "use strict";
  var convert = require_convert();
  var protocols = require_protocols_table();
  var varint = require_varint3();
  var uint8ArrayConcat = require_concat2();
  var uint8ArrayToString = require_to_string2();
  module2.exports = {
    stringToStringTuples,
    stringTuplesToString,
    tuplesToStringTuples,
    stringTuplesToTuples,
    bytesToTuples,
    tuplesToBytes,
    bytesToString,
    stringToBytes,
    fromString,
    fromBytes,
    validateBytes,
    isValidBytes,
    cleanPath,
    ParseError,
    protoFromTuple,
    sizeForAddr
  };
  function stringToStringTuples(str) {
    const tuples = [];
    const parts = str.split("/").slice(1);
    if (parts.length === 1 && parts[0] === "") {
      return [];
    }
    for (let p = 0; p < parts.length; p++) {
      const part = parts[p];
      const proto = protocols(part);
      if (proto.size === 0) {
        tuples.push([part]);
        continue;
      }
      p++;
      if (p >= parts.length) {
        throw ParseError("invalid address: " + str);
      }
      if (proto.path) {
        tuples.push([
          part,
          cleanPath(parts.slice(p).join("/"))
        ]);
        break;
      }
      tuples.push([part, parts[p]]);
    }
    return tuples;
  }
  function stringTuplesToString(tuples) {
    const parts = [];
    tuples.map((tup) => {
      const proto = protoFromTuple(tup);
      parts.push(proto.name);
      if (tup.length > 1) {
        parts.push(tup[1]);
      }
    });
    return cleanPath(parts.join("/"));
  }
  function stringTuplesToTuples(tuples) {
    return tuples.map((tup) => {
      if (!Array.isArray(tup)) {
        tup = [tup];
      }
      const proto = protoFromTuple(tup);
      if (tup.length > 1) {
        return [proto.code, convert.toBytes(proto.code, tup[1])];
      }
      return [proto.code];
    });
  }
  function tuplesToStringTuples(tuples) {
    return tuples.map((tup) => {
      const proto = protoFromTuple(tup);
      if (tup.length > 1) {
        return [proto.code, convert.toString(proto.code, tup[1])];
      }
      return [proto.code];
    });
  }
  function tuplesToBytes(tuples) {
    return fromBytes(uint8ArrayConcat(tuples.map((tup) => {
      const proto = protoFromTuple(tup);
      let buf = Uint8Array.from(varint.encode(proto.code));
      if (tup.length > 1) {
        buf = uint8ArrayConcat([buf, tup[1]]);
      }
      return buf;
    })));
  }
  function sizeForAddr(p, addr) {
    if (p.size > 0) {
      return p.size / 8;
    } else if (p.size === 0) {
      return 0;
    } else {
      const size = varint.decode(addr);
      return size + varint.decode.bytes;
    }
  }
  function bytesToTuples(buf) {
    const tuples = [];
    let i = 0;
    while (i < buf.length) {
      const code = varint.decode(buf, i);
      const n = varint.decode.bytes;
      const p = protocols(code);
      const size = sizeForAddr(p, buf.slice(i + n));
      if (size === 0) {
        tuples.push([code]);
        i += n;
        continue;
      }
      const addr = buf.slice(i + n, i + n + size);
      i += size + n;
      if (i > buf.length) {
        throw ParseError("Invalid address Uint8Array: " + uint8ArrayToString(buf, "base16"));
      }
      tuples.push([code, addr]);
    }
    return tuples;
  }
  function bytesToString(buf) {
    const a = bytesToTuples(buf);
    const b = tuplesToStringTuples(a);
    return stringTuplesToString(b);
  }
  function stringToBytes(str) {
    str = cleanPath(str);
    const a = stringToStringTuples(str);
    const b = stringTuplesToTuples(a);
    return tuplesToBytes(b);
  }
  function fromString(str) {
    return stringToBytes(str);
  }
  function fromBytes(buf) {
    const err = validateBytes(buf);
    if (err)
      throw err;
    return Uint8Array.from(buf);
  }
  function validateBytes(buf) {
    try {
      bytesToTuples(buf);
    } catch (err) {
      return err;
    }
  }
  function isValidBytes(buf) {
    return validateBytes(buf) === void 0;
  }
  function cleanPath(str) {
    return "/" + str.trim().split("/").filter((a) => a).join("/");
  }
  function ParseError(str) {
    return new Error("Error parsing address: " + str);
  }
  function protoFromTuple(tup) {
    const proto = protocols(tup[0]);
    return proto;
  }
});

// node_modules/multiaddr/src/index.js
var require_src11 = __commonJS((exports2, module2) => {
  "use strict";
  var codec = require_codec();
  var protocols = require_protocols_table();
  var varint = require_varint3();
  var CID = require_src7();
  var withIs = require_class_is();
  var errCode = require_err_code();
  var inspect = Symbol.for("nodejs.util.inspect.custom");
  var uint8ArrayToString = require_to_string2();
  var uint8ArrayEquals = require_equals2();
  var resolvers = new Map();
  var Multiaddr = withIs.proto(function(addr) {
    if (!(this instanceof Multiaddr)) {
      return new Multiaddr(addr);
    }
    if (addr == null) {
      addr = "";
    }
    if (addr instanceof Uint8Array) {
      this.bytes = codec.fromBytes(addr);
    } else if (typeof addr === "string" || addr instanceof String) {
      if (addr.length > 0 && addr.charAt(0) !== "/") {
        throw new Error(`multiaddr "${addr}" must start with a "/"`);
      }
      this.bytes = codec.fromString(addr);
    } else if (addr.bytes && addr.protos && addr.protoCodes) {
      this.bytes = codec.fromBytes(addr.bytes);
    } else {
      throw new Error("addr must be a string, Buffer, or another Multiaddr");
    }
  }, {className: "Multiaddr", symbolName: "@multiformats/js-multiaddr/multiaddr"});
  Multiaddr.prototype.toString = function toString() {
    return codec.bytesToString(this.bytes);
  };
  Multiaddr.prototype.toJSON = Multiaddr.prototype.toString;
  Multiaddr.prototype.toOptions = function toOptions() {
    const opts = {};
    const parsed = this.toString().split("/");
    opts.family = parsed[1] === "ip4" ? "ipv4" : "ipv6";
    opts.host = parsed[2];
    opts.transport = parsed[3];
    opts.port = parseInt(parsed[4]);
    return opts;
  };
  Multiaddr.prototype[inspect] = function inspectCustom() {
    return "<Multiaddr " + uint8ArrayToString(this.bytes, "base16") + " - " + codec.bytesToString(this.bytes) + ">";
  };
  Multiaddr.prototype.inspect = function inspect2() {
    return "<Multiaddr " + uint8ArrayToString(this.bytes, "base16") + " - " + codec.bytesToString(this.bytes) + ">";
  };
  Multiaddr.prototype.protos = function protos() {
    return this.protoCodes().map((code) => Object.assign({}, protocols(code)));
  };
  Multiaddr.prototype.protoCodes = function protoCodes() {
    const codes = [];
    const buf = this.bytes;
    let i = 0;
    while (i < buf.length) {
      const code = varint.decode(buf, i);
      const n = varint.decode.bytes;
      const p = protocols(code);
      const size = codec.sizeForAddr(p, buf.slice(i + n));
      i += size + n;
      codes.push(code);
    }
    return codes;
  };
  Multiaddr.prototype.protoNames = function protoNames() {
    return this.protos().map((proto) => proto.name);
  };
  Multiaddr.prototype.tuples = function tuples() {
    return codec.bytesToTuples(this.bytes);
  };
  Multiaddr.prototype.stringTuples = function stringTuples() {
    const t = codec.bytesToTuples(this.bytes);
    return codec.tuplesToStringTuples(t);
  };
  Multiaddr.prototype.encapsulate = function encapsulate(addr) {
    addr = Multiaddr(addr);
    return Multiaddr(this.toString() + addr.toString());
  };
  Multiaddr.prototype.decapsulate = function decapsulate(addr) {
    addr = addr.toString();
    const s = this.toString();
    const i = s.lastIndexOf(addr);
    if (i < 0) {
      throw new Error("Address " + this + " does not contain subaddress: " + addr);
    }
    return Multiaddr(s.slice(0, i));
  };
  Multiaddr.prototype.decapsulateCode = function decapsulateCode(code) {
    const tuples = this.tuples();
    for (let i = tuples.length - 1; i >= 0; i--) {
      if (tuples[i][0] === code) {
        return Multiaddr(codec.tuplesToBytes(tuples.slice(0, i)));
      }
    }
    return this;
  };
  Multiaddr.prototype.getPeerId = function getPeerId() {
    let b58str = null;
    try {
      const tuples = this.stringTuples().filter((tuple) => {
        if (tuple[0] === protocols.names.ipfs.code) {
          return true;
        }
      });
      b58str = tuples.pop()[1];
      b58str = uint8ArrayToString(new CID(b58str).multihash, "base58btc");
    } catch (e) {
      b58str = null;
    }
    return b58str;
  };
  Multiaddr.prototype.getPath = function getPath() {
    let path = null;
    try {
      path = this.stringTuples().filter((tuple) => {
        const proto = protocols(tuple[0]);
        if (proto.path) {
          return true;
        }
      })[0][1];
    } catch (e) {
      path = null;
    }
    return path;
  };
  Multiaddr.prototype.equals = function equals(addr) {
    return uint8ArrayEquals(this.bytes, addr.bytes);
  };
  Multiaddr.prototype.resolve = async function resolve() {
    const resolvableProto = this.protos().find((p) => p.resolvable);
    if (!resolvableProto) {
      return [this];
    }
    const resolver = resolvers.get(resolvableProto.name);
    if (!resolver) {
      throw errCode(new Error(`no available resolver for ${resolvableProto.name}`), "ERR_NO_AVAILABLE_RESOLVER");
    }
    const addresses = await resolver(this);
    return addresses.map((a) => Multiaddr(a));
  };
  Multiaddr.prototype.nodeAddress = function nodeAddress() {
    const codes = this.protoCodes();
    const names = this.protoNames();
    const parts = this.toString().split("/").slice(1);
    if (parts.length < 4) {
      throw new Error('multiaddr must have a valid format: "/{ip4, ip6, dns4, dns6}/{address}/{tcp, udp}/{port}".');
    } else if (codes[0] !== 4 && codes[0] !== 41 && codes[0] !== 54 && codes[0] !== 55) {
      throw new Error(`no protocol with name: "'${names[0]}'". Must have a valid family name: "{ip4, ip6, dns4, dns6}".`);
    } else if (parts[2] !== "tcp" && parts[2] !== "udp") {
      throw new Error(`no protocol with name: "'${names[1]}'". Must have a valid transport protocol: "{tcp, udp}".`);
    }
    return {
      family: codes[0] === 41 || codes[0] === 55 ? 6 : 4,
      address: parts[1],
      port: parseInt(parts[3])
    };
  };
  Multiaddr.fromNodeAddress = function fromNodeAddress(addr, transport) {
    if (!addr)
      throw new Error("requires node address object");
    if (!transport)
      throw new Error("requires transport protocol");
    let ip;
    switch (addr.family) {
      case "IPv4":
        ip = "ip4";
        break;
      case "IPv6":
        ip = "ip6";
        break;
      default:
        throw Error(`Invalid addr family. Got '${addr.family}' instead of 'IPv4' or 'IPv6'`);
    }
    return Multiaddr("/" + [ip, addr.address, transport, addr.port].join("/"));
  };
  Multiaddr.prototype.isThinWaistAddress = function isThinWaistAddress(addr) {
    const protos = (addr || this).protos();
    if (protos.length !== 2) {
      return false;
    }
    if (protos[0].code !== 4 && protos[0].code !== 41) {
      return false;
    }
    if (protos[1].code !== 6 && protos[1].code !== 273) {
      return false;
    }
    return true;
  };
  Multiaddr.protocols = protocols;
  Multiaddr.isName = function isName(addr) {
    if (!Multiaddr.isMultiaddr(addr)) {
      return false;
    }
    return addr.protos().some((proto) => proto.resolvable);
  };
  Multiaddr.resolve = function resolve(addr) {
    if (!Multiaddr.isMultiaddr(addr) || !Multiaddr.isName(addr)) {
      return Promise.reject(Error("not a valid name"));
    }
    return Promise.reject(new Error("not implemented yet"));
  };
  Multiaddr.resolvers = resolvers;
  exports2 = module2.exports = Multiaddr;
});

// node_modules/mafmt/src/index.js
var require_src12 = __commonJS((exports2) => {
  "use strict";
  var multiaddr = require_src11();
  var DNS4 = base("dns4");
  var DNS6 = base("dns6");
  var DNSADDR = base("dnsaddr");
  var DNS = or(base("dns"), DNSADDR, DNS4, DNS6);
  var IP = or(base("ip4"), base("ip6"));
  var TCP = or(and(IP, base("tcp")), and(DNS, base("tcp")));
  var UDP = and(IP, base("udp"));
  var UTP = and(UDP, base("utp"));
  var QUIC = and(UDP, base("quic"));
  var WebSockets = or(and(TCP, base("ws")), and(DNS, base("ws")));
  var WebSocketsSecure = or(and(TCP, base("wss")), and(DNS, base("wss")));
  var HTTP = or(and(TCP, base("http")), and(IP, base("http")), and(DNS, base("http")));
  var HTTPS = or(and(TCP, base("https")), and(IP, base("https")), and(DNS, base("https")));
  var WebRTCStar = or(and(WebSockets, base("p2p-webrtc-star"), base("p2p")), and(WebSocketsSecure, base("p2p-webrtc-star"), base("p2p")), and(WebSockets, base("p2p-webrtc-star")), and(WebSocketsSecure, base("p2p-webrtc-star")));
  var WebSocketStar = or(and(WebSockets, base("p2p-websocket-star"), base("p2p")), and(WebSocketsSecure, base("p2p-websocket-star"), base("p2p")), and(WebSockets, base("p2p-websocket-star")), and(WebSocketsSecure, base("p2p-websocket-star")));
  var WebRTCDirect = or(and(HTTP, base("p2p-webrtc-direct"), base("p2p")), and(HTTPS, base("p2p-webrtc-direct"), base("p2p")), and(HTTP, base("p2p-webrtc-direct")), and(HTTPS, base("p2p-webrtc-direct")));
  var Reliable = or(WebSockets, WebSocketsSecure, HTTP, HTTPS, WebRTCStar, WebRTCDirect, TCP, UTP, QUIC, DNS);
  var Stardust = or(and(Reliable, base("p2p-stardust"), base("p2p")), and(Reliable, base("p2p-stardust")));
  var _P2P = or(and(Reliable, base("p2p")), WebRTCStar, WebRTCDirect, base("p2p"));
  var _Circuit = or(and(_P2P, base("p2p-circuit"), _P2P), and(_P2P, base("p2p-circuit")), and(base("p2p-circuit"), _P2P), and(Reliable, base("p2p-circuit")), and(base("p2p-circuit"), Reliable), base("p2p-circuit"));
  var CircuitRecursive = () => or(and(_Circuit, CircuitRecursive), _Circuit);
  var Circuit = CircuitRecursive();
  var P2P = or(and(Circuit, _P2P, Circuit), and(_P2P, Circuit), and(Circuit, _P2P), Circuit, _P2P);
  exports2.DNS = DNS;
  exports2.DNS4 = DNS4;
  exports2.DNS6 = DNS6;
  exports2.DNSADDR = DNSADDR;
  exports2.IP = IP;
  exports2.TCP = TCP;
  exports2.UDP = UDP;
  exports2.QUIC = QUIC;
  exports2.UTP = UTP;
  exports2.HTTP = HTTP;
  exports2.HTTPS = HTTPS;
  exports2.WebSockets = WebSockets;
  exports2.WebSocketsSecure = WebSocketsSecure;
  exports2.WebSocketStar = WebSocketStar;
  exports2.WebRTCStar = WebRTCStar;
  exports2.WebRTCDirect = WebRTCDirect;
  exports2.Reliable = Reliable;
  exports2.Stardust = Stardust;
  exports2.Circuit = Circuit;
  exports2.P2P = P2P;
  exports2.IPFS = P2P;
  function makeMatchesFunction(partialMatch) {
    return function matches(a) {
      if (!multiaddr.isMultiaddr(a)) {
        try {
          a = multiaddr(a);
        } catch (err) {
          return false;
        }
      }
      const out = partialMatch(a.protoNames());
      if (out === null) {
        return false;
      }
      return out.length === 0;
    };
  }
  function and() {
    const args = Array.from(arguments);
    function partialMatch(a) {
      if (a.length < args.length) {
        return null;
      }
      args.some((arg) => {
        a = typeof arg === "function" ? arg().partialMatch(a) : arg.partialMatch(a);
        if (a === null) {
          return true;
        }
      });
      return a;
    }
    return {
      toString: function() {
        return "{ " + args.join(" ") + " }";
      },
      input: args,
      matches: makeMatchesFunction(partialMatch),
      partialMatch
    };
  }
  function or() {
    const args = Array.from(arguments);
    function partialMatch(a) {
      let out = null;
      args.some((arg) => {
        const res = typeof arg === "function" ? arg().partialMatch(a) : arg.partialMatch(a);
        if (res) {
          out = res;
          return true;
        }
      });
      return out;
    }
    const result = {
      toString: function() {
        return "{ " + args.join(" ") + " }";
      },
      input: args,
      matches: makeMatchesFunction(partialMatch),
      partialMatch
    };
    return result;
  }
  function base(n) {
    const name = n;
    function matches(a) {
      if (typeof a === "string") {
        try {
          a = multiaddr(a);
        } catch (err) {
          return false;
        }
      }
      const pnames = a.protoNames();
      if (pnames.length === 1 && pnames[0] === name) {
        return true;
      }
      return false;
    }
    function partialMatch(protos) {
      if (protos.length === 0) {
        return null;
      }
      if (protos[0] === name) {
        return protos.slice(1);
      }
      return null;
    }
    return {
      toString: function() {
        return name;
      },
      matches,
      partialMatch
    };
  }
});

// node_modules/is-ipfs/node_modules/iso-url/src/url-browser.js
var require_url_browser2 = __commonJS((exports2, module2) => {
  "use strict";
  var defaultBase = self.location ? self.location.protocol + "//" + self.location.host : "";
  var URL2 = self.URL;
  var URLWithLegacySupport = class {
    constructor(url = "", base = defaultBase) {
      this.super = new URL2(url, base);
      this.path = this.pathname + this.search;
      this.auth = this.username && this.password ? this.username + ":" + this.password : null;
      this.query = this.search && this.search.startsWith("?") ? this.search.slice(1) : null;
    }
    get hash() {
      return this.super.hash;
    }
    get host() {
      return this.super.host;
    }
    get hostname() {
      return this.super.hostname;
    }
    get href() {
      return this.super.href;
    }
    get origin() {
      return this.super.origin;
    }
    get password() {
      return this.super.password;
    }
    get pathname() {
      return this.super.pathname;
    }
    get port() {
      return this.super.port;
    }
    get protocol() {
      return this.super.protocol;
    }
    get search() {
      return this.super.search;
    }
    get searchParams() {
      return this.super.searchParams;
    }
    get username() {
      return this.super.username;
    }
    set hash(hash) {
      this.super.hash = hash;
    }
    set host(host) {
      this.super.host = host;
    }
    set hostname(hostname) {
      this.super.hostname = hostname;
    }
    set href(href) {
      this.super.href = href;
    }
    set origin(origin) {
      this.super.origin = origin;
    }
    set password(password) {
      this.super.password = password;
    }
    set pathname(pathname) {
      this.super.pathname = pathname;
    }
    set port(port) {
      this.super.port = port;
    }
    set protocol(protocol) {
      this.super.protocol = protocol;
    }
    set search(search) {
      this.super.search = search;
    }
    set searchParams(searchParams) {
      this.super.searchParams = searchParams;
    }
    set username(username) {
      this.super.username = username;
    }
    createObjectURL(o) {
      return this.super.createObjectURL(o);
    }
    revokeObjectURL(o) {
      this.super.revokeObjectURL(o);
    }
    toJSON() {
      return this.super.toJSON();
    }
    toString() {
      return this.super.toString();
    }
    format() {
      return this.toString();
    }
  };
  function format(obj) {
    if (typeof obj === "string") {
      const url = new URL2(obj);
      return url.toString();
    }
    if (!(obj instanceof URL2)) {
      const userPass = obj.username && obj.password ? `${obj.username}:${obj.password}@` : "";
      const auth = obj.auth ? obj.auth + "@" : "";
      const port = obj.port ? ":" + obj.port : "";
      const protocol = obj.protocol ? obj.protocol + "//" : "";
      const host = obj.host || "";
      const hostname = obj.hostname || "";
      const search = obj.search || (obj.query ? "?" + obj.query : "");
      const hash = obj.hash || "";
      const pathname = obj.pathname || "";
      const path = obj.path || pathname + search;
      return `${protocol}${userPass || auth}${host || hostname + port}${path}${hash}`;
    }
  }
  module2.exports = {
    URLWithLegacySupport,
    URLSearchParams: self.URLSearchParams,
    defaultBase,
    format
  };
});

// node_modules/is-ipfs/node_modules/iso-url/src/relative.js
var require_relative2 = __commonJS((exports2, module2) => {
  "use strict";
  var {URLWithLegacySupport, format} = require_url_browser2();
  module2.exports = (url, location2 = {}, protocolMap = {}, defaultProtocol) => {
    let protocol = location2.protocol ? location2.protocol.replace(":", "") : "http";
    protocol = (protocolMap[protocol] || defaultProtocol || protocol) + ":";
    let urlParsed;
    try {
      urlParsed = new URLWithLegacySupport(url);
    } catch (err) {
      urlParsed = {};
    }
    const base = Object.assign({}, location2, {
      protocol: protocol || urlParsed.protocol,
      host: location2.host || urlParsed.host
    });
    return new URLWithLegacySupport(url, format(base)).toString();
  };
});

// node_modules/is-ipfs/node_modules/iso-url/index.js
var require_iso_url2 = __commonJS((exports2, module2) => {
  "use strict";
  var {
    URLWithLegacySupport,
    format,
    URLSearchParams: URLSearchParams2,
    defaultBase
  } = require_url_browser2();
  var relative = require_relative2();
  module2.exports = {
    URL: URLWithLegacySupport,
    URLSearchParams: URLSearchParams2,
    format,
    relative,
    defaultBase
  };
});

// node_modules/is-ipfs/src/index.js
var require_src13 = __commonJS((exports2, module2) => {
  "use strict";
  var multihash = require_src5();
  var multibase = require_src4();
  var Multiaddr = require_src11();
  var mafmt = require_src12();
  var CID = require_src7();
  var {URL: URL2} = require_iso_url2();
  var uint8ArrayToString = require_to_string2();
  var pathGatewayPattern = /^https?:\/\/[^/]+\/(ip[fn]s)\/([^/?#]+)/;
  var pathPattern = /^\/(ip[fn]s)\/([^/?#]+)/;
  var defaultProtocolMatch = 1;
  var defaultHashMath = 2;
  var subdomainGatewayPattern = /^https?:\/\/([^/]+)\.(ip[fn]s)\.[^/?]+/;
  var subdomainIdMatch = 1;
  var subdomainProtocolMatch = 2;
  var fqdnWithTld = /^(([a-z0-9]|[a-z0-9][a-z0-9-]*[a-z0-9])\.)+([a-z0-9]|[a-z0-9][a-z0-9-]*[a-z0-9])$/;
  function isMultihash(hash) {
    const formatted = convertToString(hash);
    try {
      multihash.decode(multibase.decode("z" + formatted));
      return true;
    } catch (e) {
      return false;
    }
  }
  function isMultibase(hash) {
    try {
      return multibase.isEncoded(hash);
    } catch (e) {
      return false;
    }
  }
  function isCID(hash) {
    try {
      new CID(hash);
      return true;
    } catch (e) {
      return false;
    }
  }
  function isMultiaddr(input) {
    if (!input)
      return false;
    if (Multiaddr.isMultiaddr(input))
      return true;
    try {
      new Multiaddr(input);
      return true;
    } catch (e) {
      return false;
    }
  }
  function isPeerMultiaddr(input) {
    return isMultiaddr(input) && mafmt.IPFS.matches(input);
  }
  function isIpfs(input, pattern, protocolMatch = defaultProtocolMatch, hashMatch = defaultHashMath) {
    const formatted = convertToString(input);
    if (!formatted) {
      return false;
    }
    const match = formatted.match(pattern);
    if (!match) {
      return false;
    }
    if (match[protocolMatch] !== "ipfs") {
      return false;
    }
    let hash = match[hashMatch];
    if (hash && pattern === subdomainGatewayPattern) {
      hash = hash.toLowerCase();
    }
    return isCID(hash);
  }
  function isIpns(input, pattern, protocolMatch = defaultProtocolMatch, hashMatch) {
    const formatted = convertToString(input);
    if (!formatted) {
      return false;
    }
    const match = formatted.match(pattern);
    if (!match) {
      return false;
    }
    if (match[protocolMatch] !== "ipns") {
      return false;
    }
    let ipnsId = match[hashMatch];
    if (ipnsId && pattern === subdomainGatewayPattern) {
      ipnsId = ipnsId.toLowerCase();
      if (isCID(ipnsId))
        return true;
      try {
        const {hostname} = new URL2(`http://${ipnsId}`);
        return fqdnWithTld.test(hostname);
      } catch (e) {
        return false;
      }
    }
    return true;
  }
  function isString(input) {
    return typeof input === "string";
  }
  function convertToString(input) {
    if (input instanceof Uint8Array) {
      return uint8ArrayToString(input, "base58btc");
    }
    if (isString(input)) {
      return input;
    }
    return false;
  }
  var ipfsSubdomain = (url2) => isIpfs(url2, subdomainGatewayPattern, subdomainProtocolMatch, subdomainIdMatch);
  var ipnsSubdomain = (url2) => isIpns(url2, subdomainGatewayPattern, subdomainProtocolMatch, subdomainIdMatch);
  var subdomain = (url2) => ipfsSubdomain(url2) || ipnsSubdomain(url2);
  var ipfsUrl = (url2) => isIpfs(url2, pathGatewayPattern) || ipfsSubdomain(url2);
  var ipnsUrl = (url2) => isIpns(url2, pathGatewayPattern) || ipnsSubdomain(url2);
  var url = (url2) => ipfsUrl(url2) || ipnsUrl(url2) || subdomain(url2);
  var path = (path2) => isIpfs(path2, pathPattern) || isIpns(path2, pathPattern);
  module2.exports = {
    multihash: isMultihash,
    multiaddr: isMultiaddr,
    peerMultiaddr: isPeerMultiaddr,
    cid: isCID,
    base32cid: (cid) => isMultibase(cid) === "base32" && isCID(cid),
    ipfsSubdomain,
    ipnsSubdomain,
    subdomain,
    subdomainGatewayPattern,
    ipfsUrl,
    ipnsUrl,
    url,
    pathGatewayPattern,
    ipfsPath: (path2) => isIpfs(path2, pathPattern),
    ipnsPath: (path2) => isIpns(path2, pathPattern),
    path,
    pathPattern,
    urlOrPath: (x) => url(x) || path(x),
    cidPath: (path2) => isString(path2) && !isCID(path2) && isIpfs(`/ipfs/${path2}`, pathPattern)
  };
});

// node_modules/js-sha3/src/sha3.js
var require_sha3 = __commonJS((exports2, module2) => {
  /**
   * [js-sha3]{@link https://github.com/emn178/js-sha3}
   *
   * @version 0.8.0
   * @author Chen, Yi-Cyuan [emn178@gmail.com]
   * @copyright Chen, Yi-Cyuan 2015-2018
   * @license MIT
   */
  (function() {
    "use strict";
    var INPUT_ERROR = "input is invalid type";
    var FINALIZE_ERROR = "finalize already called";
    var WINDOW = typeof window === "object";
    var root = WINDOW ? window : {};
    if (root.JS_SHA3_NO_WINDOW) {
      WINDOW = false;
    }
    var WEB_WORKER = !WINDOW && typeof self === "object";
    var NODE_JS = !root.JS_SHA3_NO_NODE_JS && typeof process === "object" && process.versions && process.versions.node;
    if (NODE_JS) {
      root = global;
    } else if (WEB_WORKER) {
      root = self;
    }
    var COMMON_JS = !root.JS_SHA3_NO_COMMON_JS && typeof module2 === "object" && module2.exports;
    var AMD = typeof define === "function" && define.amd;
    var ARRAY_BUFFER = !root.JS_SHA3_NO_ARRAY_BUFFER && typeof ArrayBuffer !== "undefined";
    var HEX_CHARS = "0123456789abcdef".split("");
    var SHAKE_PADDING = [31, 7936, 2031616, 520093696];
    var CSHAKE_PADDING = [4, 1024, 262144, 67108864];
    var KECCAK_PADDING = [1, 256, 65536, 16777216];
    var PADDING = [6, 1536, 393216, 100663296];
    var SHIFT = [0, 8, 16, 24];
    var RC = [
      1,
      0,
      32898,
      0,
      32906,
      2147483648,
      2147516416,
      2147483648,
      32907,
      0,
      2147483649,
      0,
      2147516545,
      2147483648,
      32777,
      2147483648,
      138,
      0,
      136,
      0,
      2147516425,
      0,
      2147483658,
      0,
      2147516555,
      0,
      139,
      2147483648,
      32905,
      2147483648,
      32771,
      2147483648,
      32770,
      2147483648,
      128,
      2147483648,
      32778,
      0,
      2147483658,
      2147483648,
      2147516545,
      2147483648,
      32896,
      2147483648,
      2147483649,
      0,
      2147516424,
      2147483648
    ];
    var BITS = [224, 256, 384, 512];
    var SHAKE_BITS = [128, 256];
    var OUTPUT_TYPES = ["hex", "buffer", "arrayBuffer", "array", "digest"];
    var CSHAKE_BYTEPAD = {
      "128": 168,
      "256": 136
    };
    if (root.JS_SHA3_NO_NODE_JS || !Array.isArray) {
      Array.isArray = function(obj) {
        return Object.prototype.toString.call(obj) === "[object Array]";
      };
    }
    if (ARRAY_BUFFER && (root.JS_SHA3_NO_ARRAY_BUFFER_IS_VIEW || !ArrayBuffer.isView)) {
      ArrayBuffer.isView = function(obj) {
        return typeof obj === "object" && obj.buffer && obj.buffer.constructor === ArrayBuffer;
      };
    }
    var createOutputMethod = function(bits2, padding, outputType) {
      return function(message) {
        return new Keccak(bits2, padding, bits2).update(message)[outputType]();
      };
    };
    var createShakeOutputMethod = function(bits2, padding, outputType) {
      return function(message, outputBits) {
        return new Keccak(bits2, padding, outputBits).update(message)[outputType]();
      };
    };
    var createCshakeOutputMethod = function(bits2, padding, outputType) {
      return function(message, outputBits, n, s) {
        return methods["cshake" + bits2].update(message, outputBits, n, s)[outputType]();
      };
    };
    var createKmacOutputMethod = function(bits2, padding, outputType) {
      return function(key, message, outputBits, s) {
        return methods["kmac" + bits2].update(key, message, outputBits, s)[outputType]();
      };
    };
    var createOutputMethods = function(method, createMethod2, bits2, padding) {
      for (var i2 = 0; i2 < OUTPUT_TYPES.length; ++i2) {
        var type = OUTPUT_TYPES[i2];
        method[type] = createMethod2(bits2, padding, type);
      }
      return method;
    };
    var createMethod = function(bits2, padding) {
      var method = createOutputMethod(bits2, padding, "hex");
      method.create = function() {
        return new Keccak(bits2, padding, bits2);
      };
      method.update = function(message) {
        return method.create().update(message);
      };
      return createOutputMethods(method, createOutputMethod, bits2, padding);
    };
    var createShakeMethod = function(bits2, padding) {
      var method = createShakeOutputMethod(bits2, padding, "hex");
      method.create = function(outputBits) {
        return new Keccak(bits2, padding, outputBits);
      };
      method.update = function(message, outputBits) {
        return method.create(outputBits).update(message);
      };
      return createOutputMethods(method, createShakeOutputMethod, bits2, padding);
    };
    var createCshakeMethod = function(bits2, padding) {
      var w = CSHAKE_BYTEPAD[bits2];
      var method = createCshakeOutputMethod(bits2, padding, "hex");
      method.create = function(outputBits, n, s) {
        if (!n && !s) {
          return methods["shake" + bits2].create(outputBits);
        } else {
          return new Keccak(bits2, padding, outputBits).bytepad([n, s], w);
        }
      };
      method.update = function(message, outputBits, n, s) {
        return method.create(outputBits, n, s).update(message);
      };
      return createOutputMethods(method, createCshakeOutputMethod, bits2, padding);
    };
    var createKmacMethod = function(bits2, padding) {
      var w = CSHAKE_BYTEPAD[bits2];
      var method = createKmacOutputMethod(bits2, padding, "hex");
      method.create = function(key, outputBits, s) {
        return new Kmac(bits2, padding, outputBits).bytepad(["KMAC", s], w).bytepad([key], w);
      };
      method.update = function(key, message, outputBits, s) {
        return method.create(key, outputBits, s).update(message);
      };
      return createOutputMethods(method, createKmacOutputMethod, bits2, padding);
    };
    var algorithms = [
      {name: "keccak", padding: KECCAK_PADDING, bits: BITS, createMethod},
      {name: "sha3", padding: PADDING, bits: BITS, createMethod},
      {name: "shake", padding: SHAKE_PADDING, bits: SHAKE_BITS, createMethod: createShakeMethod},
      {name: "cshake", padding: CSHAKE_PADDING, bits: SHAKE_BITS, createMethod: createCshakeMethod},
      {name: "kmac", padding: CSHAKE_PADDING, bits: SHAKE_BITS, createMethod: createKmacMethod}
    ];
    var methods = {}, methodNames = [];
    for (var i = 0; i < algorithms.length; ++i) {
      var algorithm = algorithms[i];
      var bits = algorithm.bits;
      for (var j = 0; j < bits.length; ++j) {
        var methodName = algorithm.name + "_" + bits[j];
        methodNames.push(methodName);
        methods[methodName] = algorithm.createMethod(bits[j], algorithm.padding);
        if (algorithm.name !== "sha3") {
          var newMethodName = algorithm.name + bits[j];
          methodNames.push(newMethodName);
          methods[newMethodName] = methods[methodName];
        }
      }
    }
    function Keccak(bits2, padding, outputBits) {
      this.blocks = [];
      this.s = [];
      this.padding = padding;
      this.outputBits = outputBits;
      this.reset = true;
      this.finalized = false;
      this.block = 0;
      this.start = 0;
      this.blockCount = 1600 - (bits2 << 1) >> 5;
      this.byteCount = this.blockCount << 2;
      this.outputBlocks = outputBits >> 5;
      this.extraBytes = (outputBits & 31) >> 3;
      for (var i2 = 0; i2 < 50; ++i2) {
        this.s[i2] = 0;
      }
    }
    Keccak.prototype.update = function(message) {
      if (this.finalized) {
        throw new Error(FINALIZE_ERROR);
      }
      var notString, type = typeof message;
      if (type !== "string") {
        if (type === "object") {
          if (message === null) {
            throw new Error(INPUT_ERROR);
          } else if (ARRAY_BUFFER && message.constructor === ArrayBuffer) {
            message = new Uint8Array(message);
          } else if (!Array.isArray(message)) {
            if (!ARRAY_BUFFER || !ArrayBuffer.isView(message)) {
              throw new Error(INPUT_ERROR);
            }
          }
        } else {
          throw new Error(INPUT_ERROR);
        }
        notString = true;
      }
      var blocks = this.blocks, byteCount = this.byteCount, length = message.length, blockCount = this.blockCount, index = 0, s = this.s, i2, code;
      while (index < length) {
        if (this.reset) {
          this.reset = false;
          blocks[0] = this.block;
          for (i2 = 1; i2 < blockCount + 1; ++i2) {
            blocks[i2] = 0;
          }
        }
        if (notString) {
          for (i2 = this.start; index < length && i2 < byteCount; ++index) {
            blocks[i2 >> 2] |= message[index] << SHIFT[i2++ & 3];
          }
        } else {
          for (i2 = this.start; index < length && i2 < byteCount; ++index) {
            code = message.charCodeAt(index);
            if (code < 128) {
              blocks[i2 >> 2] |= code << SHIFT[i2++ & 3];
            } else if (code < 2048) {
              blocks[i2 >> 2] |= (192 | code >> 6) << SHIFT[i2++ & 3];
              blocks[i2 >> 2] |= (128 | code & 63) << SHIFT[i2++ & 3];
            } else if (code < 55296 || code >= 57344) {
              blocks[i2 >> 2] |= (224 | code >> 12) << SHIFT[i2++ & 3];
              blocks[i2 >> 2] |= (128 | code >> 6 & 63) << SHIFT[i2++ & 3];
              blocks[i2 >> 2] |= (128 | code & 63) << SHIFT[i2++ & 3];
            } else {
              code = 65536 + ((code & 1023) << 10 | message.charCodeAt(++index) & 1023);
              blocks[i2 >> 2] |= (240 | code >> 18) << SHIFT[i2++ & 3];
              blocks[i2 >> 2] |= (128 | code >> 12 & 63) << SHIFT[i2++ & 3];
              blocks[i2 >> 2] |= (128 | code >> 6 & 63) << SHIFT[i2++ & 3];
              blocks[i2 >> 2] |= (128 | code & 63) << SHIFT[i2++ & 3];
            }
          }
        }
        this.lastByteIndex = i2;
        if (i2 >= byteCount) {
          this.start = i2 - byteCount;
          this.block = blocks[blockCount];
          for (i2 = 0; i2 < blockCount; ++i2) {
            s[i2] ^= blocks[i2];
          }
          f(s);
          this.reset = true;
        } else {
          this.start = i2;
        }
      }
      return this;
    };
    Keccak.prototype.encode = function(x, right) {
      var o = x & 255, n = 1;
      var bytes = [o];
      x = x >> 8;
      o = x & 255;
      while (o > 0) {
        bytes.unshift(o);
        x = x >> 8;
        o = x & 255;
        ++n;
      }
      if (right) {
        bytes.push(n);
      } else {
        bytes.unshift(n);
      }
      this.update(bytes);
      return bytes.length;
    };
    Keccak.prototype.encodeString = function(str) {
      var notString, type = typeof str;
      if (type !== "string") {
        if (type === "object") {
          if (str === null) {
            throw new Error(INPUT_ERROR);
          } else if (ARRAY_BUFFER && str.constructor === ArrayBuffer) {
            str = new Uint8Array(str);
          } else if (!Array.isArray(str)) {
            if (!ARRAY_BUFFER || !ArrayBuffer.isView(str)) {
              throw new Error(INPUT_ERROR);
            }
          }
        } else {
          throw new Error(INPUT_ERROR);
        }
        notString = true;
      }
      var bytes = 0, length = str.length;
      if (notString) {
        bytes = length;
      } else {
        for (var i2 = 0; i2 < str.length; ++i2) {
          var code = str.charCodeAt(i2);
          if (code < 128) {
            bytes += 1;
          } else if (code < 2048) {
            bytes += 2;
          } else if (code < 55296 || code >= 57344) {
            bytes += 3;
          } else {
            code = 65536 + ((code & 1023) << 10 | str.charCodeAt(++i2) & 1023);
            bytes += 4;
          }
        }
      }
      bytes += this.encode(bytes * 8);
      this.update(str);
      return bytes;
    };
    Keccak.prototype.bytepad = function(strs, w) {
      var bytes = this.encode(w);
      for (var i2 = 0; i2 < strs.length; ++i2) {
        bytes += this.encodeString(strs[i2]);
      }
      var paddingBytes = w - bytes % w;
      var zeros = [];
      zeros.length = paddingBytes;
      this.update(zeros);
      return this;
    };
    Keccak.prototype.finalize = function() {
      if (this.finalized) {
        return;
      }
      this.finalized = true;
      var blocks = this.blocks, i2 = this.lastByteIndex, blockCount = this.blockCount, s = this.s;
      blocks[i2 >> 2] |= this.padding[i2 & 3];
      if (this.lastByteIndex === this.byteCount) {
        blocks[0] = blocks[blockCount];
        for (i2 = 1; i2 < blockCount + 1; ++i2) {
          blocks[i2] = 0;
        }
      }
      blocks[blockCount - 1] |= 2147483648;
      for (i2 = 0; i2 < blockCount; ++i2) {
        s[i2] ^= blocks[i2];
      }
      f(s);
    };
    Keccak.prototype.toString = Keccak.prototype.hex = function() {
      this.finalize();
      var blockCount = this.blockCount, s = this.s, outputBlocks = this.outputBlocks, extraBytes = this.extraBytes, i2 = 0, j2 = 0;
      var hex = "", block;
      while (j2 < outputBlocks) {
        for (i2 = 0; i2 < blockCount && j2 < outputBlocks; ++i2, ++j2) {
          block = s[i2];
          hex += HEX_CHARS[block >> 4 & 15] + HEX_CHARS[block & 15] + HEX_CHARS[block >> 12 & 15] + HEX_CHARS[block >> 8 & 15] + HEX_CHARS[block >> 20 & 15] + HEX_CHARS[block >> 16 & 15] + HEX_CHARS[block >> 28 & 15] + HEX_CHARS[block >> 24 & 15];
        }
        if (j2 % blockCount === 0) {
          f(s);
          i2 = 0;
        }
      }
      if (extraBytes) {
        block = s[i2];
        hex += HEX_CHARS[block >> 4 & 15] + HEX_CHARS[block & 15];
        if (extraBytes > 1) {
          hex += HEX_CHARS[block >> 12 & 15] + HEX_CHARS[block >> 8 & 15];
        }
        if (extraBytes > 2) {
          hex += HEX_CHARS[block >> 20 & 15] + HEX_CHARS[block >> 16 & 15];
        }
      }
      return hex;
    };
    Keccak.prototype.arrayBuffer = function() {
      this.finalize();
      var blockCount = this.blockCount, s = this.s, outputBlocks = this.outputBlocks, extraBytes = this.extraBytes, i2 = 0, j2 = 0;
      var bytes = this.outputBits >> 3;
      var buffer;
      if (extraBytes) {
        buffer = new ArrayBuffer(outputBlocks + 1 << 2);
      } else {
        buffer = new ArrayBuffer(bytes);
      }
      var array = new Uint32Array(buffer);
      while (j2 < outputBlocks) {
        for (i2 = 0; i2 < blockCount && j2 < outputBlocks; ++i2, ++j2) {
          array[j2] = s[i2];
        }
        if (j2 % blockCount === 0) {
          f(s);
        }
      }
      if (extraBytes) {
        array[i2] = s[i2];
        buffer = buffer.slice(0, bytes);
      }
      return buffer;
    };
    Keccak.prototype.buffer = Keccak.prototype.arrayBuffer;
    Keccak.prototype.digest = Keccak.prototype.array = function() {
      this.finalize();
      var blockCount = this.blockCount, s = this.s, outputBlocks = this.outputBlocks, extraBytes = this.extraBytes, i2 = 0, j2 = 0;
      var array = [], offset, block;
      while (j2 < outputBlocks) {
        for (i2 = 0; i2 < blockCount && j2 < outputBlocks; ++i2, ++j2) {
          offset = j2 << 2;
          block = s[i2];
          array[offset] = block & 255;
          array[offset + 1] = block >> 8 & 255;
          array[offset + 2] = block >> 16 & 255;
          array[offset + 3] = block >> 24 & 255;
        }
        if (j2 % blockCount === 0) {
          f(s);
        }
      }
      if (extraBytes) {
        offset = j2 << 2;
        block = s[i2];
        array[offset] = block & 255;
        if (extraBytes > 1) {
          array[offset + 1] = block >> 8 & 255;
        }
        if (extraBytes > 2) {
          array[offset + 2] = block >> 16 & 255;
        }
      }
      return array;
    };
    function Kmac(bits2, padding, outputBits) {
      Keccak.call(this, bits2, padding, outputBits);
    }
    Kmac.prototype = new Keccak();
    Kmac.prototype.finalize = function() {
      this.encode(this.outputBits, true);
      return Keccak.prototype.finalize.call(this);
    };
    var f = function(s) {
      var h, l, n, c0, c1, c2, c3, c4, c5, c6, c7, c8, c9, b0, b1, b2, b3, b4, b5, b6, b7, b8, b9, b10, b11, b12, b13, b14, b15, b16, b17, b18, b19, b20, b21, b22, b23, b24, b25, b26, b27, b28, b29, b30, b31, b32, b33, b34, b35, b36, b37, b38, b39, b40, b41, b42, b43, b44, b45, b46, b47, b48, b49;
      for (n = 0; n < 48; n += 2) {
        c0 = s[0] ^ s[10] ^ s[20] ^ s[30] ^ s[40];
        c1 = s[1] ^ s[11] ^ s[21] ^ s[31] ^ s[41];
        c2 = s[2] ^ s[12] ^ s[22] ^ s[32] ^ s[42];
        c3 = s[3] ^ s[13] ^ s[23] ^ s[33] ^ s[43];
        c4 = s[4] ^ s[14] ^ s[24] ^ s[34] ^ s[44];
        c5 = s[5] ^ s[15] ^ s[25] ^ s[35] ^ s[45];
        c6 = s[6] ^ s[16] ^ s[26] ^ s[36] ^ s[46];
        c7 = s[7] ^ s[17] ^ s[27] ^ s[37] ^ s[47];
        c8 = s[8] ^ s[18] ^ s[28] ^ s[38] ^ s[48];
        c9 = s[9] ^ s[19] ^ s[29] ^ s[39] ^ s[49];
        h = c8 ^ (c2 << 1 | c3 >>> 31);
        l = c9 ^ (c3 << 1 | c2 >>> 31);
        s[0] ^= h;
        s[1] ^= l;
        s[10] ^= h;
        s[11] ^= l;
        s[20] ^= h;
        s[21] ^= l;
        s[30] ^= h;
        s[31] ^= l;
        s[40] ^= h;
        s[41] ^= l;
        h = c0 ^ (c4 << 1 | c5 >>> 31);
        l = c1 ^ (c5 << 1 | c4 >>> 31);
        s[2] ^= h;
        s[3] ^= l;
        s[12] ^= h;
        s[13] ^= l;
        s[22] ^= h;
        s[23] ^= l;
        s[32] ^= h;
        s[33] ^= l;
        s[42] ^= h;
        s[43] ^= l;
        h = c2 ^ (c6 << 1 | c7 >>> 31);
        l = c3 ^ (c7 << 1 | c6 >>> 31);
        s[4] ^= h;
        s[5] ^= l;
        s[14] ^= h;
        s[15] ^= l;
        s[24] ^= h;
        s[25] ^= l;
        s[34] ^= h;
        s[35] ^= l;
        s[44] ^= h;
        s[45] ^= l;
        h = c4 ^ (c8 << 1 | c9 >>> 31);
        l = c5 ^ (c9 << 1 | c8 >>> 31);
        s[6] ^= h;
        s[7] ^= l;
        s[16] ^= h;
        s[17] ^= l;
        s[26] ^= h;
        s[27] ^= l;
        s[36] ^= h;
        s[37] ^= l;
        s[46] ^= h;
        s[47] ^= l;
        h = c6 ^ (c0 << 1 | c1 >>> 31);
        l = c7 ^ (c1 << 1 | c0 >>> 31);
        s[8] ^= h;
        s[9] ^= l;
        s[18] ^= h;
        s[19] ^= l;
        s[28] ^= h;
        s[29] ^= l;
        s[38] ^= h;
        s[39] ^= l;
        s[48] ^= h;
        s[49] ^= l;
        b0 = s[0];
        b1 = s[1];
        b32 = s[11] << 4 | s[10] >>> 28;
        b33 = s[10] << 4 | s[11] >>> 28;
        b14 = s[20] << 3 | s[21] >>> 29;
        b15 = s[21] << 3 | s[20] >>> 29;
        b46 = s[31] << 9 | s[30] >>> 23;
        b47 = s[30] << 9 | s[31] >>> 23;
        b28 = s[40] << 18 | s[41] >>> 14;
        b29 = s[41] << 18 | s[40] >>> 14;
        b20 = s[2] << 1 | s[3] >>> 31;
        b21 = s[3] << 1 | s[2] >>> 31;
        b2 = s[13] << 12 | s[12] >>> 20;
        b3 = s[12] << 12 | s[13] >>> 20;
        b34 = s[22] << 10 | s[23] >>> 22;
        b35 = s[23] << 10 | s[22] >>> 22;
        b16 = s[33] << 13 | s[32] >>> 19;
        b17 = s[32] << 13 | s[33] >>> 19;
        b48 = s[42] << 2 | s[43] >>> 30;
        b49 = s[43] << 2 | s[42] >>> 30;
        b40 = s[5] << 30 | s[4] >>> 2;
        b41 = s[4] << 30 | s[5] >>> 2;
        b22 = s[14] << 6 | s[15] >>> 26;
        b23 = s[15] << 6 | s[14] >>> 26;
        b4 = s[25] << 11 | s[24] >>> 21;
        b5 = s[24] << 11 | s[25] >>> 21;
        b36 = s[34] << 15 | s[35] >>> 17;
        b37 = s[35] << 15 | s[34] >>> 17;
        b18 = s[45] << 29 | s[44] >>> 3;
        b19 = s[44] << 29 | s[45] >>> 3;
        b10 = s[6] << 28 | s[7] >>> 4;
        b11 = s[7] << 28 | s[6] >>> 4;
        b42 = s[17] << 23 | s[16] >>> 9;
        b43 = s[16] << 23 | s[17] >>> 9;
        b24 = s[26] << 25 | s[27] >>> 7;
        b25 = s[27] << 25 | s[26] >>> 7;
        b6 = s[36] << 21 | s[37] >>> 11;
        b7 = s[37] << 21 | s[36] >>> 11;
        b38 = s[47] << 24 | s[46] >>> 8;
        b39 = s[46] << 24 | s[47] >>> 8;
        b30 = s[8] << 27 | s[9] >>> 5;
        b31 = s[9] << 27 | s[8] >>> 5;
        b12 = s[18] << 20 | s[19] >>> 12;
        b13 = s[19] << 20 | s[18] >>> 12;
        b44 = s[29] << 7 | s[28] >>> 25;
        b45 = s[28] << 7 | s[29] >>> 25;
        b26 = s[38] << 8 | s[39] >>> 24;
        b27 = s[39] << 8 | s[38] >>> 24;
        b8 = s[48] << 14 | s[49] >>> 18;
        b9 = s[49] << 14 | s[48] >>> 18;
        s[0] = b0 ^ ~b2 & b4;
        s[1] = b1 ^ ~b3 & b5;
        s[10] = b10 ^ ~b12 & b14;
        s[11] = b11 ^ ~b13 & b15;
        s[20] = b20 ^ ~b22 & b24;
        s[21] = b21 ^ ~b23 & b25;
        s[30] = b30 ^ ~b32 & b34;
        s[31] = b31 ^ ~b33 & b35;
        s[40] = b40 ^ ~b42 & b44;
        s[41] = b41 ^ ~b43 & b45;
        s[2] = b2 ^ ~b4 & b6;
        s[3] = b3 ^ ~b5 & b7;
        s[12] = b12 ^ ~b14 & b16;
        s[13] = b13 ^ ~b15 & b17;
        s[22] = b22 ^ ~b24 & b26;
        s[23] = b23 ^ ~b25 & b27;
        s[32] = b32 ^ ~b34 & b36;
        s[33] = b33 ^ ~b35 & b37;
        s[42] = b42 ^ ~b44 & b46;
        s[43] = b43 ^ ~b45 & b47;
        s[4] = b4 ^ ~b6 & b8;
        s[5] = b5 ^ ~b7 & b9;
        s[14] = b14 ^ ~b16 & b18;
        s[15] = b15 ^ ~b17 & b19;
        s[24] = b24 ^ ~b26 & b28;
        s[25] = b25 ^ ~b27 & b29;
        s[34] = b34 ^ ~b36 & b38;
        s[35] = b35 ^ ~b37 & b39;
        s[44] = b44 ^ ~b46 & b48;
        s[45] = b45 ^ ~b47 & b49;
        s[6] = b6 ^ ~b8 & b0;
        s[7] = b7 ^ ~b9 & b1;
        s[16] = b16 ^ ~b18 & b10;
        s[17] = b17 ^ ~b19 & b11;
        s[26] = b26 ^ ~b28 & b20;
        s[27] = b27 ^ ~b29 & b21;
        s[36] = b36 ^ ~b38 & b30;
        s[37] = b37 ^ ~b39 & b31;
        s[46] = b46 ^ ~b48 & b40;
        s[47] = b47 ^ ~b49 & b41;
        s[8] = b8 ^ ~b0 & b2;
        s[9] = b9 ^ ~b1 & b3;
        s[18] = b18 ^ ~b10 & b12;
        s[19] = b19 ^ ~b11 & b13;
        s[28] = b28 ^ ~b20 & b22;
        s[29] = b29 ^ ~b21 & b23;
        s[38] = b38 ^ ~b30 & b32;
        s[39] = b39 ^ ~b31 & b33;
        s[48] = b48 ^ ~b40 & b42;
        s[49] = b49 ^ ~b41 & b43;
        s[0] ^= RC[n];
        s[1] ^= RC[n + 1];
      }
    };
    if (COMMON_JS) {
      module2.exports = methods;
    } else {
      for (i = 0; i < methodNames.length; ++i) {
        root[methodNames[i]] = methods[methodNames[i]];
      }
      if (AMD) {
        define(function() {
          return methods;
        });
      }
    }
  })();
});

// node_modules/murmurhash3js-revisited/lib/murmurHash3js.js
var require_murmurHash3js = __commonJS((exports2, module2) => {
  (function(root, undefined2) {
    "use strict";
    var library = {
      version: "3.0.0",
      x86: {},
      x64: {},
      inputValidation: true
    };
    function _validBytes(bytes) {
      if (!Array.isArray(bytes) && !ArrayBuffer.isView(bytes)) {
        return false;
      }
      for (var i = 0; i < bytes.length; i++) {
        if (!Number.isInteger(bytes[i]) || bytes[i] < 0 || bytes[i] > 255) {
          return false;
        }
      }
      return true;
    }
    function _x86Multiply(m, n) {
      return (m & 65535) * n + (((m >>> 16) * n & 65535) << 16);
    }
    function _x86Rotl(m, n) {
      return m << n | m >>> 32 - n;
    }
    function _x86Fmix(h) {
      h ^= h >>> 16;
      h = _x86Multiply(h, 2246822507);
      h ^= h >>> 13;
      h = _x86Multiply(h, 3266489909);
      h ^= h >>> 16;
      return h;
    }
    function _x64Add(m, n) {
      m = [m[0] >>> 16, m[0] & 65535, m[1] >>> 16, m[1] & 65535];
      n = [n[0] >>> 16, n[0] & 65535, n[1] >>> 16, n[1] & 65535];
      var o = [0, 0, 0, 0];
      o[3] += m[3] + n[3];
      o[2] += o[3] >>> 16;
      o[3] &= 65535;
      o[2] += m[2] + n[2];
      o[1] += o[2] >>> 16;
      o[2] &= 65535;
      o[1] += m[1] + n[1];
      o[0] += o[1] >>> 16;
      o[1] &= 65535;
      o[0] += m[0] + n[0];
      o[0] &= 65535;
      return [o[0] << 16 | o[1], o[2] << 16 | o[3]];
    }
    function _x64Multiply(m, n) {
      m = [m[0] >>> 16, m[0] & 65535, m[1] >>> 16, m[1] & 65535];
      n = [n[0] >>> 16, n[0] & 65535, n[1] >>> 16, n[1] & 65535];
      var o = [0, 0, 0, 0];
      o[3] += m[3] * n[3];
      o[2] += o[3] >>> 16;
      o[3] &= 65535;
      o[2] += m[2] * n[3];
      o[1] += o[2] >>> 16;
      o[2] &= 65535;
      o[2] += m[3] * n[2];
      o[1] += o[2] >>> 16;
      o[2] &= 65535;
      o[1] += m[1] * n[3];
      o[0] += o[1] >>> 16;
      o[1] &= 65535;
      o[1] += m[2] * n[2];
      o[0] += o[1] >>> 16;
      o[1] &= 65535;
      o[1] += m[3] * n[1];
      o[0] += o[1] >>> 16;
      o[1] &= 65535;
      o[0] += m[0] * n[3] + m[1] * n[2] + m[2] * n[1] + m[3] * n[0];
      o[0] &= 65535;
      return [o[0] << 16 | o[1], o[2] << 16 | o[3]];
    }
    function _x64Rotl(m, n) {
      n %= 64;
      if (n === 32) {
        return [m[1], m[0]];
      } else if (n < 32) {
        return [m[0] << n | m[1] >>> 32 - n, m[1] << n | m[0] >>> 32 - n];
      } else {
        n -= 32;
        return [m[1] << n | m[0] >>> 32 - n, m[0] << n | m[1] >>> 32 - n];
      }
    }
    function _x64LeftShift(m, n) {
      n %= 64;
      if (n === 0) {
        return m;
      } else if (n < 32) {
        return [m[0] << n | m[1] >>> 32 - n, m[1] << n];
      } else {
        return [m[1] << n - 32, 0];
      }
    }
    function _x64Xor(m, n) {
      return [m[0] ^ n[0], m[1] ^ n[1]];
    }
    function _x64Fmix(h) {
      h = _x64Xor(h, [0, h[0] >>> 1]);
      h = _x64Multiply(h, [4283543511, 3981806797]);
      h = _x64Xor(h, [0, h[0] >>> 1]);
      h = _x64Multiply(h, [3301882366, 444984403]);
      h = _x64Xor(h, [0, h[0] >>> 1]);
      return h;
    }
    library.x86.hash32 = function(bytes, seed) {
      if (library.inputValidation && !_validBytes(bytes)) {
        return undefined2;
      }
      seed = seed || 0;
      var remainder = bytes.length % 4;
      var blocks = bytes.length - remainder;
      var h1 = seed;
      var k1 = 0;
      var c1 = 3432918353;
      var c2 = 461845907;
      for (var i = 0; i < blocks; i = i + 4) {
        k1 = bytes[i] | bytes[i + 1] << 8 | bytes[i + 2] << 16 | bytes[i + 3] << 24;
        k1 = _x86Multiply(k1, c1);
        k1 = _x86Rotl(k1, 15);
        k1 = _x86Multiply(k1, c2);
        h1 ^= k1;
        h1 = _x86Rotl(h1, 13);
        h1 = _x86Multiply(h1, 5) + 3864292196;
      }
      k1 = 0;
      switch (remainder) {
        case 3:
          k1 ^= bytes[i + 2] << 16;
        case 2:
          k1 ^= bytes[i + 1] << 8;
        case 1:
          k1 ^= bytes[i];
          k1 = _x86Multiply(k1, c1);
          k1 = _x86Rotl(k1, 15);
          k1 = _x86Multiply(k1, c2);
          h1 ^= k1;
      }
      h1 ^= bytes.length;
      h1 = _x86Fmix(h1);
      return h1 >>> 0;
    };
    library.x86.hash128 = function(bytes, seed) {
      if (library.inputValidation && !_validBytes(bytes)) {
        return undefined2;
      }
      seed = seed || 0;
      var remainder = bytes.length % 16;
      var blocks = bytes.length - remainder;
      var h1 = seed;
      var h2 = seed;
      var h3 = seed;
      var h4 = seed;
      var k1 = 0;
      var k2 = 0;
      var k3 = 0;
      var k4 = 0;
      var c1 = 597399067;
      var c2 = 2869860233;
      var c3 = 951274213;
      var c4 = 2716044179;
      for (var i = 0; i < blocks; i = i + 16) {
        k1 = bytes[i] | bytes[i + 1] << 8 | bytes[i + 2] << 16 | bytes[i + 3] << 24;
        k2 = bytes[i + 4] | bytes[i + 5] << 8 | bytes[i + 6] << 16 | bytes[i + 7] << 24;
        k3 = bytes[i + 8] | bytes[i + 9] << 8 | bytes[i + 10] << 16 | bytes[i + 11] << 24;
        k4 = bytes[i + 12] | bytes[i + 13] << 8 | bytes[i + 14] << 16 | bytes[i + 15] << 24;
        k1 = _x86Multiply(k1, c1);
        k1 = _x86Rotl(k1, 15);
        k1 = _x86Multiply(k1, c2);
        h1 ^= k1;
        h1 = _x86Rotl(h1, 19);
        h1 += h2;
        h1 = _x86Multiply(h1, 5) + 1444728091;
        k2 = _x86Multiply(k2, c2);
        k2 = _x86Rotl(k2, 16);
        k2 = _x86Multiply(k2, c3);
        h2 ^= k2;
        h2 = _x86Rotl(h2, 17);
        h2 += h3;
        h2 = _x86Multiply(h2, 5) + 197830471;
        k3 = _x86Multiply(k3, c3);
        k3 = _x86Rotl(k3, 17);
        k3 = _x86Multiply(k3, c4);
        h3 ^= k3;
        h3 = _x86Rotl(h3, 15);
        h3 += h4;
        h3 = _x86Multiply(h3, 5) + 2530024501;
        k4 = _x86Multiply(k4, c4);
        k4 = _x86Rotl(k4, 18);
        k4 = _x86Multiply(k4, c1);
        h4 ^= k4;
        h4 = _x86Rotl(h4, 13);
        h4 += h1;
        h4 = _x86Multiply(h4, 5) + 850148119;
      }
      k1 = 0;
      k2 = 0;
      k3 = 0;
      k4 = 0;
      switch (remainder) {
        case 15:
          k4 ^= bytes[i + 14] << 16;
        case 14:
          k4 ^= bytes[i + 13] << 8;
        case 13:
          k4 ^= bytes[i + 12];
          k4 = _x86Multiply(k4, c4);
          k4 = _x86Rotl(k4, 18);
          k4 = _x86Multiply(k4, c1);
          h4 ^= k4;
        case 12:
          k3 ^= bytes[i + 11] << 24;
        case 11:
          k3 ^= bytes[i + 10] << 16;
        case 10:
          k3 ^= bytes[i + 9] << 8;
        case 9:
          k3 ^= bytes[i + 8];
          k3 = _x86Multiply(k3, c3);
          k3 = _x86Rotl(k3, 17);
          k3 = _x86Multiply(k3, c4);
          h3 ^= k3;
        case 8:
          k2 ^= bytes[i + 7] << 24;
        case 7:
          k2 ^= bytes[i + 6] << 16;
        case 6:
          k2 ^= bytes[i + 5] << 8;
        case 5:
          k2 ^= bytes[i + 4];
          k2 = _x86Multiply(k2, c2);
          k2 = _x86Rotl(k2, 16);
          k2 = _x86Multiply(k2, c3);
          h2 ^= k2;
        case 4:
          k1 ^= bytes[i + 3] << 24;
        case 3:
          k1 ^= bytes[i + 2] << 16;
        case 2:
          k1 ^= bytes[i + 1] << 8;
        case 1:
          k1 ^= bytes[i];
          k1 = _x86Multiply(k1, c1);
          k1 = _x86Rotl(k1, 15);
          k1 = _x86Multiply(k1, c2);
          h1 ^= k1;
      }
      h1 ^= bytes.length;
      h2 ^= bytes.length;
      h3 ^= bytes.length;
      h4 ^= bytes.length;
      h1 += h2;
      h1 += h3;
      h1 += h4;
      h2 += h1;
      h3 += h1;
      h4 += h1;
      h1 = _x86Fmix(h1);
      h2 = _x86Fmix(h2);
      h3 = _x86Fmix(h3);
      h4 = _x86Fmix(h4);
      h1 += h2;
      h1 += h3;
      h1 += h4;
      h2 += h1;
      h3 += h1;
      h4 += h1;
      return ("00000000" + (h1 >>> 0).toString(16)).slice(-8) + ("00000000" + (h2 >>> 0).toString(16)).slice(-8) + ("00000000" + (h3 >>> 0).toString(16)).slice(-8) + ("00000000" + (h4 >>> 0).toString(16)).slice(-8);
    };
    library.x64.hash128 = function(bytes, seed) {
      if (library.inputValidation && !_validBytes(bytes)) {
        return undefined2;
      }
      seed = seed || 0;
      var remainder = bytes.length % 16;
      var blocks = bytes.length - remainder;
      var h1 = [0, seed];
      var h2 = [0, seed];
      var k1 = [0, 0];
      var k2 = [0, 0];
      var c1 = [2277735313, 289559509];
      var c2 = [1291169091, 658871167];
      for (var i = 0; i < blocks; i = i + 16) {
        k1 = [bytes[i + 4] | bytes[i + 5] << 8 | bytes[i + 6] << 16 | bytes[i + 7] << 24, bytes[i] | bytes[i + 1] << 8 | bytes[i + 2] << 16 | bytes[i + 3] << 24];
        k2 = [bytes[i + 12] | bytes[i + 13] << 8 | bytes[i + 14] << 16 | bytes[i + 15] << 24, bytes[i + 8] | bytes[i + 9] << 8 | bytes[i + 10] << 16 | bytes[i + 11] << 24];
        k1 = _x64Multiply(k1, c1);
        k1 = _x64Rotl(k1, 31);
        k1 = _x64Multiply(k1, c2);
        h1 = _x64Xor(h1, k1);
        h1 = _x64Rotl(h1, 27);
        h1 = _x64Add(h1, h2);
        h1 = _x64Add(_x64Multiply(h1, [0, 5]), [0, 1390208809]);
        k2 = _x64Multiply(k2, c2);
        k2 = _x64Rotl(k2, 33);
        k2 = _x64Multiply(k2, c1);
        h2 = _x64Xor(h2, k2);
        h2 = _x64Rotl(h2, 31);
        h2 = _x64Add(h2, h1);
        h2 = _x64Add(_x64Multiply(h2, [0, 5]), [0, 944331445]);
      }
      k1 = [0, 0];
      k2 = [0, 0];
      switch (remainder) {
        case 15:
          k2 = _x64Xor(k2, _x64LeftShift([0, bytes[i + 14]], 48));
        case 14:
          k2 = _x64Xor(k2, _x64LeftShift([0, bytes[i + 13]], 40));
        case 13:
          k2 = _x64Xor(k2, _x64LeftShift([0, bytes[i + 12]], 32));
        case 12:
          k2 = _x64Xor(k2, _x64LeftShift([0, bytes[i + 11]], 24));
        case 11:
          k2 = _x64Xor(k2, _x64LeftShift([0, bytes[i + 10]], 16));
        case 10:
          k2 = _x64Xor(k2, _x64LeftShift([0, bytes[i + 9]], 8));
        case 9:
          k2 = _x64Xor(k2, [0, bytes[i + 8]]);
          k2 = _x64Multiply(k2, c2);
          k2 = _x64Rotl(k2, 33);
          k2 = _x64Multiply(k2, c1);
          h2 = _x64Xor(h2, k2);
        case 8:
          k1 = _x64Xor(k1, _x64LeftShift([0, bytes[i + 7]], 56));
        case 7:
          k1 = _x64Xor(k1, _x64LeftShift([0, bytes[i + 6]], 48));
        case 6:
          k1 = _x64Xor(k1, _x64LeftShift([0, bytes[i + 5]], 40));
        case 5:
          k1 = _x64Xor(k1, _x64LeftShift([0, bytes[i + 4]], 32));
        case 4:
          k1 = _x64Xor(k1, _x64LeftShift([0, bytes[i + 3]], 24));
        case 3:
          k1 = _x64Xor(k1, _x64LeftShift([0, bytes[i + 2]], 16));
        case 2:
          k1 = _x64Xor(k1, _x64LeftShift([0, bytes[i + 1]], 8));
        case 1:
          k1 = _x64Xor(k1, [0, bytes[i]]);
          k1 = _x64Multiply(k1, c1);
          k1 = _x64Rotl(k1, 31);
          k1 = _x64Multiply(k1, c2);
          h1 = _x64Xor(h1, k1);
      }
      h1 = _x64Xor(h1, [0, bytes.length]);
      h2 = _x64Xor(h2, [0, bytes.length]);
      h1 = _x64Add(h1, h2);
      h2 = _x64Add(h2, h1);
      h1 = _x64Fmix(h1);
      h2 = _x64Fmix(h2);
      h1 = _x64Add(h1, h2);
      h2 = _x64Add(h2, h1);
      return ("00000000" + (h1[0] >>> 0).toString(16)).slice(-8) + ("00000000" + (h1[1] >>> 0).toString(16)).slice(-8) + ("00000000" + (h2[0] >>> 0).toString(16)).slice(-8) + ("00000000" + (h2[1] >>> 0).toString(16)).slice(-8);
    };
    if (typeof exports2 !== "undefined") {
      if (typeof module2 !== "undefined" && module2.exports) {
        exports2 = module2.exports = library;
      }
      exports2.murmurHash3 = library;
    } else if (typeof define === "function" && define.amd) {
      define([], function() {
        return library;
      });
    } else {
      library._murmurHash3 = root.murmurHash3;
      library.noConflict = function() {
        root.murmurHash3 = library._murmurHash3;
        library._murmurHash3 = undefined2;
        library.noConflict = undefined2;
        return library;
      };
      root.murmurHash3 = library;
    }
  })(exports2);
});

// node_modules/murmurhash3js-revisited/index.js
var require_murmurhash3js_revisited = __commonJS((exports2, module2) => {
  module2.exports = require_murmurHash3js();
});

// node_modules/multihashing-async/src/utils.js
var require_utils5 = __commonJS((exports2, module2) => {
  "use strict";
  var fromNumberTo32BitBuf = (number) => {
    const bytes = new Uint8Array(4);
    for (let i = 0; i < 4; i++) {
      bytes[i] = number & 255;
      number = number >> 8;
    }
    return bytes;
  };
  module2.exports = {
    fromNumberTo32BitBuf
  };
});

// node_modules/blakejs/util.js
var require_util5 = __commonJS((exports2, module2) => {
  var ERROR_MSG_INPUT = "Input must be an string, Buffer or Uint8Array";
  function normalizeInput(input) {
    var ret;
    if (input instanceof Uint8Array) {
      ret = input;
    } else if (input instanceof Buffer) {
      ret = new Uint8Array(input);
    } else if (typeof input === "string") {
      ret = new Uint8Array(Buffer.from(input, "utf8"));
    } else {
      throw new Error(ERROR_MSG_INPUT);
    }
    return ret;
  }
  function toHex(bytes) {
    return Array.prototype.map.call(bytes, function(n) {
      return (n < 16 ? "0" : "") + n.toString(16);
    }).join("");
  }
  function uint32ToHex(val) {
    return (4294967296 + val).toString(16).substring(1);
  }
  function debugPrint(label, arr, size) {
    var msg = "\n" + label + " = ";
    for (var i = 0; i < arr.length; i += 2) {
      if (size === 32) {
        msg += uint32ToHex(arr[i]).toUpperCase();
        msg += " ";
        msg += uint32ToHex(arr[i + 1]).toUpperCase();
      } else if (size === 64) {
        msg += uint32ToHex(arr[i + 1]).toUpperCase();
        msg += uint32ToHex(arr[i]).toUpperCase();
      } else
        throw new Error("Invalid size " + size);
      if (i % 6 === 4) {
        msg += "\n" + new Array(label.length + 4).join(" ");
      } else if (i < arr.length - 2) {
        msg += " ";
      }
    }
    console.log(msg);
  }
  function testSpeed(hashFn, N, M) {
    var startMs = new Date().getTime();
    var input = new Uint8Array(N);
    for (var i = 0; i < N; i++) {
      input[i] = i % 256;
    }
    var genMs = new Date().getTime();
    console.log("Generated random input in " + (genMs - startMs) + "ms");
    startMs = genMs;
    for (i = 0; i < M; i++) {
      var hashHex = hashFn(input);
      var hashMs = new Date().getTime();
      var ms = hashMs - startMs;
      startMs = hashMs;
      console.log("Hashed in " + ms + "ms: " + hashHex.substring(0, 20) + "...");
      console.log(Math.round(N / (1 << 20) / (ms / 1e3) * 100) / 100 + " MB PER SECOND");
    }
  }
  module2.exports = {
    normalizeInput,
    toHex,
    debugPrint,
    testSpeed
  };
});

// node_modules/blakejs/blake2b.js
var require_blake2b = __commonJS((exports2, module2) => {
  var util = require_util5();
  function ADD64AA(v2, a, b) {
    var o0 = v2[a] + v2[b];
    var o1 = v2[a + 1] + v2[b + 1];
    if (o0 >= 4294967296) {
      o1++;
    }
    v2[a] = o0;
    v2[a + 1] = o1;
  }
  function ADD64AC(v2, a, b0, b1) {
    var o0 = v2[a] + b0;
    if (b0 < 0) {
      o0 += 4294967296;
    }
    var o1 = v2[a + 1] + b1;
    if (o0 >= 4294967296) {
      o1++;
    }
    v2[a] = o0;
    v2[a + 1] = o1;
  }
  function B2B_GET32(arr, i) {
    return arr[i] ^ arr[i + 1] << 8 ^ arr[i + 2] << 16 ^ arr[i + 3] << 24;
  }
  function B2B_G(a, b, c, d, ix, iy) {
    var x0 = m[ix];
    var x1 = m[ix + 1];
    var y0 = m[iy];
    var y1 = m[iy + 1];
    ADD64AA(v, a, b);
    ADD64AC(v, a, x0, x1);
    var xor0 = v[d] ^ v[a];
    var xor1 = v[d + 1] ^ v[a + 1];
    v[d] = xor1;
    v[d + 1] = xor0;
    ADD64AA(v, c, d);
    xor0 = v[b] ^ v[c];
    xor1 = v[b + 1] ^ v[c + 1];
    v[b] = xor0 >>> 24 ^ xor1 << 8;
    v[b + 1] = xor1 >>> 24 ^ xor0 << 8;
    ADD64AA(v, a, b);
    ADD64AC(v, a, y0, y1);
    xor0 = v[d] ^ v[a];
    xor1 = v[d + 1] ^ v[a + 1];
    v[d] = xor0 >>> 16 ^ xor1 << 16;
    v[d + 1] = xor1 >>> 16 ^ xor0 << 16;
    ADD64AA(v, c, d);
    xor0 = v[b] ^ v[c];
    xor1 = v[b + 1] ^ v[c + 1];
    v[b] = xor1 >>> 31 ^ xor0 << 1;
    v[b + 1] = xor0 >>> 31 ^ xor1 << 1;
  }
  var BLAKE2B_IV32 = new Uint32Array([
    4089235720,
    1779033703,
    2227873595,
    3144134277,
    4271175723,
    1013904242,
    1595750129,
    2773480762,
    2917565137,
    1359893119,
    725511199,
    2600822924,
    4215389547,
    528734635,
    327033209,
    1541459225
  ]);
  var SIGMA8 = [
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    12,
    13,
    14,
    15,
    14,
    10,
    4,
    8,
    9,
    15,
    13,
    6,
    1,
    12,
    0,
    2,
    11,
    7,
    5,
    3,
    11,
    8,
    12,
    0,
    5,
    2,
    15,
    13,
    10,
    14,
    3,
    6,
    7,
    1,
    9,
    4,
    7,
    9,
    3,
    1,
    13,
    12,
    11,
    14,
    2,
    6,
    5,
    10,
    4,
    0,
    15,
    8,
    9,
    0,
    5,
    7,
    2,
    4,
    10,
    15,
    14,
    1,
    11,
    12,
    6,
    8,
    3,
    13,
    2,
    12,
    6,
    10,
    0,
    11,
    8,
    3,
    4,
    13,
    7,
    5,
    15,
    14,
    1,
    9,
    12,
    5,
    1,
    15,
    14,
    13,
    4,
    10,
    0,
    7,
    6,
    3,
    9,
    2,
    8,
    11,
    13,
    11,
    7,
    14,
    12,
    1,
    3,
    9,
    5,
    0,
    15,
    4,
    8,
    6,
    2,
    10,
    6,
    15,
    14,
    9,
    11,
    3,
    0,
    8,
    12,
    2,
    13,
    7,
    1,
    4,
    10,
    5,
    10,
    2,
    8,
    4,
    7,
    6,
    1,
    5,
    15,
    11,
    9,
    14,
    3,
    12,
    13,
    0,
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    12,
    13,
    14,
    15,
    14,
    10,
    4,
    8,
    9,
    15,
    13,
    6,
    1,
    12,
    0,
    2,
    11,
    7,
    5,
    3
  ];
  var SIGMA82 = new Uint8Array(SIGMA8.map(function(x) {
    return x * 2;
  }));
  var v = new Uint32Array(32);
  var m = new Uint32Array(32);
  function blake2bCompress(ctx, last) {
    var i = 0;
    for (i = 0; i < 16; i++) {
      v[i] = ctx.h[i];
      v[i + 16] = BLAKE2B_IV32[i];
    }
    v[24] = v[24] ^ ctx.t;
    v[25] = v[25] ^ ctx.t / 4294967296;
    if (last) {
      v[28] = ~v[28];
      v[29] = ~v[29];
    }
    for (i = 0; i < 32; i++) {
      m[i] = B2B_GET32(ctx.b, 4 * i);
    }
    for (i = 0; i < 12; i++) {
      B2B_G(0, 8, 16, 24, SIGMA82[i * 16 + 0], SIGMA82[i * 16 + 1]);
      B2B_G(2, 10, 18, 26, SIGMA82[i * 16 + 2], SIGMA82[i * 16 + 3]);
      B2B_G(4, 12, 20, 28, SIGMA82[i * 16 + 4], SIGMA82[i * 16 + 5]);
      B2B_G(6, 14, 22, 30, SIGMA82[i * 16 + 6], SIGMA82[i * 16 + 7]);
      B2B_G(0, 10, 20, 30, SIGMA82[i * 16 + 8], SIGMA82[i * 16 + 9]);
      B2B_G(2, 12, 22, 24, SIGMA82[i * 16 + 10], SIGMA82[i * 16 + 11]);
      B2B_G(4, 14, 16, 26, SIGMA82[i * 16 + 12], SIGMA82[i * 16 + 13]);
      B2B_G(6, 8, 18, 28, SIGMA82[i * 16 + 14], SIGMA82[i * 16 + 15]);
    }
    for (i = 0; i < 16; i++) {
      ctx.h[i] = ctx.h[i] ^ v[i] ^ v[i + 16];
    }
  }
  function blake2bInit(outlen, key) {
    if (outlen === 0 || outlen > 64) {
      throw new Error("Illegal output length, expected 0 < length <= 64");
    }
    if (key && key.length > 64) {
      throw new Error("Illegal key, expected Uint8Array with 0 < length <= 64");
    }
    var ctx = {
      b: new Uint8Array(128),
      h: new Uint32Array(16),
      t: 0,
      c: 0,
      outlen
    };
    for (var i = 0; i < 16; i++) {
      ctx.h[i] = BLAKE2B_IV32[i];
    }
    var keylen = key ? key.length : 0;
    ctx.h[0] ^= 16842752 ^ keylen << 8 ^ outlen;
    if (key) {
      blake2bUpdate(ctx, key);
      ctx.c = 128;
    }
    return ctx;
  }
  function blake2bUpdate(ctx, input) {
    for (var i = 0; i < input.length; i++) {
      if (ctx.c === 128) {
        ctx.t += ctx.c;
        blake2bCompress(ctx, false);
        ctx.c = 0;
      }
      ctx.b[ctx.c++] = input[i];
    }
  }
  function blake2bFinal(ctx) {
    ctx.t += ctx.c;
    while (ctx.c < 128) {
      ctx.b[ctx.c++] = 0;
    }
    blake2bCompress(ctx, true);
    var out = new Uint8Array(ctx.outlen);
    for (var i = 0; i < ctx.outlen; i++) {
      out[i] = ctx.h[i >> 2] >> 8 * (i & 3);
    }
    return out;
  }
  function blake2b(input, key, outlen) {
    outlen = outlen || 64;
    input = util.normalizeInput(input);
    var ctx = blake2bInit(outlen, key);
    blake2bUpdate(ctx, input);
    return blake2bFinal(ctx);
  }
  function blake2bHex(input, key, outlen) {
    var output = blake2b(input, key, outlen);
    return util.toHex(output);
  }
  module2.exports = {
    blake2b,
    blake2bHex,
    blake2bInit,
    blake2bUpdate,
    blake2bFinal
  };
});

// node_modules/blakejs/blake2s.js
var require_blake2s = __commonJS((exports2, module2) => {
  var util = require_util5();
  function B2S_GET32(v2, i) {
    return v2[i] ^ v2[i + 1] << 8 ^ v2[i + 2] << 16 ^ v2[i + 3] << 24;
  }
  function B2S_G(a, b, c, d, x, y) {
    v[a] = v[a] + v[b] + x;
    v[d] = ROTR32(v[d] ^ v[a], 16);
    v[c] = v[c] + v[d];
    v[b] = ROTR32(v[b] ^ v[c], 12);
    v[a] = v[a] + v[b] + y;
    v[d] = ROTR32(v[d] ^ v[a], 8);
    v[c] = v[c] + v[d];
    v[b] = ROTR32(v[b] ^ v[c], 7);
  }
  function ROTR32(x, y) {
    return x >>> y ^ x << 32 - y;
  }
  var BLAKE2S_IV = new Uint32Array([
    1779033703,
    3144134277,
    1013904242,
    2773480762,
    1359893119,
    2600822924,
    528734635,
    1541459225
  ]);
  var SIGMA = new Uint8Array([
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    12,
    13,
    14,
    15,
    14,
    10,
    4,
    8,
    9,
    15,
    13,
    6,
    1,
    12,
    0,
    2,
    11,
    7,
    5,
    3,
    11,
    8,
    12,
    0,
    5,
    2,
    15,
    13,
    10,
    14,
    3,
    6,
    7,
    1,
    9,
    4,
    7,
    9,
    3,
    1,
    13,
    12,
    11,
    14,
    2,
    6,
    5,
    10,
    4,
    0,
    15,
    8,
    9,
    0,
    5,
    7,
    2,
    4,
    10,
    15,
    14,
    1,
    11,
    12,
    6,
    8,
    3,
    13,
    2,
    12,
    6,
    10,
    0,
    11,
    8,
    3,
    4,
    13,
    7,
    5,
    15,
    14,
    1,
    9,
    12,
    5,
    1,
    15,
    14,
    13,
    4,
    10,
    0,
    7,
    6,
    3,
    9,
    2,
    8,
    11,
    13,
    11,
    7,
    14,
    12,
    1,
    3,
    9,
    5,
    0,
    15,
    4,
    8,
    6,
    2,
    10,
    6,
    15,
    14,
    9,
    11,
    3,
    0,
    8,
    12,
    2,
    13,
    7,
    1,
    4,
    10,
    5,
    10,
    2,
    8,
    4,
    7,
    6,
    1,
    5,
    15,
    11,
    9,
    14,
    3,
    12,
    13,
    0
  ]);
  var v = new Uint32Array(16);
  var m = new Uint32Array(16);
  function blake2sCompress(ctx, last) {
    var i = 0;
    for (i = 0; i < 8; i++) {
      v[i] = ctx.h[i];
      v[i + 8] = BLAKE2S_IV[i];
    }
    v[12] ^= ctx.t;
    v[13] ^= ctx.t / 4294967296;
    if (last) {
      v[14] = ~v[14];
    }
    for (i = 0; i < 16; i++) {
      m[i] = B2S_GET32(ctx.b, 4 * i);
    }
    for (i = 0; i < 10; i++) {
      B2S_G(0, 4, 8, 12, m[SIGMA[i * 16 + 0]], m[SIGMA[i * 16 + 1]]);
      B2S_G(1, 5, 9, 13, m[SIGMA[i * 16 + 2]], m[SIGMA[i * 16 + 3]]);
      B2S_G(2, 6, 10, 14, m[SIGMA[i * 16 + 4]], m[SIGMA[i * 16 + 5]]);
      B2S_G(3, 7, 11, 15, m[SIGMA[i * 16 + 6]], m[SIGMA[i * 16 + 7]]);
      B2S_G(0, 5, 10, 15, m[SIGMA[i * 16 + 8]], m[SIGMA[i * 16 + 9]]);
      B2S_G(1, 6, 11, 12, m[SIGMA[i * 16 + 10]], m[SIGMA[i * 16 + 11]]);
      B2S_G(2, 7, 8, 13, m[SIGMA[i * 16 + 12]], m[SIGMA[i * 16 + 13]]);
      B2S_G(3, 4, 9, 14, m[SIGMA[i * 16 + 14]], m[SIGMA[i * 16 + 15]]);
    }
    for (i = 0; i < 8; i++) {
      ctx.h[i] ^= v[i] ^ v[i + 8];
    }
  }
  function blake2sInit(outlen, key) {
    if (!(outlen > 0 && outlen <= 32)) {
      throw new Error("Incorrect output length, should be in [1, 32]");
    }
    var keylen = key ? key.length : 0;
    if (key && !(keylen > 0 && keylen <= 32)) {
      throw new Error("Incorrect key length, should be in [1, 32]");
    }
    var ctx = {
      h: new Uint32Array(BLAKE2S_IV),
      b: new Uint32Array(64),
      c: 0,
      t: 0,
      outlen
    };
    ctx.h[0] ^= 16842752 ^ keylen << 8 ^ outlen;
    if (keylen > 0) {
      blake2sUpdate(ctx, key);
      ctx.c = 64;
    }
    return ctx;
  }
  function blake2sUpdate(ctx, input) {
    for (var i = 0; i < input.length; i++) {
      if (ctx.c === 64) {
        ctx.t += ctx.c;
        blake2sCompress(ctx, false);
        ctx.c = 0;
      }
      ctx.b[ctx.c++] = input[i];
    }
  }
  function blake2sFinal(ctx) {
    ctx.t += ctx.c;
    while (ctx.c < 64) {
      ctx.b[ctx.c++] = 0;
    }
    blake2sCompress(ctx, true);
    var out = new Uint8Array(ctx.outlen);
    for (var i = 0; i < ctx.outlen; i++) {
      out[i] = ctx.h[i >> 2] >> 8 * (i & 3) & 255;
    }
    return out;
  }
  function blake2s(input, key, outlen) {
    outlen = outlen || 32;
    input = util.normalizeInput(input);
    var ctx = blake2sInit(outlen, key);
    blake2sUpdate(ctx, input);
    return blake2sFinal(ctx);
  }
  function blake2sHex(input, key, outlen) {
    var output = blake2s(input, key, outlen);
    return util.toHex(output);
  }
  module2.exports = {
    blake2s,
    blake2sHex,
    blake2sInit,
    blake2sUpdate,
    blake2sFinal
  };
});

// node_modules/blakejs/index.js
var require_blakejs = __commonJS((exports2, module2) => {
  var b2b = require_blake2b();
  var b2s = require_blake2s();
  module2.exports = {
    blake2b: b2b.blake2b,
    blake2bHex: b2b.blake2bHex,
    blake2bInit: b2b.blake2bInit,
    blake2bUpdate: b2b.blake2bUpdate,
    blake2bFinal: b2b.blake2bFinal,
    blake2s: b2s.blake2s,
    blake2sHex: b2s.blake2sHex,
    blake2sInit: b2s.blake2sInit,
    blake2sUpdate: b2s.blake2sUpdate,
    blake2sFinal: b2s.blake2sFinal
  };
});

// node_modules/multihashing-async/src/blake.js
var require_blake = __commonJS((exports2, module2) => {
  "use strict";
  var blake = require_blakejs();
  var minB = 45569;
  var minS = 45633;
  var blake2b = {
    init: blake.blake2bInit,
    update: blake.blake2bUpdate,
    digest: blake.blake2bFinal
  };
  var blake2s = {
    init: blake.blake2sInit,
    update: blake.blake2sUpdate,
    digest: blake.blake2sFinal
  };
  var makeB2Hash = (size, hf) => async (data) => {
    const ctx = hf.init(size, null);
    hf.update(ctx, data);
    return hf.digest(ctx);
  };
  module2.exports = (table) => {
    for (let i = 0; i < 64; i++) {
      table[minB + i] = makeB2Hash(i + 1, blake2b);
    }
    for (let i = 0; i < 32; i++) {
      table[minS + i] = makeB2Hash(i + 1, blake2s);
    }
  };
});

// node_modules/multihashing-async/src/crypto.js
var require_crypto2 = __commonJS((exports2, module2) => {
  "use strict";
  var sha3 = require_sha3();
  var mur = require_murmurhash3js_revisited();
  var {factory: sha} = require_sha_browser();
  var {fromNumberTo32BitBuf} = require_utils5();
  var uint8ArrayFromString = require_from_string2();
  var hash = (algorithm) => async (data) => {
    switch (algorithm) {
      case "sha3-224":
        return new Uint8Array(sha3.sha3_224.arrayBuffer(data));
      case "sha3-256":
        return new Uint8Array(sha3.sha3_256.arrayBuffer(data));
      case "sha3-384":
        return new Uint8Array(sha3.sha3_384.arrayBuffer(data));
      case "sha3-512":
        return new Uint8Array(sha3.sha3_512.arrayBuffer(data));
      case "shake-128":
        return new Uint8Array(sha3.shake128.create(128).update(data).arrayBuffer());
      case "shake-256":
        return new Uint8Array(sha3.shake256.create(256).update(data).arrayBuffer());
      case "keccak-224":
        return new Uint8Array(sha3.keccak224.arrayBuffer(data));
      case "keccak-256":
        return new Uint8Array(sha3.keccak256.arrayBuffer(data));
      case "keccak-384":
        return new Uint8Array(sha3.keccak384.arrayBuffer(data));
      case "keccak-512":
        return new Uint8Array(sha3.keccak512.arrayBuffer(data));
      case "murmur3-128":
        return uint8ArrayFromString(mur.x64.hash128(data), "base16");
      case "murmur3-32":
        return fromNumberTo32BitBuf(mur.x86.hash32(data));
      default:
        throw new TypeError(`${algorithm} is not a supported algorithm`);
    }
  };
  var identity = (data) => data;
  module2.exports = {
    identity,
    sha1: sha("sha1"),
    sha2256: sha("sha2-256"),
    sha2512: sha("sha2-512"),
    dblSha2256: sha("dbl-sha2-256"),
    sha3224: hash("sha3-224"),
    sha3256: hash("sha3-256"),
    sha3384: hash("sha3-384"),
    sha3512: hash("sha3-512"),
    shake128: hash("shake-128"),
    shake256: hash("shake-256"),
    keccak224: hash("keccak-224"),
    keccak256: hash("keccak-256"),
    keccak384: hash("keccak-384"),
    keccak512: hash("keccak-512"),
    murmur3128: hash("murmur3-128"),
    murmur332: hash("murmur3-32"),
    addBlake: require_blake()
  };
});

// node_modules/multihashing-async/src/index.js
var require_src14 = __commonJS((exports2, module2) => {
  "use strict";
  var errcode = require_err_code();
  var multihash = require_src5();
  var crypto2 = require_crypto2();
  var equals = require_equals2();
  async function Multihashing(buf, alg, length) {
    const digest = await Multihashing.digest(buf, alg, length);
    return multihash.encode(digest, alg, length);
  }
  Multihashing.multihash = multihash;
  Multihashing.digest = async (buf, alg, length) => {
    const hash = Multihashing.createHash(alg);
    const digest = await hash(buf);
    return length ? digest.slice(0, length) : digest;
  };
  Multihashing.createHash = function(alg) {
    if (!alg) {
      throw errcode(new Error("hash algorithm must be specified"), "ERR_HASH_ALGORITHM_NOT_SPECIFIED");
    }
    alg = multihash.coerceCode(alg);
    if (!Multihashing.functions[alg]) {
      throw errcode(new Error(`multihash function '${alg}' not yet supported`), "ERR_HASH_ALGORITHM_NOT_SUPPORTED");
    }
    return Multihashing.functions[alg];
  };
  Multihashing.functions = {
    0: crypto2.identity,
    17: crypto2.sha1,
    18: crypto2.sha2256,
    19: crypto2.sha2512,
    20: crypto2.sha3512,
    21: crypto2.sha3384,
    22: crypto2.sha3256,
    23: crypto2.sha3224,
    24: crypto2.shake128,
    25: crypto2.shake256,
    26: crypto2.keccak224,
    27: crypto2.keccak256,
    28: crypto2.keccak384,
    29: crypto2.keccak512,
    34: crypto2.murmur3128,
    35: crypto2.murmur332,
    86: crypto2.dblSha2256
  };
  crypto2.addBlake(Multihashing.functions);
  Multihashing.validate = async (buf, hash) => {
    const newHash = await Multihashing(buf, multihash.decode(hash).name);
    return equals(hash, newHash);
  };
  module2.exports = Multihashing;
});

// node_modules/nanoid/index.browser.js
var require_index_browser2 = __commonJS((exports2) => {
  __export(exports2, {
    customAlphabet: () => customAlphabet,
    customRandom: () => customRandom,
    nanoid: () => nanoid,
    random: () => random,
    urlAlphabet: () => urlAlphabet
  });
  if (process.env.NODE_ENV !== "production") {
    if (typeof navigator !== "undefined" && navigator.product === "ReactNative" && typeof crypto === "undefined") {
      throw new Error("React Native does not have a built-in secure random generator. If you don\u2019t need unpredictable IDs use `nanoid/non-secure`. For secure IDs, import `react-native-get-random-values` before Nano ID. If you use Expo, install `expo-random` and use `nanoid/async`.");
    }
    if (typeof msCrypto !== "undefined" && typeof crypto === "undefined") {
      throw new Error("Import file with `if (!window.crypto) window.crypto = window.msCrypto` before importing Nano ID to fix IE 11 support");
    }
    if (typeof crypto === "undefined") {
      throw new Error("Your browser does not have secure random generator. If you don\u2019t need unpredictable IDs, you can use nanoid/non-secure.");
    }
  }
  var random = (bytes) => crypto.getRandomValues(new Uint8Array(bytes));
  var customRandom = (alphabet, size, getRandom) => {
    let mask = (2 << Math.log(alphabet.length - 1) / Math.LN2) - 1;
    let step = -~(1.6 * mask * size / alphabet.length);
    return () => {
      let id = "";
      while (true) {
        let bytes = getRandom(step);
        let j = step;
        while (j--) {
          id += alphabet[bytes[j] & mask] || "";
          if (id.length === size)
            return id;
        }
      }
    };
  };
  var customAlphabet = (alphabet, size) => customRandom(alphabet, size, random);
  var nanoid = (size = 21) => {
    let id = "";
    let bytes = crypto.getRandomValues(new Uint8Array(size));
    while (size--) {
      let byte = bytes[size] & 63;
      if (byte < 36) {
        id += byte.toString(36);
      } else if (byte < 62) {
        id += (byte - 26).toString(36).toUpperCase();
      } else if (byte < 63) {
        id += "_";
      } else {
        id += "-";
      }
    }
    return id;
  };
});

// node_modules/ipfs-utils/src/temp-dir.browser.js
var require_temp_dir_browser = __commonJS((exports2, module2) => {
  "use strict";
  var {nanoid} = require_index_browser2();
  var tempdir = (transform = (d) => d) => {
    return transform(nanoid());
  };
  module2.exports = tempdir;
});

// node_modules/ipfs-utils/src/text-encoder.js
var require_text_encoder = __commonJS((exports2, module2) => {
  "use strict";
  var {TextEncoder: TextEncoder2} = require_lib_browser();
  module2.exports = TextEncoder2;
});

// node_modules/interface-datastore/src/utils.js
var require_utils6 = __commonJS((exports2, module2) => {
  "use strict";
  var tempdir = require_temp_dir_browser();
  var TextEncoder2 = require_text_encoder();
  var TextDecoder2 = require_text_decoder();
  var utf8Encoder = new TextEncoder2();
  var utf8Decoder = new TextDecoder2("utf8");
  var filter = (iterable, filterer) => {
    return async function* () {
      for await (const value of iterable) {
        const keep = await filterer(value);
        if (!keep)
          continue;
        yield value;
      }
    }();
  };
  var sortAll = (iterable, sorter) => {
    return async function* () {
      let values = [];
      for await (const value of iterable)
        values.push(value);
      values = await sorter(values);
      for (const value of values)
        yield value;
    }();
  };
  var take = (iterable, n) => {
    return async function* () {
      if (n <= 0)
        return;
      let i = 0;
      for await (const value of iterable) {
        yield value;
        i++;
        if (i >= n)
          return;
      }
    }();
  };
  var map = (iterable, mapper) => {
    return async function* () {
      for await (const value of iterable) {
        yield mapper(value);
      }
    }();
  };
  var replaceStartWith = (s, r) => {
    const matcher = new RegExp("^" + r);
    return s.replace(matcher, "");
  };
  module2.exports = {
    map,
    take,
    sortAll,
    filter,
    utf8Encoder,
    utf8Decoder,
    tmpdir: tempdir,
    replaceStartWith
  };
});

// node_modules/interface-datastore/src/key.js
var require_key3 = __commonJS((exports2, module2) => {
  "use strict";
  var {nanoid} = require_index_browser2();
  var {utf8Encoder, utf8Decoder} = require_utils6();
  var TextDecoder2 = require_text_decoder();
  var symbol = Symbol.for("@ipfs/interface-datastore/key");
  var pathSepS = "/";
  var pathSepB = utf8Encoder.encode(pathSepS);
  var pathSep = pathSepB[0];
  var Key = class {
    constructor(s, clean) {
      if (typeof s === "string") {
        this._buf = utf8Encoder.encode(s);
      } else if (s instanceof Uint8Array) {
        this._buf = s;
      } else {
        throw new Error("Invalid key, should be String of Uint8Array");
      }
      if (clean == null) {
        clean = true;
      }
      if (clean) {
        this.clean();
      }
      if (this._buf.byteLength === 0 || this._buf[0] !== pathSep) {
        throw new Error("Invalid key");
      }
    }
    toString(encoding = "utf8") {
      if (encoding === "utf8" || encoding === "utf-8") {
        return utf8Decoder.decode(this._buf);
      }
      return new TextDecoder2(encoding).decode(this._buf);
    }
    uint8Array() {
      return this._buf;
    }
    get [symbol]() {
      return true;
    }
    get [Symbol.toStringTag]() {
      return `Key(${this.toString()})`;
    }
    static withNamespaces(list) {
      return new Key(list.join(pathSepS));
    }
    static random() {
      return new Key(nanoid().replace(/-/g, ""));
    }
    clean() {
      if (!this._buf || this._buf.byteLength === 0) {
        this._buf = pathSepB;
      }
      if (this._buf[0] !== pathSep) {
        const bytes = new Uint8Array(this._buf.byteLength + 1);
        bytes.fill(pathSep, 0, 1);
        bytes.set(this._buf, 1);
        this._buf = bytes;
      }
      while (this._buf.byteLength > 1 && this._buf[this._buf.byteLength - 1] === pathSep) {
        this._buf = this._buf.subarray(0, -1);
      }
    }
    less(key) {
      const list1 = this.list();
      const list2 = key.list();
      for (let i = 0; i < list1.length; i++) {
        if (list2.length < i + 1) {
          return false;
        }
        const c1 = list1[i];
        const c2 = list2[i];
        if (c1 < c2) {
          return true;
        } else if (c1 > c2) {
          return false;
        }
      }
      return list1.length < list2.length;
    }
    reverse() {
      return Key.withNamespaces(this.list().slice().reverse());
    }
    namespaces() {
      return this.list();
    }
    baseNamespace() {
      const ns = this.namespaces();
      return ns[ns.length - 1];
    }
    list() {
      return this.toString().split(pathSepS).slice(1);
    }
    type() {
      return namespaceType(this.baseNamespace());
    }
    name() {
      return namespaceValue(this.baseNamespace());
    }
    instance(s) {
      return new Key(this.toString() + ":" + s);
    }
    path() {
      let p = this.parent().toString();
      if (!p.endsWith(pathSepS)) {
        p += pathSepS;
      }
      p += this.type();
      return new Key(p);
    }
    parent() {
      const list = this.list();
      if (list.length === 1) {
        return new Key(pathSepS);
      }
      return new Key(list.slice(0, -1).join(pathSepS));
    }
    child(key) {
      if (this.toString() === pathSepS) {
        return key;
      } else if (key.toString() === pathSepS) {
        return this;
      }
      return new Key(this.toString() + key.toString(), false);
    }
    isAncestorOf(other) {
      if (other.toString() === this.toString()) {
        return false;
      }
      return other.toString().startsWith(this.toString());
    }
    isDecendantOf(other) {
      if (other.toString() === this.toString()) {
        return false;
      }
      return this.toString().startsWith(other.toString());
    }
    isTopLevel() {
      return this.list().length === 1;
    }
    concat(...keys) {
      return Key.withNamespaces([...this.namespaces(), ...flatten(keys.map((key) => key.namespaces()))]);
    }
    static isKey(value) {
      return value instanceof Key || Boolean(value && value[symbol]);
    }
  };
  function namespaceType(ns) {
    const parts = ns.split(":");
    if (parts.length < 2) {
      return "";
    }
    return parts.slice(0, -1).join(":");
  }
  function namespaceValue(ns) {
    const parts = ns.split(":");
    return parts[parts.length - 1];
  }
  function flatten(arr) {
    return [].concat(...arr);
  }
  module2.exports = Key;
});

// node_modules/it-drain/index.js
var require_it_drain = __commonJS((exports2, module2) => {
  "use strict";
  var drain = async (source) => {
    for await (const _ of source) {
    }
  };
  module2.exports = drain;
});

// node_modules/interface-datastore/src/adapter.js
var require_adapter = __commonJS((exports2, module2) => {
  "use strict";
  var {filter, sortAll, take, map} = require_utils6();
  var drain = require_it_drain();
  var Adapter = class {
    open() {
      return Promise.reject(new Error(".open is not implemented"));
    }
    close() {
      return Promise.reject(new Error(".close is not implemented"));
    }
    put(key, val, options) {
      return Promise.reject(new Error(".put is not implemented"));
    }
    get(key, options) {
      return Promise.reject(new Error(".get is not implemented"));
    }
    has(key, options) {
      return Promise.reject(new Error(".has is not implemented"));
    }
    delete(key, options) {
      return Promise.reject(new Error(".delete is not implemented"));
    }
    async *putMany(source, options = {}) {
      for await (const {key, value} of source) {
        await this.put(key, value, options);
        yield {key, value};
      }
    }
    async *getMany(source, options = {}) {
      for await (const key of source) {
        yield this.get(key, options);
      }
    }
    async *deleteMany(source, options = {}) {
      for await (const key of source) {
        await this.delete(key, options);
        yield key;
      }
    }
    batch() {
      let puts = [];
      let dels = [];
      return {
        put(key, value) {
          puts.push({key, value});
        },
        delete(key) {
          dels.push(key);
        },
        commit: async (options) => {
          await drain(this.putMany(puts, options));
          puts = [];
          await drain(this.deleteMany(dels, options));
          dels = [];
        }
      };
    }
    async *_all(q, options) {
      throw new Error("._all is not implemented");
    }
    query(q, options) {
      let it = this._all(q, options);
      if (q.prefix != null) {
        it = filter(it, (e) => e.key.toString().startsWith(q.prefix));
      }
      if (Array.isArray(q.filters)) {
        it = q.filters.reduce((it2, f) => filter(it2, f), it);
      }
      if (Array.isArray(q.orders)) {
        it = q.orders.reduce((it2, f) => sortAll(it2, f), it);
      }
      if (q.offset != null) {
        let i = 0;
        it = filter(it, () => i++ >= q.offset);
      }
      if (q.limit != null) {
        it = take(it, q.limit);
      }
      if (q.keysOnly === true) {
        return map(it, (e) => ({key: e.key}));
      }
      return it;
    }
  };
  module2.exports = Adapter;
});

// node_modules/interface-datastore/src/errors.js
var require_errors = __commonJS((exports2, module2) => {
  "use strict";
  var errcode = require_err_code();
  var dbOpenFailedError = (err) => {
    err = err || new Error("Cannot open database");
    return errcode(err, "ERR_DB_OPEN_FAILED");
  };
  var dbDeleteFailedError = (err) => {
    err = err || new Error("Delete failed");
    return errcode(err, "ERR_DB_DELETE_FAILED");
  };
  var dbWriteFailedError = (err) => {
    err = err || new Error("Write failed");
    return errcode(err, "ERR_DB_WRITE_FAILED");
  };
  var notFoundError = (err) => {
    err = err || new Error("Not Found");
    return errcode(err, "ERR_NOT_FOUND");
  };
  var abortedError = (err) => {
    err = err || new Error("Aborted");
    return errcode(err, "ERR_ABORTED");
  };
  module2.exports = {
    dbOpenFailedError,
    dbDeleteFailedError,
    dbWriteFailedError,
    notFoundError,
    abortedError
  };
});

// node_modules/interface-datastore/src/memory.js
var require_memory = __commonJS((exports2, module2) => {
  "use strict";
  var Key = require_key3();
  var Adapter = require_adapter();
  var Errors = require_errors();
  var MemoryDatastore = class extends Adapter {
    constructor() {
      super();
      this.data = {};
    }
    open() {
      return Promise.resolve();
    }
    close() {
      return Promise.resolve();
    }
    async put(key, val) {
      this.data[key.toString()] = val;
    }
    async get(key) {
      const exists = await this.has(key);
      if (!exists)
        throw Errors.notFoundError();
      return this.data[key.toString()];
    }
    async has(key) {
      return this.data[key.toString()] !== void 0;
    }
    async delete(key) {
      delete this.data[key.toString()];
    }
    async *_all() {
      yield* Object.entries(this.data).map(([key, value]) => ({key: new Key(key), value}));
    }
  };
  module2.exports = MemoryDatastore;
});

// node_modules/interface-datastore/src/index.js
var require_src15 = __commonJS((exports2, module2) => {
  "use strict";
  var Key = require_key3();
  var MemoryDatastore = require_memory();
  var utils = require_utils6();
  var Errors = require_errors();
  var Adapter = require_adapter();
  module2.exports = {
    Key,
    MemoryDatastore,
    utils,
    Errors,
    Adapter
  };
});

// node_modules/ipfs-core-utils/src/to-cid-and-path.js
var require_to_cid_and_path = __commonJS((exports2, module2) => {
  "use strict";
  var CID = require_src7();
  var errCode = require_err_code();
  var IPFS_PREFIX = "/ipfs/";
  var toCidAndPath = (string) => {
    if (string instanceof Uint8Array) {
      try {
        string = new CID(string);
      } catch (err) {
        throw errCode(err, "ERR_INVALID_CID");
      }
    }
    if (CID.isCID(string)) {
      return {
        cid: string,
        path: void 0
      };
    }
    if (string.startsWith(IPFS_PREFIX)) {
      string = string.substring(IPFS_PREFIX.length);
    }
    const parts = string.split("/");
    let cid;
    let path;
    try {
      cid = new CID(parts.shift());
    } catch (err) {
      throw errCode(err, "ERR_INVALID_CID");
    }
    if (parts.length) {
      path = `/${parts.join("/")}`;
    }
    return {
      cid,
      path
    };
  };
  module2.exports = toCidAndPath;
});

// node_modules/retimer/time-browser.js
var require_time_browser = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = function getTime() {
    return Date.now();
  };
});

// node_modules/retimer/retimer.js
var require_retimer = __commonJS((exports2, module2) => {
  "use strict";
  var getTime = require_time_browser();
  function Retimer(callback, timeout, args) {
    var that = this;
    this._started = getTime();
    this._rescheduled = 0;
    this._scheduled = timeout;
    this._args = args;
    this._timer = setTimeout(timerWrapper, timeout);
    function timerWrapper() {
      if (that._rescheduled > 0) {
        that._scheduled = that._rescheduled - (getTime() - that._started);
        that._timer = setTimeout(timerWrapper, that._scheduled);
        that._rescheduled = 0;
      } else {
        callback.apply(null, that._args);
      }
    }
  }
  Retimer.prototype.reschedule = function(timeout) {
    var now = getTime();
    if (now + timeout - (this._started + this._scheduled) < 0) {
      return false;
    } else {
      this._started = now;
      this._rescheduled = timeout;
      return true;
    }
  };
  Retimer.prototype.clear = function() {
    clearTimeout(this._timer);
  };
  function retimer() {
    if (typeof arguments[0] !== "function") {
      throw new Error("callback needed");
    }
    if (typeof arguments[1] !== "number") {
      throw new Error("timeout needed");
    }
    var args;
    if (arguments.length > 0) {
      args = new Array(arguments.length - 2);
      for (var i = 0; i < args.length; i++) {
        args[i] = arguments[i + 2];
      }
    }
    return new Retimer(arguments[0], arguments[1], args);
  }
  module2.exports = retimer;
});

// node_modules/timeout-abort-controller/index.js
var require_timeout_abort_controller = __commonJS((exports2, module2) => {
  "use strict";
  var {AbortController} = typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : require_browser3();
  var retimer = require_retimer();
  var TimeoutController = class extends AbortController {
    constructor(ms) {
      super();
      this._ms = ms;
      this._timer = retimer(() => this.abort(), ms);
      Object.setPrototypeOf(this, TimeoutController.prototype);
    }
    abort() {
      this._timer.clear();
      return super.abort();
    }
    clear() {
      this._timer.clear();
    }
    reset() {
      this._timer.clear();
      this._timer = retimer(() => this.abort(), this._ms);
    }
  };
  module2.exports = TimeoutController;
  module2.exports.TimeoutController = TimeoutController;
});

// node_modules/parse-duration/index.mjs
var require_parse_duration = __commonJS((exports2) => {
  __export(exports2, {
    default: () => parse
  });
  var duration = /(-?(?:\d+\.?\d*|\d*\.?\d+)(?:e[-+]?\d+)?)\s*([a-z]*)/ig;
  parse.nanosecond = parse.ns = 1 / 1e6;
  parse["\xB5s"] = parse["\u03BCs"] = parse.us = parse.microsecond = 1 / 1e3;
  parse.millisecond = parse.ms = 1;
  parse.second = parse.sec = parse.s = parse.ms * 1e3;
  parse.minute = parse.min = parse.m = parse.s * 60;
  parse.hour = parse.hr = parse.h = parse.m * 60;
  parse.day = parse.d = parse.h * 24;
  parse.week = parse.wk = parse.w = parse.d * 7;
  parse.month = parse.b = parse.d * (365.25 / 12);
  parse.year = parse.yr = parse.y = parse.d * 365.25;
  function parse(str = "", format = "ms") {
    var result = null;
    str = str.replace(/(\d),(\d)/g, "$1$2");
    str.replace(duration, function(_, n, units) {
      units = parse[units] || parse[units.toLowerCase().replace(/s$/, "")];
      if (units)
        result = (result || 0) + parseFloat(n, 10) * units;
    });
    return result && result / parse[format];
  }
});

// node_modules/ipfs-core-utils/src/errors.js
var require_errors2 = __commonJS((exports2) => {
  "use strict";
  var TimeoutError = class extends Error {
    constructor(message = "request timed out") {
      super(message);
      this.name = "TimeoutError";
      this.code = TimeoutError.code;
    }
  };
  TimeoutError.code = "ERR_TIMEOUT";
  exports2.TimeoutError = TimeoutError;
});

// node_modules/ipfs-core-utils/src/with-timeout-option.js
var require_with_timeout_option = __commonJS((exports2, module2) => {
  "use strict";
  var TimeoutController = require_timeout_abort_controller();
  var {anySignal} = require_any_signal();
  var {default: parseDuration} = require_parse_duration();
  var {TimeoutError} = require_errors2();
  function withTimeoutOption(fn, optionsArgIndex) {
    return (...args) => {
      const options = args[optionsArgIndex == null ? args.length - 1 : optionsArgIndex];
      if (!options || !options.timeout)
        return fn(...args);
      const timeout = typeof options.timeout === "string" ? parseDuration(options.timeout) : options.timeout;
      const controller = new TimeoutController(timeout);
      options.signal = anySignal([options.signal, controller.signal]);
      const fnRes = fn(...args);
      const timeoutPromise = new Promise((_resolve, reject) => {
        controller.signal.addEventListener("abort", () => {
          reject(new TimeoutError());
        });
      });
      const start = Date.now();
      const maybeThrowTimeoutError = () => {
        if (controller.signal.aborted) {
          throw new TimeoutError();
        }
        const timeTaken = Date.now() - start;
        if (timeTaken > timeout) {
          controller.abort();
          throw new TimeoutError();
        }
      };
      if (fnRes[Symbol.asyncIterator]) {
        return async function* () {
          const it = fnRes[Symbol.asyncIterator]();
          try {
            while (true) {
              const {value, done} = await Promise.race([it.next(), timeoutPromise]);
              if (done) {
                break;
              }
              maybeThrowTimeoutError();
              yield value;
            }
          } catch (err) {
            maybeThrowTimeoutError();
            throw err;
          } finally {
            controller.clear();
            if (it.return) {
              it.return();
            }
          }
        }();
      }
      return (async () => {
        try {
          const res = await Promise.race([fnRes, timeoutPromise]);
          maybeThrowTimeoutError();
          return res;
        } catch (err) {
          maybeThrowTimeoutError();
          throw err;
        } finally {
          controller.clear();
        }
      })();
    };
  }
  module2.exports = withTimeoutOption;
});

// node_modules/ipfs-core/src/utils.js
var require_utils7 = __commonJS((exports2) => {
  "use strict";
  var isIpfs = require_src13();
  var CID = require_src7();
  var Key = require_src15().Key;
  var errCode = require_err_code();
  var toCidAndPath = require_to_cid_and_path();
  var withTimeoutOption = require_with_timeout_option();
  var mergeOptions = require_merge_options();
  exports2.mergeOptions = mergeOptions;
  var ERR_BAD_PATH = "ERR_BAD_PATH";
  exports2.OFFLINE_ERROR = "This command must be run in online mode. Try running 'ipfs daemon' first.";
  exports2.MFS_ROOT_KEY = new Key("/local/filesroot");
  exports2.MFS_MAX_CHUNK_SIZE = 262144;
  exports2.MFS_MAX_LINKS = 174;
  var normalizePath = (pathStr) => {
    if (isIpfs.cid(pathStr)) {
      return `/ipfs/${new CID(pathStr)}`;
    } else if (isIpfs.path(pathStr)) {
      return pathStr;
    } else {
      throw errCode(new Error(`invalid path: ${pathStr}`), ERR_BAD_PATH);
    }
  };
  var normalizeCidPath = (path) => {
    if (path instanceof Uint8Array) {
      return new CID(path).toString();
    }
    if (CID.isCID(path)) {
      return path.toString();
    }
    if (path.indexOf("/ipfs/") === 0) {
      path = path.substring("/ipfs/".length);
    }
    if (path.charAt(path.length - 1) === "/") {
      path = path.substring(0, path.length - 1);
    }
    return path;
  };
  var resolvePath = async function(dag, ipfsPath, options = {}) {
    if (isIpfs.cid(ipfsPath)) {
      return new CID(ipfsPath);
    }
    const {
      cid,
      path
    } = toCidAndPath(ipfsPath);
    if (!path) {
      return cid;
    }
    const result = await dag.resolve(cid, {
      ...options,
      path
    });
    return result.cid;
  };
  var mapFile = (file, options = {}) => {
    const output = {
      cid: file.cid,
      path: file.path,
      name: file.name,
      depth: file.path.split("/").length,
      size: 0,
      type: "file"
    };
    if (file.unixfs) {
      output.type = file.unixfs.type === "directory" ? "dir" : "file";
      if (file.unixfs.type === "file") {
        output.size = file.unixfs.fileSize();
        if (options.includeContent) {
          output.content = file.content();
        }
      }
      output.mode = file.unixfs.mode;
      output.mtime = file.unixfs.mtime;
    }
    return output;
  };
  var withTimeout = withTimeoutOption(async (promise, _options) => await promise);
  exports2.normalizePath = normalizePath;
  exports2.normalizeCidPath = normalizeCidPath;
  exports2.resolvePath = resolvePath;
  exports2.mapFile = mapFile;
  exports2.withTimeoutOption = withTimeoutOption;
  exports2.withTimeout = withTimeout;
});

// node_modules/debug/node_modules/ms/index.js
var require_ms = __commonJS((exports2, module2) => {
  var s = 1e3;
  var m = s * 60;
  var h = m * 60;
  var d = h * 24;
  var w = d * 7;
  var y = d * 365.25;
  module2.exports = function(val, options) {
    options = options || {};
    var type = typeof val;
    if (type === "string" && val.length > 0) {
      return parse(val);
    } else if (type === "number" && isFinite(val)) {
      return options.long ? fmtLong(val) : fmtShort(val);
    }
    throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(val));
  };
  function parse(str) {
    str = String(str);
    if (str.length > 100) {
      return;
    }
    var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);
    if (!match) {
      return;
    }
    var n = parseFloat(match[1]);
    var type = (match[2] || "ms").toLowerCase();
    switch (type) {
      case "years":
      case "year":
      case "yrs":
      case "yr":
      case "y":
        return n * y;
      case "weeks":
      case "week":
      case "w":
        return n * w;
      case "days":
      case "day":
      case "d":
        return n * d;
      case "hours":
      case "hour":
      case "hrs":
      case "hr":
      case "h":
        return n * h;
      case "minutes":
      case "minute":
      case "mins":
      case "min":
      case "m":
        return n * m;
      case "seconds":
      case "second":
      case "secs":
      case "sec":
      case "s":
        return n * s;
      case "milliseconds":
      case "millisecond":
      case "msecs":
      case "msec":
      case "ms":
        return n;
      default:
        return void 0;
    }
  }
  function fmtShort(ms) {
    var msAbs = Math.abs(ms);
    if (msAbs >= d) {
      return Math.round(ms / d) + "d";
    }
    if (msAbs >= h) {
      return Math.round(ms / h) + "h";
    }
    if (msAbs >= m) {
      return Math.round(ms / m) + "m";
    }
    if (msAbs >= s) {
      return Math.round(ms / s) + "s";
    }
    return ms + "ms";
  }
  function fmtLong(ms) {
    var msAbs = Math.abs(ms);
    if (msAbs >= d) {
      return plural(ms, msAbs, d, "day");
    }
    if (msAbs >= h) {
      return plural(ms, msAbs, h, "hour");
    }
    if (msAbs >= m) {
      return plural(ms, msAbs, m, "minute");
    }
    if (msAbs >= s) {
      return plural(ms, msAbs, s, "second");
    }
    return ms + " ms";
  }
  function plural(ms, msAbs, n, name) {
    var isPlural = msAbs >= n * 1.5;
    return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
  }
});

// node_modules/debug/src/common.js
var require_common3 = __commonJS((exports2, module2) => {
  function setup(env) {
    createDebug.debug = createDebug;
    createDebug.default = createDebug;
    createDebug.coerce = coerce;
    createDebug.disable = disable;
    createDebug.enable = enable;
    createDebug.enabled = enabled;
    createDebug.humanize = require_ms();
    createDebug.destroy = destroy;
    Object.keys(env).forEach((key) => {
      createDebug[key] = env[key];
    });
    createDebug.names = [];
    createDebug.skips = [];
    createDebug.formatters = {};
    function selectColor(namespace) {
      let hash = 0;
      for (let i = 0; i < namespace.length; i++) {
        hash = (hash << 5) - hash + namespace.charCodeAt(i);
        hash |= 0;
      }
      return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
    }
    createDebug.selectColor = selectColor;
    function createDebug(namespace) {
      let prevTime;
      let enableOverride = null;
      function debug(...args) {
        if (!debug.enabled) {
          return;
        }
        const self2 = debug;
        const curr = Number(new Date());
        const ms = curr - (prevTime || curr);
        self2.diff = ms;
        self2.prev = prevTime;
        self2.curr = curr;
        prevTime = curr;
        args[0] = createDebug.coerce(args[0]);
        if (typeof args[0] !== "string") {
          args.unshift("%O");
        }
        let index = 0;
        args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
          if (match === "%%") {
            return "%";
          }
          index++;
          const formatter = createDebug.formatters[format];
          if (typeof formatter === "function") {
            const val = args[index];
            match = formatter.call(self2, val);
            args.splice(index, 1);
            index--;
          }
          return match;
        });
        createDebug.formatArgs.call(self2, args);
        const logFn = self2.log || createDebug.log;
        logFn.apply(self2, args);
      }
      debug.namespace = namespace;
      debug.useColors = createDebug.useColors();
      debug.color = createDebug.selectColor(namespace);
      debug.extend = extend;
      debug.destroy = createDebug.destroy;
      Object.defineProperty(debug, "enabled", {
        enumerable: true,
        configurable: false,
        get: () => enableOverride === null ? createDebug.enabled(namespace) : enableOverride,
        set: (v) => {
          enableOverride = v;
        }
      });
      if (typeof createDebug.init === "function") {
        createDebug.init(debug);
      }
      return debug;
    }
    function extend(namespace, delimiter) {
      const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
      newDebug.log = this.log;
      return newDebug;
    }
    function enable(namespaces) {
      createDebug.save(namespaces);
      createDebug.names = [];
      createDebug.skips = [];
      let i;
      const split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
      const len = split.length;
      for (i = 0; i < len; i++) {
        if (!split[i]) {
          continue;
        }
        namespaces = split[i].replace(/\*/g, ".*?");
        if (namespaces[0] === "-") {
          createDebug.skips.push(new RegExp("^" + namespaces.substr(1) + "$"));
        } else {
          createDebug.names.push(new RegExp("^" + namespaces + "$"));
        }
      }
    }
    function disable() {
      const namespaces = [
        ...createDebug.names.map(toNamespace),
        ...createDebug.skips.map(toNamespace).map((namespace) => "-" + namespace)
      ].join(",");
      createDebug.enable("");
      return namespaces;
    }
    function enabled(name) {
      if (name[name.length - 1] === "*") {
        return true;
      }
      let i;
      let len;
      for (i = 0, len = createDebug.skips.length; i < len; i++) {
        if (createDebug.skips[i].test(name)) {
          return false;
        }
      }
      for (i = 0, len = createDebug.names.length; i < len; i++) {
        if (createDebug.names[i].test(name)) {
          return true;
        }
      }
      return false;
    }
    function toNamespace(regexp) {
      return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
    }
    function coerce(val) {
      if (val instanceof Error) {
        return val.stack || val.message;
      }
      return val;
    }
    function destroy() {
      console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
    }
    createDebug.enable(createDebug.load());
    return createDebug;
  }
  module2.exports = setup;
});

// node_modules/debug/src/browser.js
var require_browser4 = __commonJS((exports2, module2) => {
  exports2.formatArgs = formatArgs;
  exports2.save = save;
  exports2.load = load;
  exports2.useColors = useColors;
  exports2.storage = localstorage();
  exports2.destroy = (() => {
    let warned = false;
    return () => {
      if (!warned) {
        warned = true;
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
    };
  })();
  exports2.colors = [
    "#0000CC",
    "#0000FF",
    "#0033CC",
    "#0033FF",
    "#0066CC",
    "#0066FF",
    "#0099CC",
    "#0099FF",
    "#00CC00",
    "#00CC33",
    "#00CC66",
    "#00CC99",
    "#00CCCC",
    "#00CCFF",
    "#3300CC",
    "#3300FF",
    "#3333CC",
    "#3333FF",
    "#3366CC",
    "#3366FF",
    "#3399CC",
    "#3399FF",
    "#33CC00",
    "#33CC33",
    "#33CC66",
    "#33CC99",
    "#33CCCC",
    "#33CCFF",
    "#6600CC",
    "#6600FF",
    "#6633CC",
    "#6633FF",
    "#66CC00",
    "#66CC33",
    "#9900CC",
    "#9900FF",
    "#9933CC",
    "#9933FF",
    "#99CC00",
    "#99CC33",
    "#CC0000",
    "#CC0033",
    "#CC0066",
    "#CC0099",
    "#CC00CC",
    "#CC00FF",
    "#CC3300",
    "#CC3333",
    "#CC3366",
    "#CC3399",
    "#CC33CC",
    "#CC33FF",
    "#CC6600",
    "#CC6633",
    "#CC9900",
    "#CC9933",
    "#CCCC00",
    "#CCCC33",
    "#FF0000",
    "#FF0033",
    "#FF0066",
    "#FF0099",
    "#FF00CC",
    "#FF00FF",
    "#FF3300",
    "#FF3333",
    "#FF3366",
    "#FF3399",
    "#FF33CC",
    "#FF33FF",
    "#FF6600",
    "#FF6633",
    "#FF9900",
    "#FF9933",
    "#FFCC00",
    "#FFCC33"
  ];
  function useColors() {
    if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
      return true;
    }
    if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
      return false;
    }
    return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
  }
  function formatArgs(args) {
    args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module2.exports.humanize(this.diff);
    if (!this.useColors) {
      return;
    }
    const c = "color: " + this.color;
    args.splice(1, 0, c, "color: inherit");
    let index = 0;
    let lastC = 0;
    args[0].replace(/%[a-zA-Z%]/g, (match) => {
      if (match === "%%") {
        return;
      }
      index++;
      if (match === "%c") {
        lastC = index;
      }
    });
    args.splice(lastC, 0, c);
  }
  exports2.log = console.debug || console.log || (() => {
  });
  function save(namespaces) {
    try {
      if (namespaces) {
        exports2.storage.setItem("debug", namespaces);
      } else {
        exports2.storage.removeItem("debug");
      }
    } catch (error) {
    }
  }
  function load() {
    let r;
    try {
      r = exports2.storage.getItem("debug");
    } catch (error) {
    }
    if (!r && typeof process !== "undefined" && "env" in process) {
      r = process.env.DEBUG;
    }
    return r;
  }
  function localstorage() {
    try {
      return localStorage;
    } catch (error) {
    }
  }
  module2.exports = require_common3()(exports2);
  var {formatters} = module2.exports;
  formatters.j = function(v) {
    try {
      return JSON.stringify(v);
    } catch (error) {
      return "[UnexpectedJSONParseError]: " + error.message;
    }
  };
});

// node_modules/stable/stable.js
var require_stable = __commonJS((exports2, module2) => {
  //! stable.js 0.1.8, https://github.com/Two-Screen/stable
  //!  2018 Angry Bytes and contributors. MIT licensed.
  (function(global2, factory) {
    typeof exports2 === "object" && typeof module2 !== "undefined" ? module2.exports = factory() : typeof define === "function" && define.amd ? define(factory) : global2.stable = factory();
  })(exports2, function() {
    "use strict";
    var stable = function(arr, comp) {
      return exec(arr.slice(), comp);
    };
    stable.inplace = function(arr, comp) {
      var result = exec(arr, comp);
      if (result !== arr) {
        pass(result, null, arr.length, arr);
      }
      return arr;
    };
    function exec(arr, comp) {
      if (typeof comp !== "function") {
        comp = function(a, b) {
          return String(a).localeCompare(b);
        };
      }
      var len = arr.length;
      if (len <= 1) {
        return arr;
      }
      var buffer = new Array(len);
      for (var chk = 1; chk < len; chk *= 2) {
        pass(arr, comp, chk, buffer);
        var tmp = arr;
        arr = buffer;
        buffer = tmp;
      }
      return arr;
    }
    var pass = function(arr, comp, chk, result) {
      var len = arr.length;
      var i = 0;
      var dbl = chk * 2;
      var l, r, e;
      var li, ri;
      for (l = 0; l < len; l += dbl) {
        r = l + chk;
        e = r + chk;
        if (r > len)
          r = len;
        if (e > len)
          e = len;
        li = l;
        ri = r;
        while (true) {
          if (li < r && ri < e) {
            if (comp(arr[li], arr[ri]) <= 0) {
              result[i++] = arr[li++];
            } else {
              result[i++] = arr[ri++];
            }
          } else if (li < r) {
            result[i++] = arr[li++];
          } else if (ri < e) {
            result[i++] = arr[ri++];
          } else {
            break;
          }
        }
      }
    };
    return stable;
  });
});

// node_modules/uint8arrays/compare.js
var require_compare = __commonJS((exports2, module2) => {
  "use strict";
  function compare(a, b) {
    for (let i = 0; i < a.byteLength; i++) {
      if (a[i] < b[i]) {
        return -1;
      }
      if (a[i] > b[i]) {
        return 1;
      }
    }
    if (a.byteLength > b.byteLength) {
      return 1;
    }
    if (a.byteLength < b.byteLength) {
      return -1;
    }
    return 0;
  }
  module2.exports = compare;
});

// node_modules/ipld-dag-pb/src/dag-node/sortLinks.js
var require_sortLinks = __commonJS((exports2, module2) => {
  "use strict";
  var sort = require_stable();
  var uint8ArrayCompare = require_compare();
  var linkSort = (a, b) => {
    const buf1 = a.nameAsBuffer;
    const buf2 = b.nameAsBuffer;
    return uint8ArrayCompare(buf1, buf2);
  };
  var sortLinks = (links) => {
    sort.inplace(links, linkSort);
  };
  module2.exports = sortLinks;
});

// node_modules/ipld-dag-pb/src/dag-link/dagLink.js
var require_dagLink = __commonJS((exports2, module2) => {
  "use strict";
  var CID = require_src7();
  var withIs = require_class_is();
  var uint8ArrayFromString = require_from_string2();
  var DAGLink = class {
    constructor(name, size, cid) {
      if (!cid) {
        throw new Error("A link requires a cid to point to");
      }
      Object.defineProperties(this, {
        Name: {value: name || "", writable: false, enumerable: true},
        Tsize: {value: size, writable: false, enumerable: true},
        Hash: {value: new CID(cid), writable: false, enumerable: true},
        _nameBuf: {value: null, writable: true, enumerable: false}
      });
    }
    toString() {
      return `DAGLink <${this.Hash.toBaseEncodedString()} - name: "${this.Name}", size: ${this.Tsize}>`;
    }
    toJSON() {
      if (!this._json) {
        this._json = Object.freeze({
          name: this.Name,
          size: this.Tsize,
          cid: this.Hash.toBaseEncodedString()
        });
      }
      return Object.assign({}, this._json);
    }
    get nameAsBuffer() {
      if (this._nameBuf !== null) {
        return this._nameBuf;
      }
      this._nameBuf = uint8ArrayFromString(this.Name);
      return this._nameBuf;
    }
  };
  exports2 = module2.exports = withIs(DAGLink, {className: "DAGLink", symbolName: "@ipld/js-ipld-dag-pb/daglink"});
});

// node_modules/ipld-dag-pb/src/dag.proto.js
var require_dag_proto = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = `// An IPFS MerkleDAG Link
message PBLink {

  // multihash of the target object
  optional bytes Hash = 1;

  // utf string name. should be unique per object
  optional string Name = 2;

  // cumulative size of target object
  optional uint64 Tsize = 3;
}

// An IPFS MerkleDAG Node
message PBNode {

  // refs to other objects
  repeated PBLink Links = 2;

  // opaque user data
  optional bytes Data = 1;
}`;
});

// node_modules/ipld-dag-pb/src/serialize.js
var require_serialize = __commonJS((exports2, module2) => {
  "use strict";
  var protons = require_src8();
  var proto = protons(require_dag_proto());
  var DAGLink = require_dagLink();
  exports2 = module2.exports;
  var toProtoBuf = (node) => {
    const pbn = {};
    if (node.Data && node.Data.byteLength > 0) {
      pbn.Data = node.Data;
    } else {
      pbn.Data = null;
    }
    if (node.Links && node.Links.length > 0) {
      pbn.Links = node.Links.map((link) => ({
        Hash: link.Hash.bytes,
        Name: link.Name,
        Tsize: link.Tsize
      }));
    } else {
      pbn.Links = null;
    }
    return pbn;
  };
  var serializeDAGNode = (node) => {
    const data = node.Data;
    const links = node.Links || [];
    const serialized = proto.PBNode.encode(toProtoBuf({
      Data: data,
      Links: links
    }));
    return serialized;
  };
  var serializeDAGNodeLike = (data, links = []) => {
    const node = {Data: data};
    node.Links = links.map((link) => {
      return DAGLink.isDAGLink(link) ? link : DAGLink.util.createDagLinkFromB58EncodedHash(link);
    });
    return serializeDAGNode(node);
  };
  exports2.serializeDAGNode = serializeDAGNode;
  exports2.serializeDAGNodeLike = serializeDAGNodeLike;
});

// node_modules/ipld-dag-pb/src/genCid.js
var require_genCid = __commonJS((exports2, module2) => {
  "use strict";
  var CID = require_src7();
  var multicodec = require_src6();
  var multihashing = require_src14();
  exports2 = module2.exports;
  exports2.codec = multicodec.DAG_PB;
  exports2.defaultHashAlg = multicodec.SHA2_256;
  var cid = async (binaryBlob, userOptions) => {
    const defaultOptions = {cidVersion: 1, hashAlg: exports2.defaultHashAlg};
    const options = Object.assign(defaultOptions, userOptions);
    const multihash = await multihashing(binaryBlob, options.hashAlg);
    const codecName = multicodec.print[exports2.codec];
    const cid2 = new CID(options.cidVersion, codecName, multihash);
    return cid2;
  };
  exports2.cid = cid;
});

// node_modules/ipld-dag-pb/src/dag-node/toDagLink.js
var require_toDagLink = __commonJS((exports2, module2) => {
  "use strict";
  var DAGLink = require_dagLink();
  var genCid = require_genCid();
  var toDAGLink = async (node, options = {}) => {
    const nodeCid = await genCid.cid(node.serialize(), options);
    return new DAGLink(options.name || "", node.size, nodeCid);
  };
  module2.exports = toDAGLink;
});

// node_modules/ipld-dag-pb/src/dag-link/util.js
var require_util6 = __commonJS((exports2, module2) => {
  "use strict";
  var DAGLink = require_dagLink();
  function createDagLinkFromB58EncodedHash(link) {
    return new DAGLink(link.Name || link.name || "", link.Tsize || link.Size || link.size || 0, link.Hash || link.hash || link.multihash || link.cid);
  }
  exports2 = module2.exports;
  exports2.createDagLinkFromB58EncodedHash = createDagLinkFromB58EncodedHash;
});

// node_modules/ipld-dag-pb/src/dag-link/index.js
var require_dag_link = __commonJS((exports2, module2) => {
  "use strict";
  exports2 = module2.exports = require_dagLink();
  exports2.util = require_util6();
});

// node_modules/ipld-dag-pb/src/dag-node/addLink.js
var require_addLink = __commonJS((exports2, module2) => {
  "use strict";
  var sortLinks = require_sortLinks();
  var DAGLink = require_dag_link();
  var asDAGLink = (link) => {
    if (DAGLink.isDAGLink(link)) {
      return link;
    }
    if (!("cid" in link || "hash" in link || "Hash" in link || "multihash" in link)) {
      throw new Error("Link must be a DAGLink or DAGLink-like. Convert the DAGNode into a DAGLink via `node.toDAGLink()`.");
    }
    return new DAGLink(link.Name || link.name, link.Tsize || link.size, link.Hash || link.multihash || link.hash || link.cid);
  };
  var addLink = (node, link) => {
    const dagLink = asDAGLink(link);
    node.Links.push(dagLink);
    sortLinks(node.Links);
  };
  module2.exports = addLink;
});

// node_modules/ipld-dag-pb/src/dag-node/rmLink.js
var require_rmLink = __commonJS((exports2, module2) => {
  "use strict";
  var CID = require_src7();
  var uint8ArrayEquals = require_equals2();
  var rmLink = (dagNode, nameOrCid) => {
    let predicate = null;
    if (typeof nameOrCid === "string") {
      predicate = (link) => link.Name === nameOrCid;
    } else if (nameOrCid instanceof Uint8Array || CID.isCID(nameOrCid)) {
      predicate = (link) => uint8ArrayEquals(link.Hash, nameOrCid);
    }
    if (predicate) {
      const links = dagNode.Links;
      let index = 0;
      while (index < links.length) {
        const link = links[index];
        if (predicate(link)) {
          links.splice(index, 1);
        } else {
          index++;
        }
      }
    } else {
      throw new Error("second arg needs to be a name or CID");
    }
  };
  module2.exports = rmLink;
});

// node_modules/ipld-dag-pb/src/dag-node/dagNode.js
var require_dagNode = __commonJS((exports2, module2) => {
  "use strict";
  var withIs = require_class_is();
  var sortLinks = require_sortLinks();
  var DAGLink = require_dagLink();
  var {serializeDAGNode} = require_serialize();
  var toDAGLink = require_toDagLink();
  var addLink = require_addLink();
  var rmLink = require_rmLink();
  var uint8ArrayFromString = require_from_string2();
  var uint8ArrayToString = require_to_string2();
  var DAGNode = class {
    constructor(data, links = [], serializedSize = null) {
      if (!data) {
        data = new Uint8Array(0);
      }
      if (typeof data === "string") {
        data = uint8ArrayFromString(data);
      }
      if (!(data instanceof Uint8Array)) {
        throw new Error("Passed 'data' is not a Uint8Array or a String!");
      }
      if (serializedSize !== null && typeof serializedSize !== "number") {
        throw new Error("Passed 'serializedSize' must be a number!");
      }
      links = links.map((link) => {
        return DAGLink.isDAGLink(link) ? link : DAGLink.util.createDagLinkFromB58EncodedHash(link);
      });
      sortLinks(links);
      Object.defineProperties(this, {
        Data: {value: data, writable: false, enumerable: true},
        Links: {value: links, writable: false, enumerable: true},
        _serializedSize: {value: serializedSize, writable: true, enumerable: false},
        _size: {value: null, writable: true, enumerable: false}
      });
    }
    toJSON() {
      if (!this._json) {
        this._json = Object.freeze({
          data: this.Data,
          links: this.Links.map((l) => l.toJSON()),
          size: this.size
        });
      }
      return Object.assign({}, this._json);
    }
    toString() {
      return `DAGNode <data: "${uint8ArrayToString(this.Data, "base64urlpad")}", links: ${this.Links.length}, size: ${this.size}>`;
    }
    _invalidateCached() {
      this._serializedSize = null;
      this._size = null;
    }
    addLink(link) {
      this._invalidateCached();
      return addLink(this, link);
    }
    rmLink(link) {
      this._invalidateCached();
      return rmLink(this, link);
    }
    toDAGLink(options) {
      return toDAGLink(this, options);
    }
    serialize() {
      return serializeDAGNode(this);
    }
    get size() {
      if (this._size === null) {
        if (this._serializedSize === null) {
          this._serializedSize = this.serialize().length;
        }
        this._size = this.Links.reduce((sum, l) => sum + l.Tsize, this._serializedSize);
      }
      return this._size;
    }
    set size(size) {
      throw new Error("Can't set property: 'size' is immutable");
    }
  };
  exports2 = module2.exports = withIs(DAGNode, {className: "DAGNode", symbolName: "@ipld/js-ipld-dag-pb/dagnode"});
});

// node_modules/ipld-dag-pb/src/dag-node/index.js
var require_dag_node = __commonJS((exports2, module2) => {
  "use strict";
  exports2 = module2.exports = require_dagNode();
});

// node_modules/ipld-dag-pb/src/util.js
var require_util7 = __commonJS((exports2, module2) => {
  "use strict";
  var protons = require_src8();
  var proto = protons(require_dag_proto());
  var DAGLink = require_dagLink();
  var DAGNode = require_dagNode();
  var {serializeDAGNodeLike} = require_serialize();
  var genCid = require_genCid();
  exports2 = module2.exports;
  exports2.codec = genCid.codec;
  exports2.defaultHashAlg = genCid.defaultHashAlg;
  var cid = (binaryBlob, userOptions) => {
    return genCid.cid(binaryBlob, userOptions);
  };
  var serialize = (node) => {
    if (DAGNode.isDAGNode(node)) {
      return node.serialize();
    } else {
      return serializeDAGNodeLike(node.Data, node.Links);
    }
  };
  var deserialize = (buffer) => {
    const pbn = proto.PBNode.decode(buffer);
    const links = pbn.Links.map((link) => {
      return new DAGLink(link.Name, link.Tsize, link.Hash);
    });
    const data = pbn.Data == null ? new Uint8Array(0) : pbn.Data;
    return new DAGNode(data, links, buffer.byteLength);
  };
  exports2.serialize = serialize;
  exports2.deserialize = deserialize;
  exports2.cid = cid;
});

// node_modules/ipld-dag-pb/src/resolver.js
var require_resolver = __commonJS((exports2) => {
  "use strict";
  var CID = require_src7();
  var util = require_util7();
  exports2.resolve = (binaryBlob, path) => {
    let node = util.deserialize(binaryBlob);
    const parts = path.split("/").filter(Boolean);
    while (parts.length) {
      const key = parts.shift();
      if (node[key] === void 0) {
        for (const link of node.Links) {
          if (link.Name === key) {
            return {
              value: link.Hash,
              remainderPath: parts.join("/")
            };
          }
        }
        throw new Error(`Object has no property '${key}'`);
      }
      node = node[key];
      if (CID.isCID(node)) {
        return {
          value: node,
          remainderPath: parts.join("/")
        };
      }
    }
    return {
      value: node,
      remainderPath: ""
    };
  };
  exports2.tree = function* (binaryBlob) {
    const node = util.deserialize(binaryBlob);
    yield "Data";
    yield "Links";
    for (let ii = 0; ii < node.Links.length; ii++) {
      yield `Links/${ii}`;
      yield `Links/${ii}/Name`;
      yield `Links/${ii}/Tsize`;
      yield `Links/${ii}/Hash`;
    }
  };
});

// node_modules/ipld-dag-pb/src/index.js
var require_src16 = __commonJS((exports2) => {
  "use strict";
  exports2.DAGNode = require_dag_node();
  exports2.DAGLink = require_dag_link();
  exports2.resolver = require_resolver();
  exports2.util = require_util7();
  exports2.codec = exports2.util.codec;
  exports2.defaultHashAlg = exports2.util.defaultHashAlg;
});

// node_modules/ipfs-unixfs/src/unixfs.proto.js
var require_unixfs_proto = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = `
syntax = "proto2";

message Data {
  enum DataType {
    Raw = 0;
    Directory = 1;
    File = 2;
    Metadata = 3;
    Symlink = 4;
    HAMTShard = 5;
  }

  required DataType Type = 1;
  optional bytes Data = 2;
  optional uint64 filesize = 3;
  repeated uint64 blocksizes = 4;
  optional uint64 hashType = 5;
  optional uint64 fanout = 6;
  optional uint32 mode = 7;
  optional UnixTime mtime = 8;
}

message UnixTime {
  required int64 Seconds = 1;
  optional fixed32 FractionalNanoseconds = 2;
}

message Metadata {
  optional string MimeType = 1;
}
`;
});

// node_modules/ipfs-unixfs/src/index.js
var require_src17 = __commonJS((exports2, module2) => {
  "use strict";
  var protons = require_src8();
  var pb = protons(require_unixfs_proto());
  var unixfsData = pb.Data;
  var errcode = require_err_code();
  var types = [
    "raw",
    "directory",
    "file",
    "metadata",
    "symlink",
    "hamt-sharded-directory"
  ];
  var dirTypes = [
    "directory",
    "hamt-sharded-directory"
  ];
  var DEFAULT_FILE_MODE = parseInt("0644", 8);
  var DEFAULT_DIRECTORY_MODE = parseInt("0755", 8);
  function parseArgs(args) {
    if (args.length === 0) {
      return {
        type: "file"
      };
    }
    if (args.length === 2) {
      return {
        type: args[0],
        data: args[1]
      };
    }
    if (typeof args[0] === "string" || args[0] instanceof String) {
      return {
        type: args[0]
      };
    }
    return args[0];
  }
  function parseMtime(mtime) {
    if (mtime == null) {
      return void 0;
    }
    if (Object.prototype.hasOwnProperty.call(mtime, "secs")) {
      mtime = {
        secs: mtime.secs,
        nsecs: mtime.nsecs
      };
    }
    if (Object.prototype.hasOwnProperty.call(mtime, "Seconds")) {
      mtime = {
        secs: mtime.Seconds,
        nsecs: mtime.FractionalNanoseconds
      };
    }
    if (Array.isArray(mtime)) {
      mtime = {
        secs: mtime[0],
        nsecs: mtime[1]
      };
    }
    if (mtime instanceof Date) {
      const ms = mtime.getTime();
      const secs = Math.floor(ms / 1e3);
      mtime = {
        secs,
        nsecs: (ms - secs * 1e3) * 1e3
      };
    }
    if (!Object.prototype.hasOwnProperty.call(mtime, "secs")) {
      return void 0;
    }
    if (mtime.nsecs < 0 || mtime.nsecs > 999999999) {
      throw errcode(new Error("mtime-nsecs must be within the range [0,999999999]"), "ERR_INVALID_MTIME_NSECS");
    }
    return mtime;
  }
  function parseMode(mode) {
    if (mode == null) {
      return void 0;
    }
    if (typeof mode === "string" || mode instanceof String) {
      mode = parseInt(mode, 8);
    }
    return mode & 4095;
  }
  var Data = class {
    static unmarshal(marshaled) {
      const decoded = unixfsData.decode(marshaled);
      const data = new Data({
        type: types[decoded.Type],
        data: decoded.hasData() ? decoded.Data : void 0,
        blockSizes: decoded.blocksizes,
        mode: decoded.hasMode() ? decoded.mode : void 0,
        mtime: decoded.hasMtime() ? decoded.mtime : void 0
      });
      data._originalMode = decoded.hasMode() ? decoded.mode : void 0;
      return data;
    }
    constructor(...args) {
      const {
        type,
        data,
        blockSizes,
        hashType,
        fanout,
        mtime,
        mode
      } = parseArgs(args);
      if (!types.includes(type)) {
        throw errcode(new Error("Type: " + type + " is not valid"), "ERR_INVALID_TYPE");
      }
      this.type = type;
      this.data = data;
      this.hashType = hashType;
      this.fanout = fanout;
      this.blockSizes = blockSizes || [];
      const parsedMode = parseMode(mode);
      if (parsedMode !== void 0) {
        this.mode = parsedMode;
      }
      if (this.mode === void 0 && type === "file") {
        this.mode = DEFAULT_FILE_MODE;
      }
      if (this.mode === void 0 && this.isDirectory()) {
        this.mode = DEFAULT_DIRECTORY_MODE;
      }
      const parsedMtime = parseMtime(mtime);
      if (parsedMtime) {
        this.mtime = parsedMtime;
      }
    }
    isDirectory() {
      return dirTypes.includes(this.type);
    }
    addBlockSize(size) {
      this.blockSizes.push(size);
    }
    removeBlockSize(index) {
      this.blockSizes.splice(index, 1);
    }
    fileSize() {
      if (this.isDirectory()) {
        return void 0;
      }
      let sum = 0;
      this.blockSizes.forEach((size) => {
        sum += size;
      });
      if (this.data) {
        sum += this.data.length;
      }
      return sum;
    }
    marshal() {
      let type;
      switch (this.type) {
        case "raw":
          type = unixfsData.DataType.Raw;
          break;
        case "directory":
          type = unixfsData.DataType.Directory;
          break;
        case "file":
          type = unixfsData.DataType.File;
          break;
        case "metadata":
          type = unixfsData.DataType.Metadata;
          break;
        case "symlink":
          type = unixfsData.DataType.Symlink;
          break;
        case "hamt-sharded-directory":
          type = unixfsData.DataType.HAMTShard;
          break;
        default:
          throw errcode(new Error("Type: " + type + " is not valid"), "ERR_INVALID_TYPE");
      }
      let data = this.data;
      if (!this.data || !this.data.length) {
        data = void 0;
      }
      let blockSizes = this.blockSizes;
      if (!this.blockSizes || !this.blockSizes.length) {
        blockSizes = void 0;
      }
      let mode;
      if (this.mode != null) {
        mode = this._originalMode & 4294963200 | parseMode(this.mode);
        if (mode === DEFAULT_FILE_MODE && this.type === "file") {
          mode = void 0;
        }
        if (mode === DEFAULT_DIRECTORY_MODE && this.isDirectory()) {
          mode = void 0;
        }
      }
      let mtime;
      if (this.mtime != null) {
        const parsed = parseMtime(this.mtime);
        if (parsed) {
          mtime = {
            Seconds: parsed.secs,
            FractionalNanoseconds: parsed.nsecs
          };
          if (mtime.FractionalNanoseconds === 0) {
            delete mtime.FractionalNanoseconds;
          }
        }
      }
      return unixfsData.encode({
        Type: type,
        Data: data,
        filesize: this.fileSize(),
        blocksizes: blockSizes,
        hashType: this.hashType,
        fanout: this.fanout,
        mode,
        mtime
      });
    }
  };
  module2.exports = Data;
});

// node_modules/ipfs-core/src/runtime/init-assets-browser.js
var require_init_assets_browser = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = () => {
  };
});

// node_modules/ipfs-core/src/errors.js
var require_errors3 = __commonJS((exports2) => {
  "use strict";
  var NotInitializedError = class extends Error {
    constructor(message = "not initialized") {
      super(message);
      this.name = "NotInitializedError";
      this.code = NotInitializedError.code;
    }
  };
  NotInitializedError.code = "ERR_NOT_INITIALIZED";
  exports2.NotInitializedError = NotInitializedError;
  var AlreadyInitializingError = class extends Error {
    constructor(message = "cannot initialize an initializing node") {
      super(message);
      this.name = "AlreadyInitializingError";
      this.code = AlreadyInitializedError.code;
    }
  };
  AlreadyInitializingError.code = "ERR_ALREADY_INITIALIZING";
  exports2.AlreadyInitializingError = AlreadyInitializingError;
  var AlreadyInitializedError = class extends Error {
    constructor(message = "cannot re-initialize an initialized node") {
      super(message);
      this.name = "AlreadyInitializedError";
      this.code = AlreadyInitializedError.code;
    }
  };
  AlreadyInitializedError.code = "ERR_ALREADY_INITIALIZED";
  exports2.AlreadyInitializedError = AlreadyInitializedError;
  var NotStartedError = class extends Error {
    constructor(message = "not started") {
      super(message);
      this.name = "NotStartedError";
      this.code = NotStartedError.code;
    }
  };
  NotStartedError.code = "ERR_NOT_STARTED";
  exports2.NotStartedError = NotStartedError;
  var AlreadyStartingError = class extends Error {
    constructor(message = "cannot start, already startin") {
      super(message);
      this.name = "AlreadyStartingError";
      this.code = AlreadyStartingError.code;
    }
  };
  AlreadyStartingError.code = "ERR_ALREADY_STARTING";
  exports2.AlreadyStartingError = AlreadyStartingError;
  var AlreadyStartedError = class extends Error {
    constructor(message = "cannot start, already started") {
      super(message);
      this.name = "AlreadyStartedError";
      this.code = AlreadyStartedError.code;
    }
  };
  AlreadyStartedError.code = "ERR_ALREADY_STARTED";
  exports2.AlreadyStartedError = AlreadyStartedError;
  var NotEnabledError = class extends Error {
    constructor(message = "not enabled") {
      super(message);
      this.name = "NotEnabledError";
      this.code = NotEnabledError.code;
    }
  };
  NotEnabledError.code = "ERR_NOT_ENABLED";
  exports2.NotEnabledError = NotEnabledError;
});

// node_modules/ipfs-core/src/utils/service.js
var require_service = __commonJS((exports2, module2) => {
  "use strict";
  var {NotStartedError, AlreadyStartingError, AlreadyStartedError} = require_errors3();
  var {withTimeout} = require_utils7();
  var Service = class {
    static create({start, stop}) {
      return new Service(start, stop);
    }
    static async start(service, options) {
      const {state, activate} = service;
      switch (state.status) {
        case "stopped": {
          try {
            const promise = activate(options);
            service.state = {status: "starting", ready: promise};
            const result = await promise;
            service.state = {status: "started", value: result};
            return result;
          } catch (error) {
            service.state = {status: "stopped"};
            throw error;
          }
        }
        case "starting": {
          throw new AlreadyStartingError();
        }
        case "started": {
          throw new AlreadyStartedError();
        }
        case "stopping": {
          await state.ready;
          return await Service.start(service, options);
        }
        default: {
          return Service.panic(service);
        }
      }
    }
    static async stop(service) {
      const {state, deactivate} = service;
      switch (state.status) {
        case "stopped": {
          break;
        }
        case "starting": {
          try {
            await state.ready;
          } catch (_) {
          }
          return await Service.stop(service);
        }
        case "stopping": {
          return await state.ready;
        }
        case "started": {
          if (deactivate) {
            await deactivate(state.value);
          }
          service.state = {status: "stopped"};
          break;
        }
        default: {
          Service.panic(state);
        }
      }
    }
    static try({state}) {
      switch (state.status) {
        case "started":
          return state.value;
        default:
          return null;
      }
    }
    static async use({state}, options) {
      switch (state.status) {
        case "started":
          return state.value;
        case "starting":
          return await withTimeout(state.ready, options);
        default:
          throw new NotStartedError();
      }
    }
    static panic({state}) {
      const status = JSON.stringify({status: state.status});
      throw RangeError(`Service in invalid state ${status}, should never happen if you see this please report a bug`);
    }
    constructor(activate, deactivate) {
      this.activate = activate;
      this.deactivate = deactivate;
      this.state = {status: "stopped"};
    }
    async use(options) {
      return await Service.use(this, options);
    }
    try() {
      return Service.try(this);
    }
  };
  module2.exports = Service;
});

// node_modules/ipfs-core/src/components/start.js
var require_start = __commonJS((exports2, module2) => {
  "use strict";
  var Service = require_service();
  module2.exports = ({network, preload, peerId, keychain, repo, ipns, blockService, mfsPreload, print, options}) => {
    const start = async () => {
      const {bitswap, libp2p} = await Service.start(network, {
        peerId,
        repo,
        print,
        options
      });
      blockService.setExchange(bitswap);
      await Promise.all([
        ipns.startOnline({keychain, libp2p, peerId, repo}),
        preload.start(),
        mfsPreload.start()
      ]);
    };
    return start;
  };
});

// node_modules/ipfs-core/src/components/stop.js
var require_stop = __commonJS((exports2, module2) => {
  "use strict";
  var Service = require_service();
  module2.exports = ({network, preload, blockService, ipns, repo, mfsPreload}) => {
    const stop = async () => {
      blockService.unsetExchange();
      await Promise.all([
        preload.stop(),
        ipns.stop(),
        mfsPreload.stop(),
        Service.stop(network),
        repo.close()
      ]);
    };
    return stop;
  };
});

// node_modules/hashlru/index.js
var require_hashlru = __commonJS((exports2, module2) => {
  module2.exports = function(max) {
    if (!max)
      throw Error("hashlru must have a max value, of type number, greater than 0");
    var size = 0, cache = Object.create(null), _cache = Object.create(null);
    function update(key, value) {
      cache[key] = value;
      size++;
      if (size >= max) {
        size = 0;
        _cache = cache;
        cache = Object.create(null);
      }
    }
    return {
      has: function(key) {
        return cache[key] !== void 0 || _cache[key] !== void 0;
      },
      remove: function(key) {
        if (cache[key] !== void 0)
          cache[key] = void 0;
        if (_cache[key] !== void 0)
          _cache[key] = void 0;
      },
      get: function(key) {
        var v = cache[key];
        if (v !== void 0)
          return v;
        if ((v = _cache[key]) !== void 0) {
          update(key, v);
          return v;
        }
      },
      set: function(key, value) {
        if (cache[key] !== void 0)
          cache[key] = value;
        else
          update(key, value);
      },
      clear: function() {
        cache = Object.create(null);
        _cache = Object.create(null);
      }
    };
  };
});

// node_modules/ipfs-core/src/utils/tlru.js
var require_tlru = __commonJS((exports2, module2) => {
  "use strict";
  var hashlru = require_hashlru();
  var TLRU = class {
    constructor(maxSize) {
      this.lru = hashlru(maxSize);
    }
    get(key) {
      const value = this.lru.get(key);
      if (value) {
        if (value.expire && value.expire < Date.now()) {
          this.lru.remove(key);
          return void 0;
        }
        return value.value;
      }
      return void 0;
    }
    set(key, value, ttl) {
      this.lru.set(key, {value, expire: Date.now() + ttl});
    }
    has(key) {
      const value = this.get(key);
      if (value) {
        return true;
      }
      return false;
    }
    remove(key) {
      this.lru.remove(key);
    }
    clear() {
      this.lru.clear();
    }
  };
  module2.exports = TLRU;
});

// node_modules/eventemitter3/index.js
var require_eventemitter3 = __commonJS((exports2, module2) => {
  "use strict";
  var has = Object.prototype.hasOwnProperty;
  var prefix = "~";
  function Events() {
  }
  if (Object.create) {
    Events.prototype = Object.create(null);
    if (!new Events().__proto__)
      prefix = false;
  }
  function EE(fn, context, once) {
    this.fn = fn;
    this.context = context;
    this.once = once || false;
  }
  function addListener(emitter, event, fn, context, once) {
    if (typeof fn !== "function") {
      throw new TypeError("The listener must be a function");
    }
    var listener = new EE(fn, context || emitter, once), evt = prefix ? prefix + event : event;
    if (!emitter._events[evt])
      emitter._events[evt] = listener, emitter._eventsCount++;
    else if (!emitter._events[evt].fn)
      emitter._events[evt].push(listener);
    else
      emitter._events[evt] = [emitter._events[evt], listener];
    return emitter;
  }
  function clearEvent(emitter, evt) {
    if (--emitter._eventsCount === 0)
      emitter._events = new Events();
    else
      delete emitter._events[evt];
  }
  function EventEmitter() {
    this._events = new Events();
    this._eventsCount = 0;
  }
  EventEmitter.prototype.eventNames = function eventNames() {
    var names = [], events, name;
    if (this._eventsCount === 0)
      return names;
    for (name in events = this._events) {
      if (has.call(events, name))
        names.push(prefix ? name.slice(1) : name);
    }
    if (Object.getOwnPropertySymbols) {
      return names.concat(Object.getOwnPropertySymbols(events));
    }
    return names;
  };
  EventEmitter.prototype.listeners = function listeners(event) {
    var evt = prefix ? prefix + event : event, handlers = this._events[evt];
    if (!handlers)
      return [];
    if (handlers.fn)
      return [handlers.fn];
    for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {
      ee[i] = handlers[i].fn;
    }
    return ee;
  };
  EventEmitter.prototype.listenerCount = function listenerCount(event) {
    var evt = prefix ? prefix + event : event, listeners = this._events[evt];
    if (!listeners)
      return 0;
    if (listeners.fn)
      return 1;
    return listeners.length;
  };
  EventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
    var evt = prefix ? prefix + event : event;
    if (!this._events[evt])
      return false;
    var listeners = this._events[evt], len = arguments.length, args, i;
    if (listeners.fn) {
      if (listeners.once)
        this.removeListener(event, listeners.fn, void 0, true);
      switch (len) {
        case 1:
          return listeners.fn.call(listeners.context), true;
        case 2:
          return listeners.fn.call(listeners.context, a1), true;
        case 3:
          return listeners.fn.call(listeners.context, a1, a2), true;
        case 4:
          return listeners.fn.call(listeners.context, a1, a2, a3), true;
        case 5:
          return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
        case 6:
          return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
      }
      for (i = 1, args = new Array(len - 1); i < len; i++) {
        args[i - 1] = arguments[i];
      }
      listeners.fn.apply(listeners.context, args);
    } else {
      var length = listeners.length, j;
      for (i = 0; i < length; i++) {
        if (listeners[i].once)
          this.removeListener(event, listeners[i].fn, void 0, true);
        switch (len) {
          case 1:
            listeners[i].fn.call(listeners[i].context);
            break;
          case 2:
            listeners[i].fn.call(listeners[i].context, a1);
            break;
          case 3:
            listeners[i].fn.call(listeners[i].context, a1, a2);
            break;
          case 4:
            listeners[i].fn.call(listeners[i].context, a1, a2, a3);
            break;
          default:
            if (!args)
              for (j = 1, args = new Array(len - 1); j < len; j++) {
                args[j - 1] = arguments[j];
              }
            listeners[i].fn.apply(listeners[i].context, args);
        }
      }
    }
    return true;
  };
  EventEmitter.prototype.on = function on(event, fn, context) {
    return addListener(this, event, fn, context, false);
  };
  EventEmitter.prototype.once = function once(event, fn, context) {
    return addListener(this, event, fn, context, true);
  };
  EventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {
    var evt = prefix ? prefix + event : event;
    if (!this._events[evt])
      return this;
    if (!fn) {
      clearEvent(this, evt);
      return this;
    }
    var listeners = this._events[evt];
    if (listeners.fn) {
      if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context)) {
        clearEvent(this, evt);
      }
    } else {
      for (var i = 0, events = [], length = listeners.length; i < length; i++) {
        if (listeners[i].fn !== fn || once && !listeners[i].once || context && listeners[i].context !== context) {
          events.push(listeners[i]);
        }
      }
      if (events.length)
        this._events[evt] = events.length === 1 ? events[0] : events;
      else
        clearEvent(this, evt);
    }
    return this;
  };
  EventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {
    var evt;
    if (event) {
      evt = prefix ? prefix + event : event;
      if (this._events[evt])
        clearEvent(this, evt);
    } else {
      this._events = new Events();
      this._eventsCount = 0;
    }
    return this;
  };
  EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
  EventEmitter.prototype.addListener = EventEmitter.prototype.on;
  EventEmitter.prefixed = prefix;
  EventEmitter.EventEmitter = EventEmitter;
  if (typeof module2 !== "undefined") {
    module2.exports = EventEmitter;
  }
});

// node_modules/p-finally/index.js
var require_p_finally = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = (promise, onFinally) => {
    onFinally = onFinally || (() => {
    });
    return promise.then((val) => new Promise((resolve) => {
      resolve(onFinally());
    }).then(() => val), (err) => new Promise((resolve) => {
      resolve(onFinally());
    }).then(() => {
      throw err;
    }));
  };
});

// node_modules/p-timeout/index.js
var require_p_timeout = __commonJS((exports2, module2) => {
  "use strict";
  var pFinally = require_p_finally();
  var TimeoutError = class extends Error {
    constructor(message) {
      super(message);
      this.name = "TimeoutError";
    }
  };
  var pTimeout = (promise, milliseconds, fallback) => new Promise((resolve, reject) => {
    if (typeof milliseconds !== "number" || milliseconds < 0) {
      throw new TypeError("Expected `milliseconds` to be a positive number");
    }
    if (milliseconds === Infinity) {
      resolve(promise);
      return;
    }
    const timer = setTimeout(() => {
      if (typeof fallback === "function") {
        try {
          resolve(fallback());
        } catch (error) {
          reject(error);
        }
        return;
      }
      const message = typeof fallback === "string" ? fallback : `Promise timed out after ${milliseconds} milliseconds`;
      const timeoutError = fallback instanceof Error ? fallback : new TimeoutError(message);
      if (typeof promise.cancel === "function") {
        promise.cancel();
      }
      reject(timeoutError);
    }, milliseconds);
    pFinally(promise.then(resolve, reject), () => {
      clearTimeout(timer);
    });
  });
  module2.exports = pTimeout;
  module2.exports.default = pTimeout;
  module2.exports.TimeoutError = TimeoutError;
});

// node_modules/p-queue/dist/lower-bound.js
var require_lower_bound = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  function lowerBound(array, value, comparator) {
    let first = 0;
    let count = array.length;
    while (count > 0) {
      const step = count / 2 | 0;
      let it = first + step;
      if (comparator(array[it], value) <= 0) {
        first = ++it;
        count -= step + 1;
      } else {
        count = step;
      }
    }
    return first;
  }
  exports2.default = lowerBound;
});

// node_modules/p-queue/dist/priority-queue.js
var require_priority_queue = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  var lower_bound_1 = require_lower_bound();
  var PriorityQueue = class {
    constructor() {
      this._queue = [];
    }
    enqueue(run, options) {
      options = Object.assign({priority: 0}, options);
      const element = {
        priority: options.priority,
        run
      };
      if (this.size && this._queue[this.size - 1].priority >= options.priority) {
        this._queue.push(element);
        return;
      }
      const index = lower_bound_1.default(this._queue, element, (a, b) => b.priority - a.priority);
      this._queue.splice(index, 0, element);
    }
    dequeue() {
      const item = this._queue.shift();
      return item === null || item === void 0 ? void 0 : item.run;
    }
    filter(options) {
      return this._queue.filter((element) => element.priority === options.priority).map((element) => element.run);
    }
    get size() {
      return this._queue.length;
    }
  };
  exports2.default = PriorityQueue;
});

// node_modules/p-queue/dist/index.js
var require_dist = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  var EventEmitter = require_eventemitter3();
  var p_timeout_1 = require_p_timeout();
  var priority_queue_1 = require_priority_queue();
  var empty = () => {
  };
  var timeoutError = new p_timeout_1.TimeoutError();
  var PQueue = class extends EventEmitter {
    constructor(options) {
      var _a, _b, _c, _d;
      super();
      this._intervalCount = 0;
      this._intervalEnd = 0;
      this._pendingCount = 0;
      this._resolveEmpty = empty;
      this._resolveIdle = empty;
      options = Object.assign({carryoverConcurrencyCount: false, intervalCap: Infinity, interval: 0, concurrency: Infinity, autoStart: true, queueClass: priority_queue_1.default}, options);
      if (!(typeof options.intervalCap === "number" && options.intervalCap >= 1)) {
        throw new TypeError(`Expected \`intervalCap\` to be a number from 1 and up, got \`${(_b = (_a = options.intervalCap) === null || _a === void 0 ? void 0 : _a.toString()) !== null && _b !== void 0 ? _b : ""}\` (${typeof options.intervalCap})`);
      }
      if (options.interval === void 0 || !(Number.isFinite(options.interval) && options.interval >= 0)) {
        throw new TypeError(`Expected \`interval\` to be a finite number >= 0, got \`${(_d = (_c = options.interval) === null || _c === void 0 ? void 0 : _c.toString()) !== null && _d !== void 0 ? _d : ""}\` (${typeof options.interval})`);
      }
      this._carryoverConcurrencyCount = options.carryoverConcurrencyCount;
      this._isIntervalIgnored = options.intervalCap === Infinity || options.interval === 0;
      this._intervalCap = options.intervalCap;
      this._interval = options.interval;
      this._queue = new options.queueClass();
      this._queueClass = options.queueClass;
      this.concurrency = options.concurrency;
      this._timeout = options.timeout;
      this._throwOnTimeout = options.throwOnTimeout === true;
      this._isPaused = options.autoStart === false;
    }
    get _doesIntervalAllowAnother() {
      return this._isIntervalIgnored || this._intervalCount < this._intervalCap;
    }
    get _doesConcurrentAllowAnother() {
      return this._pendingCount < this._concurrency;
    }
    _next() {
      this._pendingCount--;
      this._tryToStartAnother();
      this.emit("next");
    }
    _resolvePromises() {
      this._resolveEmpty();
      this._resolveEmpty = empty;
      if (this._pendingCount === 0) {
        this._resolveIdle();
        this._resolveIdle = empty;
        this.emit("idle");
      }
    }
    _onResumeInterval() {
      this._onInterval();
      this._initializeIntervalIfNeeded();
      this._timeoutId = void 0;
    }
    _isIntervalPaused() {
      const now = Date.now();
      if (this._intervalId === void 0) {
        const delay = this._intervalEnd - now;
        if (delay < 0) {
          this._intervalCount = this._carryoverConcurrencyCount ? this._pendingCount : 0;
        } else {
          if (this._timeoutId === void 0) {
            this._timeoutId = setTimeout(() => {
              this._onResumeInterval();
            }, delay);
          }
          return true;
        }
      }
      return false;
    }
    _tryToStartAnother() {
      if (this._queue.size === 0) {
        if (this._intervalId) {
          clearInterval(this._intervalId);
        }
        this._intervalId = void 0;
        this._resolvePromises();
        return false;
      }
      if (!this._isPaused) {
        const canInitializeInterval = !this._isIntervalPaused();
        if (this._doesIntervalAllowAnother && this._doesConcurrentAllowAnother) {
          const job = this._queue.dequeue();
          if (!job) {
            return false;
          }
          this.emit("active");
          job();
          if (canInitializeInterval) {
            this._initializeIntervalIfNeeded();
          }
          return true;
        }
      }
      return false;
    }
    _initializeIntervalIfNeeded() {
      if (this._isIntervalIgnored || this._intervalId !== void 0) {
        return;
      }
      this._intervalId = setInterval(() => {
        this._onInterval();
      }, this._interval);
      this._intervalEnd = Date.now() + this._interval;
    }
    _onInterval() {
      if (this._intervalCount === 0 && this._pendingCount === 0 && this._intervalId) {
        clearInterval(this._intervalId);
        this._intervalId = void 0;
      }
      this._intervalCount = this._carryoverConcurrencyCount ? this._pendingCount : 0;
      this._processQueue();
    }
    _processQueue() {
      while (this._tryToStartAnother()) {
      }
    }
    get concurrency() {
      return this._concurrency;
    }
    set concurrency(newConcurrency) {
      if (!(typeof newConcurrency === "number" && newConcurrency >= 1)) {
        throw new TypeError(`Expected \`concurrency\` to be a number from 1 and up, got \`${newConcurrency}\` (${typeof newConcurrency})`);
      }
      this._concurrency = newConcurrency;
      this._processQueue();
    }
    async add(fn, options = {}) {
      return new Promise((resolve, reject) => {
        const run = async () => {
          this._pendingCount++;
          this._intervalCount++;
          try {
            const operation = this._timeout === void 0 && options.timeout === void 0 ? fn() : p_timeout_1.default(Promise.resolve(fn()), options.timeout === void 0 ? this._timeout : options.timeout, () => {
              if (options.throwOnTimeout === void 0 ? this._throwOnTimeout : options.throwOnTimeout) {
                reject(timeoutError);
              }
              return void 0;
            });
            resolve(await operation);
          } catch (error) {
            reject(error);
          }
          this._next();
        };
        this._queue.enqueue(run, options);
        this._tryToStartAnother();
        this.emit("add");
      });
    }
    async addAll(functions, options) {
      return Promise.all(functions.map(async (function_) => this.add(function_, options)));
    }
    start() {
      if (!this._isPaused) {
        return this;
      }
      this._isPaused = false;
      this._processQueue();
      return this;
    }
    pause() {
      this._isPaused = true;
    }
    clear() {
      this._queue = new this._queueClass();
    }
    async onEmpty() {
      if (this._queue.size === 0) {
        return;
      }
      return new Promise((resolve) => {
        const existingResolve = this._resolveEmpty;
        this._resolveEmpty = () => {
          existingResolve();
          resolve();
        };
      });
    }
    async onIdle() {
      if (this._pendingCount === 0 && this._queue.size === 0) {
        return;
      }
      return new Promise((resolve) => {
        const existingResolve = this._resolveIdle;
        this._resolveIdle = () => {
          existingResolve();
          resolve();
        };
      });
    }
    get size() {
      return this._queue.size;
    }
    sizeBy(options) {
      return this._queue.filter(options).length;
    }
    get pending() {
      return this._pendingCount;
    }
    get isPaused() {
      return this._isPaused;
    }
    get timeout() {
      return this._timeout;
    }
    set timeout(milliseconds) {
      this._timeout = milliseconds;
    }
  };
  exports2.default = PQueue;
});

// node_modules/ipfs-core/src/runtime/dns-browser.js
var require_dns_browser = __commonJS((exports2, module2) => {
  "use strict";
  var TLRU = require_tlru();
  var {default: PQueue} = require_dist();
  var HTTP = require_http();
  var cache = new TLRU(1e3);
  var ttl = 60 * 1e3;
  var httpQueue = new PQueue({concurrency: 4});
  var ipfsPath = (response) => {
    if (response.Path)
      return response.Path;
    throw new Error(response.Message);
  };
  module2.exports = async (fqdn, opts) => {
    const resolveDnslink = async (fqdn2, opts2 = {}) => {
      const searchParams = new URLSearchParams(opts2);
      searchParams.set("arg", fqdn2);
      const query = searchParams.toString();
      if (!opts2.nocache && cache.has(query)) {
        const response2 = cache.get(query);
        return ipfsPath(response2);
      }
      const response = await httpQueue.add(async () => {
        const res = await HTTP.get("https://ipfs.io/api/v0/dns", {searchParams});
        const query2 = new URL(res.url).search.slice(1);
        const json = await res.json();
        cache.set(query2, json, ttl);
        return json;
      });
      return ipfsPath(response);
    };
    return resolveDnslink(fqdn, opts);
  };
});

// node_modules/ipfs-core/src/components/dns.js
var require_dns = __commonJS((exports2, module2) => {
  "use strict";
  var dns = require_dns_browser();
  var withTimeoutOption = require_with_timeout_option();
  function fqdnFixups(domain) {
    if (domain.endsWith(".eth")) {
      domain = domain.replace(/.eth$/, ".eth.link");
    }
    return domain;
  }
  module2.exports = () => {
    const resolveDNS = async (domain, options = {}) => {
      if (typeof domain !== "string") {
        throw new Error("Invalid arguments, domain must be a string");
      }
      domain = fqdnFixups(domain);
      return dns(domain, options);
    };
    return withTimeoutOption(resolveDNS);
  };
});

// node_modules/ipfs-core/src/components/is-online.js
var require_is_online = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = ({network}) => () => {
    const net = network.try();
    return net != null && Boolean(net.libp2p.isStarted());
  };
});

// node_modules/ipfs-core-utils/src/cid.js
var require_cid = __commonJS((exports2) => {
  "use strict";
  var CID = require_src7();
  exports2.cidToString = (input, options = {}) => {
    const upgrade = options.upgrade !== false;
    let cid = CID.isCID(input) ? input : new CID(input);
    if (cid.version === 0 && options.base && options.base !== "base58btc") {
      if (!upgrade)
        return cid.toString();
      cid = cid.toV1();
    }
    return cid.toBaseEncodedString(options.base);
  };
});

// node_modules/ipfs-core/src/components/resolve.js
var require_resolve = __commonJS((exports2, module2) => {
  "use strict";
  var isIpfs = require_src13();
  var CID = require_src7();
  var {cidToString} = require_cid();
  var withTimeoutOption = require_with_timeout_option();
  module2.exports = ({ipld, name}) => {
    async function resolve(path, opts = {}) {
      if (!isIpfs.path(path)) {
        throw new Error("invalid argument " + path);
      }
      if (isIpfs.ipnsPath(path)) {
        if (!name) {
          throw new Error("failed to resolve IPNS path: name API unavailable");
        }
        for await (const resolvedPath of name.resolve(path, opts)) {
          path = resolvedPath;
        }
      }
      const [, , hash, ...rest] = path.split("/");
      const cid = new CID(hash);
      if (rest.length === 0) {
        return `/ipfs/${cidToString(cid, {base: opts.cidBase})}`;
      }
      path = rest.join("/");
      const results = ipld.resolve(cid, path);
      let value = cid;
      let remainderPath = path;
      for await (const result of results) {
        if (CID.isCID(result.value)) {
          value = result.value;
          remainderPath = result.remainderPath;
        }
      }
      return `/ipfs/${cidToString(value, {base: opts.cidBase})}${remainderPath ? "/" + remainderPath : ""}`;
    }
    return withTimeoutOption(resolve);
  };
});

// node_modules/it-last/index.js
var require_it_last = __commonJS((exports2, module2) => {
  "use strict";
  var last = async (source) => {
    let res;
    for await (const entry of source) {
      res = entry;
    }
    return res;
  };
  module2.exports = last;
});

// node_modules/ipfs-core/src/components/pin/add.js
var require_add = __commonJS((exports2, module2) => {
  "use strict";
  var last = require_it_last();
  module2.exports = ({addAll}) => async (path, options = {}) => await last(addAll({path, ...options}, options));
});

// node_modules/bignumber.js/bignumber.js
var require_bignumber = __commonJS((exports2, module2) => {
  (function(globalObject) {
    "use strict";
    var BigNumber, isNumeric = /^-?(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?$/i, mathceil = Math.ceil, mathfloor = Math.floor, bignumberError = "[BigNumber Error] ", tooManyDigits = bignumberError + "Number primitive has more than 15 significant digits: ", BASE = 1e14, LOG_BASE = 14, MAX_SAFE_INTEGER = 9007199254740991, POWS_TEN = [1, 10, 100, 1e3, 1e4, 1e5, 1e6, 1e7, 1e8, 1e9, 1e10, 1e11, 1e12, 1e13], SQRT_BASE = 1e7, MAX = 1e9;
    function clone(configObject) {
      var div, convertBase, parseNumeric, P = BigNumber2.prototype = {constructor: BigNumber2, toString: null, valueOf: null}, ONE = new BigNumber2(1), DECIMAL_PLACES = 20, ROUNDING_MODE = 4, TO_EXP_NEG = -7, TO_EXP_POS = 21, MIN_EXP = -1e7, MAX_EXP = 1e7, CRYPTO = false, MODULO_MODE = 1, POW_PRECISION = 0, FORMAT = {
        prefix: "",
        groupSize: 3,
        secondaryGroupSize: 0,
        groupSeparator: ",",
        decimalSeparator: ".",
        fractionGroupSize: 0,
        fractionGroupSeparator: "\xA0",
        suffix: ""
      }, ALPHABET = "0123456789abcdefghijklmnopqrstuvwxyz";
      function BigNumber2(v, b) {
        var alphabet, c, caseChanged, e, i, isNum, len, str, x = this;
        if (!(x instanceof BigNumber2))
          return new BigNumber2(v, b);
        if (b == null) {
          if (v && v._isBigNumber === true) {
            x.s = v.s;
            if (!v.c || v.e > MAX_EXP) {
              x.c = x.e = null;
            } else if (v.e < MIN_EXP) {
              x.c = [x.e = 0];
            } else {
              x.e = v.e;
              x.c = v.c.slice();
            }
            return;
          }
          if ((isNum = typeof v == "number") && v * 0 == 0) {
            x.s = 1 / v < 0 ? (v = -v, -1) : 1;
            if (v === ~~v) {
              for (e = 0, i = v; i >= 10; i /= 10, e++)
                ;
              if (e > MAX_EXP) {
                x.c = x.e = null;
              } else {
                x.e = e;
                x.c = [v];
              }
              return;
            }
            str = String(v);
          } else {
            if (!isNumeric.test(str = String(v)))
              return parseNumeric(x, str, isNum);
            x.s = str.charCodeAt(0) == 45 ? (str = str.slice(1), -1) : 1;
          }
          if ((e = str.indexOf(".")) > -1)
            str = str.replace(".", "");
          if ((i = str.search(/e/i)) > 0) {
            if (e < 0)
              e = i;
            e += +str.slice(i + 1);
            str = str.substring(0, i);
          } else if (e < 0) {
            e = str.length;
          }
        } else {
          intCheck(b, 2, ALPHABET.length, "Base");
          if (b == 10) {
            x = new BigNumber2(v);
            return round(x, DECIMAL_PLACES + x.e + 1, ROUNDING_MODE);
          }
          str = String(v);
          if (isNum = typeof v == "number") {
            if (v * 0 != 0)
              return parseNumeric(x, str, isNum, b);
            x.s = 1 / v < 0 ? (str = str.slice(1), -1) : 1;
            if (BigNumber2.DEBUG && str.replace(/^0\.0*|\./, "").length > 15) {
              throw Error(tooManyDigits + v);
            }
          } else {
            x.s = str.charCodeAt(0) === 45 ? (str = str.slice(1), -1) : 1;
          }
          alphabet = ALPHABET.slice(0, b);
          e = i = 0;
          for (len = str.length; i < len; i++) {
            if (alphabet.indexOf(c = str.charAt(i)) < 0) {
              if (c == ".") {
                if (i > e) {
                  e = len;
                  continue;
                }
              } else if (!caseChanged) {
                if (str == str.toUpperCase() && (str = str.toLowerCase()) || str == str.toLowerCase() && (str = str.toUpperCase())) {
                  caseChanged = true;
                  i = -1;
                  e = 0;
                  continue;
                }
              }
              return parseNumeric(x, String(v), isNum, b);
            }
          }
          isNum = false;
          str = convertBase(str, b, 10, x.s);
          if ((e = str.indexOf(".")) > -1)
            str = str.replace(".", "");
          else
            e = str.length;
        }
        for (i = 0; str.charCodeAt(i) === 48; i++)
          ;
        for (len = str.length; str.charCodeAt(--len) === 48; )
          ;
        if (str = str.slice(i, ++len)) {
          len -= i;
          if (isNum && BigNumber2.DEBUG && len > 15 && (v > MAX_SAFE_INTEGER || v !== mathfloor(v))) {
            throw Error(tooManyDigits + x.s * v);
          }
          if ((e = e - i - 1) > MAX_EXP) {
            x.c = x.e = null;
          } else if (e < MIN_EXP) {
            x.c = [x.e = 0];
          } else {
            x.e = e;
            x.c = [];
            i = (e + 1) % LOG_BASE;
            if (e < 0)
              i += LOG_BASE;
            if (i < len) {
              if (i)
                x.c.push(+str.slice(0, i));
              for (len -= LOG_BASE; i < len; ) {
                x.c.push(+str.slice(i, i += LOG_BASE));
              }
              i = LOG_BASE - (str = str.slice(i)).length;
            } else {
              i -= len;
            }
            for (; i--; str += "0")
              ;
            x.c.push(+str);
          }
        } else {
          x.c = [x.e = 0];
        }
      }
      BigNumber2.clone = clone;
      BigNumber2.ROUND_UP = 0;
      BigNumber2.ROUND_DOWN = 1;
      BigNumber2.ROUND_CEIL = 2;
      BigNumber2.ROUND_FLOOR = 3;
      BigNumber2.ROUND_HALF_UP = 4;
      BigNumber2.ROUND_HALF_DOWN = 5;
      BigNumber2.ROUND_HALF_EVEN = 6;
      BigNumber2.ROUND_HALF_CEIL = 7;
      BigNumber2.ROUND_HALF_FLOOR = 8;
      BigNumber2.EUCLID = 9;
      BigNumber2.config = BigNumber2.set = function(obj) {
        var p, v;
        if (obj != null) {
          if (typeof obj == "object") {
            if (obj.hasOwnProperty(p = "DECIMAL_PLACES")) {
              v = obj[p];
              intCheck(v, 0, MAX, p);
              DECIMAL_PLACES = v;
            }
            if (obj.hasOwnProperty(p = "ROUNDING_MODE")) {
              v = obj[p];
              intCheck(v, 0, 8, p);
              ROUNDING_MODE = v;
            }
            if (obj.hasOwnProperty(p = "EXPONENTIAL_AT")) {
              v = obj[p];
              if (v && v.pop) {
                intCheck(v[0], -MAX, 0, p);
                intCheck(v[1], 0, MAX, p);
                TO_EXP_NEG = v[0];
                TO_EXP_POS = v[1];
              } else {
                intCheck(v, -MAX, MAX, p);
                TO_EXP_NEG = -(TO_EXP_POS = v < 0 ? -v : v);
              }
            }
            if (obj.hasOwnProperty(p = "RANGE")) {
              v = obj[p];
              if (v && v.pop) {
                intCheck(v[0], -MAX, -1, p);
                intCheck(v[1], 1, MAX, p);
                MIN_EXP = v[0];
                MAX_EXP = v[1];
              } else {
                intCheck(v, -MAX, MAX, p);
                if (v) {
                  MIN_EXP = -(MAX_EXP = v < 0 ? -v : v);
                } else {
                  throw Error(bignumberError + p + " cannot be zero: " + v);
                }
              }
            }
            if (obj.hasOwnProperty(p = "CRYPTO")) {
              v = obj[p];
              if (v === !!v) {
                if (v) {
                  if (typeof crypto != "undefined" && crypto && (crypto.getRandomValues || crypto.randomBytes)) {
                    CRYPTO = v;
                  } else {
                    CRYPTO = !v;
                    throw Error(bignumberError + "crypto unavailable");
                  }
                } else {
                  CRYPTO = v;
                }
              } else {
                throw Error(bignumberError + p + " not true or false: " + v);
              }
            }
            if (obj.hasOwnProperty(p = "MODULO_MODE")) {
              v = obj[p];
              intCheck(v, 0, 9, p);
              MODULO_MODE = v;
            }
            if (obj.hasOwnProperty(p = "POW_PRECISION")) {
              v = obj[p];
              intCheck(v, 0, MAX, p);
              POW_PRECISION = v;
            }
            if (obj.hasOwnProperty(p = "FORMAT")) {
              v = obj[p];
              if (typeof v == "object")
                FORMAT = v;
              else
                throw Error(bignumberError + p + " not an object: " + v);
            }
            if (obj.hasOwnProperty(p = "ALPHABET")) {
              v = obj[p];
              if (typeof v == "string" && !/^.?$|[+\-.\s]|(.).*\1/.test(v)) {
                ALPHABET = v;
              } else {
                throw Error(bignumberError + p + " invalid: " + v);
              }
            }
          } else {
            throw Error(bignumberError + "Object expected: " + obj);
          }
        }
        return {
          DECIMAL_PLACES,
          ROUNDING_MODE,
          EXPONENTIAL_AT: [TO_EXP_NEG, TO_EXP_POS],
          RANGE: [MIN_EXP, MAX_EXP],
          CRYPTO,
          MODULO_MODE,
          POW_PRECISION,
          FORMAT,
          ALPHABET
        };
      };
      BigNumber2.isBigNumber = function(v) {
        if (!v || v._isBigNumber !== true)
          return false;
        if (!BigNumber2.DEBUG)
          return true;
        var i, n, c = v.c, e = v.e, s = v.s;
        out:
          if ({}.toString.call(c) == "[object Array]") {
            if ((s === 1 || s === -1) && e >= -MAX && e <= MAX && e === mathfloor(e)) {
              if (c[0] === 0) {
                if (e === 0 && c.length === 1)
                  return true;
                break out;
              }
              i = (e + 1) % LOG_BASE;
              if (i < 1)
                i += LOG_BASE;
              if (String(c[0]).length == i) {
                for (i = 0; i < c.length; i++) {
                  n = c[i];
                  if (n < 0 || n >= BASE || n !== mathfloor(n))
                    break out;
                }
                if (n !== 0)
                  return true;
              }
            }
          } else if (c === null && e === null && (s === null || s === 1 || s === -1)) {
            return true;
          }
        throw Error(bignumberError + "Invalid BigNumber: " + v);
      };
      BigNumber2.maximum = BigNumber2.max = function() {
        return maxOrMin(arguments, P.lt);
      };
      BigNumber2.minimum = BigNumber2.min = function() {
        return maxOrMin(arguments, P.gt);
      };
      BigNumber2.random = function() {
        var pow2_53 = 9007199254740992;
        var random53bitInt = Math.random() * pow2_53 & 2097151 ? function() {
          return mathfloor(Math.random() * pow2_53);
        } : function() {
          return (Math.random() * 1073741824 | 0) * 8388608 + (Math.random() * 8388608 | 0);
        };
        return function(dp) {
          var a, b, e, k, v, i = 0, c = [], rand = new BigNumber2(ONE);
          if (dp == null)
            dp = DECIMAL_PLACES;
          else
            intCheck(dp, 0, MAX);
          k = mathceil(dp / LOG_BASE);
          if (CRYPTO) {
            if (crypto.getRandomValues) {
              a = crypto.getRandomValues(new Uint32Array(k *= 2));
              for (; i < k; ) {
                v = a[i] * 131072 + (a[i + 1] >>> 11);
                if (v >= 9e15) {
                  b = crypto.getRandomValues(new Uint32Array(2));
                  a[i] = b[0];
                  a[i + 1] = b[1];
                } else {
                  c.push(v % 1e14);
                  i += 2;
                }
              }
              i = k / 2;
            } else if (crypto.randomBytes) {
              a = crypto.randomBytes(k *= 7);
              for (; i < k; ) {
                v = (a[i] & 31) * 281474976710656 + a[i + 1] * 1099511627776 + a[i + 2] * 4294967296 + a[i + 3] * 16777216 + (a[i + 4] << 16) + (a[i + 5] << 8) + a[i + 6];
                if (v >= 9e15) {
                  crypto.randomBytes(7).copy(a, i);
                } else {
                  c.push(v % 1e14);
                  i += 7;
                }
              }
              i = k / 7;
            } else {
              CRYPTO = false;
              throw Error(bignumberError + "crypto unavailable");
            }
          }
          if (!CRYPTO) {
            for (; i < k; ) {
              v = random53bitInt();
              if (v < 9e15)
                c[i++] = v % 1e14;
            }
          }
          k = c[--i];
          dp %= LOG_BASE;
          if (k && dp) {
            v = POWS_TEN[LOG_BASE - dp];
            c[i] = mathfloor(k / v) * v;
          }
          for (; c[i] === 0; c.pop(), i--)
            ;
          if (i < 0) {
            c = [e = 0];
          } else {
            for (e = -1; c[0] === 0; c.splice(0, 1), e -= LOG_BASE)
              ;
            for (i = 1, v = c[0]; v >= 10; v /= 10, i++)
              ;
            if (i < LOG_BASE)
              e -= LOG_BASE - i;
          }
          rand.e = e;
          rand.c = c;
          return rand;
        };
      }();
      BigNumber2.sum = function() {
        var i = 1, args = arguments, sum = new BigNumber2(args[0]);
        for (; i < args.length; )
          sum = sum.plus(args[i++]);
        return sum;
      };
      convertBase = function() {
        var decimal = "0123456789";
        function toBaseOut(str, baseIn, baseOut, alphabet) {
          var j, arr = [0], arrL, i = 0, len = str.length;
          for (; i < len; ) {
            for (arrL = arr.length; arrL--; arr[arrL] *= baseIn)
              ;
            arr[0] += alphabet.indexOf(str.charAt(i++));
            for (j = 0; j < arr.length; j++) {
              if (arr[j] > baseOut - 1) {
                if (arr[j + 1] == null)
                  arr[j + 1] = 0;
                arr[j + 1] += arr[j] / baseOut | 0;
                arr[j] %= baseOut;
              }
            }
          }
          return arr.reverse();
        }
        return function(str, baseIn, baseOut, sign, callerIsToString) {
          var alphabet, d, e, k, r, x, xc, y, i = str.indexOf("."), dp = DECIMAL_PLACES, rm = ROUNDING_MODE;
          if (i >= 0) {
            k = POW_PRECISION;
            POW_PRECISION = 0;
            str = str.replace(".", "");
            y = new BigNumber2(baseIn);
            x = y.pow(str.length - i);
            POW_PRECISION = k;
            y.c = toBaseOut(toFixedPoint(coeffToString(x.c), x.e, "0"), 10, baseOut, decimal);
            y.e = y.c.length;
          }
          xc = toBaseOut(str, baseIn, baseOut, callerIsToString ? (alphabet = ALPHABET, decimal) : (alphabet = decimal, ALPHABET));
          e = k = xc.length;
          for (; xc[--k] == 0; xc.pop())
            ;
          if (!xc[0])
            return alphabet.charAt(0);
          if (i < 0) {
            --e;
          } else {
            x.c = xc;
            x.e = e;
            x.s = sign;
            x = div(x, y, dp, rm, baseOut);
            xc = x.c;
            r = x.r;
            e = x.e;
          }
          d = e + dp + 1;
          i = xc[d];
          k = baseOut / 2;
          r = r || d < 0 || xc[d + 1] != null;
          r = rm < 4 ? (i != null || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2)) : i > k || i == k && (rm == 4 || r || rm == 6 && xc[d - 1] & 1 || rm == (x.s < 0 ? 8 : 7));
          if (d < 1 || !xc[0]) {
            str = r ? toFixedPoint(alphabet.charAt(1), -dp, alphabet.charAt(0)) : alphabet.charAt(0);
          } else {
            xc.length = d;
            if (r) {
              for (--baseOut; ++xc[--d] > baseOut; ) {
                xc[d] = 0;
                if (!d) {
                  ++e;
                  xc = [1].concat(xc);
                }
              }
            }
            for (k = xc.length; !xc[--k]; )
              ;
            for (i = 0, str = ""; i <= k; str += alphabet.charAt(xc[i++]))
              ;
            str = toFixedPoint(str, e, alphabet.charAt(0));
          }
          return str;
        };
      }();
      div = function() {
        function multiply(x, k, base) {
          var m, temp, xlo, xhi, carry = 0, i = x.length, klo = k % SQRT_BASE, khi = k / SQRT_BASE | 0;
          for (x = x.slice(); i--; ) {
            xlo = x[i] % SQRT_BASE;
            xhi = x[i] / SQRT_BASE | 0;
            m = khi * xlo + xhi * klo;
            temp = klo * xlo + m % SQRT_BASE * SQRT_BASE + carry;
            carry = (temp / base | 0) + (m / SQRT_BASE | 0) + khi * xhi;
            x[i] = temp % base;
          }
          if (carry)
            x = [carry].concat(x);
          return x;
        }
        function compare2(a, b, aL, bL) {
          var i, cmp;
          if (aL != bL) {
            cmp = aL > bL ? 1 : -1;
          } else {
            for (i = cmp = 0; i < aL; i++) {
              if (a[i] != b[i]) {
                cmp = a[i] > b[i] ? 1 : -1;
                break;
              }
            }
          }
          return cmp;
        }
        function subtract(a, b, aL, base) {
          var i = 0;
          for (; aL--; ) {
            a[aL] -= i;
            i = a[aL] < b[aL] ? 1 : 0;
            a[aL] = i * base + a[aL] - b[aL];
          }
          for (; !a[0] && a.length > 1; a.splice(0, 1))
            ;
        }
        return function(x, y, dp, rm, base) {
          var cmp, e, i, more, n, prod, prodL, q, qc, rem, remL, rem0, xi, xL, yc0, yL, yz, s = x.s == y.s ? 1 : -1, xc = x.c, yc = y.c;
          if (!xc || !xc[0] || !yc || !yc[0]) {
            return new BigNumber2(!x.s || !y.s || (xc ? yc && xc[0] == yc[0] : !yc) ? NaN : xc && xc[0] == 0 || !yc ? s * 0 : s / 0);
          }
          q = new BigNumber2(s);
          qc = q.c = [];
          e = x.e - y.e;
          s = dp + e + 1;
          if (!base) {
            base = BASE;
            e = bitFloor(x.e / LOG_BASE) - bitFloor(y.e / LOG_BASE);
            s = s / LOG_BASE | 0;
          }
          for (i = 0; yc[i] == (xc[i] || 0); i++)
            ;
          if (yc[i] > (xc[i] || 0))
            e--;
          if (s < 0) {
            qc.push(1);
            more = true;
          } else {
            xL = xc.length;
            yL = yc.length;
            i = 0;
            s += 2;
            n = mathfloor(base / (yc[0] + 1));
            if (n > 1) {
              yc = multiply(yc, n, base);
              xc = multiply(xc, n, base);
              yL = yc.length;
              xL = xc.length;
            }
            xi = yL;
            rem = xc.slice(0, yL);
            remL = rem.length;
            for (; remL < yL; rem[remL++] = 0)
              ;
            yz = yc.slice();
            yz = [0].concat(yz);
            yc0 = yc[0];
            if (yc[1] >= base / 2)
              yc0++;
            do {
              n = 0;
              cmp = compare2(yc, rem, yL, remL);
              if (cmp < 0) {
                rem0 = rem[0];
                if (yL != remL)
                  rem0 = rem0 * base + (rem[1] || 0);
                n = mathfloor(rem0 / yc0);
                if (n > 1) {
                  if (n >= base)
                    n = base - 1;
                  prod = multiply(yc, n, base);
                  prodL = prod.length;
                  remL = rem.length;
                  while (compare2(prod, rem, prodL, remL) == 1) {
                    n--;
                    subtract(prod, yL < prodL ? yz : yc, prodL, base);
                    prodL = prod.length;
                    cmp = 1;
                  }
                } else {
                  if (n == 0) {
                    cmp = n = 1;
                  }
                  prod = yc.slice();
                  prodL = prod.length;
                }
                if (prodL < remL)
                  prod = [0].concat(prod);
                subtract(rem, prod, remL, base);
                remL = rem.length;
                if (cmp == -1) {
                  while (compare2(yc, rem, yL, remL) < 1) {
                    n++;
                    subtract(rem, yL < remL ? yz : yc, remL, base);
                    remL = rem.length;
                  }
                }
              } else if (cmp === 0) {
                n++;
                rem = [0];
              }
              qc[i++] = n;
              if (rem[0]) {
                rem[remL++] = xc[xi] || 0;
              } else {
                rem = [xc[xi]];
                remL = 1;
              }
            } while ((xi++ < xL || rem[0] != null) && s--);
            more = rem[0] != null;
            if (!qc[0])
              qc.splice(0, 1);
          }
          if (base == BASE) {
            for (i = 1, s = qc[0]; s >= 10; s /= 10, i++)
              ;
            round(q, dp + (q.e = i + e * LOG_BASE - 1) + 1, rm, more);
          } else {
            q.e = e;
            q.r = +more;
          }
          return q;
        };
      }();
      function format(n, i, rm, id) {
        var c0, e, ne, len, str;
        if (rm == null)
          rm = ROUNDING_MODE;
        else
          intCheck(rm, 0, 8);
        if (!n.c)
          return n.toString();
        c0 = n.c[0];
        ne = n.e;
        if (i == null) {
          str = coeffToString(n.c);
          str = id == 1 || id == 2 && (ne <= TO_EXP_NEG || ne >= TO_EXP_POS) ? toExponential(str, ne) : toFixedPoint(str, ne, "0");
        } else {
          n = round(new BigNumber2(n), i, rm);
          e = n.e;
          str = coeffToString(n.c);
          len = str.length;
          if (id == 1 || id == 2 && (i <= e || e <= TO_EXP_NEG)) {
            for (; len < i; str += "0", len++)
              ;
            str = toExponential(str, e);
          } else {
            i -= ne;
            str = toFixedPoint(str, e, "0");
            if (e + 1 > len) {
              if (--i > 0)
                for (str += "."; i--; str += "0")
                  ;
            } else {
              i += e - len;
              if (i > 0) {
                if (e + 1 == len)
                  str += ".";
                for (; i--; str += "0")
                  ;
              }
            }
          }
        }
        return n.s < 0 && c0 ? "-" + str : str;
      }
      function maxOrMin(args, method) {
        var n, i = 1, m = new BigNumber2(args[0]);
        for (; i < args.length; i++) {
          n = new BigNumber2(args[i]);
          if (!n.s) {
            m = n;
            break;
          } else if (method.call(m, n)) {
            m = n;
          }
        }
        return m;
      }
      function normalise(n, c, e) {
        var i = 1, j = c.length;
        for (; !c[--j]; c.pop())
          ;
        for (j = c[0]; j >= 10; j /= 10, i++)
          ;
        if ((e = i + e * LOG_BASE - 1) > MAX_EXP) {
          n.c = n.e = null;
        } else if (e < MIN_EXP) {
          n.c = [n.e = 0];
        } else {
          n.e = e;
          n.c = c;
        }
        return n;
      }
      parseNumeric = function() {
        var basePrefix = /^(-?)0([xbo])(?=\w[\w.]*$)/i, dotAfter = /^([^.]+)\.$/, dotBefore = /^\.([^.]+)$/, isInfinityOrNaN = /^-?(Infinity|NaN)$/, whitespaceOrPlus = /^\s*\+(?=[\w.])|^\s+|\s+$/g;
        return function(x, str, isNum, b) {
          var base, s = isNum ? str : str.replace(whitespaceOrPlus, "");
          if (isInfinityOrNaN.test(s)) {
            x.s = isNaN(s) ? null : s < 0 ? -1 : 1;
          } else {
            if (!isNum) {
              s = s.replace(basePrefix, function(m, p1, p2) {
                base = (p2 = p2.toLowerCase()) == "x" ? 16 : p2 == "b" ? 2 : 8;
                return !b || b == base ? p1 : m;
              });
              if (b) {
                base = b;
                s = s.replace(dotAfter, "$1").replace(dotBefore, "0.$1");
              }
              if (str != s)
                return new BigNumber2(s, base);
            }
            if (BigNumber2.DEBUG) {
              throw Error(bignumberError + "Not a" + (b ? " base " + b : "") + " number: " + str);
            }
            x.s = null;
          }
          x.c = x.e = null;
        };
      }();
      function round(x, sd, rm, r) {
        var d, i, j, k, n, ni, rd, xc = x.c, pows10 = POWS_TEN;
        if (xc) {
          out: {
            for (d = 1, k = xc[0]; k >= 10; k /= 10, d++)
              ;
            i = sd - d;
            if (i < 0) {
              i += LOG_BASE;
              j = sd;
              n = xc[ni = 0];
              rd = n / pows10[d - j - 1] % 10 | 0;
            } else {
              ni = mathceil((i + 1) / LOG_BASE);
              if (ni >= xc.length) {
                if (r) {
                  for (; xc.length <= ni; xc.push(0))
                    ;
                  n = rd = 0;
                  d = 1;
                  i %= LOG_BASE;
                  j = i - LOG_BASE + 1;
                } else {
                  break out;
                }
              } else {
                n = k = xc[ni];
                for (d = 1; k >= 10; k /= 10, d++)
                  ;
                i %= LOG_BASE;
                j = i - LOG_BASE + d;
                rd = j < 0 ? 0 : n / pows10[d - j - 1] % 10 | 0;
              }
            }
            r = r || sd < 0 || xc[ni + 1] != null || (j < 0 ? n : n % pows10[d - j - 1]);
            r = rm < 4 ? (rd || r) && (rm == 0 || rm == (x.s < 0 ? 3 : 2)) : rd > 5 || rd == 5 && (rm == 4 || r || rm == 6 && (i > 0 ? j > 0 ? n / pows10[d - j] : 0 : xc[ni - 1]) % 10 & 1 || rm == (x.s < 0 ? 8 : 7));
            if (sd < 1 || !xc[0]) {
              xc.length = 0;
              if (r) {
                sd -= x.e + 1;
                xc[0] = pows10[(LOG_BASE - sd % LOG_BASE) % LOG_BASE];
                x.e = -sd || 0;
              } else {
                xc[0] = x.e = 0;
              }
              return x;
            }
            if (i == 0) {
              xc.length = ni;
              k = 1;
              ni--;
            } else {
              xc.length = ni + 1;
              k = pows10[LOG_BASE - i];
              xc[ni] = j > 0 ? mathfloor(n / pows10[d - j] % pows10[j]) * k : 0;
            }
            if (r) {
              for (; ; ) {
                if (ni == 0) {
                  for (i = 1, j = xc[0]; j >= 10; j /= 10, i++)
                    ;
                  j = xc[0] += k;
                  for (k = 1; j >= 10; j /= 10, k++)
                    ;
                  if (i != k) {
                    x.e++;
                    if (xc[0] == BASE)
                      xc[0] = 1;
                  }
                  break;
                } else {
                  xc[ni] += k;
                  if (xc[ni] != BASE)
                    break;
                  xc[ni--] = 0;
                  k = 1;
                }
              }
            }
            for (i = xc.length; xc[--i] === 0; xc.pop())
              ;
          }
          if (x.e > MAX_EXP) {
            x.c = x.e = null;
          } else if (x.e < MIN_EXP) {
            x.c = [x.e = 0];
          }
        }
        return x;
      }
      function valueOf(n) {
        var str, e = n.e;
        if (e === null)
          return n.toString();
        str = coeffToString(n.c);
        str = e <= TO_EXP_NEG || e >= TO_EXP_POS ? toExponential(str, e) : toFixedPoint(str, e, "0");
        return n.s < 0 ? "-" + str : str;
      }
      P.absoluteValue = P.abs = function() {
        var x = new BigNumber2(this);
        if (x.s < 0)
          x.s = 1;
        return x;
      };
      P.comparedTo = function(y, b) {
        return compare(this, new BigNumber2(y, b));
      };
      P.decimalPlaces = P.dp = function(dp, rm) {
        var c, n, v, x = this;
        if (dp != null) {
          intCheck(dp, 0, MAX);
          if (rm == null)
            rm = ROUNDING_MODE;
          else
            intCheck(rm, 0, 8);
          return round(new BigNumber2(x), dp + x.e + 1, rm);
        }
        if (!(c = x.c))
          return null;
        n = ((v = c.length - 1) - bitFloor(this.e / LOG_BASE)) * LOG_BASE;
        if (v = c[v])
          for (; v % 10 == 0; v /= 10, n--)
            ;
        if (n < 0)
          n = 0;
        return n;
      };
      P.dividedBy = P.div = function(y, b) {
        return div(this, new BigNumber2(y, b), DECIMAL_PLACES, ROUNDING_MODE);
      };
      P.dividedToIntegerBy = P.idiv = function(y, b) {
        return div(this, new BigNumber2(y, b), 0, 1);
      };
      P.exponentiatedBy = P.pow = function(n, m) {
        var half, isModExp, i, k, more, nIsBig, nIsNeg, nIsOdd, y, x = this;
        n = new BigNumber2(n);
        if (n.c && !n.isInteger()) {
          throw Error(bignumberError + "Exponent not an integer: " + valueOf(n));
        }
        if (m != null)
          m = new BigNumber2(m);
        nIsBig = n.e > 14;
        if (!x.c || !x.c[0] || x.c[0] == 1 && !x.e && x.c.length == 1 || !n.c || !n.c[0]) {
          y = new BigNumber2(Math.pow(+valueOf(x), nIsBig ? 2 - isOdd(n) : +valueOf(n)));
          return m ? y.mod(m) : y;
        }
        nIsNeg = n.s < 0;
        if (m) {
          if (m.c ? !m.c[0] : !m.s)
            return new BigNumber2(NaN);
          isModExp = !nIsNeg && x.isInteger() && m.isInteger();
          if (isModExp)
            x = x.mod(m);
        } else if (n.e > 9 && (x.e > 0 || x.e < -1 || (x.e == 0 ? x.c[0] > 1 || nIsBig && x.c[1] >= 24e7 : x.c[0] < 8e13 || nIsBig && x.c[0] <= 9999975e7))) {
          k = x.s < 0 && isOdd(n) ? -0 : 0;
          if (x.e > -1)
            k = 1 / k;
          return new BigNumber2(nIsNeg ? 1 / k : k);
        } else if (POW_PRECISION) {
          k = mathceil(POW_PRECISION / LOG_BASE + 2);
        }
        if (nIsBig) {
          half = new BigNumber2(0.5);
          if (nIsNeg)
            n.s = 1;
          nIsOdd = isOdd(n);
        } else {
          i = Math.abs(+valueOf(n));
          nIsOdd = i % 2;
        }
        y = new BigNumber2(ONE);
        for (; ; ) {
          if (nIsOdd) {
            y = y.times(x);
            if (!y.c)
              break;
            if (k) {
              if (y.c.length > k)
                y.c.length = k;
            } else if (isModExp) {
              y = y.mod(m);
            }
          }
          if (i) {
            i = mathfloor(i / 2);
            if (i === 0)
              break;
            nIsOdd = i % 2;
          } else {
            n = n.times(half);
            round(n, n.e + 1, 1);
            if (n.e > 14) {
              nIsOdd = isOdd(n);
            } else {
              i = +valueOf(n);
              if (i === 0)
                break;
              nIsOdd = i % 2;
            }
          }
          x = x.times(x);
          if (k) {
            if (x.c && x.c.length > k)
              x.c.length = k;
          } else if (isModExp) {
            x = x.mod(m);
          }
        }
        if (isModExp)
          return y;
        if (nIsNeg)
          y = ONE.div(y);
        return m ? y.mod(m) : k ? round(y, POW_PRECISION, ROUNDING_MODE, more) : y;
      };
      P.integerValue = function(rm) {
        var n = new BigNumber2(this);
        if (rm == null)
          rm = ROUNDING_MODE;
        else
          intCheck(rm, 0, 8);
        return round(n, n.e + 1, rm);
      };
      P.isEqualTo = P.eq = function(y, b) {
        return compare(this, new BigNumber2(y, b)) === 0;
      };
      P.isFinite = function() {
        return !!this.c;
      };
      P.isGreaterThan = P.gt = function(y, b) {
        return compare(this, new BigNumber2(y, b)) > 0;
      };
      P.isGreaterThanOrEqualTo = P.gte = function(y, b) {
        return (b = compare(this, new BigNumber2(y, b))) === 1 || b === 0;
      };
      P.isInteger = function() {
        return !!this.c && bitFloor(this.e / LOG_BASE) > this.c.length - 2;
      };
      P.isLessThan = P.lt = function(y, b) {
        return compare(this, new BigNumber2(y, b)) < 0;
      };
      P.isLessThanOrEqualTo = P.lte = function(y, b) {
        return (b = compare(this, new BigNumber2(y, b))) === -1 || b === 0;
      };
      P.isNaN = function() {
        return !this.s;
      };
      P.isNegative = function() {
        return this.s < 0;
      };
      P.isPositive = function() {
        return this.s > 0;
      };
      P.isZero = function() {
        return !!this.c && this.c[0] == 0;
      };
      P.minus = function(y, b) {
        var i, j, t, xLTy, x = this, a = x.s;
        y = new BigNumber2(y, b);
        b = y.s;
        if (!a || !b)
          return new BigNumber2(NaN);
        if (a != b) {
          y.s = -b;
          return x.plus(y);
        }
        var xe = x.e / LOG_BASE, ye = y.e / LOG_BASE, xc = x.c, yc = y.c;
        if (!xe || !ye) {
          if (!xc || !yc)
            return xc ? (y.s = -b, y) : new BigNumber2(yc ? x : NaN);
          if (!xc[0] || !yc[0]) {
            return yc[0] ? (y.s = -b, y) : new BigNumber2(xc[0] ? x : ROUNDING_MODE == 3 ? -0 : 0);
          }
        }
        xe = bitFloor(xe);
        ye = bitFloor(ye);
        xc = xc.slice();
        if (a = xe - ye) {
          if (xLTy = a < 0) {
            a = -a;
            t = xc;
          } else {
            ye = xe;
            t = yc;
          }
          t.reverse();
          for (b = a; b--; t.push(0))
            ;
          t.reverse();
        } else {
          j = (xLTy = (a = xc.length) < (b = yc.length)) ? a : b;
          for (a = b = 0; b < j; b++) {
            if (xc[b] != yc[b]) {
              xLTy = xc[b] < yc[b];
              break;
            }
          }
        }
        if (xLTy)
          t = xc, xc = yc, yc = t, y.s = -y.s;
        b = (j = yc.length) - (i = xc.length);
        if (b > 0)
          for (; b--; xc[i++] = 0)
            ;
        b = BASE - 1;
        for (; j > a; ) {
          if (xc[--j] < yc[j]) {
            for (i = j; i && !xc[--i]; xc[i] = b)
              ;
            --xc[i];
            xc[j] += BASE;
          }
          xc[j] -= yc[j];
        }
        for (; xc[0] == 0; xc.splice(0, 1), --ye)
          ;
        if (!xc[0]) {
          y.s = ROUNDING_MODE == 3 ? -1 : 1;
          y.c = [y.e = 0];
          return y;
        }
        return normalise(y, xc, ye);
      };
      P.modulo = P.mod = function(y, b) {
        var q, s, x = this;
        y = new BigNumber2(y, b);
        if (!x.c || !y.s || y.c && !y.c[0]) {
          return new BigNumber2(NaN);
        } else if (!y.c || x.c && !x.c[0]) {
          return new BigNumber2(x);
        }
        if (MODULO_MODE == 9) {
          s = y.s;
          y.s = 1;
          q = div(x, y, 0, 3);
          y.s = s;
          q.s *= s;
        } else {
          q = div(x, y, 0, MODULO_MODE);
        }
        y = x.minus(q.times(y));
        if (!y.c[0] && MODULO_MODE == 1)
          y.s = x.s;
        return y;
      };
      P.multipliedBy = P.times = function(y, b) {
        var c, e, i, j, k, m, xcL, xlo, xhi, ycL, ylo, yhi, zc, base, sqrtBase, x = this, xc = x.c, yc = (y = new BigNumber2(y, b)).c;
        if (!xc || !yc || !xc[0] || !yc[0]) {
          if (!x.s || !y.s || xc && !xc[0] && !yc || yc && !yc[0] && !xc) {
            y.c = y.e = y.s = null;
          } else {
            y.s *= x.s;
            if (!xc || !yc) {
              y.c = y.e = null;
            } else {
              y.c = [0];
              y.e = 0;
            }
          }
          return y;
        }
        e = bitFloor(x.e / LOG_BASE) + bitFloor(y.e / LOG_BASE);
        y.s *= x.s;
        xcL = xc.length;
        ycL = yc.length;
        if (xcL < ycL)
          zc = xc, xc = yc, yc = zc, i = xcL, xcL = ycL, ycL = i;
        for (i = xcL + ycL, zc = []; i--; zc.push(0))
          ;
        base = BASE;
        sqrtBase = SQRT_BASE;
        for (i = ycL; --i >= 0; ) {
          c = 0;
          ylo = yc[i] % sqrtBase;
          yhi = yc[i] / sqrtBase | 0;
          for (k = xcL, j = i + k; j > i; ) {
            xlo = xc[--k] % sqrtBase;
            xhi = xc[k] / sqrtBase | 0;
            m = yhi * xlo + xhi * ylo;
            xlo = ylo * xlo + m % sqrtBase * sqrtBase + zc[j] + c;
            c = (xlo / base | 0) + (m / sqrtBase | 0) + yhi * xhi;
            zc[j--] = xlo % base;
          }
          zc[j] = c;
        }
        if (c) {
          ++e;
        } else {
          zc.splice(0, 1);
        }
        return normalise(y, zc, e);
      };
      P.negated = function() {
        var x = new BigNumber2(this);
        x.s = -x.s || null;
        return x;
      };
      P.plus = function(y, b) {
        var t, x = this, a = x.s;
        y = new BigNumber2(y, b);
        b = y.s;
        if (!a || !b)
          return new BigNumber2(NaN);
        if (a != b) {
          y.s = -b;
          return x.minus(y);
        }
        var xe = x.e / LOG_BASE, ye = y.e / LOG_BASE, xc = x.c, yc = y.c;
        if (!xe || !ye) {
          if (!xc || !yc)
            return new BigNumber2(a / 0);
          if (!xc[0] || !yc[0])
            return yc[0] ? y : new BigNumber2(xc[0] ? x : a * 0);
        }
        xe = bitFloor(xe);
        ye = bitFloor(ye);
        xc = xc.slice();
        if (a = xe - ye) {
          if (a > 0) {
            ye = xe;
            t = yc;
          } else {
            a = -a;
            t = xc;
          }
          t.reverse();
          for (; a--; t.push(0))
            ;
          t.reverse();
        }
        a = xc.length;
        b = yc.length;
        if (a - b < 0)
          t = yc, yc = xc, xc = t, b = a;
        for (a = 0; b; ) {
          a = (xc[--b] = xc[b] + yc[b] + a) / BASE | 0;
          xc[b] = BASE === xc[b] ? 0 : xc[b] % BASE;
        }
        if (a) {
          xc = [a].concat(xc);
          ++ye;
        }
        return normalise(y, xc, ye);
      };
      P.precision = P.sd = function(sd, rm) {
        var c, n, v, x = this;
        if (sd != null && sd !== !!sd) {
          intCheck(sd, 1, MAX);
          if (rm == null)
            rm = ROUNDING_MODE;
          else
            intCheck(rm, 0, 8);
          return round(new BigNumber2(x), sd, rm);
        }
        if (!(c = x.c))
          return null;
        v = c.length - 1;
        n = v * LOG_BASE + 1;
        if (v = c[v]) {
          for (; v % 10 == 0; v /= 10, n--)
            ;
          for (v = c[0]; v >= 10; v /= 10, n++)
            ;
        }
        if (sd && x.e + 1 > n)
          n = x.e + 1;
        return n;
      };
      P.shiftedBy = function(k) {
        intCheck(k, -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER);
        return this.times("1e" + k);
      };
      P.squareRoot = P.sqrt = function() {
        var m, n, r, rep, t, x = this, c = x.c, s = x.s, e = x.e, dp = DECIMAL_PLACES + 4, half = new BigNumber2("0.5");
        if (s !== 1 || !c || !c[0]) {
          return new BigNumber2(!s || s < 0 && (!c || c[0]) ? NaN : c ? x : 1 / 0);
        }
        s = Math.sqrt(+valueOf(x));
        if (s == 0 || s == 1 / 0) {
          n = coeffToString(c);
          if ((n.length + e) % 2 == 0)
            n += "0";
          s = Math.sqrt(+n);
          e = bitFloor((e + 1) / 2) - (e < 0 || e % 2);
          if (s == 1 / 0) {
            n = "5e" + e;
          } else {
            n = s.toExponential();
            n = n.slice(0, n.indexOf("e") + 1) + e;
          }
          r = new BigNumber2(n);
        } else {
          r = new BigNumber2(s + "");
        }
        if (r.c[0]) {
          e = r.e;
          s = e + dp;
          if (s < 3)
            s = 0;
          for (; ; ) {
            t = r;
            r = half.times(t.plus(div(x, t, dp, 1)));
            if (coeffToString(t.c).slice(0, s) === (n = coeffToString(r.c)).slice(0, s)) {
              if (r.e < e)
                --s;
              n = n.slice(s - 3, s + 1);
              if (n == "9999" || !rep && n == "4999") {
                if (!rep) {
                  round(t, t.e + DECIMAL_PLACES + 2, 0);
                  if (t.times(t).eq(x)) {
                    r = t;
                    break;
                  }
                }
                dp += 4;
                s += 4;
                rep = 1;
              } else {
                if (!+n || !+n.slice(1) && n.charAt(0) == "5") {
                  round(r, r.e + DECIMAL_PLACES + 2, 1);
                  m = !r.times(r).eq(x);
                }
                break;
              }
            }
          }
        }
        return round(r, r.e + DECIMAL_PLACES + 1, ROUNDING_MODE, m);
      };
      P.toExponential = function(dp, rm) {
        if (dp != null) {
          intCheck(dp, 0, MAX);
          dp++;
        }
        return format(this, dp, rm, 1);
      };
      P.toFixed = function(dp, rm) {
        if (dp != null) {
          intCheck(dp, 0, MAX);
          dp = dp + this.e + 1;
        }
        return format(this, dp, rm);
      };
      P.toFormat = function(dp, rm, format2) {
        var str, x = this;
        if (format2 == null) {
          if (dp != null && rm && typeof rm == "object") {
            format2 = rm;
            rm = null;
          } else if (dp && typeof dp == "object") {
            format2 = dp;
            dp = rm = null;
          } else {
            format2 = FORMAT;
          }
        } else if (typeof format2 != "object") {
          throw Error(bignumberError + "Argument not an object: " + format2);
        }
        str = x.toFixed(dp, rm);
        if (x.c) {
          var i, arr = str.split("."), g1 = +format2.groupSize, g2 = +format2.secondaryGroupSize, groupSeparator = format2.groupSeparator || "", intPart = arr[0], fractionPart = arr[1], isNeg = x.s < 0, intDigits = isNeg ? intPart.slice(1) : intPart, len = intDigits.length;
          if (g2)
            i = g1, g1 = g2, g2 = i, len -= i;
          if (g1 > 0 && len > 0) {
            i = len % g1 || g1;
            intPart = intDigits.substr(0, i);
            for (; i < len; i += g1)
              intPart += groupSeparator + intDigits.substr(i, g1);
            if (g2 > 0)
              intPart += groupSeparator + intDigits.slice(i);
            if (isNeg)
              intPart = "-" + intPart;
          }
          str = fractionPart ? intPart + (format2.decimalSeparator || "") + ((g2 = +format2.fractionGroupSize) ? fractionPart.replace(new RegExp("\\d{" + g2 + "}\\B", "g"), "$&" + (format2.fractionGroupSeparator || "")) : fractionPart) : intPart;
        }
        return (format2.prefix || "") + str + (format2.suffix || "");
      };
      P.toFraction = function(md) {
        var d, d0, d1, d2, e, exp, n, n0, n1, q, r, s, x = this, xc = x.c;
        if (md != null) {
          n = new BigNumber2(md);
          if (!n.isInteger() && (n.c || n.s !== 1) || n.lt(ONE)) {
            throw Error(bignumberError + "Argument " + (n.isInteger() ? "out of range: " : "not an integer: ") + valueOf(n));
          }
        }
        if (!xc)
          return new BigNumber2(x);
        d = new BigNumber2(ONE);
        n1 = d0 = new BigNumber2(ONE);
        d1 = n0 = new BigNumber2(ONE);
        s = coeffToString(xc);
        e = d.e = s.length - x.e - 1;
        d.c[0] = POWS_TEN[(exp = e % LOG_BASE) < 0 ? LOG_BASE + exp : exp];
        md = !md || n.comparedTo(d) > 0 ? e > 0 ? d : n1 : n;
        exp = MAX_EXP;
        MAX_EXP = 1 / 0;
        n = new BigNumber2(s);
        n0.c[0] = 0;
        for (; ; ) {
          q = div(n, d, 0, 1);
          d2 = d0.plus(q.times(d1));
          if (d2.comparedTo(md) == 1)
            break;
          d0 = d1;
          d1 = d2;
          n1 = n0.plus(q.times(d2 = n1));
          n0 = d2;
          d = n.minus(q.times(d2 = d));
          n = d2;
        }
        d2 = div(md.minus(d0), d1, 0, 1);
        n0 = n0.plus(d2.times(n1));
        d0 = d0.plus(d2.times(d1));
        n0.s = n1.s = x.s;
        e = e * 2;
        r = div(n1, d1, e, ROUNDING_MODE).minus(x).abs().comparedTo(div(n0, d0, e, ROUNDING_MODE).minus(x).abs()) < 1 ? [n1, d1] : [n0, d0];
        MAX_EXP = exp;
        return r;
      };
      P.toNumber = function() {
        return +valueOf(this);
      };
      P.toPrecision = function(sd, rm) {
        if (sd != null)
          intCheck(sd, 1, MAX);
        return format(this, sd, rm, 2);
      };
      P.toString = function(b) {
        var str, n = this, s = n.s, e = n.e;
        if (e === null) {
          if (s) {
            str = "Infinity";
            if (s < 0)
              str = "-" + str;
          } else {
            str = "NaN";
          }
        } else {
          if (b == null) {
            str = e <= TO_EXP_NEG || e >= TO_EXP_POS ? toExponential(coeffToString(n.c), e) : toFixedPoint(coeffToString(n.c), e, "0");
          } else if (b === 10) {
            n = round(new BigNumber2(n), DECIMAL_PLACES + e + 1, ROUNDING_MODE);
            str = toFixedPoint(coeffToString(n.c), n.e, "0");
          } else {
            intCheck(b, 2, ALPHABET.length, "Base");
            str = convertBase(toFixedPoint(coeffToString(n.c), e, "0"), 10, b, s, true);
          }
          if (s < 0 && n.c[0])
            str = "-" + str;
        }
        return str;
      };
      P.valueOf = P.toJSON = function() {
        return valueOf(this);
      };
      P._isBigNumber = true;
      if (configObject != null)
        BigNumber2.set(configObject);
      return BigNumber2;
    }
    function bitFloor(n) {
      var i = n | 0;
      return n > 0 || n === i ? i : i - 1;
    }
    function coeffToString(a) {
      var s, z, i = 1, j = a.length, r = a[0] + "";
      for (; i < j; ) {
        s = a[i++] + "";
        z = LOG_BASE - s.length;
        for (; z--; s = "0" + s)
          ;
        r += s;
      }
      for (j = r.length; r.charCodeAt(--j) === 48; )
        ;
      return r.slice(0, j + 1 || 1);
    }
    function compare(x, y) {
      var a, b, xc = x.c, yc = y.c, i = x.s, j = y.s, k = x.e, l = y.e;
      if (!i || !j)
        return null;
      a = xc && !xc[0];
      b = yc && !yc[0];
      if (a || b)
        return a ? b ? 0 : -j : i;
      if (i != j)
        return i;
      a = i < 0;
      b = k == l;
      if (!xc || !yc)
        return b ? 0 : !xc ^ a ? 1 : -1;
      if (!b)
        return k > l ^ a ? 1 : -1;
      j = (k = xc.length) < (l = yc.length) ? k : l;
      for (i = 0; i < j; i++)
        if (xc[i] != yc[i])
          return xc[i] > yc[i] ^ a ? 1 : -1;
      return k == l ? 0 : k > l ^ a ? 1 : -1;
    }
    function intCheck(n, min, max, name) {
      if (n < min || n > max || n !== mathfloor(n)) {
        throw Error(bignumberError + (name || "Argument") + (typeof n == "number" ? n < min || n > max ? " out of range: " : " not an integer: " : " not a primitive number: ") + String(n));
      }
    }
    function isOdd(n) {
      var k = n.c.length - 1;
      return bitFloor(n.e / LOG_BASE) == k && n.c[k] % 2 != 0;
    }
    function toExponential(str, e) {
      return (str.length > 1 ? str.charAt(0) + "." + str.slice(1) : str) + (e < 0 ? "e" : "e+") + e;
    }
    function toFixedPoint(str, e, z) {
      var len, zs;
      if (e < 0) {
        for (zs = z + "."; ++e; zs += z)
          ;
        str = zs + str;
      } else {
        len = str.length;
        if (++e > len) {
          for (zs = z, e -= len; --e; zs += z)
            ;
          str += zs;
        } else if (e < len) {
          str = str.slice(0, e) + "." + str.slice(e);
        }
      }
      return str;
    }
    BigNumber = clone();
    BigNumber["default"] = BigNumber.BigNumber = BigNumber;
    if (typeof define == "function" && define.amd) {
      define(function() {
        return BigNumber;
      });
    } else if (typeof module2 != "undefined" && module2.exports) {
      module2.exports = BigNumber;
    } else {
      if (!globalObject) {
        globalObject = typeof self != "undefined" && self ? self : window;
      }
      globalObject.BigNumber = BigNumber;
    }
  })(exports2);
});

// node_modules/borc/src/decoder.asm.js
var require_decoder_asm = __commonJS((exports2, module2) => {
  module2.exports = function decodeAsm(stdlib, foreign, buffer) {
    "use asm";
    var heap = new stdlib.Uint8Array(buffer);
    var pushInt = foreign.pushInt;
    var pushInt32 = foreign.pushInt32;
    var pushInt32Neg = foreign.pushInt32Neg;
    var pushInt64 = foreign.pushInt64;
    var pushInt64Neg = foreign.pushInt64Neg;
    var pushFloat = foreign.pushFloat;
    var pushFloatSingle = foreign.pushFloatSingle;
    var pushFloatDouble = foreign.pushFloatDouble;
    var pushTrue = foreign.pushTrue;
    var pushFalse = foreign.pushFalse;
    var pushUndefined = foreign.pushUndefined;
    var pushNull = foreign.pushNull;
    var pushInfinity = foreign.pushInfinity;
    var pushInfinityNeg = foreign.pushInfinityNeg;
    var pushNaN = foreign.pushNaN;
    var pushNaNNeg = foreign.pushNaNNeg;
    var pushArrayStart = foreign.pushArrayStart;
    var pushArrayStartFixed = foreign.pushArrayStartFixed;
    var pushArrayStartFixed32 = foreign.pushArrayStartFixed32;
    var pushArrayStartFixed64 = foreign.pushArrayStartFixed64;
    var pushObjectStart = foreign.pushObjectStart;
    var pushObjectStartFixed = foreign.pushObjectStartFixed;
    var pushObjectStartFixed32 = foreign.pushObjectStartFixed32;
    var pushObjectStartFixed64 = foreign.pushObjectStartFixed64;
    var pushByteString = foreign.pushByteString;
    var pushByteStringStart = foreign.pushByteStringStart;
    var pushUtf8String = foreign.pushUtf8String;
    var pushUtf8StringStart = foreign.pushUtf8StringStart;
    var pushSimpleUnassigned = foreign.pushSimpleUnassigned;
    var pushTagStart = foreign.pushTagStart;
    var pushTagStart4 = foreign.pushTagStart4;
    var pushTagStart8 = foreign.pushTagStart8;
    var pushTagUnassigned = foreign.pushTagUnassigned;
    var pushBreak = foreign.pushBreak;
    var pow = stdlib.Math.pow;
    var offset = 0;
    var inputLength = 0;
    var code = 0;
    function parse(input) {
      input = input | 0;
      offset = 0;
      inputLength = input;
      while ((offset | 0) < (inputLength | 0)) {
        code = jumpTable[heap[offset] & 255](heap[offset] | 0) | 0;
        if ((code | 0) > 0) {
          break;
        }
      }
      return code | 0;
    }
    function checkOffset(n) {
      n = n | 0;
      if (((offset | 0) + (n | 0) | 0) < (inputLength | 0)) {
        return 0;
      }
      return 1;
    }
    function readUInt16(n) {
      n = n | 0;
      return heap[n | 0] << 8 | heap[n + 1 | 0] | 0;
    }
    function readUInt32(n) {
      n = n | 0;
      return heap[n | 0] << 24 | heap[n + 1 | 0] << 16 | heap[n + 2 | 0] << 8 | heap[n + 3 | 0] | 0;
    }
    function INT_P(octet) {
      octet = octet | 0;
      pushInt(octet | 0);
      offset = offset + 1 | 0;
      return 0;
    }
    function UINT_P_8(octet) {
      octet = octet | 0;
      if (checkOffset(1) | 0) {
        return 1;
      }
      pushInt(heap[offset + 1 | 0] | 0);
      offset = offset + 2 | 0;
      return 0;
    }
    function UINT_P_16(octet) {
      octet = octet | 0;
      if (checkOffset(2) | 0) {
        return 1;
      }
      pushInt(readUInt16(offset + 1 | 0) | 0);
      offset = offset + 3 | 0;
      return 0;
    }
    function UINT_P_32(octet) {
      octet = octet | 0;
      if (checkOffset(4) | 0) {
        return 1;
      }
      pushInt32(readUInt16(offset + 1 | 0) | 0, readUInt16(offset + 3 | 0) | 0);
      offset = offset + 5 | 0;
      return 0;
    }
    function UINT_P_64(octet) {
      octet = octet | 0;
      if (checkOffset(8) | 0) {
        return 1;
      }
      pushInt64(readUInt16(offset + 1 | 0) | 0, readUInt16(offset + 3 | 0) | 0, readUInt16(offset + 5 | 0) | 0, readUInt16(offset + 7 | 0) | 0);
      offset = offset + 9 | 0;
      return 0;
    }
    function INT_N(octet) {
      octet = octet | 0;
      pushInt(-1 - (octet - 32 | 0) | 0);
      offset = offset + 1 | 0;
      return 0;
    }
    function UINT_N_8(octet) {
      octet = octet | 0;
      if (checkOffset(1) | 0) {
        return 1;
      }
      pushInt(-1 - (heap[offset + 1 | 0] | 0) | 0);
      offset = offset + 2 | 0;
      return 0;
    }
    function UINT_N_16(octet) {
      octet = octet | 0;
      var val = 0;
      if (checkOffset(2) | 0) {
        return 1;
      }
      val = readUInt16(offset + 1 | 0) | 0;
      pushInt(-1 - (val | 0) | 0);
      offset = offset + 3 | 0;
      return 0;
    }
    function UINT_N_32(octet) {
      octet = octet | 0;
      if (checkOffset(4) | 0) {
        return 1;
      }
      pushInt32Neg(readUInt16(offset + 1 | 0) | 0, readUInt16(offset + 3 | 0) | 0);
      offset = offset + 5 | 0;
      return 0;
    }
    function UINT_N_64(octet) {
      octet = octet | 0;
      if (checkOffset(8) | 0) {
        return 1;
      }
      pushInt64Neg(readUInt16(offset + 1 | 0) | 0, readUInt16(offset + 3 | 0) | 0, readUInt16(offset + 5 | 0) | 0, readUInt16(offset + 7 | 0) | 0);
      offset = offset + 9 | 0;
      return 0;
    }
    function BYTE_STRING(octet) {
      octet = octet | 0;
      var start = 0;
      var end = 0;
      var step = 0;
      step = octet - 64 | 0;
      if (checkOffset(step | 0) | 0) {
        return 1;
      }
      start = offset + 1 | 0;
      end = (offset + 1 | 0) + (step | 0) | 0;
      pushByteString(start | 0, end | 0);
      offset = end | 0;
      return 0;
    }
    function BYTE_STRING_8(octet) {
      octet = octet | 0;
      var start = 0;
      var end = 0;
      var length = 0;
      if (checkOffset(1) | 0) {
        return 1;
      }
      length = heap[offset + 1 | 0] | 0;
      start = offset + 2 | 0;
      end = (offset + 2 | 0) + (length | 0) | 0;
      if (checkOffset(length + 1 | 0) | 0) {
        return 1;
      }
      pushByteString(start | 0, end | 0);
      offset = end | 0;
      return 0;
    }
    function BYTE_STRING_16(octet) {
      octet = octet | 0;
      var start = 0;
      var end = 0;
      var length = 0;
      if (checkOffset(2) | 0) {
        return 1;
      }
      length = readUInt16(offset + 1 | 0) | 0;
      start = offset + 3 | 0;
      end = (offset + 3 | 0) + (length | 0) | 0;
      if (checkOffset(length + 2 | 0) | 0) {
        return 1;
      }
      pushByteString(start | 0, end | 0);
      offset = end | 0;
      return 0;
    }
    function BYTE_STRING_32(octet) {
      octet = octet | 0;
      var start = 0;
      var end = 0;
      var length = 0;
      if (checkOffset(4) | 0) {
        return 1;
      }
      length = readUInt32(offset + 1 | 0) | 0;
      start = offset + 5 | 0;
      end = (offset + 5 | 0) + (length | 0) | 0;
      if (checkOffset(length + 4 | 0) | 0) {
        return 1;
      }
      pushByteString(start | 0, end | 0);
      offset = end | 0;
      return 0;
    }
    function BYTE_STRING_64(octet) {
      octet = octet | 0;
      return 1;
    }
    function BYTE_STRING_BREAK(octet) {
      octet = octet | 0;
      pushByteStringStart();
      offset = offset + 1 | 0;
      return 0;
    }
    function UTF8_STRING(octet) {
      octet = octet | 0;
      var start = 0;
      var end = 0;
      var step = 0;
      step = octet - 96 | 0;
      if (checkOffset(step | 0) | 0) {
        return 1;
      }
      start = offset + 1 | 0;
      end = (offset + 1 | 0) + (step | 0) | 0;
      pushUtf8String(start | 0, end | 0);
      offset = end | 0;
      return 0;
    }
    function UTF8_STRING_8(octet) {
      octet = octet | 0;
      var start = 0;
      var end = 0;
      var length = 0;
      if (checkOffset(1) | 0) {
        return 1;
      }
      length = heap[offset + 1 | 0] | 0;
      start = offset + 2 | 0;
      end = (offset + 2 | 0) + (length | 0) | 0;
      if (checkOffset(length + 1 | 0) | 0) {
        return 1;
      }
      pushUtf8String(start | 0, end | 0);
      offset = end | 0;
      return 0;
    }
    function UTF8_STRING_16(octet) {
      octet = octet | 0;
      var start = 0;
      var end = 0;
      var length = 0;
      if (checkOffset(2) | 0) {
        return 1;
      }
      length = readUInt16(offset + 1 | 0) | 0;
      start = offset + 3 | 0;
      end = (offset + 3 | 0) + (length | 0) | 0;
      if (checkOffset(length + 2 | 0) | 0) {
        return 1;
      }
      pushUtf8String(start | 0, end | 0);
      offset = end | 0;
      return 0;
    }
    function UTF8_STRING_32(octet) {
      octet = octet | 0;
      var start = 0;
      var end = 0;
      var length = 0;
      if (checkOffset(4) | 0) {
        return 1;
      }
      length = readUInt32(offset + 1 | 0) | 0;
      start = offset + 5 | 0;
      end = (offset + 5 | 0) + (length | 0) | 0;
      if (checkOffset(length + 4 | 0) | 0) {
        return 1;
      }
      pushUtf8String(start | 0, end | 0);
      offset = end | 0;
      return 0;
    }
    function UTF8_STRING_64(octet) {
      octet = octet | 0;
      return 1;
    }
    function UTF8_STRING_BREAK(octet) {
      octet = octet | 0;
      pushUtf8StringStart();
      offset = offset + 1 | 0;
      return 0;
    }
    function ARRAY(octet) {
      octet = octet | 0;
      pushArrayStartFixed(octet - 128 | 0);
      offset = offset + 1 | 0;
      return 0;
    }
    function ARRAY_8(octet) {
      octet = octet | 0;
      if (checkOffset(1) | 0) {
        return 1;
      }
      pushArrayStartFixed(heap[offset + 1 | 0] | 0);
      offset = offset + 2 | 0;
      return 0;
    }
    function ARRAY_16(octet) {
      octet = octet | 0;
      if (checkOffset(2) | 0) {
        return 1;
      }
      pushArrayStartFixed(readUInt16(offset + 1 | 0) | 0);
      offset = offset + 3 | 0;
      return 0;
    }
    function ARRAY_32(octet) {
      octet = octet | 0;
      if (checkOffset(4) | 0) {
        return 1;
      }
      pushArrayStartFixed32(readUInt16(offset + 1 | 0) | 0, readUInt16(offset + 3 | 0) | 0);
      offset = offset + 5 | 0;
      return 0;
    }
    function ARRAY_64(octet) {
      octet = octet | 0;
      if (checkOffset(8) | 0) {
        return 1;
      }
      pushArrayStartFixed64(readUInt16(offset + 1 | 0) | 0, readUInt16(offset + 3 | 0) | 0, readUInt16(offset + 5 | 0) | 0, readUInt16(offset + 7 | 0) | 0);
      offset = offset + 9 | 0;
      return 0;
    }
    function ARRAY_BREAK(octet) {
      octet = octet | 0;
      pushArrayStart();
      offset = offset + 1 | 0;
      return 0;
    }
    function MAP(octet) {
      octet = octet | 0;
      var step = 0;
      step = octet - 160 | 0;
      if (checkOffset(step | 0) | 0) {
        return 1;
      }
      pushObjectStartFixed(step | 0);
      offset = offset + 1 | 0;
      return 0;
    }
    function MAP_8(octet) {
      octet = octet | 0;
      if (checkOffset(1) | 0) {
        return 1;
      }
      pushObjectStartFixed(heap[offset + 1 | 0] | 0);
      offset = offset + 2 | 0;
      return 0;
    }
    function MAP_16(octet) {
      octet = octet | 0;
      if (checkOffset(2) | 0) {
        return 1;
      }
      pushObjectStartFixed(readUInt16(offset + 1 | 0) | 0);
      offset = offset + 3 | 0;
      return 0;
    }
    function MAP_32(octet) {
      octet = octet | 0;
      if (checkOffset(4) | 0) {
        return 1;
      }
      pushObjectStartFixed32(readUInt16(offset + 1 | 0) | 0, readUInt16(offset + 3 | 0) | 0);
      offset = offset + 5 | 0;
      return 0;
    }
    function MAP_64(octet) {
      octet = octet | 0;
      if (checkOffset(8) | 0) {
        return 1;
      }
      pushObjectStartFixed64(readUInt16(offset + 1 | 0) | 0, readUInt16(offset + 3 | 0) | 0, readUInt16(offset + 5 | 0) | 0, readUInt16(offset + 7 | 0) | 0);
      offset = offset + 9 | 0;
      return 0;
    }
    function MAP_BREAK(octet) {
      octet = octet | 0;
      pushObjectStart();
      offset = offset + 1 | 0;
      return 0;
    }
    function TAG_KNOWN(octet) {
      octet = octet | 0;
      pushTagStart(octet - 192 | 0 | 0);
      offset = offset + 1 | 0;
      return 0;
    }
    function TAG_BIGNUM_POS(octet) {
      octet = octet | 0;
      pushTagStart(octet | 0);
      offset = offset + 1 | 0;
      return 0;
    }
    function TAG_BIGNUM_NEG(octet) {
      octet = octet | 0;
      pushTagStart(octet | 0);
      offset = offset + 1 | 0;
      return 0;
    }
    function TAG_FRAC(octet) {
      octet = octet | 0;
      pushTagStart(octet | 0);
      offset = offset + 1 | 0;
      return 0;
    }
    function TAG_BIGNUM_FLOAT(octet) {
      octet = octet | 0;
      pushTagStart(octet | 0);
      offset = offset + 1 | 0;
      return 0;
    }
    function TAG_UNASSIGNED(octet) {
      octet = octet | 0;
      pushTagStart(octet - 192 | 0 | 0);
      offset = offset + 1 | 0;
      return 0;
    }
    function TAG_BASE64_URL(octet) {
      octet = octet | 0;
      pushTagStart(octet | 0);
      offset = offset + 1 | 0;
      return 0;
    }
    function TAG_BASE64(octet) {
      octet = octet | 0;
      pushTagStart(octet | 0);
      offset = offset + 1 | 0;
      return 0;
    }
    function TAG_BASE16(octet) {
      octet = octet | 0;
      pushTagStart(octet | 0);
      offset = offset + 1 | 0;
      return 0;
    }
    function TAG_MORE_1(octet) {
      octet = octet | 0;
      if (checkOffset(1) | 0) {
        return 1;
      }
      pushTagStart(heap[offset + 1 | 0] | 0);
      offset = offset + 2 | 0;
      return 0;
    }
    function TAG_MORE_2(octet) {
      octet = octet | 0;
      if (checkOffset(2) | 0) {
        return 1;
      }
      pushTagStart(readUInt16(offset + 1 | 0) | 0);
      offset = offset + 3 | 0;
      return 0;
    }
    function TAG_MORE_4(octet) {
      octet = octet | 0;
      if (checkOffset(4) | 0) {
        return 1;
      }
      pushTagStart4(readUInt16(offset + 1 | 0) | 0, readUInt16(offset + 3 | 0) | 0);
      offset = offset + 5 | 0;
      return 0;
    }
    function TAG_MORE_8(octet) {
      octet = octet | 0;
      if (checkOffset(8) | 0) {
        return 1;
      }
      pushTagStart8(readUInt16(offset + 1 | 0) | 0, readUInt16(offset + 3 | 0) | 0, readUInt16(offset + 5 | 0) | 0, readUInt16(offset + 7 | 0) | 0);
      offset = offset + 9 | 0;
      return 0;
    }
    function SIMPLE_UNASSIGNED(octet) {
      octet = octet | 0;
      pushSimpleUnassigned((octet | 0) - 224 | 0);
      offset = offset + 1 | 0;
      return 0;
    }
    function SIMPLE_FALSE(octet) {
      octet = octet | 0;
      pushFalse();
      offset = offset + 1 | 0;
      return 0;
    }
    function SIMPLE_TRUE(octet) {
      octet = octet | 0;
      pushTrue();
      offset = offset + 1 | 0;
      return 0;
    }
    function SIMPLE_NULL(octet) {
      octet = octet | 0;
      pushNull();
      offset = offset + 1 | 0;
      return 0;
    }
    function SIMPLE_UNDEFINED(octet) {
      octet = octet | 0;
      pushUndefined();
      offset = offset + 1 | 0;
      return 0;
    }
    function SIMPLE_BYTE(octet) {
      octet = octet | 0;
      if (checkOffset(1) | 0) {
        return 1;
      }
      pushSimpleUnassigned(heap[offset + 1 | 0] | 0);
      offset = offset + 2 | 0;
      return 0;
    }
    function SIMPLE_FLOAT_HALF(octet) {
      octet = octet | 0;
      var f = 0;
      var g = 0;
      var sign = 1;
      var exp = 0;
      var mant = 0;
      var r = 0;
      if (checkOffset(2) | 0) {
        return 1;
      }
      f = heap[offset + 1 | 0] | 0;
      g = heap[offset + 2 | 0] | 0;
      if ((f | 0) & 128) {
        sign = -1;
      }
      exp = +(((f | 0) & 124) >> 2);
      mant = +(((f | 0) & 3) << 8 | g);
      if (+exp == 0) {
        pushFloat(+(+sign * 5960464477539063e-23 * +mant));
      } else if (+exp == 31) {
        if (+sign == 1) {
          if (+mant > 0) {
            pushNaN();
          } else {
            pushInfinity();
          }
        } else {
          if (+mant > 0) {
            pushNaNNeg();
          } else {
            pushInfinityNeg();
          }
        }
      } else {
        pushFloat(+(+sign * pow(2, +(+exp - 25)) * +(1024 + mant)));
      }
      offset = offset + 3 | 0;
      return 0;
    }
    function SIMPLE_FLOAT_SINGLE(octet) {
      octet = octet | 0;
      if (checkOffset(4) | 0) {
        return 1;
      }
      pushFloatSingle(heap[offset + 1 | 0] | 0, heap[offset + 2 | 0] | 0, heap[offset + 3 | 0] | 0, heap[offset + 4 | 0] | 0);
      offset = offset + 5 | 0;
      return 0;
    }
    function SIMPLE_FLOAT_DOUBLE(octet) {
      octet = octet | 0;
      if (checkOffset(8) | 0) {
        return 1;
      }
      pushFloatDouble(heap[offset + 1 | 0] | 0, heap[offset + 2 | 0] | 0, heap[offset + 3 | 0] | 0, heap[offset + 4 | 0] | 0, heap[offset + 5 | 0] | 0, heap[offset + 6 | 0] | 0, heap[offset + 7 | 0] | 0, heap[offset + 8 | 0] | 0);
      offset = offset + 9 | 0;
      return 0;
    }
    function ERROR(octet) {
      octet = octet | 0;
      return 1;
    }
    function BREAK(octet) {
      octet = octet | 0;
      pushBreak();
      offset = offset + 1 | 0;
      return 0;
    }
    var jumpTable = [
      INT_P,
      INT_P,
      INT_P,
      INT_P,
      INT_P,
      INT_P,
      INT_P,
      INT_P,
      INT_P,
      INT_P,
      INT_P,
      INT_P,
      INT_P,
      INT_P,
      INT_P,
      INT_P,
      INT_P,
      INT_P,
      INT_P,
      INT_P,
      INT_P,
      INT_P,
      INT_P,
      INT_P,
      UINT_P_8,
      UINT_P_16,
      UINT_P_32,
      UINT_P_64,
      ERROR,
      ERROR,
      ERROR,
      ERROR,
      INT_N,
      INT_N,
      INT_N,
      INT_N,
      INT_N,
      INT_N,
      INT_N,
      INT_N,
      INT_N,
      INT_N,
      INT_N,
      INT_N,
      INT_N,
      INT_N,
      INT_N,
      INT_N,
      INT_N,
      INT_N,
      INT_N,
      INT_N,
      INT_N,
      INT_N,
      INT_N,
      INT_N,
      UINT_N_8,
      UINT_N_16,
      UINT_N_32,
      UINT_N_64,
      ERROR,
      ERROR,
      ERROR,
      ERROR,
      BYTE_STRING,
      BYTE_STRING,
      BYTE_STRING,
      BYTE_STRING,
      BYTE_STRING,
      BYTE_STRING,
      BYTE_STRING,
      BYTE_STRING,
      BYTE_STRING,
      BYTE_STRING,
      BYTE_STRING,
      BYTE_STRING,
      BYTE_STRING,
      BYTE_STRING,
      BYTE_STRING,
      BYTE_STRING,
      BYTE_STRING,
      BYTE_STRING,
      BYTE_STRING,
      BYTE_STRING,
      BYTE_STRING,
      BYTE_STRING,
      BYTE_STRING,
      BYTE_STRING,
      BYTE_STRING_8,
      BYTE_STRING_16,
      BYTE_STRING_32,
      BYTE_STRING_64,
      ERROR,
      ERROR,
      ERROR,
      BYTE_STRING_BREAK,
      UTF8_STRING,
      UTF8_STRING,
      UTF8_STRING,
      UTF8_STRING,
      UTF8_STRING,
      UTF8_STRING,
      UTF8_STRING,
      UTF8_STRING,
      UTF8_STRING,
      UTF8_STRING,
      UTF8_STRING,
      UTF8_STRING,
      UTF8_STRING,
      UTF8_STRING,
      UTF8_STRING,
      UTF8_STRING,
      UTF8_STRING,
      UTF8_STRING,
      UTF8_STRING,
      UTF8_STRING,
      UTF8_STRING,
      UTF8_STRING,
      UTF8_STRING,
      UTF8_STRING,
      UTF8_STRING_8,
      UTF8_STRING_16,
      UTF8_STRING_32,
      UTF8_STRING_64,
      ERROR,
      ERROR,
      ERROR,
      UTF8_STRING_BREAK,
      ARRAY,
      ARRAY,
      ARRAY,
      ARRAY,
      ARRAY,
      ARRAY,
      ARRAY,
      ARRAY,
      ARRAY,
      ARRAY,
      ARRAY,
      ARRAY,
      ARRAY,
      ARRAY,
      ARRAY,
      ARRAY,
      ARRAY,
      ARRAY,
      ARRAY,
      ARRAY,
      ARRAY,
      ARRAY,
      ARRAY,
      ARRAY,
      ARRAY_8,
      ARRAY_16,
      ARRAY_32,
      ARRAY_64,
      ERROR,
      ERROR,
      ERROR,
      ARRAY_BREAK,
      MAP,
      MAP,
      MAP,
      MAP,
      MAP,
      MAP,
      MAP,
      MAP,
      MAP,
      MAP,
      MAP,
      MAP,
      MAP,
      MAP,
      MAP,
      MAP,
      MAP,
      MAP,
      MAP,
      MAP,
      MAP,
      MAP,
      MAP,
      MAP,
      MAP_8,
      MAP_16,
      MAP_32,
      MAP_64,
      ERROR,
      ERROR,
      ERROR,
      MAP_BREAK,
      TAG_KNOWN,
      TAG_KNOWN,
      TAG_KNOWN,
      TAG_KNOWN,
      TAG_KNOWN,
      TAG_KNOWN,
      TAG_UNASSIGNED,
      TAG_UNASSIGNED,
      TAG_UNASSIGNED,
      TAG_UNASSIGNED,
      TAG_UNASSIGNED,
      TAG_UNASSIGNED,
      TAG_UNASSIGNED,
      TAG_UNASSIGNED,
      TAG_UNASSIGNED,
      TAG_UNASSIGNED,
      TAG_UNASSIGNED,
      TAG_UNASSIGNED,
      TAG_UNASSIGNED,
      TAG_UNASSIGNED,
      TAG_UNASSIGNED,
      TAG_UNASSIGNED,
      TAG_UNASSIGNED,
      TAG_UNASSIGNED,
      TAG_MORE_1,
      TAG_MORE_2,
      TAG_MORE_4,
      TAG_MORE_8,
      ERROR,
      ERROR,
      ERROR,
      ERROR,
      SIMPLE_UNASSIGNED,
      SIMPLE_UNASSIGNED,
      SIMPLE_UNASSIGNED,
      SIMPLE_UNASSIGNED,
      SIMPLE_UNASSIGNED,
      SIMPLE_UNASSIGNED,
      SIMPLE_UNASSIGNED,
      SIMPLE_UNASSIGNED,
      SIMPLE_UNASSIGNED,
      SIMPLE_UNASSIGNED,
      SIMPLE_UNASSIGNED,
      SIMPLE_UNASSIGNED,
      SIMPLE_UNASSIGNED,
      SIMPLE_UNASSIGNED,
      SIMPLE_UNASSIGNED,
      SIMPLE_UNASSIGNED,
      SIMPLE_UNASSIGNED,
      SIMPLE_UNASSIGNED,
      SIMPLE_UNASSIGNED,
      SIMPLE_UNASSIGNED,
      SIMPLE_FALSE,
      SIMPLE_TRUE,
      SIMPLE_NULL,
      SIMPLE_UNDEFINED,
      SIMPLE_BYTE,
      SIMPLE_FLOAT_HALF,
      SIMPLE_FLOAT_SINGLE,
      SIMPLE_FLOAT_DOUBLE,
      ERROR,
      ERROR,
      ERROR,
      BREAK
    ];
    return {
      parse
    };
  };
});

// node_modules/borc/src/constants.js
var require_constants4 = __commonJS((exports2) => {
  "use strict";
  var Bignumber = require_bignumber().BigNumber;
  exports2.MT = {
    POS_INT: 0,
    NEG_INT: 1,
    BYTE_STRING: 2,
    UTF8_STRING: 3,
    ARRAY: 4,
    MAP: 5,
    TAG: 6,
    SIMPLE_FLOAT: 7
  };
  exports2.TAG = {
    DATE_STRING: 0,
    DATE_EPOCH: 1,
    POS_BIGINT: 2,
    NEG_BIGINT: 3,
    DECIMAL_FRAC: 4,
    BIGFLOAT: 5,
    BASE64URL_EXPECTED: 21,
    BASE64_EXPECTED: 22,
    BASE16_EXPECTED: 23,
    CBOR: 24,
    URI: 32,
    BASE64URL: 33,
    BASE64: 34,
    REGEXP: 35,
    MIME: 36
  };
  exports2.NUMBYTES = {
    ZERO: 0,
    ONE: 24,
    TWO: 25,
    FOUR: 26,
    EIGHT: 27,
    INDEFINITE: 31
  };
  exports2.SIMPLE = {
    FALSE: 20,
    TRUE: 21,
    NULL: 22,
    UNDEFINED: 23
  };
  exports2.SYMS = {
    NULL: Symbol("null"),
    UNDEFINED: Symbol("undef"),
    PARENT: Symbol("parent"),
    BREAK: Symbol("break"),
    STREAM: Symbol("stream")
  };
  exports2.SHIFT32 = Math.pow(2, 32);
  exports2.SHIFT16 = Math.pow(2, 16);
  exports2.MAX_SAFE_HIGH = 2097151;
  exports2.NEG_ONE = new Bignumber(-1);
  exports2.TEN = new Bignumber(10);
  exports2.TWO = new Bignumber(2);
  exports2.PARENT = {
    ARRAY: 0,
    OBJECT: 1,
    MAP: 2,
    TAG: 3,
    BYTE_STRING: 4,
    UTF8_STRING: 5
  };
});

// node_modules/borc/src/utils.js
var require_utils8 = __commonJS((exports2) => {
  "use strict";
  var {Buffer: Buffer2} = require_buffer();
  var Bignumber = require_bignumber().BigNumber;
  var constants = require_constants4();
  var SHIFT32 = constants.SHIFT32;
  var SHIFT16 = constants.SHIFT16;
  var MAX_SAFE_HIGH = 2097151;
  exports2.parseHalf = function parseHalf(buf) {
    var exp, mant, sign;
    sign = buf[0] & 128 ? -1 : 1;
    exp = (buf[0] & 124) >> 2;
    mant = (buf[0] & 3) << 8 | buf[1];
    if (!exp) {
      return sign * 5960464477539063e-23 * mant;
    } else if (exp === 31) {
      return sign * (mant ? 0 / 0 : Infinity);
    } else {
      return sign * Math.pow(2, exp - 25) * (1024 + mant);
    }
  };
  function toHex(n) {
    if (n < 16) {
      return "0" + n.toString(16);
    }
    return n.toString(16);
  }
  exports2.arrayBufferToBignumber = function(buf) {
    const len = buf.byteLength;
    let res = "";
    for (let i = 0; i < len; i++) {
      res += toHex(buf[i]);
    }
    return new Bignumber(res, 16);
  };
  exports2.buildMap = (obj) => {
    const res = new Map();
    const keys = Object.keys(obj);
    const length = keys.length;
    for (let i = 0; i < length; i++) {
      res.set(keys[i], obj[keys[i]]);
    }
    return res;
  };
  exports2.buildInt32 = (f, g) => {
    return f * SHIFT16 + g;
  };
  exports2.buildInt64 = (f1, f2, g1, g2) => {
    const f = exports2.buildInt32(f1, f2);
    const g = exports2.buildInt32(g1, g2);
    if (f > MAX_SAFE_HIGH) {
      return new Bignumber(f).times(SHIFT32).plus(g);
    } else {
      return f * SHIFT32 + g;
    }
  };
  exports2.writeHalf = function writeHalf(buf, half) {
    const u32 = Buffer2.allocUnsafe(4);
    u32.writeFloatBE(half, 0);
    const u = u32.readUInt32BE(0);
    if ((u & 8191) !== 0) {
      return false;
    }
    var s16 = u >> 16 & 32768;
    const exp = u >> 23 & 255;
    const mant = u & 8388607;
    if (exp >= 113 && exp <= 142) {
      s16 += (exp - 112 << 10) + (mant >> 13);
    } else if (exp >= 103 && exp < 113) {
      if (mant & (1 << 126 - exp) - 1) {
        return false;
      }
      s16 += mant + 8388608 >> 126 - exp;
    } else {
      return false;
    }
    buf.writeUInt16BE(s16, 0);
    return true;
  };
  exports2.keySorter = function(a, b) {
    var lenA = a[0].byteLength;
    var lenB = b[0].byteLength;
    if (lenA > lenB) {
      return 1;
    }
    if (lenB > lenA) {
      return -1;
    }
    return a[0].compare(b[0]);
  };
  exports2.isNegativeZero = (x) => {
    return x === 0 && 1 / x < 0;
  };
  exports2.nextPowerOf2 = (n) => {
    let count = 0;
    if (n && !(n & n - 1)) {
      return n;
    }
    while (n !== 0) {
      n >>= 1;
      count += 1;
    }
    return 1 << count;
  };
});

// node_modules/borc/src/simple.js
var require_simple = __commonJS((exports2, module2) => {
  "use strict";
  var constants = require_constants4();
  var MT = constants.MT;
  var SIMPLE = constants.SIMPLE;
  var SYMS = constants.SYMS;
  var Simple = class {
    constructor(value) {
      if (typeof value !== "number") {
        throw new Error("Invalid Simple type: " + typeof value);
      }
      if (value < 0 || value > 255 || (value | 0) !== value) {
        throw new Error("value must be a small positive integer: " + value);
      }
      this.value = value;
    }
    toString() {
      return "simple(" + this.value + ")";
    }
    inspect() {
      return "simple(" + this.value + ")";
    }
    encodeCBOR(gen) {
      return gen._pushInt(this.value, MT.SIMPLE_FLOAT);
    }
    static isSimple(obj) {
      return obj instanceof Simple;
    }
    static decode(val, hasParent) {
      if (hasParent == null) {
        hasParent = true;
      }
      switch (val) {
        case SIMPLE.FALSE:
          return false;
        case SIMPLE.TRUE:
          return true;
        case SIMPLE.NULL:
          if (hasParent) {
            return null;
          } else {
            return SYMS.NULL;
          }
        case SIMPLE.UNDEFINED:
          if (hasParent) {
            return void 0;
          } else {
            return SYMS.UNDEFINED;
          }
        case -1:
          if (!hasParent) {
            throw new Error("Invalid BREAK");
          }
          return SYMS.BREAK;
        default:
          return new Simple(val);
      }
    }
  };
  module2.exports = Simple;
});

// node_modules/borc/src/tagged.js
var require_tagged = __commonJS((exports2, module2) => {
  "use strict";
  var Tagged = class {
    constructor(tag, value, err) {
      this.tag = tag;
      this.value = value;
      this.err = err;
      if (typeof this.tag !== "number") {
        throw new Error("Invalid tag type (" + typeof this.tag + ")");
      }
      if (this.tag < 0 || (this.tag | 0) !== this.tag) {
        throw new Error("Tag must be a positive integer: " + this.tag);
      }
    }
    toString() {
      return `${this.tag}(${JSON.stringify(this.value)})`;
    }
    encodeCBOR(gen) {
      gen._pushTag(this.tag);
      return gen.pushAny(this.value);
    }
    convert(converters) {
      var er, f;
      f = converters != null ? converters[this.tag] : void 0;
      if (typeof f !== "function") {
        f = Tagged["_tag" + this.tag];
        if (typeof f !== "function") {
          return this;
        }
      }
      try {
        return f.call(Tagged, this.value);
      } catch (error) {
        er = error;
        this.err = er;
        return this;
      }
    }
  };
  module2.exports = Tagged;
});

// node_modules/borc/node_modules/iso-url/src/url-browser.js
var require_url_browser3 = __commonJS((exports2, module2) => {
  "use strict";
  var defaultBase = self.location ? self.location.protocol + "//" + self.location.host : "";
  var URL2 = self.URL;
  var URLWithLegacySupport = class {
    constructor(url = "", base = defaultBase) {
      this.super = new URL2(url, base);
      this.path = this.pathname + this.search;
      this.auth = this.username && this.password ? this.username + ":" + this.password : null;
      this.query = this.search && this.search.startsWith("?") ? this.search.slice(1) : null;
    }
    get hash() {
      return this.super.hash;
    }
    get host() {
      return this.super.host;
    }
    get hostname() {
      return this.super.hostname;
    }
    get href() {
      return this.super.href;
    }
    get origin() {
      return this.super.origin;
    }
    get password() {
      return this.super.password;
    }
    get pathname() {
      return this.super.pathname;
    }
    get port() {
      return this.super.port;
    }
    get protocol() {
      return this.super.protocol;
    }
    get search() {
      return this.super.search;
    }
    get searchParams() {
      return this.super.searchParams;
    }
    get username() {
      return this.super.username;
    }
    set hash(hash) {
      this.super.hash = hash;
    }
    set host(host) {
      this.super.host = host;
    }
    set hostname(hostname) {
      this.super.hostname = hostname;
    }
    set href(href) {
      this.super.href = href;
    }
    set origin(origin) {
      this.super.origin = origin;
    }
    set password(password) {
      this.super.password = password;
    }
    set pathname(pathname) {
      this.super.pathname = pathname;
    }
    set port(port) {
      this.super.port = port;
    }
    set protocol(protocol) {
      this.super.protocol = protocol;
    }
    set search(search) {
      this.super.search = search;
    }
    set searchParams(searchParams) {
      this.super.searchParams = searchParams;
    }
    set username(username) {
      this.super.username = username;
    }
    createObjectURL(o) {
      return this.super.createObjectURL(o);
    }
    revokeObjectURL(o) {
      this.super.revokeObjectURL(o);
    }
    toJSON() {
      return this.super.toJSON();
    }
    toString() {
      return this.super.toString();
    }
    format() {
      return this.toString();
    }
  };
  function format(obj) {
    if (typeof obj === "string") {
      const url = new URL2(obj);
      return url.toString();
    }
    if (!(obj instanceof URL2)) {
      const userPass = obj.username && obj.password ? `${obj.username}:${obj.password}@` : "";
      const auth = obj.auth ? obj.auth + "@" : "";
      const port = obj.port ? ":" + obj.port : "";
      const protocol = obj.protocol ? obj.protocol + "//" : "";
      const host = obj.host || "";
      const hostname = obj.hostname || "";
      const search = obj.search || (obj.query ? "?" + obj.query : "");
      const hash = obj.hash || "";
      const pathname = obj.pathname || "";
      const path = obj.path || pathname + search;
      return `${protocol}${userPass || auth}${host || hostname + port}${path}${hash}`;
    }
  }
  module2.exports = {
    URLWithLegacySupport,
    URLSearchParams: self.URLSearchParams,
    defaultBase,
    format
  };
});

// node_modules/borc/node_modules/iso-url/src/relative.js
var require_relative3 = __commonJS((exports2, module2) => {
  "use strict";
  var {URLWithLegacySupport, format} = require_url_browser3();
  module2.exports = (url, location2 = {}, protocolMap = {}, defaultProtocol) => {
    let protocol = location2.protocol ? location2.protocol.replace(":", "") : "http";
    protocol = (protocolMap[protocol] || defaultProtocol || protocol) + ":";
    let urlParsed;
    try {
      urlParsed = new URLWithLegacySupport(url);
    } catch (err) {
      urlParsed = {};
    }
    const base = Object.assign({}, location2, {
      protocol: protocol || urlParsed.protocol,
      host: location2.host || urlParsed.host
    });
    return new URLWithLegacySupport(url, format(base)).toString();
  };
});

// node_modules/borc/node_modules/iso-url/index.js
var require_iso_url3 = __commonJS((exports2, module2) => {
  "use strict";
  var {
    URLWithLegacySupport,
    format,
    URLSearchParams: URLSearchParams2,
    defaultBase
  } = require_url_browser3();
  var relative = require_relative3();
  module2.exports = {
    URL: URLWithLegacySupport,
    URLSearchParams: URLSearchParams2,
    format,
    relative,
    defaultBase
  };
});

// node_modules/borc/src/decoder.js
var require_decoder = __commonJS((exports2, module2) => {
  "use strict";
  var {Buffer: Buffer2} = require_buffer();
  var ieee754 = require_ieee754();
  var Bignumber = require_bignumber().BigNumber;
  var parser = require_decoder_asm();
  var utils = require_utils8();
  var c = require_constants4();
  var Simple = require_simple();
  var Tagged = require_tagged();
  var {URL: URL2} = require_iso_url3();
  var Decoder = class {
    constructor(opts) {
      opts = opts || {};
      if (!opts.size || opts.size < 65536) {
        opts.size = 65536;
      } else {
        opts.size = utils.nextPowerOf2(opts.size);
      }
      this._heap = new ArrayBuffer(opts.size);
      this._heap8 = new Uint8Array(this._heap);
      this._buffer = Buffer2.from(this._heap);
      this._reset();
      this._knownTags = Object.assign({
        0: (val) => new Date(val),
        1: (val) => new Date(val * 1e3),
        2: (val) => utils.arrayBufferToBignumber(val),
        3: (val) => c.NEG_ONE.minus(utils.arrayBufferToBignumber(val)),
        4: (v) => {
          return c.TEN.pow(v[0]).times(v[1]);
        },
        5: (v) => {
          return c.TWO.pow(v[0]).times(v[1]);
        },
        32: (val) => new URL2(val),
        35: (val) => new RegExp(val)
      }, opts.tags);
      this.parser = parser(global, {
        log: console.log.bind(console),
        pushInt: this.pushInt.bind(this),
        pushInt32: this.pushInt32.bind(this),
        pushInt32Neg: this.pushInt32Neg.bind(this),
        pushInt64: this.pushInt64.bind(this),
        pushInt64Neg: this.pushInt64Neg.bind(this),
        pushFloat: this.pushFloat.bind(this),
        pushFloatSingle: this.pushFloatSingle.bind(this),
        pushFloatDouble: this.pushFloatDouble.bind(this),
        pushTrue: this.pushTrue.bind(this),
        pushFalse: this.pushFalse.bind(this),
        pushUndefined: this.pushUndefined.bind(this),
        pushNull: this.pushNull.bind(this),
        pushInfinity: this.pushInfinity.bind(this),
        pushInfinityNeg: this.pushInfinityNeg.bind(this),
        pushNaN: this.pushNaN.bind(this),
        pushNaNNeg: this.pushNaNNeg.bind(this),
        pushArrayStart: this.pushArrayStart.bind(this),
        pushArrayStartFixed: this.pushArrayStartFixed.bind(this),
        pushArrayStartFixed32: this.pushArrayStartFixed32.bind(this),
        pushArrayStartFixed64: this.pushArrayStartFixed64.bind(this),
        pushObjectStart: this.pushObjectStart.bind(this),
        pushObjectStartFixed: this.pushObjectStartFixed.bind(this),
        pushObjectStartFixed32: this.pushObjectStartFixed32.bind(this),
        pushObjectStartFixed64: this.pushObjectStartFixed64.bind(this),
        pushByteString: this.pushByteString.bind(this),
        pushByteStringStart: this.pushByteStringStart.bind(this),
        pushUtf8String: this.pushUtf8String.bind(this),
        pushUtf8StringStart: this.pushUtf8StringStart.bind(this),
        pushSimpleUnassigned: this.pushSimpleUnassigned.bind(this),
        pushTagUnassigned: this.pushTagUnassigned.bind(this),
        pushTagStart: this.pushTagStart.bind(this),
        pushTagStart4: this.pushTagStart4.bind(this),
        pushTagStart8: this.pushTagStart8.bind(this),
        pushBreak: this.pushBreak.bind(this)
      }, this._heap);
    }
    get _depth() {
      return this._parents.length;
    }
    get _currentParent() {
      return this._parents[this._depth - 1];
    }
    get _ref() {
      return this._currentParent.ref;
    }
    _closeParent() {
      var p = this._parents.pop();
      if (p.length > 0) {
        throw new Error(`Missing ${p.length} elements`);
      }
      switch (p.type) {
        case c.PARENT.TAG:
          this._push(this.createTag(p.ref[0], p.ref[1]));
          break;
        case c.PARENT.BYTE_STRING:
          this._push(this.createByteString(p.ref, p.length));
          break;
        case c.PARENT.UTF8_STRING:
          this._push(this.createUtf8String(p.ref, p.length));
          break;
        case c.PARENT.MAP:
          if (p.values % 2 > 0) {
            throw new Error("Odd number of elements in the map");
          }
          this._push(this.createMap(p.ref, p.length));
          break;
        case c.PARENT.OBJECT:
          if (p.values % 2 > 0) {
            throw new Error("Odd number of elements in the map");
          }
          this._push(this.createObject(p.ref, p.length));
          break;
        case c.PARENT.ARRAY:
          this._push(this.createArray(p.ref, p.length));
          break;
        default:
          break;
      }
      if (this._currentParent && this._currentParent.type === c.PARENT.TAG) {
        this._dec();
      }
    }
    _dec() {
      const p = this._currentParent;
      if (p.length < 0) {
        return;
      }
      p.length--;
      if (p.length === 0) {
        this._closeParent();
      }
    }
    _push(val, hasChildren) {
      const p = this._currentParent;
      p.values++;
      switch (p.type) {
        case c.PARENT.ARRAY:
        case c.PARENT.BYTE_STRING:
        case c.PARENT.UTF8_STRING:
          if (p.length > -1) {
            this._ref[this._ref.length - p.length] = val;
          } else {
            this._ref.push(val);
          }
          this._dec();
          break;
        case c.PARENT.OBJECT:
          if (p.tmpKey != null) {
            this._ref[p.tmpKey] = val;
            p.tmpKey = null;
            this._dec();
          } else {
            p.tmpKey = val;
            if (typeof p.tmpKey !== "string") {
              p.type = c.PARENT.MAP;
              p.ref = utils.buildMap(p.ref);
            }
          }
          break;
        case c.PARENT.MAP:
          if (p.tmpKey != null) {
            this._ref.set(p.tmpKey, val);
            p.tmpKey = null;
            this._dec();
          } else {
            p.tmpKey = val;
          }
          break;
        case c.PARENT.TAG:
          this._ref.push(val);
          if (!hasChildren) {
            this._dec();
          }
          break;
        default:
          throw new Error("Unknown parent type");
      }
    }
    _createParent(obj, type, len) {
      this._parents[this._depth] = {
        type,
        length: len,
        ref: obj,
        values: 0,
        tmpKey: null
      };
    }
    _reset() {
      this._res = [];
      this._parents = [{
        type: c.PARENT.ARRAY,
        length: -1,
        ref: this._res,
        values: 0,
        tmpKey: null
      }];
    }
    createTag(tagNumber, value) {
      const typ = this._knownTags[tagNumber];
      if (!typ) {
        return new Tagged(tagNumber, value);
      }
      return typ(value);
    }
    createMap(obj, len) {
      return obj;
    }
    createObject(obj, len) {
      return obj;
    }
    createArray(arr, len) {
      return arr;
    }
    createByteString(raw, len) {
      return Buffer2.concat(raw);
    }
    createByteStringFromHeap(start, end) {
      if (start === end) {
        return Buffer2.alloc(0);
      }
      return Buffer2.from(this._heap.slice(start, end));
    }
    createInt(val) {
      return val;
    }
    createInt32(f, g) {
      return utils.buildInt32(f, g);
    }
    createInt64(f1, f2, g1, g2) {
      return utils.buildInt64(f1, f2, g1, g2);
    }
    createFloat(val) {
      return val;
    }
    createFloatSingle(a, b, c2, d) {
      return ieee754.read([a, b, c2, d], 0, false, 23, 4);
    }
    createFloatDouble(a, b, c2, d, e, f, g, h) {
      return ieee754.read([a, b, c2, d, e, f, g, h], 0, false, 52, 8);
    }
    createInt32Neg(f, g) {
      return -1 - utils.buildInt32(f, g);
    }
    createInt64Neg(f1, f2, g1, g2) {
      const f = utils.buildInt32(f1, f2);
      const g = utils.buildInt32(g1, g2);
      if (f > c.MAX_SAFE_HIGH) {
        return c.NEG_ONE.minus(new Bignumber(f).times(c.SHIFT32).plus(g));
      }
      return -1 - (f * c.SHIFT32 + g);
    }
    createTrue() {
      return true;
    }
    createFalse() {
      return false;
    }
    createNull() {
      return null;
    }
    createUndefined() {
      return void 0;
    }
    createInfinity() {
      return Infinity;
    }
    createInfinityNeg() {
      return -Infinity;
    }
    createNaN() {
      return NaN;
    }
    createNaNNeg() {
      return NaN;
    }
    createUtf8String(raw, len) {
      return raw.join("");
    }
    createUtf8StringFromHeap(start, end) {
      if (start === end) {
        return "";
      }
      return this._buffer.toString("utf8", start, end);
    }
    createSimpleUnassigned(val) {
      return new Simple(val);
    }
    pushInt(val) {
      this._push(this.createInt(val));
    }
    pushInt32(f, g) {
      this._push(this.createInt32(f, g));
    }
    pushInt64(f1, f2, g1, g2) {
      this._push(this.createInt64(f1, f2, g1, g2));
    }
    pushFloat(val) {
      this._push(this.createFloat(val));
    }
    pushFloatSingle(a, b, c2, d) {
      this._push(this.createFloatSingle(a, b, c2, d));
    }
    pushFloatDouble(a, b, c2, d, e, f, g, h) {
      this._push(this.createFloatDouble(a, b, c2, d, e, f, g, h));
    }
    pushInt32Neg(f, g) {
      this._push(this.createInt32Neg(f, g));
    }
    pushInt64Neg(f1, f2, g1, g2) {
      this._push(this.createInt64Neg(f1, f2, g1, g2));
    }
    pushTrue() {
      this._push(this.createTrue());
    }
    pushFalse() {
      this._push(this.createFalse());
    }
    pushNull() {
      this._push(this.createNull());
    }
    pushUndefined() {
      this._push(this.createUndefined());
    }
    pushInfinity() {
      this._push(this.createInfinity());
    }
    pushInfinityNeg() {
      this._push(this.createInfinityNeg());
    }
    pushNaN() {
      this._push(this.createNaN());
    }
    pushNaNNeg() {
      this._push(this.createNaNNeg());
    }
    pushArrayStart() {
      this._createParent([], c.PARENT.ARRAY, -1);
    }
    pushArrayStartFixed(len) {
      this._createArrayStartFixed(len);
    }
    pushArrayStartFixed32(len1, len2) {
      const len = utils.buildInt32(len1, len2);
      this._createArrayStartFixed(len);
    }
    pushArrayStartFixed64(len1, len2, len3, len4) {
      const len = utils.buildInt64(len1, len2, len3, len4);
      this._createArrayStartFixed(len);
    }
    pushObjectStart() {
      this._createObjectStartFixed(-1);
    }
    pushObjectStartFixed(len) {
      this._createObjectStartFixed(len);
    }
    pushObjectStartFixed32(len1, len2) {
      const len = utils.buildInt32(len1, len2);
      this._createObjectStartFixed(len);
    }
    pushObjectStartFixed64(len1, len2, len3, len4) {
      const len = utils.buildInt64(len1, len2, len3, len4);
      this._createObjectStartFixed(len);
    }
    pushByteStringStart() {
      this._parents[this._depth] = {
        type: c.PARENT.BYTE_STRING,
        length: -1,
        ref: [],
        values: 0,
        tmpKey: null
      };
    }
    pushByteString(start, end) {
      this._push(this.createByteStringFromHeap(start, end));
    }
    pushUtf8StringStart() {
      this._parents[this._depth] = {
        type: c.PARENT.UTF8_STRING,
        length: -1,
        ref: [],
        values: 0,
        tmpKey: null
      };
    }
    pushUtf8String(start, end) {
      this._push(this.createUtf8StringFromHeap(start, end));
    }
    pushSimpleUnassigned(val) {
      this._push(this.createSimpleUnassigned(val));
    }
    pushTagStart(tag) {
      this._parents[this._depth] = {
        type: c.PARENT.TAG,
        length: 1,
        ref: [tag]
      };
    }
    pushTagStart4(f, g) {
      this.pushTagStart(utils.buildInt32(f, g));
    }
    pushTagStart8(f1, f2, g1, g2) {
      this.pushTagStart(utils.buildInt64(f1, f2, g1, g2));
    }
    pushTagUnassigned(tagNumber) {
      this._push(this.createTag(tagNumber));
    }
    pushBreak() {
      if (this._currentParent.length > -1) {
        throw new Error("Unexpected break");
      }
      this._closeParent();
    }
    _createObjectStartFixed(len) {
      if (len === 0) {
        this._push(this.createObject({}));
        return;
      }
      this._createParent({}, c.PARENT.OBJECT, len);
    }
    _createArrayStartFixed(len) {
      if (len === 0) {
        this._push(this.createArray([]));
        return;
      }
      this._createParent(new Array(len), c.PARENT.ARRAY, len);
    }
    _decode(input) {
      if (input.byteLength === 0) {
        throw new Error("Input too short");
      }
      this._reset();
      this._heap8.set(input);
      const code = this.parser.parse(input.byteLength);
      if (this._depth > 1) {
        while (this._currentParent.length === 0) {
          this._closeParent();
        }
        if (this._depth > 1) {
          throw new Error("Undeterminated nesting");
        }
      }
      if (code > 0) {
        throw new Error("Failed to parse");
      }
      if (this._res.length === 0) {
        throw new Error("No valid result");
      }
    }
    decodeFirst(input) {
      this._decode(input);
      return this._res[0];
    }
    decodeAll(input) {
      this._decode(input);
      return this._res;
    }
    static decode(input, enc) {
      if (typeof input === "string") {
        input = Buffer2.from(input, enc || "hex");
      }
      const dec = new Decoder({size: input.length});
      return dec.decodeFirst(input);
    }
    static decodeAll(input, enc) {
      if (typeof input === "string") {
        input = Buffer2.from(input, enc || "hex");
      }
      const dec = new Decoder({size: input.length});
      return dec.decodeAll(input);
    }
  };
  Decoder.decodeFirst = Decoder.decode;
  module2.exports = Decoder;
});

// node_modules/borc/src/diagnose.js
var require_diagnose = __commonJS((exports2, module2) => {
  "use strict";
  var {Buffer: Buffer2} = require_buffer();
  var Decoder = require_decoder();
  var utils = require_utils8();
  var Diagnose = class extends Decoder {
    createTag(tagNumber, value) {
      return `${tagNumber}(${value})`;
    }
    createInt(val) {
      return super.createInt(val).toString();
    }
    createInt32(f, g) {
      return super.createInt32(f, g).toString();
    }
    createInt64(f1, f2, g1, g2) {
      return super.createInt64(f1, f2, g1, g2).toString();
    }
    createInt32Neg(f, g) {
      return super.createInt32Neg(f, g).toString();
    }
    createInt64Neg(f1, f2, g1, g2) {
      return super.createInt64Neg(f1, f2, g1, g2).toString();
    }
    createTrue() {
      return "true";
    }
    createFalse() {
      return "false";
    }
    createFloat(val) {
      const fl = super.createFloat(val);
      if (utils.isNegativeZero(val)) {
        return "-0_1";
      }
      return `${fl}_1`;
    }
    createFloatSingle(a, b, c, d) {
      const fl = super.createFloatSingle(a, b, c, d);
      return `${fl}_2`;
    }
    createFloatDouble(a, b, c, d, e, f, g, h) {
      const fl = super.createFloatDouble(a, b, c, d, e, f, g, h);
      return `${fl}_3`;
    }
    createByteString(raw, len) {
      const val = raw.join(", ");
      if (len === -1) {
        return `(_ ${val})`;
      }
      return `h'${val}`;
    }
    createByteStringFromHeap(start, end) {
      const val = Buffer2.from(super.createByteStringFromHeap(start, end)).toString("hex");
      return `h'${val}'`;
    }
    createInfinity() {
      return "Infinity_1";
    }
    createInfinityNeg() {
      return "-Infinity_1";
    }
    createNaN() {
      return "NaN_1";
    }
    createNaNNeg() {
      return "-NaN_1";
    }
    createNull() {
      return "null";
    }
    createUndefined() {
      return "undefined";
    }
    createSimpleUnassigned(val) {
      return `simple(${val})`;
    }
    createArray(arr, len) {
      const val = super.createArray(arr, len);
      if (len === -1) {
        return `[_ ${val.join(", ")}]`;
      }
      return `[${val.join(", ")}]`;
    }
    createMap(map, len) {
      const val = super.createMap(map);
      const list = Array.from(val.keys()).reduce(collectObject(val), "");
      if (len === -1) {
        return `{_ ${list}}`;
      }
      return `{${list}}`;
    }
    createObject(obj, len) {
      const val = super.createObject(obj);
      const map = Object.keys(val).reduce(collectObject(val), "");
      if (len === -1) {
        return `{_ ${map}}`;
      }
      return `{${map}}`;
    }
    createUtf8String(raw, len) {
      const val = raw.join(", ");
      if (len === -1) {
        return `(_ ${val})`;
      }
      return `"${val}"`;
    }
    createUtf8StringFromHeap(start, end) {
      const val = Buffer2.from(super.createUtf8StringFromHeap(start, end)).toString("utf8");
      return `"${val}"`;
    }
    static diagnose(input, enc) {
      if (typeof input === "string") {
        input = Buffer2.from(input, enc || "hex");
      }
      const dec = new Diagnose();
      return dec.decodeFirst(input);
    }
  };
  module2.exports = Diagnose;
  function collectObject(val) {
    return (acc, key) => {
      if (acc) {
        return `${acc}, ${key}: ${val[key]}`;
      }
      return `${key}: ${val[key]}`;
    };
  }
});

// node_modules/borc/src/encoder.js
var require_encoder2 = __commonJS((exports2, module2) => {
  "use strict";
  var {Buffer: Buffer2} = require_buffer();
  var {URL: URL2} = require_iso_url3();
  var Bignumber = require_bignumber().BigNumber;
  var utils = require_utils8();
  var constants = require_constants4();
  var MT = constants.MT;
  var NUMBYTES = constants.NUMBYTES;
  var SHIFT32 = constants.SHIFT32;
  var SYMS = constants.SYMS;
  var TAG = constants.TAG;
  var HALF = constants.MT.SIMPLE_FLOAT << 5 | constants.NUMBYTES.TWO;
  var FLOAT = constants.MT.SIMPLE_FLOAT << 5 | constants.NUMBYTES.FOUR;
  var DOUBLE = constants.MT.SIMPLE_FLOAT << 5 | constants.NUMBYTES.EIGHT;
  var TRUE = constants.MT.SIMPLE_FLOAT << 5 | constants.SIMPLE.TRUE;
  var FALSE = constants.MT.SIMPLE_FLOAT << 5 | constants.SIMPLE.FALSE;
  var UNDEFINED = constants.MT.SIMPLE_FLOAT << 5 | constants.SIMPLE.UNDEFINED;
  var NULL = constants.MT.SIMPLE_FLOAT << 5 | constants.SIMPLE.NULL;
  var MAXINT_BN = new Bignumber("0x20000000000000");
  var BUF_NAN = Buffer2.from("f97e00", "hex");
  var BUF_INF_NEG = Buffer2.from("f9fc00", "hex");
  var BUF_INF_POS = Buffer2.from("f97c00", "hex");
  function toType(obj) {
    return {}.toString.call(obj).slice(8, -1);
  }
  var Encoder = class {
    constructor(options) {
      options = options || {};
      this.streaming = typeof options.stream === "function";
      this.onData = options.stream;
      this.semanticTypes = [
        [URL2, this._pushUrl],
        [Bignumber, this._pushBigNumber]
      ];
      const addTypes = options.genTypes || [];
      const len = addTypes.length;
      for (let i = 0; i < len; i++) {
        this.addSemanticType(addTypes[i][0], addTypes[i][1]);
      }
      this._reset();
    }
    addSemanticType(type, fun) {
      const len = this.semanticTypes.length;
      for (let i = 0; i < len; i++) {
        const typ = this.semanticTypes[i][0];
        if (typ === type) {
          const old = this.semanticTypes[i][1];
          this.semanticTypes[i][1] = fun;
          return old;
        }
      }
      this.semanticTypes.push([type, fun]);
      return null;
    }
    push(val) {
      if (!val) {
        return true;
      }
      this.result[this.offset] = val;
      this.resultMethod[this.offset] = 0;
      this.resultLength[this.offset] = val.length;
      this.offset++;
      if (this.streaming) {
        this.onData(this.finalize());
      }
      return true;
    }
    pushWrite(val, method, len) {
      this.result[this.offset] = val;
      this.resultMethod[this.offset] = method;
      this.resultLength[this.offset] = len;
      this.offset++;
      if (this.streaming) {
        this.onData(this.finalize());
      }
      return true;
    }
    _pushUInt8(val) {
      return this.pushWrite(val, 1, 1);
    }
    _pushUInt16BE(val) {
      return this.pushWrite(val, 2, 2);
    }
    _pushUInt32BE(val) {
      return this.pushWrite(val, 3, 4);
    }
    _pushDoubleBE(val) {
      return this.pushWrite(val, 4, 8);
    }
    _pushNaN() {
      return this.push(BUF_NAN);
    }
    _pushInfinity(obj) {
      const half = obj < 0 ? BUF_INF_NEG : BUF_INF_POS;
      return this.push(half);
    }
    _pushFloat(obj) {
      const b2 = Buffer2.allocUnsafe(2);
      if (utils.writeHalf(b2, obj)) {
        if (utils.parseHalf(b2) === obj) {
          return this._pushUInt8(HALF) && this.push(b2);
        }
      }
      const b4 = Buffer2.allocUnsafe(4);
      b4.writeFloatBE(obj, 0);
      if (b4.readFloatBE(0) === obj) {
        return this._pushUInt8(FLOAT) && this.push(b4);
      }
      return this._pushUInt8(DOUBLE) && this._pushDoubleBE(obj);
    }
    _pushInt(obj, mt, orig) {
      const m = mt << 5;
      if (obj < 24) {
        return this._pushUInt8(m | obj);
      }
      if (obj <= 255) {
        return this._pushUInt8(m | NUMBYTES.ONE) && this._pushUInt8(obj);
      }
      if (obj <= 65535) {
        return this._pushUInt8(m | NUMBYTES.TWO) && this._pushUInt16BE(obj);
      }
      if (obj <= 4294967295) {
        return this._pushUInt8(m | NUMBYTES.FOUR) && this._pushUInt32BE(obj);
      }
      if (obj <= Number.MAX_SAFE_INTEGER) {
        return this._pushUInt8(m | NUMBYTES.EIGHT) && this._pushUInt32BE(Math.floor(obj / SHIFT32)) && this._pushUInt32BE(obj % SHIFT32);
      }
      if (mt === MT.NEG_INT) {
        return this._pushFloat(orig);
      }
      return this._pushFloat(obj);
    }
    _pushIntNum(obj) {
      if (obj < 0) {
        return this._pushInt(-obj - 1, MT.NEG_INT, obj);
      } else {
        return this._pushInt(obj, MT.POS_INT);
      }
    }
    _pushNumber(obj) {
      switch (false) {
        case obj === obj:
          return this._pushNaN(obj);
        case isFinite(obj):
          return this._pushInfinity(obj);
        case obj % 1 !== 0:
          return this._pushIntNum(obj);
        default:
          return this._pushFloat(obj);
      }
    }
    _pushString(obj) {
      const len = Buffer2.byteLength(obj, "utf8");
      return this._pushInt(len, MT.UTF8_STRING) && this.pushWrite(obj, 5, len);
    }
    _pushBoolean(obj) {
      return this._pushUInt8(obj ? TRUE : FALSE);
    }
    _pushUndefined(obj) {
      return this._pushUInt8(UNDEFINED);
    }
    _pushArray(gen, obj) {
      const len = obj.length;
      if (!gen._pushInt(len, MT.ARRAY)) {
        return false;
      }
      for (let j = 0; j < len; j++) {
        if (!gen.pushAny(obj[j])) {
          return false;
        }
      }
      return true;
    }
    _pushTag(tag) {
      return this._pushInt(tag, MT.TAG);
    }
    _pushDate(gen, obj) {
      return gen._pushTag(TAG.DATE_EPOCH) && gen.pushAny(Math.round(obj / 1e3));
    }
    _pushBuffer(gen, obj) {
      return gen._pushInt(obj.length, MT.BYTE_STRING) && gen.push(obj);
    }
    _pushNoFilter(gen, obj) {
      return gen._pushBuffer(gen, obj.slice());
    }
    _pushRegexp(gen, obj) {
      return gen._pushTag(TAG.REGEXP) && gen.pushAny(obj.source);
    }
    _pushSet(gen, obj) {
      if (!gen._pushInt(obj.size, MT.ARRAY)) {
        return false;
      }
      for (const x of obj) {
        if (!gen.pushAny(x)) {
          return false;
        }
      }
      return true;
    }
    _pushUrl(gen, obj) {
      return gen._pushTag(TAG.URI) && gen.pushAny(obj.format());
    }
    _pushBigint(obj) {
      let tag = TAG.POS_BIGINT;
      if (obj.isNegative()) {
        obj = obj.negated().minus(1);
        tag = TAG.NEG_BIGINT;
      }
      let str = obj.toString(16);
      if (str.length % 2) {
        str = "0" + str;
      }
      const buf = Buffer2.from(str, "hex");
      return this._pushTag(tag) && this._pushBuffer(this, buf);
    }
    _pushBigNumber(gen, obj) {
      if (obj.isNaN()) {
        return gen._pushNaN();
      }
      if (!obj.isFinite()) {
        return gen._pushInfinity(obj.isNegative() ? -Infinity : Infinity);
      }
      if (obj.isInteger()) {
        return gen._pushBigint(obj);
      }
      if (!(gen._pushTag(TAG.DECIMAL_FRAC) && gen._pushInt(2, MT.ARRAY))) {
        return false;
      }
      const dec = obj.decimalPlaces();
      const slide = obj.multipliedBy(new Bignumber(10).pow(dec));
      if (!gen._pushIntNum(-dec)) {
        return false;
      }
      if (slide.abs().isLessThan(MAXINT_BN)) {
        return gen._pushIntNum(slide.toNumber());
      } else {
        return gen._pushBigint(slide);
      }
    }
    _pushMap(gen, obj) {
      if (!gen._pushInt(obj.size, MT.MAP)) {
        return false;
      }
      return this._pushRawMap(obj.size, Array.from(obj));
    }
    _pushObject(obj) {
      if (!obj) {
        return this._pushUInt8(NULL);
      }
      var len = this.semanticTypes.length;
      for (var i = 0; i < len; i++) {
        if (obj instanceof this.semanticTypes[i][0]) {
          return this.semanticTypes[i][1].call(obj, this, obj);
        }
      }
      var f = obj.encodeCBOR;
      if (typeof f === "function") {
        return f.call(obj, this);
      }
      var keys = Object.keys(obj);
      var keyLength = keys.length;
      if (!this._pushInt(keyLength, MT.MAP)) {
        return false;
      }
      return this._pushRawMap(keyLength, keys.map((k) => [k, obj[k]]));
    }
    _pushRawMap(len, map) {
      map = map.map(function(a) {
        a[0] = Encoder.encode(a[0]);
        return a;
      }).sort(utils.keySorter);
      for (var j = 0; j < len; j++) {
        if (!this.push(map[j][0])) {
          return false;
        }
        if (!this.pushAny(map[j][1])) {
          return false;
        }
      }
      return true;
    }
    write(obj) {
      return this.pushAny(obj);
    }
    pushAny(obj) {
      var typ = toType(obj);
      switch (typ) {
        case "Number":
          return this._pushNumber(obj);
        case "String":
          return this._pushString(obj);
        case "Boolean":
          return this._pushBoolean(obj);
        case "Object":
          return this._pushObject(obj);
        case "Array":
          return this._pushArray(this, obj);
        case "Uint8Array":
          return this._pushBuffer(this, Buffer2.isBuffer(obj) ? obj : Buffer2.from(obj));
        case "Null":
          return this._pushUInt8(NULL);
        case "Undefined":
          return this._pushUndefined(obj);
        case "Map":
          return this._pushMap(this, obj);
        case "Set":
          return this._pushSet(this, obj);
        case "URL":
          return this._pushUrl(this, obj);
        case "BigNumber":
          return this._pushBigNumber(this, obj);
        case "Date":
          return this._pushDate(this, obj);
        case "RegExp":
          return this._pushRegexp(this, obj);
        case "Symbol":
          switch (obj) {
            case SYMS.NULL:
              return this._pushObject(null);
            case SYMS.UNDEFINED:
              return this._pushUndefined(void 0);
            default:
              throw new Error("Unknown symbol: " + obj.toString());
          }
        default:
          throw new Error("Unknown type: " + typeof obj + ", " + (obj ? obj.toString() : ""));
      }
    }
    finalize() {
      if (this.offset === 0) {
        return null;
      }
      var result = this.result;
      var resultLength = this.resultLength;
      var resultMethod = this.resultMethod;
      var offset = this.offset;
      var size = 0;
      var i = 0;
      for (; i < offset; i++) {
        size += resultLength[i];
      }
      var res = Buffer2.allocUnsafe(size);
      var index = 0;
      var length = 0;
      for (i = 0; i < offset; i++) {
        length = resultLength[i];
        switch (resultMethod[i]) {
          case 0:
            result[i].copy(res, index);
            break;
          case 1:
            res.writeUInt8(result[i], index, true);
            break;
          case 2:
            res.writeUInt16BE(result[i], index, true);
            break;
          case 3:
            res.writeUInt32BE(result[i], index, true);
            break;
          case 4:
            res.writeDoubleBE(result[i], index, true);
            break;
          case 5:
            res.write(result[i], index, length, "utf8");
            break;
          default:
            throw new Error("unkown method");
        }
        index += length;
      }
      var tmp = res;
      this._reset();
      return tmp;
    }
    _reset() {
      this.result = [];
      this.resultMethod = [];
      this.resultLength = [];
      this.offset = 0;
    }
    static encode(o) {
      const enc = new Encoder();
      const ret = enc.pushAny(o);
      if (!ret) {
        throw new Error("Failed to encode input");
      }
      return enc.finalize();
    }
  };
  module2.exports = Encoder;
});

// node_modules/borc/src/index.js
var require_src18 = __commonJS((exports2) => {
  "use strict";
  exports2.Diagnose = require_diagnose();
  exports2.Decoder = require_decoder();
  exports2.Encoder = require_encoder2();
  exports2.Simple = require_simple();
  exports2.Tagged = require_tagged();
  exports2.decodeAll = exports2.Decoder.decodeAll;
  exports2.decodeFirst = exports2.Decoder.decodeFirst;
  exports2.diagnose = exports2.Diagnose.diagnose;
  exports2.encode = exports2.Encoder.encode;
  exports2.decode = exports2.Decoder.decode;
  exports2.leveldb = {
    decode: exports2.Decoder.decodeAll,
    encode: exports2.Encoder.encode,
    buffer: true,
    name: "cbor"
  };
});

// node_modules/is-circular/lib/node.js
var require_node = __commonJS((exports2, module2) => {
  module2.exports = Node;
  function Node(value, next) {
    this.value = value;
    this.next = next;
  }
  Node.prototype.contains = function(value) {
    var cursor = this;
    while (cursor) {
      if (cursor.value === value)
        return true;
      cursor = cursor.next;
    }
    return false;
  };
});

// node_modules/is-circular/index.js
var require_is_circular = __commonJS((exports2, module2) => {
  var Node = require_node();
  module2.exports = isCircular;
  function isCircular(obj) {
    if (!(obj instanceof Object)) {
      throw new TypeError('"obj" must be an object (or inherit from it)');
    }
    return _isCircular(obj);
  }
  function _isCircular(obj, parentList) {
    parentList = new Node(obj, parentList);
    for (var key in obj) {
      var val = obj[key];
      if (val instanceof Object) {
        if (parentList.contains(val) || _isCircular(val, parentList)) {
          return true;
        }
      }
    }
    return false;
  }
});

// node_modules/ipld-dag-cbor/src/util.js
var require_util8 = __commonJS((exports2, module2) => {
  "use strict";
  var cbor = require_src18();
  var multicodec = require_src6();
  var multihashing = require_src14();
  var CID = require_src7();
  var isCircular = require_is_circular();
  var uint8ArrayConcat = require_concat2();
  var uint8ArrayFromString = require_from_string2();
  var CID_CBOR_TAG = 42;
  function tagCID(cid) {
    if (typeof cid === "string") {
      cid = new CID(cid).bytes;
    } else if (CID.isCID(cid)) {
      cid = cid.bytes;
    }
    return new cbor.Tagged(CID_CBOR_TAG, uint8ArrayConcat([
      uint8ArrayFromString("00", "base16"),
      cid
    ], 1 + cid.length));
  }
  function replaceCIDbyTAG(dagNode) {
    let circular;
    try {
      circular = isCircular(dagNode);
    } catch (e) {
      circular = false;
    }
    if (circular) {
      throw new Error("The object passed has circular references");
    }
    function transform(obj) {
      if (!obj || obj instanceof Uint8Array || typeof obj === "string") {
        return obj;
      }
      if (Array.isArray(obj)) {
        return obj.map(transform);
      }
      if (CID.isCID(obj)) {
        return tagCID(obj);
      }
      const keys = Object.keys(obj);
      if (keys.length > 0) {
        const out = {};
        keys.forEach((key) => {
          if (typeof obj[key] === "object") {
            out[key] = transform(obj[key]);
          } else {
            out[key] = obj[key];
          }
        });
        return out;
      } else {
        return obj;
      }
    }
    return transform(dagNode);
  }
  exports2 = module2.exports;
  exports2.codec = multicodec.DAG_CBOR;
  exports2.defaultHashAlg = multicodec.SHA2_256;
  var defaultTags = {
    [CID_CBOR_TAG]: (val) => {
      val = val.slice(1);
      return new CID(val);
    }
  };
  var defaultSize = 64 * 1024;
  var currentSize = defaultSize;
  var defaultMaxSize = 64 * 1024 * 1024;
  var maxSize = defaultMaxSize;
  var decoder = null;
  exports2.configureDecoder = (options) => {
    let tags = defaultTags;
    if (options) {
      if (typeof options.size === "number") {
        currentSize = options.size;
      }
      if (typeof options.maxSize === "number") {
        maxSize = options.maxSize;
      }
      if (options.tags) {
        tags = Object.assign({}, defaultTags, options && options.tags);
      }
    } else {
      currentSize = defaultSize;
      maxSize = defaultMaxSize;
    }
    const decoderOptions = {
      tags,
      size: currentSize
    };
    decoder = new cbor.Decoder(decoderOptions);
    currentSize = decoderOptions.size;
  };
  exports2.configureDecoder();
  exports2.serialize = (node) => {
    const nodeTagged = replaceCIDbyTAG(node);
    const serialized = cbor.encode(nodeTagged);
    return serialized;
  };
  exports2.deserialize = (data) => {
    if (data.length > currentSize && data.length <= maxSize) {
      exports2.configureDecoder({size: data.length});
    }
    if (data.length > currentSize) {
      throw new Error("Data is too large to deserialize with current decoder");
    }
    const all = decoder.decodeAll(data);
    if (all.length !== 1) {
      throw new Error("Extraneous CBOR data found beyond initial top-level object");
    }
    return all[0];
  };
  exports2.cid = async (binaryBlob, userOptions) => {
    const defaultOptions = {cidVersion: 1, hashAlg: exports2.defaultHashAlg};
    const options = Object.assign(defaultOptions, userOptions);
    const multihash = await multihashing(binaryBlob, options.hashAlg);
    const codecName = multicodec.print[exports2.codec];
    const cid = new CID(options.cidVersion, codecName, multihash);
    return cid;
  };
});

// node_modules/ipld-dag-cbor/src/resolver.js
var require_resolver2 = __commonJS((exports2) => {
  "use strict";
  var CID = require_src7();
  var util = require_util8();
  exports2.resolve = (binaryBlob, path) => {
    let node = util.deserialize(binaryBlob);
    const parts = path.split("/").filter(Boolean);
    while (parts.length) {
      const key = parts.shift();
      if (node[key] === void 0) {
        throw new Error(`Object has no property '${key}'`);
      }
      node = node[key];
      if (CID.isCID(node)) {
        return {
          value: node,
          remainderPath: parts.join("/")
        };
      }
    }
    return {
      value: node,
      remainderPath: ""
    };
  };
  var traverse = function* (node, path) {
    if (node instanceof Uint8Array || CID.isCID(node) || typeof node === "string" || node === null) {
      return;
    }
    for (const item of Object.keys(node)) {
      const nextpath = path === void 0 ? item : path + "/" + item;
      yield nextpath;
      yield* traverse(node[item], nextpath);
    }
  };
  exports2.tree = function* (binaryBlob) {
    const node = util.deserialize(binaryBlob);
    yield* traverse(node);
  };
});

// node_modules/ipld-dag-cbor/src/index.js
var require_src19 = __commonJS((exports2) => {
  "use strict";
  exports2.util = require_util8();
  exports2.resolver = require_resolver2();
  exports2.codec = exports2.util.codec;
  exports2.defaultHashAlg = exports2.util.defaultHashAlg;
});

// node_modules/dag-cbor-links/index.js
var require_dag_cbor_links = __commonJS((exports2, module2) => {
  var cbor = require_src19().util;
  var CID = require_src7();
  var links = (obj, path = [], parseBuffer = true) => {
    if (parseBuffer && Buffer.isBuffer(obj)) {
      obj = cbor.deserialize(obj);
    }
    return function* () {
      for (let key of Object.keys(obj)) {
        let _path = path.slice();
        _path.push(key);
        let val = obj[key];
        if (val && typeof val === "object") {
          if (Array.isArray(val)) {
            for (let i = 0; i < val.length; i++) {
              let __path = _path.slice();
              __path.push(i);
              let o = val[i];
              if (CID.isCID(o)) {
                yield [__path.join("/"), o];
              } else if (typeof o === "object") {
                yield* links(o, _path, false);
              }
            }
          } else {
            if (CID.isCID(val)) {
              yield [_path.join("/"), val];
            } else {
              yield* links(val, _path, false);
            }
          }
        }
      }
    }();
  };
  module2.exports = links;
});

// node_modules/it-first/index.js
var require_it_first = __commonJS((exports2, module2) => {
  "use strict";
  var first = async (source) => {
    for await (const entry of source) {
      return entry;
    }
  };
  module2.exports = first;
});

// node_modules/it-all/index.js
var require_it_all = __commonJS((exports2, module2) => {
  "use strict";
  var all = async (source) => {
    const arr = [];
    for await (const entry of source) {
      arr.push(entry);
    }
    return arr;
  };
  module2.exports = all;
});

// node_modules/cbor/lib/constants.js
var require_constants5 = __commonJS((exports2) => {
  "use strict";
  var {BigNumber} = require_bignumber();
  exports2.BigNumber = BigNumber;
  exports2.MT = {
    POS_INT: 0,
    NEG_INT: 1,
    BYTE_STRING: 2,
    UTF8_STRING: 3,
    ARRAY: 4,
    MAP: 5,
    TAG: 6,
    SIMPLE_FLOAT: 7
  };
  exports2.TAG = {
    DATE_STRING: 0,
    DATE_EPOCH: 1,
    POS_BIGINT: 2,
    NEG_BIGINT: 3,
    DECIMAL_FRAC: 4,
    BIGFLOAT: 5,
    BASE64URL_EXPECTED: 21,
    BASE64_EXPECTED: 22,
    BASE16_EXPECTED: 23,
    CBOR: 24,
    URI: 32,
    BASE64URL: 33,
    BASE64: 34,
    REGEXP: 35,
    MIME: 36
  };
  exports2.NUMBYTES = {
    ZERO: 0,
    ONE: 24,
    TWO: 25,
    FOUR: 26,
    EIGHT: 27,
    INDEFINITE: 31
  };
  exports2.SIMPLE = {
    FALSE: 20,
    TRUE: 21,
    NULL: 22,
    UNDEFINED: 23
  };
  exports2.SYMS = {
    NULL: Symbol("null"),
    UNDEFINED: Symbol("undef"),
    PARENT: Symbol("parent"),
    BREAK: Symbol("break"),
    STREAM: Symbol("stream")
  };
  exports2.SHIFT32 = 4294967296;
  exports2.BI = {
    MINUS_ONE: BigInt(-1),
    NEG_MAX: BigInt(-1) - BigInt(Number.MAX_SAFE_INTEGER),
    MAXINT32: BigInt("0xffffffff"),
    MAXINT64: BigInt("0xffffffffffffffff"),
    SHIFT32: BigInt(exports2.SHIFT32)
  };
  var MINUS_ONE = new BigNumber(-1);
  exports2.BN = {
    MINUS_ONE,
    NEG_MAX: MINUS_ONE.minus(new BigNumber(Number.MAX_SAFE_INTEGER.toString(16), 16)),
    TWO: new BigNumber(2),
    MAXINT: new BigNumber("0x20000000000000"),
    MAXINT32: new BigNumber(4294967295),
    MAXINT64: new BigNumber("0xffffffffffffffff"),
    SHIFT32: new BigNumber(exports2.SHIFT32)
  };
});

// node_modules/events/events.js
var require_events = __commonJS((exports2, module2) => {
  "use strict";
  var R = typeof Reflect === "object" ? Reflect : null;
  var ReflectApply = R && typeof R.apply === "function" ? R.apply : function ReflectApply2(target, receiver, args) {
    return Function.prototype.apply.call(target, receiver, args);
  };
  var ReflectOwnKeys;
  if (R && typeof R.ownKeys === "function") {
    ReflectOwnKeys = R.ownKeys;
  } else if (Object.getOwnPropertySymbols) {
    ReflectOwnKeys = function ReflectOwnKeys2(target) {
      return Object.getOwnPropertyNames(target).concat(Object.getOwnPropertySymbols(target));
    };
  } else {
    ReflectOwnKeys = function ReflectOwnKeys2(target) {
      return Object.getOwnPropertyNames(target);
    };
  }
  function ProcessEmitWarning(warning) {
    if (console && console.warn)
      console.warn(warning);
  }
  var NumberIsNaN = Number.isNaN || function NumberIsNaN2(value) {
    return value !== value;
  };
  function EventEmitter() {
    EventEmitter.init.call(this);
  }
  module2.exports = EventEmitter;
  module2.exports.once = once;
  EventEmitter.EventEmitter = EventEmitter;
  EventEmitter.prototype._events = void 0;
  EventEmitter.prototype._eventsCount = 0;
  EventEmitter.prototype._maxListeners = void 0;
  var defaultMaxListeners = 10;
  function checkListener(listener) {
    if (typeof listener !== "function") {
      throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
    }
  }
  Object.defineProperty(EventEmitter, "defaultMaxListeners", {
    enumerable: true,
    get: function() {
      return defaultMaxListeners;
    },
    set: function(arg) {
      if (typeof arg !== "number" || arg < 0 || NumberIsNaN(arg)) {
        throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + ".");
      }
      defaultMaxListeners = arg;
    }
  });
  EventEmitter.init = function() {
    if (this._events === void 0 || this._events === Object.getPrototypeOf(this)._events) {
      this._events = Object.create(null);
      this._eventsCount = 0;
    }
    this._maxListeners = this._maxListeners || void 0;
  };
  EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
    if (typeof n !== "number" || n < 0 || NumberIsNaN(n)) {
      throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + ".");
    }
    this._maxListeners = n;
    return this;
  };
  function _getMaxListeners(that) {
    if (that._maxListeners === void 0)
      return EventEmitter.defaultMaxListeners;
    return that._maxListeners;
  }
  EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
    return _getMaxListeners(this);
  };
  EventEmitter.prototype.emit = function emit(type) {
    var args = [];
    for (var i = 1; i < arguments.length; i++)
      args.push(arguments[i]);
    var doError = type === "error";
    var events = this._events;
    if (events !== void 0)
      doError = doError && events.error === void 0;
    else if (!doError)
      return false;
    if (doError) {
      var er;
      if (args.length > 0)
        er = args[0];
      if (er instanceof Error) {
        throw er;
      }
      var err = new Error("Unhandled error." + (er ? " (" + er.message + ")" : ""));
      err.context = er;
      throw err;
    }
    var handler = events[type];
    if (handler === void 0)
      return false;
    if (typeof handler === "function") {
      ReflectApply(handler, this, args);
    } else {
      var len = handler.length;
      var listeners = arrayClone(handler, len);
      for (var i = 0; i < len; ++i)
        ReflectApply(listeners[i], this, args);
    }
    return true;
  };
  function _addListener(target, type, listener, prepend) {
    var m;
    var events;
    var existing;
    checkListener(listener);
    events = target._events;
    if (events === void 0) {
      events = target._events = Object.create(null);
      target._eventsCount = 0;
    } else {
      if (events.newListener !== void 0) {
        target.emit("newListener", type, listener.listener ? listener.listener : listener);
        events = target._events;
      }
      existing = events[type];
    }
    if (existing === void 0) {
      existing = events[type] = listener;
      ++target._eventsCount;
    } else {
      if (typeof existing === "function") {
        existing = events[type] = prepend ? [listener, existing] : [existing, listener];
      } else if (prepend) {
        existing.unshift(listener);
      } else {
        existing.push(listener);
      }
      m = _getMaxListeners(target);
      if (m > 0 && existing.length > m && !existing.warned) {
        existing.warned = true;
        var w = new Error("Possible EventEmitter memory leak detected. " + existing.length + " " + String(type) + " listeners added. Use emitter.setMaxListeners() to increase limit");
        w.name = "MaxListenersExceededWarning";
        w.emitter = target;
        w.type = type;
        w.count = existing.length;
        ProcessEmitWarning(w);
      }
    }
    return target;
  }
  EventEmitter.prototype.addListener = function addListener(type, listener) {
    return _addListener(this, type, listener, false);
  };
  EventEmitter.prototype.on = EventEmitter.prototype.addListener;
  EventEmitter.prototype.prependListener = function prependListener(type, listener) {
    return _addListener(this, type, listener, true);
  };
  function onceWrapper() {
    if (!this.fired) {
      this.target.removeListener(this.type, this.wrapFn);
      this.fired = true;
      if (arguments.length === 0)
        return this.listener.call(this.target);
      return this.listener.apply(this.target, arguments);
    }
  }
  function _onceWrap(target, type, listener) {
    var state = {fired: false, wrapFn: void 0, target, type, listener};
    var wrapped = onceWrapper.bind(state);
    wrapped.listener = listener;
    state.wrapFn = wrapped;
    return wrapped;
  }
  EventEmitter.prototype.once = function once2(type, listener) {
    checkListener(listener);
    this.on(type, _onceWrap(this, type, listener));
    return this;
  };
  EventEmitter.prototype.prependOnceListener = function prependOnceListener(type, listener) {
    checkListener(listener);
    this.prependListener(type, _onceWrap(this, type, listener));
    return this;
  };
  EventEmitter.prototype.removeListener = function removeListener(type, listener) {
    var list, events, position, i, originalListener;
    checkListener(listener);
    events = this._events;
    if (events === void 0)
      return this;
    list = events[type];
    if (list === void 0)
      return this;
    if (list === listener || list.listener === listener) {
      if (--this._eventsCount === 0)
        this._events = Object.create(null);
      else {
        delete events[type];
        if (events.removeListener)
          this.emit("removeListener", type, list.listener || listener);
      }
    } else if (typeof list !== "function") {
      position = -1;
      for (i = list.length - 1; i >= 0; i--) {
        if (list[i] === listener || list[i].listener === listener) {
          originalListener = list[i].listener;
          position = i;
          break;
        }
      }
      if (position < 0)
        return this;
      if (position === 0)
        list.shift();
      else {
        spliceOne(list, position);
      }
      if (list.length === 1)
        events[type] = list[0];
      if (events.removeListener !== void 0)
        this.emit("removeListener", type, originalListener || listener);
    }
    return this;
  };
  EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
  EventEmitter.prototype.removeAllListeners = function removeAllListeners(type) {
    var listeners, events, i;
    events = this._events;
    if (events === void 0)
      return this;
    if (events.removeListener === void 0) {
      if (arguments.length === 0) {
        this._events = Object.create(null);
        this._eventsCount = 0;
      } else if (events[type] !== void 0) {
        if (--this._eventsCount === 0)
          this._events = Object.create(null);
        else
          delete events[type];
      }
      return this;
    }
    if (arguments.length === 0) {
      var keys = Object.keys(events);
      var key;
      for (i = 0; i < keys.length; ++i) {
        key = keys[i];
        if (key === "removeListener")
          continue;
        this.removeAllListeners(key);
      }
      this.removeAllListeners("removeListener");
      this._events = Object.create(null);
      this._eventsCount = 0;
      return this;
    }
    listeners = events[type];
    if (typeof listeners === "function") {
      this.removeListener(type, listeners);
    } else if (listeners !== void 0) {
      for (i = listeners.length - 1; i >= 0; i--) {
        this.removeListener(type, listeners[i]);
      }
    }
    return this;
  };
  function _listeners(target, type, unwrap) {
    var events = target._events;
    if (events === void 0)
      return [];
    var evlistener = events[type];
    if (evlistener === void 0)
      return [];
    if (typeof evlistener === "function")
      return unwrap ? [evlistener.listener || evlistener] : [evlistener];
    return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
  }
  EventEmitter.prototype.listeners = function listeners(type) {
    return _listeners(this, type, true);
  };
  EventEmitter.prototype.rawListeners = function rawListeners(type) {
    return _listeners(this, type, false);
  };
  EventEmitter.listenerCount = function(emitter, type) {
    if (typeof emitter.listenerCount === "function") {
      return emitter.listenerCount(type);
    } else {
      return listenerCount.call(emitter, type);
    }
  };
  EventEmitter.prototype.listenerCount = listenerCount;
  function listenerCount(type) {
    var events = this._events;
    if (events !== void 0) {
      var evlistener = events[type];
      if (typeof evlistener === "function") {
        return 1;
      } else if (evlistener !== void 0) {
        return evlistener.length;
      }
    }
    return 0;
  }
  EventEmitter.prototype.eventNames = function eventNames() {
    return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
  };
  function arrayClone(arr, n) {
    var copy = new Array(n);
    for (var i = 0; i < n; ++i)
      copy[i] = arr[i];
    return copy;
  }
  function spliceOne(list, index) {
    for (; index + 1 < list.length; index++)
      list[index] = list[index + 1];
    list.pop();
  }
  function unwrapListeners(arr) {
    var ret = new Array(arr.length);
    for (var i = 0; i < ret.length; ++i) {
      ret[i] = arr[i].listener || arr[i];
    }
    return ret;
  }
  function once(emitter, name) {
    return new Promise(function(resolve, reject) {
      function eventListener() {
        if (errorListener !== void 0) {
          emitter.removeListener("error", errorListener);
        }
        resolve([].slice.call(arguments));
      }
      ;
      var errorListener;
      if (name !== "error") {
        errorListener = function errorListener2(err) {
          emitter.removeListener(name, eventListener);
          reject(err);
        };
        emitter.once("error", errorListener);
      }
      emitter.once(name, eventListener);
    });
  }
});

// node_modules/readable-stream/lib/internal/streams/stream-browser.js
var require_stream_browser = __commonJS((exports2, module2) => {
  module2.exports = require_events().EventEmitter;
});

// empty:/Users/gozala/Projects/replicator/node_modules/util/util.js
var require_util9 = __commonJS(() => {
});

// node_modules/readable-stream/lib/internal/streams/buffer_list.js
var require_buffer_list = __commonJS((exports2, module2) => {
  "use strict";
  function ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      if (enumerableOnly)
        symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        });
      keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i] != null ? arguments[i] : {};
      if (i % 2) {
        ownKeys(Object(source), true).forEach(function(key) {
          _defineProperty(target, key, source[key]);
        });
      } else if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
    }
    return target;
  }
  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {value, enumerable: true, configurable: true, writable: true});
    } else {
      obj[key] = value;
    }
    return obj;
  }
  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor)
        descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }
  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps)
      _defineProperties(Constructor.prototype, protoProps);
    if (staticProps)
      _defineProperties(Constructor, staticProps);
    return Constructor;
  }
  var _require = require_buffer();
  var Buffer2 = _require.Buffer;
  var _require2 = require_util9();
  var inspect = _require2.inspect;
  var custom = inspect && inspect.custom || "inspect";
  function copyBuffer(src, target, offset) {
    Buffer2.prototype.copy.call(src, target, offset);
  }
  module2.exports = /* @__PURE__ */ function() {
    function BufferList() {
      _classCallCheck(this, BufferList);
      this.head = null;
      this.tail = null;
      this.length = 0;
    }
    _createClass(BufferList, [{
      key: "push",
      value: function push(v) {
        var entry = {
          data: v,
          next: null
        };
        if (this.length > 0)
          this.tail.next = entry;
        else
          this.head = entry;
        this.tail = entry;
        ++this.length;
      }
    }, {
      key: "unshift",
      value: function unshift(v) {
        var entry = {
          data: v,
          next: this.head
        };
        if (this.length === 0)
          this.tail = entry;
        this.head = entry;
        ++this.length;
      }
    }, {
      key: "shift",
      value: function shift() {
        if (this.length === 0)
          return;
        var ret = this.head.data;
        if (this.length === 1)
          this.head = this.tail = null;
        else
          this.head = this.head.next;
        --this.length;
        return ret;
      }
    }, {
      key: "clear",
      value: function clear() {
        this.head = this.tail = null;
        this.length = 0;
      }
    }, {
      key: "join",
      value: function join(s) {
        if (this.length === 0)
          return "";
        var p = this.head;
        var ret = "" + p.data;
        while (p = p.next) {
          ret += s + p.data;
        }
        return ret;
      }
    }, {
      key: "concat",
      value: function concat(n) {
        if (this.length === 0)
          return Buffer2.alloc(0);
        var ret = Buffer2.allocUnsafe(n >>> 0);
        var p = this.head;
        var i = 0;
        while (p) {
          copyBuffer(p.data, ret, i);
          i += p.data.length;
          p = p.next;
        }
        return ret;
      }
    }, {
      key: "consume",
      value: function consume(n, hasStrings) {
        var ret;
        if (n < this.head.data.length) {
          ret = this.head.data.slice(0, n);
          this.head.data = this.head.data.slice(n);
        } else if (n === this.head.data.length) {
          ret = this.shift();
        } else {
          ret = hasStrings ? this._getString(n) : this._getBuffer(n);
        }
        return ret;
      }
    }, {
      key: "first",
      value: function first() {
        return this.head.data;
      }
    }, {
      key: "_getString",
      value: function _getString(n) {
        var p = this.head;
        var c = 1;
        var ret = p.data;
        n -= ret.length;
        while (p = p.next) {
          var str = p.data;
          var nb = n > str.length ? str.length : n;
          if (nb === str.length)
            ret += str;
          else
            ret += str.slice(0, n);
          n -= nb;
          if (n === 0) {
            if (nb === str.length) {
              ++c;
              if (p.next)
                this.head = p.next;
              else
                this.head = this.tail = null;
            } else {
              this.head = p;
              p.data = str.slice(nb);
            }
            break;
          }
          ++c;
        }
        this.length -= c;
        return ret;
      }
    }, {
      key: "_getBuffer",
      value: function _getBuffer(n) {
        var ret = Buffer2.allocUnsafe(n);
        var p = this.head;
        var c = 1;
        p.data.copy(ret);
        n -= p.data.length;
        while (p = p.next) {
          var buf = p.data;
          var nb = n > buf.length ? buf.length : n;
          buf.copy(ret, ret.length - n, 0, nb);
          n -= nb;
          if (n === 0) {
            if (nb === buf.length) {
              ++c;
              if (p.next)
                this.head = p.next;
              else
                this.head = this.tail = null;
            } else {
              this.head = p;
              p.data = buf.slice(nb);
            }
            break;
          }
          ++c;
        }
        this.length -= c;
        return ret;
      }
    }, {
      key: custom,
      value: function value(_, options) {
        return inspect(this, _objectSpread({}, options, {
          depth: 0,
          customInspect: false
        }));
      }
    }]);
    return BufferList;
  }();
});

// node_modules/readable-stream/lib/internal/streams/destroy.js
var require_destroy = __commonJS((exports2, module2) => {
  "use strict";
  function destroy(err, cb) {
    var _this = this;
    var readableDestroyed = this._readableState && this._readableState.destroyed;
    var writableDestroyed = this._writableState && this._writableState.destroyed;
    if (readableDestroyed || writableDestroyed) {
      if (cb) {
        cb(err);
      } else if (err) {
        if (!this._writableState) {
          process.nextTick(emitErrorNT, this, err);
        } else if (!this._writableState.errorEmitted) {
          this._writableState.errorEmitted = true;
          process.nextTick(emitErrorNT, this, err);
        }
      }
      return this;
    }
    if (this._readableState) {
      this._readableState.destroyed = true;
    }
    if (this._writableState) {
      this._writableState.destroyed = true;
    }
    this._destroy(err || null, function(err2) {
      if (!cb && err2) {
        if (!_this._writableState) {
          process.nextTick(emitErrorAndCloseNT, _this, err2);
        } else if (!_this._writableState.errorEmitted) {
          _this._writableState.errorEmitted = true;
          process.nextTick(emitErrorAndCloseNT, _this, err2);
        } else {
          process.nextTick(emitCloseNT, _this);
        }
      } else if (cb) {
        process.nextTick(emitCloseNT, _this);
        cb(err2);
      } else {
        process.nextTick(emitCloseNT, _this);
      }
    });
    return this;
  }
  function emitErrorAndCloseNT(self2, err) {
    emitErrorNT(self2, err);
    emitCloseNT(self2);
  }
  function emitCloseNT(self2) {
    if (self2._writableState && !self2._writableState.emitClose)
      return;
    if (self2._readableState && !self2._readableState.emitClose)
      return;
    self2.emit("close");
  }
  function undestroy() {
    if (this._readableState) {
      this._readableState.destroyed = false;
      this._readableState.reading = false;
      this._readableState.ended = false;
      this._readableState.endEmitted = false;
    }
    if (this._writableState) {
      this._writableState.destroyed = false;
      this._writableState.ended = false;
      this._writableState.ending = false;
      this._writableState.finalCalled = false;
      this._writableState.prefinished = false;
      this._writableState.finished = false;
      this._writableState.errorEmitted = false;
    }
  }
  function emitErrorNT(self2, err) {
    self2.emit("error", err);
  }
  function errorOrDestroy(stream, err) {
    var rState = stream._readableState;
    var wState = stream._writableState;
    if (rState && rState.autoDestroy || wState && wState.autoDestroy)
      stream.destroy(err);
    else
      stream.emit("error", err);
  }
  module2.exports = {
    destroy,
    undestroy,
    errorOrDestroy
  };
});

// node_modules/readable-stream/errors.js
var require_errors4 = __commonJS((exports2, module2) => {
  "use strict";
  var codes = {};
  function createErrorType(code, message, Base) {
    if (!Base) {
      Base = Error;
    }
    function getMessage(arg1, arg2, arg3) {
      if (typeof message === "string") {
        return message;
      } else {
        return message(arg1, arg2, arg3);
      }
    }
    class NodeError extends Base {
      constructor(arg1, arg2, arg3) {
        super(getMessage(arg1, arg2, arg3));
      }
    }
    NodeError.prototype.name = Base.name;
    NodeError.prototype.code = code;
    codes[code] = NodeError;
  }
  function oneOf(expected, thing) {
    if (Array.isArray(expected)) {
      const len = expected.length;
      expected = expected.map((i) => String(i));
      if (len > 2) {
        return `one of ${thing} ${expected.slice(0, len - 1).join(", ")}, or ` + expected[len - 1];
      } else if (len === 2) {
        return `one of ${thing} ${expected[0]} or ${expected[1]}`;
      } else {
        return `of ${thing} ${expected[0]}`;
      }
    } else {
      return `of ${thing} ${String(expected)}`;
    }
  }
  function startsWith(str, search, pos) {
    return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
  }
  function endsWith(str, search, this_len) {
    if (this_len === void 0 || this_len > str.length) {
      this_len = str.length;
    }
    return str.substring(this_len - search.length, this_len) === search;
  }
  function includes(str, search, start) {
    if (typeof start !== "number") {
      start = 0;
    }
    if (start + search.length > str.length) {
      return false;
    } else {
      return str.indexOf(search, start) !== -1;
    }
  }
  createErrorType("ERR_INVALID_OPT_VALUE", function(name, value) {
    return 'The value "' + value + '" is invalid for option "' + name + '"';
  }, TypeError);
  createErrorType("ERR_INVALID_ARG_TYPE", function(name, expected, actual) {
    let determiner;
    if (typeof expected === "string" && startsWith(expected, "not ")) {
      determiner = "must not be";
      expected = expected.replace(/^not /, "");
    } else {
      determiner = "must be";
    }
    let msg;
    if (endsWith(name, " argument")) {
      msg = `The ${name} ${determiner} ${oneOf(expected, "type")}`;
    } else {
      const type = includes(name, ".") ? "property" : "argument";
      msg = `The "${name}" ${type} ${determiner} ${oneOf(expected, "type")}`;
    }
    msg += `. Received type ${typeof actual}`;
    return msg;
  }, TypeError);
  createErrorType("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
  createErrorType("ERR_METHOD_NOT_IMPLEMENTED", function(name) {
    return "The " + name + " method is not implemented";
  });
  createErrorType("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
  createErrorType("ERR_STREAM_DESTROYED", function(name) {
    return "Cannot call " + name + " after a stream was destroyed";
  });
  createErrorType("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
  createErrorType("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
  createErrorType("ERR_STREAM_WRITE_AFTER_END", "write after end");
  createErrorType("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
  createErrorType("ERR_UNKNOWN_ENCODING", function(arg) {
    return "Unknown encoding: " + arg;
  }, TypeError);
  createErrorType("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
  module2.exports.codes = codes;
});

// node_modules/readable-stream/lib/internal/streams/state.js
var require_state = __commonJS((exports2, module2) => {
  "use strict";
  var ERR_INVALID_OPT_VALUE = require_errors4().codes.ERR_INVALID_OPT_VALUE;
  function highWaterMarkFrom(options, isDuplex, duplexKey) {
    return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
  }
  function getHighWaterMark(state, options, duplexKey, isDuplex) {
    var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);
    if (hwm != null) {
      if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
        var name = isDuplex ? duplexKey : "highWaterMark";
        throw new ERR_INVALID_OPT_VALUE(name, hwm);
      }
      return Math.floor(hwm);
    }
    return state.objectMode ? 16 : 16 * 1024;
  }
  module2.exports = {
    getHighWaterMark
  };
});

// node_modules/util-deprecate/browser.js
var require_browser5 = __commonJS((exports2, module2) => {
  module2.exports = deprecate;
  function deprecate(fn, msg) {
    if (config("noDeprecation")) {
      return fn;
    }
    var warned = false;
    function deprecated() {
      if (!warned) {
        if (config("throwDeprecation")) {
          throw new Error(msg);
        } else if (config("traceDeprecation")) {
          console.trace(msg);
        } else {
          console.warn(msg);
        }
        warned = true;
      }
      return fn.apply(this, arguments);
    }
    return deprecated;
  }
  function config(name) {
    try {
      if (!global.localStorage)
        return false;
    } catch (_) {
      return false;
    }
    var val = global.localStorage[name];
    if (val == null)
      return false;
    return String(val).toLowerCase() === "true";
  }
});

// node_modules/readable-stream/lib/_stream_writable.js
var require_stream_writable = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = Writable;
  function CorkedRequest(state) {
    var _this = this;
    this.next = null;
    this.entry = null;
    this.finish = function() {
      onCorkedFinish(_this, state);
    };
  }
  var Duplex;
  Writable.WritableState = WritableState;
  var internalUtil = {
    deprecate: require_browser5()
  };
  var Stream = require_stream_browser();
  var Buffer2 = require_buffer().Buffer;
  var OurUint8Array = global.Uint8Array || function() {
  };
  function _uint8ArrayToBuffer(chunk) {
    return Buffer2.from(chunk);
  }
  function _isUint8Array(obj) {
    return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
  }
  var destroyImpl = require_destroy();
  var _require = require_state();
  var getHighWaterMark = _require.getHighWaterMark;
  var _require$codes = require_errors4().codes;
  var ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE;
  var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
  var ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK;
  var ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE;
  var ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
  var ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES;
  var ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END;
  var ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;
  var errorOrDestroy = destroyImpl.errorOrDestroy;
  require_inherits_browser()(Writable, Stream);
  function nop() {
  }
  function WritableState(options, stream, isDuplex) {
    Duplex = Duplex || require_stream_duplex();
    options = options || {};
    if (typeof isDuplex !== "boolean")
      isDuplex = stream instanceof Duplex;
    this.objectMode = !!options.objectMode;
    if (isDuplex)
      this.objectMode = this.objectMode || !!options.writableObjectMode;
    this.highWaterMark = getHighWaterMark(this, options, "writableHighWaterMark", isDuplex);
    this.finalCalled = false;
    this.needDrain = false;
    this.ending = false;
    this.ended = false;
    this.finished = false;
    this.destroyed = false;
    var noDecode = options.decodeStrings === false;
    this.decodeStrings = !noDecode;
    this.defaultEncoding = options.defaultEncoding || "utf8";
    this.length = 0;
    this.writing = false;
    this.corked = 0;
    this.sync = true;
    this.bufferProcessing = false;
    this.onwrite = function(er) {
      onwrite(stream, er);
    };
    this.writecb = null;
    this.writelen = 0;
    this.bufferedRequest = null;
    this.lastBufferedRequest = null;
    this.pendingcb = 0;
    this.prefinished = false;
    this.errorEmitted = false;
    this.emitClose = options.emitClose !== false;
    this.autoDestroy = !!options.autoDestroy;
    this.bufferedRequestCount = 0;
    this.corkedRequestsFree = new CorkedRequest(this);
  }
  WritableState.prototype.getBuffer = function getBuffer() {
    var current = this.bufferedRequest;
    var out = [];
    while (current) {
      out.push(current);
      current = current.next;
    }
    return out;
  };
  (function() {
    try {
      Object.defineProperty(WritableState.prototype, "buffer", {
        get: internalUtil.deprecate(function writableStateBufferGetter() {
          return this.getBuffer();
        }, "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
      });
    } catch (_) {
    }
  })();
  var realHasInstance;
  if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function") {
    realHasInstance = Function.prototype[Symbol.hasInstance];
    Object.defineProperty(Writable, Symbol.hasInstance, {
      value: function value(object) {
        if (realHasInstance.call(this, object))
          return true;
        if (this !== Writable)
          return false;
        return object && object._writableState instanceof WritableState;
      }
    });
  } else {
    realHasInstance = function realHasInstance2(object) {
      return object instanceof this;
    };
  }
  function Writable(options) {
    Duplex = Duplex || require_stream_duplex();
    var isDuplex = this instanceof Duplex;
    if (!isDuplex && !realHasInstance.call(Writable, this))
      return new Writable(options);
    this._writableState = new WritableState(options, this, isDuplex);
    this.writable = true;
    if (options) {
      if (typeof options.write === "function")
        this._write = options.write;
      if (typeof options.writev === "function")
        this._writev = options.writev;
      if (typeof options.destroy === "function")
        this._destroy = options.destroy;
      if (typeof options.final === "function")
        this._final = options.final;
    }
    Stream.call(this);
  }
  Writable.prototype.pipe = function() {
    errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
  };
  function writeAfterEnd(stream, cb) {
    var er = new ERR_STREAM_WRITE_AFTER_END();
    errorOrDestroy(stream, er);
    process.nextTick(cb, er);
  }
  function validChunk(stream, state, chunk, cb) {
    var er;
    if (chunk === null) {
      er = new ERR_STREAM_NULL_VALUES();
    } else if (typeof chunk !== "string" && !state.objectMode) {
      er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer"], chunk);
    }
    if (er) {
      errorOrDestroy(stream, er);
      process.nextTick(cb, er);
      return false;
    }
    return true;
  }
  Writable.prototype.write = function(chunk, encoding, cb) {
    var state = this._writableState;
    var ret = false;
    var isBuf = !state.objectMode && _isUint8Array(chunk);
    if (isBuf && !Buffer2.isBuffer(chunk)) {
      chunk = _uint8ArrayToBuffer(chunk);
    }
    if (typeof encoding === "function") {
      cb = encoding;
      encoding = null;
    }
    if (isBuf)
      encoding = "buffer";
    else if (!encoding)
      encoding = state.defaultEncoding;
    if (typeof cb !== "function")
      cb = nop;
    if (state.ending)
      writeAfterEnd(this, cb);
    else if (isBuf || validChunk(this, state, chunk, cb)) {
      state.pendingcb++;
      ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
    }
    return ret;
  };
  Writable.prototype.cork = function() {
    this._writableState.corked++;
  };
  Writable.prototype.uncork = function() {
    var state = this._writableState;
    if (state.corked) {
      state.corked--;
      if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest)
        clearBuffer(this, state);
    }
  };
  Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
    if (typeof encoding === "string")
      encoding = encoding.toLowerCase();
    if (!(["hex", "utf8", "utf-8", "ascii", "binary", "base64", "ucs2", "ucs-2", "utf16le", "utf-16le", "raw"].indexOf((encoding + "").toLowerCase()) > -1))
      throw new ERR_UNKNOWN_ENCODING(encoding);
    this._writableState.defaultEncoding = encoding;
    return this;
  };
  Object.defineProperty(Writable.prototype, "writableBuffer", {
    enumerable: false,
    get: function get() {
      return this._writableState && this._writableState.getBuffer();
    }
  });
  function decodeChunk(state, chunk, encoding) {
    if (!state.objectMode && state.decodeStrings !== false && typeof chunk === "string") {
      chunk = Buffer2.from(chunk, encoding);
    }
    return chunk;
  }
  Object.defineProperty(Writable.prototype, "writableHighWaterMark", {
    enumerable: false,
    get: function get() {
      return this._writableState.highWaterMark;
    }
  });
  function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
    if (!isBuf) {
      var newChunk = decodeChunk(state, chunk, encoding);
      if (chunk !== newChunk) {
        isBuf = true;
        encoding = "buffer";
        chunk = newChunk;
      }
    }
    var len = state.objectMode ? 1 : chunk.length;
    state.length += len;
    var ret = state.length < state.highWaterMark;
    if (!ret)
      state.needDrain = true;
    if (state.writing || state.corked) {
      var last = state.lastBufferedRequest;
      state.lastBufferedRequest = {
        chunk,
        encoding,
        isBuf,
        callback: cb,
        next: null
      };
      if (last) {
        last.next = state.lastBufferedRequest;
      } else {
        state.bufferedRequest = state.lastBufferedRequest;
      }
      state.bufferedRequestCount += 1;
    } else {
      doWrite(stream, state, false, len, chunk, encoding, cb);
    }
    return ret;
  }
  function doWrite(stream, state, writev, len, chunk, encoding, cb) {
    state.writelen = len;
    state.writecb = cb;
    state.writing = true;
    state.sync = true;
    if (state.destroyed)
      state.onwrite(new ERR_STREAM_DESTROYED("write"));
    else if (writev)
      stream._writev(chunk, state.onwrite);
    else
      stream._write(chunk, encoding, state.onwrite);
    state.sync = false;
  }
  function onwriteError(stream, state, sync, er, cb) {
    --state.pendingcb;
    if (sync) {
      process.nextTick(cb, er);
      process.nextTick(finishMaybe, stream, state);
      stream._writableState.errorEmitted = true;
      errorOrDestroy(stream, er);
    } else {
      cb(er);
      stream._writableState.errorEmitted = true;
      errorOrDestroy(stream, er);
      finishMaybe(stream, state);
    }
  }
  function onwriteStateUpdate(state) {
    state.writing = false;
    state.writecb = null;
    state.length -= state.writelen;
    state.writelen = 0;
  }
  function onwrite(stream, er) {
    var state = stream._writableState;
    var sync = state.sync;
    var cb = state.writecb;
    if (typeof cb !== "function")
      throw new ERR_MULTIPLE_CALLBACK();
    onwriteStateUpdate(state);
    if (er)
      onwriteError(stream, state, sync, er, cb);
    else {
      var finished = needFinish(state) || stream.destroyed;
      if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
        clearBuffer(stream, state);
      }
      if (sync) {
        process.nextTick(afterWrite, stream, state, finished, cb);
      } else {
        afterWrite(stream, state, finished, cb);
      }
    }
  }
  function afterWrite(stream, state, finished, cb) {
    if (!finished)
      onwriteDrain(stream, state);
    state.pendingcb--;
    cb();
    finishMaybe(stream, state);
  }
  function onwriteDrain(stream, state) {
    if (state.length === 0 && state.needDrain) {
      state.needDrain = false;
      stream.emit("drain");
    }
  }
  function clearBuffer(stream, state) {
    state.bufferProcessing = true;
    var entry = state.bufferedRequest;
    if (stream._writev && entry && entry.next) {
      var l = state.bufferedRequestCount;
      var buffer = new Array(l);
      var holder = state.corkedRequestsFree;
      holder.entry = entry;
      var count = 0;
      var allBuffers = true;
      while (entry) {
        buffer[count] = entry;
        if (!entry.isBuf)
          allBuffers = false;
        entry = entry.next;
        count += 1;
      }
      buffer.allBuffers = allBuffers;
      doWrite(stream, state, true, state.length, buffer, "", holder.finish);
      state.pendingcb++;
      state.lastBufferedRequest = null;
      if (holder.next) {
        state.corkedRequestsFree = holder.next;
        holder.next = null;
      } else {
        state.corkedRequestsFree = new CorkedRequest(state);
      }
      state.bufferedRequestCount = 0;
    } else {
      while (entry) {
        var chunk = entry.chunk;
        var encoding = entry.encoding;
        var cb = entry.callback;
        var len = state.objectMode ? 1 : chunk.length;
        doWrite(stream, state, false, len, chunk, encoding, cb);
        entry = entry.next;
        state.bufferedRequestCount--;
        if (state.writing) {
          break;
        }
      }
      if (entry === null)
        state.lastBufferedRequest = null;
    }
    state.bufferedRequest = entry;
    state.bufferProcessing = false;
  }
  Writable.prototype._write = function(chunk, encoding, cb) {
    cb(new ERR_METHOD_NOT_IMPLEMENTED("_write()"));
  };
  Writable.prototype._writev = null;
  Writable.prototype.end = function(chunk, encoding, cb) {
    var state = this._writableState;
    if (typeof chunk === "function") {
      cb = chunk;
      chunk = null;
      encoding = null;
    } else if (typeof encoding === "function") {
      cb = encoding;
      encoding = null;
    }
    if (chunk !== null && chunk !== void 0)
      this.write(chunk, encoding);
    if (state.corked) {
      state.corked = 1;
      this.uncork();
    }
    if (!state.ending)
      endWritable(this, state, cb);
    return this;
  };
  Object.defineProperty(Writable.prototype, "writableLength", {
    enumerable: false,
    get: function get() {
      return this._writableState.length;
    }
  });
  function needFinish(state) {
    return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
  }
  function callFinal(stream, state) {
    stream._final(function(err) {
      state.pendingcb--;
      if (err) {
        errorOrDestroy(stream, err);
      }
      state.prefinished = true;
      stream.emit("prefinish");
      finishMaybe(stream, state);
    });
  }
  function prefinish(stream, state) {
    if (!state.prefinished && !state.finalCalled) {
      if (typeof stream._final === "function" && !state.destroyed) {
        state.pendingcb++;
        state.finalCalled = true;
        process.nextTick(callFinal, stream, state);
      } else {
        state.prefinished = true;
        stream.emit("prefinish");
      }
    }
  }
  function finishMaybe(stream, state) {
    var need = needFinish(state);
    if (need) {
      prefinish(stream, state);
      if (state.pendingcb === 0) {
        state.finished = true;
        stream.emit("finish");
        if (state.autoDestroy) {
          var rState = stream._readableState;
          if (!rState || rState.autoDestroy && rState.endEmitted) {
            stream.destroy();
          }
        }
      }
    }
    return need;
  }
  function endWritable(stream, state, cb) {
    state.ending = true;
    finishMaybe(stream, state);
    if (cb) {
      if (state.finished)
        process.nextTick(cb);
      else
        stream.once("finish", cb);
    }
    state.ended = true;
    stream.writable = false;
  }
  function onCorkedFinish(corkReq, state, err) {
    var entry = corkReq.entry;
    corkReq.entry = null;
    while (entry) {
      var cb = entry.callback;
      state.pendingcb--;
      cb(err);
      entry = entry.next;
    }
    state.corkedRequestsFree.next = corkReq;
  }
  Object.defineProperty(Writable.prototype, "destroyed", {
    enumerable: false,
    get: function get() {
      if (this._writableState === void 0) {
        return false;
      }
      return this._writableState.destroyed;
    },
    set: function set(value) {
      if (!this._writableState) {
        return;
      }
      this._writableState.destroyed = value;
    }
  });
  Writable.prototype.destroy = destroyImpl.destroy;
  Writable.prototype._undestroy = destroyImpl.undestroy;
  Writable.prototype._destroy = function(err, cb) {
    cb(err);
  };
});

// node_modules/readable-stream/lib/_stream_duplex.js
var require_stream_duplex = __commonJS((exports2, module2) => {
  "use strict";
  var objectKeys = Object.keys || function(obj) {
    var keys2 = [];
    for (var key in obj) {
      keys2.push(key);
    }
    return keys2;
  };
  module2.exports = Duplex;
  var Readable = require_stream_readable();
  var Writable = require_stream_writable();
  require_inherits_browser()(Duplex, Readable);
  {
    keys = objectKeys(Writable.prototype);
    for (var v = 0; v < keys.length; v++) {
      method = keys[v];
      if (!Duplex.prototype[method])
        Duplex.prototype[method] = Writable.prototype[method];
    }
  }
  var keys;
  var method;
  function Duplex(options) {
    if (!(this instanceof Duplex))
      return new Duplex(options);
    Readable.call(this, options);
    Writable.call(this, options);
    this.allowHalfOpen = true;
    if (options) {
      if (options.readable === false)
        this.readable = false;
      if (options.writable === false)
        this.writable = false;
      if (options.allowHalfOpen === false) {
        this.allowHalfOpen = false;
        this.once("end", onend);
      }
    }
  }
  Object.defineProperty(Duplex.prototype, "writableHighWaterMark", {
    enumerable: false,
    get: function get() {
      return this._writableState.highWaterMark;
    }
  });
  Object.defineProperty(Duplex.prototype, "writableBuffer", {
    enumerable: false,
    get: function get() {
      return this._writableState && this._writableState.getBuffer();
    }
  });
  Object.defineProperty(Duplex.prototype, "writableLength", {
    enumerable: false,
    get: function get() {
      return this._writableState.length;
    }
  });
  function onend() {
    if (this._writableState.ended)
      return;
    process.nextTick(onEndNT, this);
  }
  function onEndNT(self2) {
    self2.end();
  }
  Object.defineProperty(Duplex.prototype, "destroyed", {
    enumerable: false,
    get: function get() {
      if (this._readableState === void 0 || this._writableState === void 0) {
        return false;
      }
      return this._readableState.destroyed && this._writableState.destroyed;
    },
    set: function set(value) {
      if (this._readableState === void 0 || this._writableState === void 0) {
        return;
      }
      this._readableState.destroyed = value;
      this._writableState.destroyed = value;
    }
  });
});

// node_modules/safe-buffer/index.js
var require_safe_buffer = __commonJS((exports2, module2) => {
  /*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
  var buffer = require_buffer();
  var Buffer2 = buffer.Buffer;
  function copyProps(src, dst) {
    for (var key in src) {
      dst[key] = src[key];
    }
  }
  if (Buffer2.from && Buffer2.alloc && Buffer2.allocUnsafe && Buffer2.allocUnsafeSlow) {
    module2.exports = buffer;
  } else {
    copyProps(buffer, exports2);
    exports2.Buffer = SafeBuffer;
  }
  function SafeBuffer(arg, encodingOrOffset, length) {
    return Buffer2(arg, encodingOrOffset, length);
  }
  SafeBuffer.prototype = Object.create(Buffer2.prototype);
  copyProps(Buffer2, SafeBuffer);
  SafeBuffer.from = function(arg, encodingOrOffset, length) {
    if (typeof arg === "number") {
      throw new TypeError("Argument must not be a number");
    }
    return Buffer2(arg, encodingOrOffset, length);
  };
  SafeBuffer.alloc = function(size, fill, encoding) {
    if (typeof size !== "number") {
      throw new TypeError("Argument must be a number");
    }
    var buf = Buffer2(size);
    if (fill !== void 0) {
      if (typeof encoding === "string") {
        buf.fill(fill, encoding);
      } else {
        buf.fill(fill);
      }
    } else {
      buf.fill(0);
    }
    return buf;
  };
  SafeBuffer.allocUnsafe = function(size) {
    if (typeof size !== "number") {
      throw new TypeError("Argument must be a number");
    }
    return Buffer2(size);
  };
  SafeBuffer.allocUnsafeSlow = function(size) {
    if (typeof size !== "number") {
      throw new TypeError("Argument must be a number");
    }
    return buffer.SlowBuffer(size);
  };
});

// node_modules/string_decoder/lib/string_decoder.js
var require_string_decoder = __commonJS((exports2) => {
  "use strict";
  var Buffer2 = require_safe_buffer().Buffer;
  var isEncoding = Buffer2.isEncoding || function(encoding) {
    encoding = "" + encoding;
    switch (encoding && encoding.toLowerCase()) {
      case "hex":
      case "utf8":
      case "utf-8":
      case "ascii":
      case "binary":
      case "base64":
      case "ucs2":
      case "ucs-2":
      case "utf16le":
      case "utf-16le":
      case "raw":
        return true;
      default:
        return false;
    }
  };
  function _normalizeEncoding(enc) {
    if (!enc)
      return "utf8";
    var retried;
    while (true) {
      switch (enc) {
        case "utf8":
        case "utf-8":
          return "utf8";
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
          return "utf16le";
        case "latin1":
        case "binary":
          return "latin1";
        case "base64":
        case "ascii":
        case "hex":
          return enc;
        default:
          if (retried)
            return;
          enc = ("" + enc).toLowerCase();
          retried = true;
      }
    }
  }
  function normalizeEncoding(enc) {
    var nenc = _normalizeEncoding(enc);
    if (typeof nenc !== "string" && (Buffer2.isEncoding === isEncoding || !isEncoding(enc)))
      throw new Error("Unknown encoding: " + enc);
    return nenc || enc;
  }
  exports2.StringDecoder = StringDecoder;
  function StringDecoder(encoding) {
    this.encoding = normalizeEncoding(encoding);
    var nb;
    switch (this.encoding) {
      case "utf16le":
        this.text = utf16Text;
        this.end = utf16End;
        nb = 4;
        break;
      case "utf8":
        this.fillLast = utf8FillLast;
        nb = 4;
        break;
      case "base64":
        this.text = base64Text;
        this.end = base64End;
        nb = 3;
        break;
      default:
        this.write = simpleWrite;
        this.end = simpleEnd;
        return;
    }
    this.lastNeed = 0;
    this.lastTotal = 0;
    this.lastChar = Buffer2.allocUnsafe(nb);
  }
  StringDecoder.prototype.write = function(buf) {
    if (buf.length === 0)
      return "";
    var r;
    var i;
    if (this.lastNeed) {
      r = this.fillLast(buf);
      if (r === void 0)
        return "";
      i = this.lastNeed;
      this.lastNeed = 0;
    } else {
      i = 0;
    }
    if (i < buf.length)
      return r ? r + this.text(buf, i) : this.text(buf, i);
    return r || "";
  };
  StringDecoder.prototype.end = utf8End;
  StringDecoder.prototype.text = utf8Text;
  StringDecoder.prototype.fillLast = function(buf) {
    if (this.lastNeed <= buf.length) {
      buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
      return this.lastChar.toString(this.encoding, 0, this.lastTotal);
    }
    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
    this.lastNeed -= buf.length;
  };
  function utf8CheckByte(byte) {
    if (byte <= 127)
      return 0;
    else if (byte >> 5 === 6)
      return 2;
    else if (byte >> 4 === 14)
      return 3;
    else if (byte >> 3 === 30)
      return 4;
    return byte >> 6 === 2 ? -1 : -2;
  }
  function utf8CheckIncomplete(self2, buf, i) {
    var j = buf.length - 1;
    if (j < i)
      return 0;
    var nb = utf8CheckByte(buf[j]);
    if (nb >= 0) {
      if (nb > 0)
        self2.lastNeed = nb - 1;
      return nb;
    }
    if (--j < i || nb === -2)
      return 0;
    nb = utf8CheckByte(buf[j]);
    if (nb >= 0) {
      if (nb > 0)
        self2.lastNeed = nb - 2;
      return nb;
    }
    if (--j < i || nb === -2)
      return 0;
    nb = utf8CheckByte(buf[j]);
    if (nb >= 0) {
      if (nb > 0) {
        if (nb === 2)
          nb = 0;
        else
          self2.lastNeed = nb - 3;
      }
      return nb;
    }
    return 0;
  }
  function utf8CheckExtraBytes(self2, buf, p) {
    if ((buf[0] & 192) !== 128) {
      self2.lastNeed = 0;
      return "\uFFFD";
    }
    if (self2.lastNeed > 1 && buf.length > 1) {
      if ((buf[1] & 192) !== 128) {
        self2.lastNeed = 1;
        return "\uFFFD";
      }
      if (self2.lastNeed > 2 && buf.length > 2) {
        if ((buf[2] & 192) !== 128) {
          self2.lastNeed = 2;
          return "\uFFFD";
        }
      }
    }
  }
  function utf8FillLast(buf) {
    var p = this.lastTotal - this.lastNeed;
    var r = utf8CheckExtraBytes(this, buf, p);
    if (r !== void 0)
      return r;
    if (this.lastNeed <= buf.length) {
      buf.copy(this.lastChar, p, 0, this.lastNeed);
      return this.lastChar.toString(this.encoding, 0, this.lastTotal);
    }
    buf.copy(this.lastChar, p, 0, buf.length);
    this.lastNeed -= buf.length;
  }
  function utf8Text(buf, i) {
    var total = utf8CheckIncomplete(this, buf, i);
    if (!this.lastNeed)
      return buf.toString("utf8", i);
    this.lastTotal = total;
    var end = buf.length - (total - this.lastNeed);
    buf.copy(this.lastChar, 0, end);
    return buf.toString("utf8", i, end);
  }
  function utf8End(buf) {
    var r = buf && buf.length ? this.write(buf) : "";
    if (this.lastNeed)
      return r + "\uFFFD";
    return r;
  }
  function utf16Text(buf, i) {
    if ((buf.length - i) % 2 === 0) {
      var r = buf.toString("utf16le", i);
      if (r) {
        var c = r.charCodeAt(r.length - 1);
        if (c >= 55296 && c <= 56319) {
          this.lastNeed = 2;
          this.lastTotal = 4;
          this.lastChar[0] = buf[buf.length - 2];
          this.lastChar[1] = buf[buf.length - 1];
          return r.slice(0, -1);
        }
      }
      return r;
    }
    this.lastNeed = 1;
    this.lastTotal = 2;
    this.lastChar[0] = buf[buf.length - 1];
    return buf.toString("utf16le", i, buf.length - 1);
  }
  function utf16End(buf) {
    var r = buf && buf.length ? this.write(buf) : "";
    if (this.lastNeed) {
      var end = this.lastTotal - this.lastNeed;
      return r + this.lastChar.toString("utf16le", 0, end);
    }
    return r;
  }
  function base64Text(buf, i) {
    var n = (buf.length - i) % 3;
    if (n === 0)
      return buf.toString("base64", i);
    this.lastNeed = 3 - n;
    this.lastTotal = 3;
    if (n === 1) {
      this.lastChar[0] = buf[buf.length - 1];
    } else {
      this.lastChar[0] = buf[buf.length - 2];
      this.lastChar[1] = buf[buf.length - 1];
    }
    return buf.toString("base64", i, buf.length - n);
  }
  function base64End(buf) {
    var r = buf && buf.length ? this.write(buf) : "";
    if (this.lastNeed)
      return r + this.lastChar.toString("base64", 0, 3 - this.lastNeed);
    return r;
  }
  function simpleWrite(buf) {
    return buf.toString(this.encoding);
  }
  function simpleEnd(buf) {
    return buf && buf.length ? this.write(buf) : "";
  }
});

// node_modules/readable-stream/lib/internal/streams/end-of-stream.js
var require_end_of_stream = __commonJS((exports2, module2) => {
  "use strict";
  var ERR_STREAM_PREMATURE_CLOSE = require_errors4().codes.ERR_STREAM_PREMATURE_CLOSE;
  function once(callback) {
    var called = false;
    return function() {
      if (called)
        return;
      called = true;
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      callback.apply(this, args);
    };
  }
  function noop() {
  }
  function isRequest(stream) {
    return stream.setHeader && typeof stream.abort === "function";
  }
  function eos(stream, opts, callback) {
    if (typeof opts === "function")
      return eos(stream, null, opts);
    if (!opts)
      opts = {};
    callback = once(callback || noop);
    var readable = opts.readable || opts.readable !== false && stream.readable;
    var writable = opts.writable || opts.writable !== false && stream.writable;
    var onlegacyfinish = function onlegacyfinish2() {
      if (!stream.writable)
        onfinish();
    };
    var writableEnded = stream._writableState && stream._writableState.finished;
    var onfinish = function onfinish2() {
      writable = false;
      writableEnded = true;
      if (!readable)
        callback.call(stream);
    };
    var readableEnded = stream._readableState && stream._readableState.endEmitted;
    var onend = function onend2() {
      readable = false;
      readableEnded = true;
      if (!writable)
        callback.call(stream);
    };
    var onerror = function onerror2(err) {
      callback.call(stream, err);
    };
    var onclose = function onclose2() {
      var err;
      if (readable && !readableEnded) {
        if (!stream._readableState || !stream._readableState.ended)
          err = new ERR_STREAM_PREMATURE_CLOSE();
        return callback.call(stream, err);
      }
      if (writable && !writableEnded) {
        if (!stream._writableState || !stream._writableState.ended)
          err = new ERR_STREAM_PREMATURE_CLOSE();
        return callback.call(stream, err);
      }
    };
    var onrequest = function onrequest2() {
      stream.req.on("finish", onfinish);
    };
    if (isRequest(stream)) {
      stream.on("complete", onfinish);
      stream.on("abort", onclose);
      if (stream.req)
        onrequest();
      else
        stream.on("request", onrequest);
    } else if (writable && !stream._writableState) {
      stream.on("end", onlegacyfinish);
      stream.on("close", onlegacyfinish);
    }
    stream.on("end", onend);
    stream.on("finish", onfinish);
    if (opts.error !== false)
      stream.on("error", onerror);
    stream.on("close", onclose);
    return function() {
      stream.removeListener("complete", onfinish);
      stream.removeListener("abort", onclose);
      stream.removeListener("request", onrequest);
      if (stream.req)
        stream.req.removeListener("finish", onfinish);
      stream.removeListener("end", onlegacyfinish);
      stream.removeListener("close", onlegacyfinish);
      stream.removeListener("finish", onfinish);
      stream.removeListener("end", onend);
      stream.removeListener("error", onerror);
      stream.removeListener("close", onclose);
    };
  }
  module2.exports = eos;
});

// node_modules/readable-stream/lib/internal/streams/async_iterator.js
var require_async_iterator = __commonJS((exports2, module2) => {
  "use strict";
  var _Object$setPrototypeO;
  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {value, enumerable: true, configurable: true, writable: true});
    } else {
      obj[key] = value;
    }
    return obj;
  }
  var finished = require_end_of_stream();
  var kLastResolve = Symbol("lastResolve");
  var kLastReject = Symbol("lastReject");
  var kError = Symbol("error");
  var kEnded = Symbol("ended");
  var kLastPromise = Symbol("lastPromise");
  var kHandlePromise = Symbol("handlePromise");
  var kStream = Symbol("stream");
  function createIterResult(value, done) {
    return {
      value,
      done
    };
  }
  function readAndResolve(iter) {
    var resolve = iter[kLastResolve];
    if (resolve !== null) {
      var data = iter[kStream].read();
      if (data !== null) {
        iter[kLastPromise] = null;
        iter[kLastResolve] = null;
        iter[kLastReject] = null;
        resolve(createIterResult(data, false));
      }
    }
  }
  function onReadable(iter) {
    process.nextTick(readAndResolve, iter);
  }
  function wrapForNext(lastPromise, iter) {
    return function(resolve, reject) {
      lastPromise.then(function() {
        if (iter[kEnded]) {
          resolve(createIterResult(void 0, true));
          return;
        }
        iter[kHandlePromise](resolve, reject);
      }, reject);
    };
  }
  var AsyncIteratorPrototype = Object.getPrototypeOf(function() {
  });
  var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {
    get stream() {
      return this[kStream];
    },
    next: function next() {
      var _this = this;
      var error = this[kError];
      if (error !== null) {
        return Promise.reject(error);
      }
      if (this[kEnded]) {
        return Promise.resolve(createIterResult(void 0, true));
      }
      if (this[kStream].destroyed) {
        return new Promise(function(resolve, reject) {
          process.nextTick(function() {
            if (_this[kError]) {
              reject(_this[kError]);
            } else {
              resolve(createIterResult(void 0, true));
            }
          });
        });
      }
      var lastPromise = this[kLastPromise];
      var promise;
      if (lastPromise) {
        promise = new Promise(wrapForNext(lastPromise, this));
      } else {
        var data = this[kStream].read();
        if (data !== null) {
          return Promise.resolve(createIterResult(data, false));
        }
        promise = new Promise(this[kHandlePromise]);
      }
      this[kLastPromise] = promise;
      return promise;
    }
  }, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function() {
    return this;
  }), _defineProperty(_Object$setPrototypeO, "return", function _return() {
    var _this2 = this;
    return new Promise(function(resolve, reject) {
      _this2[kStream].destroy(null, function(err) {
        if (err) {
          reject(err);
          return;
        }
        resolve(createIterResult(void 0, true));
      });
    });
  }), _Object$setPrototypeO), AsyncIteratorPrototype);
  var createReadableStreamAsyncIterator = function createReadableStreamAsyncIterator2(stream) {
    var _Object$create;
    var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {
      value: stream,
      writable: true
    }), _defineProperty(_Object$create, kLastResolve, {
      value: null,
      writable: true
    }), _defineProperty(_Object$create, kLastReject, {
      value: null,
      writable: true
    }), _defineProperty(_Object$create, kError, {
      value: null,
      writable: true
    }), _defineProperty(_Object$create, kEnded, {
      value: stream._readableState.endEmitted,
      writable: true
    }), _defineProperty(_Object$create, kHandlePromise, {
      value: function value(resolve, reject) {
        var data = iterator[kStream].read();
        if (data) {
          iterator[kLastPromise] = null;
          iterator[kLastResolve] = null;
          iterator[kLastReject] = null;
          resolve(createIterResult(data, false));
        } else {
          iterator[kLastResolve] = resolve;
          iterator[kLastReject] = reject;
        }
      },
      writable: true
    }), _Object$create));
    iterator[kLastPromise] = null;
    finished(stream, function(err) {
      if (err && err.code !== "ERR_STREAM_PREMATURE_CLOSE") {
        var reject = iterator[kLastReject];
        if (reject !== null) {
          iterator[kLastPromise] = null;
          iterator[kLastResolve] = null;
          iterator[kLastReject] = null;
          reject(err);
        }
        iterator[kError] = err;
        return;
      }
      var resolve = iterator[kLastResolve];
      if (resolve !== null) {
        iterator[kLastPromise] = null;
        iterator[kLastResolve] = null;
        iterator[kLastReject] = null;
        resolve(createIterResult(void 0, true));
      }
      iterator[kEnded] = true;
    });
    stream.on("readable", onReadable.bind(null, iterator));
    return iterator;
  };
  module2.exports = createReadableStreamAsyncIterator;
});

// node_modules/readable-stream/lib/internal/streams/from-browser.js
var require_from_browser = __commonJS((exports2, module2) => {
  module2.exports = function() {
    throw new Error("Readable.from is not available in the browser");
  };
});

// node_modules/readable-stream/lib/_stream_readable.js
var require_stream_readable = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = Readable;
  var Duplex;
  Readable.ReadableState = ReadableState;
  var EE = require_events().EventEmitter;
  var EElistenerCount = function EElistenerCount2(emitter, type) {
    return emitter.listeners(type).length;
  };
  var Stream = require_stream_browser();
  var Buffer2 = require_buffer().Buffer;
  var OurUint8Array = global.Uint8Array || function() {
  };
  function _uint8ArrayToBuffer(chunk) {
    return Buffer2.from(chunk);
  }
  function _isUint8Array(obj) {
    return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
  }
  var debugUtil = require_util9();
  var debug;
  if (debugUtil && debugUtil.debuglog) {
    debug = debugUtil.debuglog("stream");
  } else {
    debug = function debug2() {
    };
  }
  var BufferList = require_buffer_list();
  var destroyImpl = require_destroy();
  var _require = require_state();
  var getHighWaterMark = _require.getHighWaterMark;
  var _require$codes = require_errors4().codes;
  var ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE;
  var ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF;
  var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
  var ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;
  var StringDecoder;
  var createReadableStreamAsyncIterator;
  var from;
  require_inherits_browser()(Readable, Stream);
  var errorOrDestroy = destroyImpl.errorOrDestroy;
  var kProxyEvents = ["error", "close", "destroy", "pause", "resume"];
  function prependListener(emitter, event, fn) {
    if (typeof emitter.prependListener === "function")
      return emitter.prependListener(event, fn);
    if (!emitter._events || !emitter._events[event])
      emitter.on(event, fn);
    else if (Array.isArray(emitter._events[event]))
      emitter._events[event].unshift(fn);
    else
      emitter._events[event] = [fn, emitter._events[event]];
  }
  function ReadableState(options, stream, isDuplex) {
    Duplex = Duplex || require_stream_duplex();
    options = options || {};
    if (typeof isDuplex !== "boolean")
      isDuplex = stream instanceof Duplex;
    this.objectMode = !!options.objectMode;
    if (isDuplex)
      this.objectMode = this.objectMode || !!options.readableObjectMode;
    this.highWaterMark = getHighWaterMark(this, options, "readableHighWaterMark", isDuplex);
    this.buffer = new BufferList();
    this.length = 0;
    this.pipes = null;
    this.pipesCount = 0;
    this.flowing = null;
    this.ended = false;
    this.endEmitted = false;
    this.reading = false;
    this.sync = true;
    this.needReadable = false;
    this.emittedReadable = false;
    this.readableListening = false;
    this.resumeScheduled = false;
    this.paused = true;
    this.emitClose = options.emitClose !== false;
    this.autoDestroy = !!options.autoDestroy;
    this.destroyed = false;
    this.defaultEncoding = options.defaultEncoding || "utf8";
    this.awaitDrain = 0;
    this.readingMore = false;
    this.decoder = null;
    this.encoding = null;
    if (options.encoding) {
      if (!StringDecoder)
        StringDecoder = require_string_decoder().StringDecoder;
      this.decoder = new StringDecoder(options.encoding);
      this.encoding = options.encoding;
    }
  }
  function Readable(options) {
    Duplex = Duplex || require_stream_duplex();
    if (!(this instanceof Readable))
      return new Readable(options);
    var isDuplex = this instanceof Duplex;
    this._readableState = new ReadableState(options, this, isDuplex);
    this.readable = true;
    if (options) {
      if (typeof options.read === "function")
        this._read = options.read;
      if (typeof options.destroy === "function")
        this._destroy = options.destroy;
    }
    Stream.call(this);
  }
  Object.defineProperty(Readable.prototype, "destroyed", {
    enumerable: false,
    get: function get() {
      if (this._readableState === void 0) {
        return false;
      }
      return this._readableState.destroyed;
    },
    set: function set(value) {
      if (!this._readableState) {
        return;
      }
      this._readableState.destroyed = value;
    }
  });
  Readable.prototype.destroy = destroyImpl.destroy;
  Readable.prototype._undestroy = destroyImpl.undestroy;
  Readable.prototype._destroy = function(err, cb) {
    cb(err);
  };
  Readable.prototype.push = function(chunk, encoding) {
    var state = this._readableState;
    var skipChunkCheck;
    if (!state.objectMode) {
      if (typeof chunk === "string") {
        encoding = encoding || state.defaultEncoding;
        if (encoding !== state.encoding) {
          chunk = Buffer2.from(chunk, encoding);
          encoding = "";
        }
        skipChunkCheck = true;
      }
    } else {
      skipChunkCheck = true;
    }
    return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
  };
  Readable.prototype.unshift = function(chunk) {
    return readableAddChunk(this, chunk, null, true, false);
  };
  function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
    debug("readableAddChunk", chunk);
    var state = stream._readableState;
    if (chunk === null) {
      state.reading = false;
      onEofChunk(stream, state);
    } else {
      var er;
      if (!skipChunkCheck)
        er = chunkInvalid(state, chunk);
      if (er) {
        errorOrDestroy(stream, er);
      } else if (state.objectMode || chunk && chunk.length > 0) {
        if (typeof chunk !== "string" && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer2.prototype) {
          chunk = _uint8ArrayToBuffer(chunk);
        }
        if (addToFront) {
          if (state.endEmitted)
            errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());
          else
            addChunk(stream, state, chunk, true);
        } else if (state.ended) {
          errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());
        } else if (state.destroyed) {
          return false;
        } else {
          state.reading = false;
          if (state.decoder && !encoding) {
            chunk = state.decoder.write(chunk);
            if (state.objectMode || chunk.length !== 0)
              addChunk(stream, state, chunk, false);
            else
              maybeReadMore(stream, state);
          } else {
            addChunk(stream, state, chunk, false);
          }
        }
      } else if (!addToFront) {
        state.reading = false;
        maybeReadMore(stream, state);
      }
    }
    return !state.ended && (state.length < state.highWaterMark || state.length === 0);
  }
  function addChunk(stream, state, chunk, addToFront) {
    if (state.flowing && state.length === 0 && !state.sync) {
      state.awaitDrain = 0;
      stream.emit("data", chunk);
    } else {
      state.length += state.objectMode ? 1 : chunk.length;
      if (addToFront)
        state.buffer.unshift(chunk);
      else
        state.buffer.push(chunk);
      if (state.needReadable)
        emitReadable(stream);
    }
    maybeReadMore(stream, state);
  }
  function chunkInvalid(state, chunk) {
    var er;
    if (!_isUint8Array(chunk) && typeof chunk !== "string" && chunk !== void 0 && !state.objectMode) {
      er = new ERR_INVALID_ARG_TYPE("chunk", ["string", "Buffer", "Uint8Array"], chunk);
    }
    return er;
  }
  Readable.prototype.isPaused = function() {
    return this._readableState.flowing === false;
  };
  Readable.prototype.setEncoding = function(enc) {
    if (!StringDecoder)
      StringDecoder = require_string_decoder().StringDecoder;
    var decoder = new StringDecoder(enc);
    this._readableState.decoder = decoder;
    this._readableState.encoding = this._readableState.decoder.encoding;
    var p = this._readableState.buffer.head;
    var content = "";
    while (p !== null) {
      content += decoder.write(p.data);
      p = p.next;
    }
    this._readableState.buffer.clear();
    if (content !== "")
      this._readableState.buffer.push(content);
    this._readableState.length = content.length;
    return this;
  };
  var MAX_HWM = 1073741824;
  function computeNewHighWaterMark(n) {
    if (n >= MAX_HWM) {
      n = MAX_HWM;
    } else {
      n--;
      n |= n >>> 1;
      n |= n >>> 2;
      n |= n >>> 4;
      n |= n >>> 8;
      n |= n >>> 16;
      n++;
    }
    return n;
  }
  function howMuchToRead(n, state) {
    if (n <= 0 || state.length === 0 && state.ended)
      return 0;
    if (state.objectMode)
      return 1;
    if (n !== n) {
      if (state.flowing && state.length)
        return state.buffer.head.data.length;
      else
        return state.length;
    }
    if (n > state.highWaterMark)
      state.highWaterMark = computeNewHighWaterMark(n);
    if (n <= state.length)
      return n;
    if (!state.ended) {
      state.needReadable = true;
      return 0;
    }
    return state.length;
  }
  Readable.prototype.read = function(n) {
    debug("read", n);
    n = parseInt(n, 10);
    var state = this._readableState;
    var nOrig = n;
    if (n !== 0)
      state.emittedReadable = false;
    if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
      debug("read: emitReadable", state.length, state.ended);
      if (state.length === 0 && state.ended)
        endReadable(this);
      else
        emitReadable(this);
      return null;
    }
    n = howMuchToRead(n, state);
    if (n === 0 && state.ended) {
      if (state.length === 0)
        endReadable(this);
      return null;
    }
    var doRead = state.needReadable;
    debug("need readable", doRead);
    if (state.length === 0 || state.length - n < state.highWaterMark) {
      doRead = true;
      debug("length less than watermark", doRead);
    }
    if (state.ended || state.reading) {
      doRead = false;
      debug("reading or ended", doRead);
    } else if (doRead) {
      debug("do read");
      state.reading = true;
      state.sync = true;
      if (state.length === 0)
        state.needReadable = true;
      this._read(state.highWaterMark);
      state.sync = false;
      if (!state.reading)
        n = howMuchToRead(nOrig, state);
    }
    var ret;
    if (n > 0)
      ret = fromList(n, state);
    else
      ret = null;
    if (ret === null) {
      state.needReadable = state.length <= state.highWaterMark;
      n = 0;
    } else {
      state.length -= n;
      state.awaitDrain = 0;
    }
    if (state.length === 0) {
      if (!state.ended)
        state.needReadable = true;
      if (nOrig !== n && state.ended)
        endReadable(this);
    }
    if (ret !== null)
      this.emit("data", ret);
    return ret;
  };
  function onEofChunk(stream, state) {
    debug("onEofChunk");
    if (state.ended)
      return;
    if (state.decoder) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length) {
        state.buffer.push(chunk);
        state.length += state.objectMode ? 1 : chunk.length;
      }
    }
    state.ended = true;
    if (state.sync) {
      emitReadable(stream);
    } else {
      state.needReadable = false;
      if (!state.emittedReadable) {
        state.emittedReadable = true;
        emitReadable_(stream);
      }
    }
  }
  function emitReadable(stream) {
    var state = stream._readableState;
    debug("emitReadable", state.needReadable, state.emittedReadable);
    state.needReadable = false;
    if (!state.emittedReadable) {
      debug("emitReadable", state.flowing);
      state.emittedReadable = true;
      process.nextTick(emitReadable_, stream);
    }
  }
  function emitReadable_(stream) {
    var state = stream._readableState;
    debug("emitReadable_", state.destroyed, state.length, state.ended);
    if (!state.destroyed && (state.length || state.ended)) {
      stream.emit("readable");
      state.emittedReadable = false;
    }
    state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
    flow(stream);
  }
  function maybeReadMore(stream, state) {
    if (!state.readingMore) {
      state.readingMore = true;
      process.nextTick(maybeReadMore_, stream, state);
    }
  }
  function maybeReadMore_(stream, state) {
    while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {
      var len = state.length;
      debug("maybeReadMore read 0");
      stream.read(0);
      if (len === state.length)
        break;
    }
    state.readingMore = false;
  }
  Readable.prototype._read = function(n) {
    errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED("_read()"));
  };
  Readable.prototype.pipe = function(dest, pipeOpts) {
    var src = this;
    var state = this._readableState;
    switch (state.pipesCount) {
      case 0:
        state.pipes = dest;
        break;
      case 1:
        state.pipes = [state.pipes, dest];
        break;
      default:
        state.pipes.push(dest);
        break;
    }
    state.pipesCount += 1;
    debug("pipe count=%d opts=%j", state.pipesCount, pipeOpts);
    var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
    var endFn = doEnd ? onend : unpipe;
    if (state.endEmitted)
      process.nextTick(endFn);
    else
      src.once("end", endFn);
    dest.on("unpipe", onunpipe);
    function onunpipe(readable, unpipeInfo) {
      debug("onunpipe");
      if (readable === src) {
        if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
          unpipeInfo.hasUnpiped = true;
          cleanup();
        }
      }
    }
    function onend() {
      debug("onend");
      dest.end();
    }
    var ondrain = pipeOnDrain(src);
    dest.on("drain", ondrain);
    var cleanedUp = false;
    function cleanup() {
      debug("cleanup");
      dest.removeListener("close", onclose);
      dest.removeListener("finish", onfinish);
      dest.removeListener("drain", ondrain);
      dest.removeListener("error", onerror);
      dest.removeListener("unpipe", onunpipe);
      src.removeListener("end", onend);
      src.removeListener("end", unpipe);
      src.removeListener("data", ondata);
      cleanedUp = true;
      if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain))
        ondrain();
    }
    src.on("data", ondata);
    function ondata(chunk) {
      debug("ondata");
      var ret = dest.write(chunk);
      debug("dest.write", ret);
      if (ret === false) {
        if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
          debug("false write response, pause", state.awaitDrain);
          state.awaitDrain++;
        }
        src.pause();
      }
    }
    function onerror(er) {
      debug("onerror", er);
      unpipe();
      dest.removeListener("error", onerror);
      if (EElistenerCount(dest, "error") === 0)
        errorOrDestroy(dest, er);
    }
    prependListener(dest, "error", onerror);
    function onclose() {
      dest.removeListener("finish", onfinish);
      unpipe();
    }
    dest.once("close", onclose);
    function onfinish() {
      debug("onfinish");
      dest.removeListener("close", onclose);
      unpipe();
    }
    dest.once("finish", onfinish);
    function unpipe() {
      debug("unpipe");
      src.unpipe(dest);
    }
    dest.emit("pipe", src);
    if (!state.flowing) {
      debug("pipe resume");
      src.resume();
    }
    return dest;
  };
  function pipeOnDrain(src) {
    return function pipeOnDrainFunctionResult() {
      var state = src._readableState;
      debug("pipeOnDrain", state.awaitDrain);
      if (state.awaitDrain)
        state.awaitDrain--;
      if (state.awaitDrain === 0 && EElistenerCount(src, "data")) {
        state.flowing = true;
        flow(src);
      }
    };
  }
  Readable.prototype.unpipe = function(dest) {
    var state = this._readableState;
    var unpipeInfo = {
      hasUnpiped: false
    };
    if (state.pipesCount === 0)
      return this;
    if (state.pipesCount === 1) {
      if (dest && dest !== state.pipes)
        return this;
      if (!dest)
        dest = state.pipes;
      state.pipes = null;
      state.pipesCount = 0;
      state.flowing = false;
      if (dest)
        dest.emit("unpipe", this, unpipeInfo);
      return this;
    }
    if (!dest) {
      var dests = state.pipes;
      var len = state.pipesCount;
      state.pipes = null;
      state.pipesCount = 0;
      state.flowing = false;
      for (var i = 0; i < len; i++) {
        dests[i].emit("unpipe", this, {
          hasUnpiped: false
        });
      }
      return this;
    }
    var index = indexOf(state.pipes, dest);
    if (index === -1)
      return this;
    state.pipes.splice(index, 1);
    state.pipesCount -= 1;
    if (state.pipesCount === 1)
      state.pipes = state.pipes[0];
    dest.emit("unpipe", this, unpipeInfo);
    return this;
  };
  Readable.prototype.on = function(ev, fn) {
    var res = Stream.prototype.on.call(this, ev, fn);
    var state = this._readableState;
    if (ev === "data") {
      state.readableListening = this.listenerCount("readable") > 0;
      if (state.flowing !== false)
        this.resume();
    } else if (ev === "readable") {
      if (!state.endEmitted && !state.readableListening) {
        state.readableListening = state.needReadable = true;
        state.flowing = false;
        state.emittedReadable = false;
        debug("on readable", state.length, state.reading);
        if (state.length) {
          emitReadable(this);
        } else if (!state.reading) {
          process.nextTick(nReadingNextTick, this);
        }
      }
    }
    return res;
  };
  Readable.prototype.addListener = Readable.prototype.on;
  Readable.prototype.removeListener = function(ev, fn) {
    var res = Stream.prototype.removeListener.call(this, ev, fn);
    if (ev === "readable") {
      process.nextTick(updateReadableListening, this);
    }
    return res;
  };
  Readable.prototype.removeAllListeners = function(ev) {
    var res = Stream.prototype.removeAllListeners.apply(this, arguments);
    if (ev === "readable" || ev === void 0) {
      process.nextTick(updateReadableListening, this);
    }
    return res;
  };
  function updateReadableListening(self2) {
    var state = self2._readableState;
    state.readableListening = self2.listenerCount("readable") > 0;
    if (state.resumeScheduled && !state.paused) {
      state.flowing = true;
    } else if (self2.listenerCount("data") > 0) {
      self2.resume();
    }
  }
  function nReadingNextTick(self2) {
    debug("readable nexttick read 0");
    self2.read(0);
  }
  Readable.prototype.resume = function() {
    var state = this._readableState;
    if (!state.flowing) {
      debug("resume");
      state.flowing = !state.readableListening;
      resume(this, state);
    }
    state.paused = false;
    return this;
  };
  function resume(stream, state) {
    if (!state.resumeScheduled) {
      state.resumeScheduled = true;
      process.nextTick(resume_, stream, state);
    }
  }
  function resume_(stream, state) {
    debug("resume", state.reading);
    if (!state.reading) {
      stream.read(0);
    }
    state.resumeScheduled = false;
    stream.emit("resume");
    flow(stream);
    if (state.flowing && !state.reading)
      stream.read(0);
  }
  Readable.prototype.pause = function() {
    debug("call pause flowing=%j", this._readableState.flowing);
    if (this._readableState.flowing !== false) {
      debug("pause");
      this._readableState.flowing = false;
      this.emit("pause");
    }
    this._readableState.paused = true;
    return this;
  };
  function flow(stream) {
    var state = stream._readableState;
    debug("flow", state.flowing);
    while (state.flowing && stream.read() !== null) {
      ;
    }
  }
  Readable.prototype.wrap = function(stream) {
    var _this = this;
    var state = this._readableState;
    var paused = false;
    stream.on("end", function() {
      debug("wrapped end");
      if (state.decoder && !state.ended) {
        var chunk = state.decoder.end();
        if (chunk && chunk.length)
          _this.push(chunk);
      }
      _this.push(null);
    });
    stream.on("data", function(chunk) {
      debug("wrapped data");
      if (state.decoder)
        chunk = state.decoder.write(chunk);
      if (state.objectMode && (chunk === null || chunk === void 0))
        return;
      else if (!state.objectMode && (!chunk || !chunk.length))
        return;
      var ret = _this.push(chunk);
      if (!ret) {
        paused = true;
        stream.pause();
      }
    });
    for (var i in stream) {
      if (this[i] === void 0 && typeof stream[i] === "function") {
        this[i] = function methodWrap(method) {
          return function methodWrapReturnFunction() {
            return stream[method].apply(stream, arguments);
          };
        }(i);
      }
    }
    for (var n = 0; n < kProxyEvents.length; n++) {
      stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
    }
    this._read = function(n2) {
      debug("wrapped _read", n2);
      if (paused) {
        paused = false;
        stream.resume();
      }
    };
    return this;
  };
  if (typeof Symbol === "function") {
    Readable.prototype[Symbol.asyncIterator] = function() {
      if (createReadableStreamAsyncIterator === void 0) {
        createReadableStreamAsyncIterator = require_async_iterator();
      }
      return createReadableStreamAsyncIterator(this);
    };
  }
  Object.defineProperty(Readable.prototype, "readableHighWaterMark", {
    enumerable: false,
    get: function get() {
      return this._readableState.highWaterMark;
    }
  });
  Object.defineProperty(Readable.prototype, "readableBuffer", {
    enumerable: false,
    get: function get() {
      return this._readableState && this._readableState.buffer;
    }
  });
  Object.defineProperty(Readable.prototype, "readableFlowing", {
    enumerable: false,
    get: function get() {
      return this._readableState.flowing;
    },
    set: function set(state) {
      if (this._readableState) {
        this._readableState.flowing = state;
      }
    }
  });
  Readable._fromList = fromList;
  Object.defineProperty(Readable.prototype, "readableLength", {
    enumerable: false,
    get: function get() {
      return this._readableState.length;
    }
  });
  function fromList(n, state) {
    if (state.length === 0)
      return null;
    var ret;
    if (state.objectMode)
      ret = state.buffer.shift();
    else if (!n || n >= state.length) {
      if (state.decoder)
        ret = state.buffer.join("");
      else if (state.buffer.length === 1)
        ret = state.buffer.first();
      else
        ret = state.buffer.concat(state.length);
      state.buffer.clear();
    } else {
      ret = state.buffer.consume(n, state.decoder);
    }
    return ret;
  }
  function endReadable(stream) {
    var state = stream._readableState;
    debug("endReadable", state.endEmitted);
    if (!state.endEmitted) {
      state.ended = true;
      process.nextTick(endReadableNT, state, stream);
    }
  }
  function endReadableNT(state, stream) {
    debug("endReadableNT", state.endEmitted, state.length);
    if (!state.endEmitted && state.length === 0) {
      state.endEmitted = true;
      stream.readable = false;
      stream.emit("end");
      if (state.autoDestroy) {
        var wState = stream._writableState;
        if (!wState || wState.autoDestroy && wState.finished) {
          stream.destroy();
        }
      }
    }
  }
  if (typeof Symbol === "function") {
    Readable.from = function(iterable, opts) {
      if (from === void 0) {
        from = require_from_browser();
      }
      return from(Readable, iterable, opts);
    };
  }
  function indexOf(xs, x) {
    for (var i = 0, l = xs.length; i < l; i++) {
      if (xs[i] === x)
        return i;
    }
    return -1;
  }
});

// node_modules/readable-stream/lib/_stream_transform.js
var require_stream_transform = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = Transform;
  var _require$codes = require_errors4().codes;
  var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
  var ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK;
  var ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING;
  var ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;
  var Duplex = require_stream_duplex();
  require_inherits_browser()(Transform, Duplex);
  function afterTransform(er, data) {
    var ts = this._transformState;
    ts.transforming = false;
    var cb = ts.writecb;
    if (cb === null) {
      return this.emit("error", new ERR_MULTIPLE_CALLBACK());
    }
    ts.writechunk = null;
    ts.writecb = null;
    if (data != null)
      this.push(data);
    cb(er);
    var rs = this._readableState;
    rs.reading = false;
    if (rs.needReadable || rs.length < rs.highWaterMark) {
      this._read(rs.highWaterMark);
    }
  }
  function Transform(options) {
    if (!(this instanceof Transform))
      return new Transform(options);
    Duplex.call(this, options);
    this._transformState = {
      afterTransform: afterTransform.bind(this),
      needTransform: false,
      transforming: false,
      writecb: null,
      writechunk: null,
      writeencoding: null
    };
    this._readableState.needReadable = true;
    this._readableState.sync = false;
    if (options) {
      if (typeof options.transform === "function")
        this._transform = options.transform;
      if (typeof options.flush === "function")
        this._flush = options.flush;
    }
    this.on("prefinish", prefinish);
  }
  function prefinish() {
    var _this = this;
    if (typeof this._flush === "function" && !this._readableState.destroyed) {
      this._flush(function(er, data) {
        done(_this, er, data);
      });
    } else {
      done(this, null, null);
    }
  }
  Transform.prototype.push = function(chunk, encoding) {
    this._transformState.needTransform = false;
    return Duplex.prototype.push.call(this, chunk, encoding);
  };
  Transform.prototype._transform = function(chunk, encoding, cb) {
    cb(new ERR_METHOD_NOT_IMPLEMENTED("_transform()"));
  };
  Transform.prototype._write = function(chunk, encoding, cb) {
    var ts = this._transformState;
    ts.writecb = cb;
    ts.writechunk = chunk;
    ts.writeencoding = encoding;
    if (!ts.transforming) {
      var rs = this._readableState;
      if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark)
        this._read(rs.highWaterMark);
    }
  };
  Transform.prototype._read = function(n) {
    var ts = this._transformState;
    if (ts.writechunk !== null && !ts.transforming) {
      ts.transforming = true;
      this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
    } else {
      ts.needTransform = true;
    }
  };
  Transform.prototype._destroy = function(err, cb) {
    Duplex.prototype._destroy.call(this, err, function(err2) {
      cb(err2);
    });
  };
  function done(stream, er, data) {
    if (er)
      return stream.emit("error", er);
    if (data != null)
      stream.push(data);
    if (stream._writableState.length)
      throw new ERR_TRANSFORM_WITH_LENGTH_0();
    if (stream._transformState.transforming)
      throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
    return stream.push(null);
  }
});

// node_modules/readable-stream/lib/_stream_passthrough.js
var require_stream_passthrough = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = PassThrough;
  var Transform = require_stream_transform();
  require_inherits_browser()(PassThrough, Transform);
  function PassThrough(options) {
    if (!(this instanceof PassThrough))
      return new PassThrough(options);
    Transform.call(this, options);
  }
  PassThrough.prototype._transform = function(chunk, encoding, cb) {
    cb(null, chunk);
  };
});

// node_modules/readable-stream/lib/internal/streams/pipeline.js
var require_pipeline = __commonJS((exports2, module2) => {
  "use strict";
  var eos;
  function once(callback) {
    var called = false;
    return function() {
      if (called)
        return;
      called = true;
      callback.apply(void 0, arguments);
    };
  }
  var _require$codes = require_errors4().codes;
  var ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS;
  var ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
  function noop(err) {
    if (err)
      throw err;
  }
  function isRequest(stream) {
    return stream.setHeader && typeof stream.abort === "function";
  }
  function destroyer(stream, reading, writing, callback) {
    callback = once(callback);
    var closed = false;
    stream.on("close", function() {
      closed = true;
    });
    if (eos === void 0)
      eos = require_end_of_stream();
    eos(stream, {
      readable: reading,
      writable: writing
    }, function(err) {
      if (err)
        return callback(err);
      closed = true;
      callback();
    });
    var destroyed = false;
    return function(err) {
      if (closed)
        return;
      if (destroyed)
        return;
      destroyed = true;
      if (isRequest(stream))
        return stream.abort();
      if (typeof stream.destroy === "function")
        return stream.destroy();
      callback(err || new ERR_STREAM_DESTROYED("pipe"));
    };
  }
  function call(fn) {
    fn();
  }
  function pipe(from, to) {
    return from.pipe(to);
  }
  function popCallback(streams) {
    if (!streams.length)
      return noop;
    if (typeof streams[streams.length - 1] !== "function")
      return noop;
    return streams.pop();
  }
  function pipeline() {
    for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {
      streams[_key] = arguments[_key];
    }
    var callback = popCallback(streams);
    if (Array.isArray(streams[0]))
      streams = streams[0];
    if (streams.length < 2) {
      throw new ERR_MISSING_ARGS("streams");
    }
    var error;
    var destroys = streams.map(function(stream, i) {
      var reading = i < streams.length - 1;
      var writing = i > 0;
      return destroyer(stream, reading, writing, function(err) {
        if (!error)
          error = err;
        if (err)
          destroys.forEach(call);
        if (reading)
          return;
        destroys.forEach(call);
        callback(error);
      });
    });
    return streams.reduce(pipe);
  }
  module2.exports = pipeline;
});

// node_modules/stream-browserify/index.js
var require_stream_browserify = __commonJS((exports2, module2) => {
  module2.exports = Stream;
  var EE = require_events().EventEmitter;
  var inherits = require_inherits_browser();
  inherits(Stream, EE);
  Stream.Readable = require_stream_readable();
  Stream.Writable = require_stream_writable();
  Stream.Duplex = require_stream_duplex();
  Stream.Transform = require_stream_transform();
  Stream.PassThrough = require_stream_passthrough();
  Stream.finished = require_end_of_stream();
  Stream.pipeline = require_pipeline();
  Stream.Stream = Stream;
  function Stream() {
    EE.call(this);
  }
  Stream.prototype.pipe = function(dest, options) {
    var source = this;
    function ondata(chunk) {
      if (dest.writable) {
        if (dest.write(chunk) === false && source.pause) {
          source.pause();
        }
      }
    }
    source.on("data", ondata);
    function ondrain() {
      if (source.readable && source.resume) {
        source.resume();
      }
    }
    dest.on("drain", ondrain);
    if (!dest._isStdio && (!options || options.end !== false)) {
      source.on("end", onend);
      source.on("close", onclose);
    }
    var didOnEnd = false;
    function onend() {
      if (didOnEnd)
        return;
      didOnEnd = true;
      dest.end();
    }
    function onclose() {
      if (didOnEnd)
        return;
      didOnEnd = true;
      if (typeof dest.destroy === "function")
        dest.destroy();
    }
    function onerror(er) {
      cleanup();
      if (EE.listenerCount(this, "error") === 0) {
        throw er;
      }
    }
    source.on("error", onerror);
    dest.on("error", onerror);
    function cleanup() {
      source.removeListener("data", ondata);
      dest.removeListener("drain", ondrain);
      source.removeListener("end", onend);
      source.removeListener("close", onclose);
      source.removeListener("error", onerror);
      dest.removeListener("error", onerror);
      source.removeListener("end", cleanup);
      source.removeListener("close", cleanup);
      dest.removeListener("close", cleanup);
    }
    source.on("end", cleanup);
    source.on("close", cleanup);
    dest.on("close", cleanup);
    dest.emit("pipe", source);
    return dest;
  };
});

// node_modules/has-symbols/shams.js
var require_shams = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = function hasSymbols() {
    if (typeof Symbol !== "function" || typeof Object.getOwnPropertySymbols !== "function") {
      return false;
    }
    if (typeof Symbol.iterator === "symbol") {
      return true;
    }
    var obj = {};
    var sym = Symbol("test");
    var symObj = Object(sym);
    if (typeof sym === "string") {
      return false;
    }
    if (Object.prototype.toString.call(sym) !== "[object Symbol]") {
      return false;
    }
    if (Object.prototype.toString.call(symObj) !== "[object Symbol]") {
      return false;
    }
    var symVal = 42;
    obj[sym] = symVal;
    for (sym in obj) {
      return false;
    }
    if (typeof Object.keys === "function" && Object.keys(obj).length !== 0) {
      return false;
    }
    if (typeof Object.getOwnPropertyNames === "function" && Object.getOwnPropertyNames(obj).length !== 0) {
      return false;
    }
    var syms = Object.getOwnPropertySymbols(obj);
    if (syms.length !== 1 || syms[0] !== sym) {
      return false;
    }
    if (!Object.prototype.propertyIsEnumerable.call(obj, sym)) {
      return false;
    }
    if (typeof Object.getOwnPropertyDescriptor === "function") {
      var descriptor = Object.getOwnPropertyDescriptor(obj, sym);
      if (descriptor.value !== symVal || descriptor.enumerable !== true) {
        return false;
      }
    }
    return true;
  };
});

// node_modules/has-symbols/index.js
var require_has_symbols = __commonJS((exports2, module2) => {
  "use strict";
  var origSymbol = global.Symbol;
  var hasSymbolSham = require_shams();
  module2.exports = function hasNativeSymbols() {
    if (typeof origSymbol !== "function") {
      return false;
    }
    if (typeof Symbol !== "function") {
      return false;
    }
    if (typeof origSymbol("foo") !== "symbol") {
      return false;
    }
    if (typeof Symbol("bar") !== "symbol") {
      return false;
    }
    return hasSymbolSham();
  };
});

// node_modules/function-bind/implementation.js
var require_implementation2 = __commonJS((exports2, module2) => {
  "use strict";
  var ERROR_MESSAGE = "Function.prototype.bind called on incompatible ";
  var slice = Array.prototype.slice;
  var toStr = Object.prototype.toString;
  var funcType = "[object Function]";
  module2.exports = function bind(that) {
    var target = this;
    if (typeof target !== "function" || toStr.call(target) !== funcType) {
      throw new TypeError(ERROR_MESSAGE + target);
    }
    var args = slice.call(arguments, 1);
    var bound;
    var binder = function() {
      if (this instanceof bound) {
        var result = target.apply(this, args.concat(slice.call(arguments)));
        if (Object(result) === result) {
          return result;
        }
        return this;
      } else {
        return target.apply(that, args.concat(slice.call(arguments)));
      }
    };
    var boundLength = Math.max(0, target.length - args.length);
    var boundArgs = [];
    for (var i = 0; i < boundLength; i++) {
      boundArgs.push("$" + i);
    }
    bound = Function("binder", "return function (" + boundArgs.join(",") + "){ return binder.apply(this,arguments); }")(binder);
    if (target.prototype) {
      var Empty = function Empty2() {
      };
      Empty.prototype = target.prototype;
      bound.prototype = new Empty();
      Empty.prototype = null;
    }
    return bound;
  };
});

// node_modules/function-bind/index.js
var require_function_bind = __commonJS((exports2, module2) => {
  "use strict";
  var implementation = require_implementation2();
  module2.exports = Function.prototype.bind || implementation;
});

// node_modules/has/src/index.js
var require_src20 = __commonJS((exports2, module2) => {
  "use strict";
  var bind = require_function_bind();
  module2.exports = bind.call(Function.call, Object.prototype.hasOwnProperty);
});

// node_modules/get-intrinsic/index.js
var require_get_intrinsic = __commonJS((exports2, module2) => {
  "use strict";
  var undefined2;
  var $SyntaxError = SyntaxError;
  var $Function = Function;
  var $TypeError = TypeError;
  var getEvalledConstructor = function(expressionSyntax) {
    try {
      return $Function('"use strict"; return (' + expressionSyntax + ").constructor;")();
    } catch (e) {
    }
  };
  var $gOPD = Object.getOwnPropertyDescriptor;
  if ($gOPD) {
    try {
      $gOPD({}, "");
    } catch (e) {
      $gOPD = null;
    }
  }
  var throwTypeError = function() {
    throw new $TypeError();
  };
  var ThrowTypeError = $gOPD ? function() {
    try {
      arguments.callee;
      return throwTypeError;
    } catch (calleeThrows) {
      try {
        return $gOPD(arguments, "callee").get;
      } catch (gOPDthrows) {
        return throwTypeError;
      }
    }
  }() : throwTypeError;
  var hasSymbols = require_has_symbols()();
  var getProto = Object.getPrototypeOf || function(x) {
    return x.__proto__;
  };
  var needsEval = {};
  var TypedArray = typeof Uint8Array === "undefined" ? undefined2 : getProto(Uint8Array);
  var INTRINSICS = {
    "%AggregateError%": typeof AggregateError === "undefined" ? undefined2 : AggregateError,
    "%Array%": Array,
    "%ArrayBuffer%": typeof ArrayBuffer === "undefined" ? undefined2 : ArrayBuffer,
    "%ArrayIteratorPrototype%": hasSymbols ? getProto([][Symbol.iterator]()) : undefined2,
    "%AsyncFromSyncIteratorPrototype%": undefined2,
    "%AsyncFunction%": needsEval,
    "%AsyncGenerator%": needsEval,
    "%AsyncGeneratorFunction%": needsEval,
    "%AsyncIteratorPrototype%": needsEval,
    "%Atomics%": typeof Atomics === "undefined" ? undefined2 : Atomics,
    "%BigInt%": typeof BigInt === "undefined" ? undefined2 : BigInt,
    "%Boolean%": Boolean,
    "%DataView%": typeof DataView === "undefined" ? undefined2 : DataView,
    "%Date%": Date,
    "%decodeURI%": decodeURI,
    "%decodeURIComponent%": decodeURIComponent,
    "%encodeURI%": encodeURI,
    "%encodeURIComponent%": encodeURIComponent,
    "%Error%": Error,
    "%eval%": eval,
    "%EvalError%": EvalError,
    "%Float32Array%": typeof Float32Array === "undefined" ? undefined2 : Float32Array,
    "%Float64Array%": typeof Float64Array === "undefined" ? undefined2 : Float64Array,
    "%FinalizationRegistry%": typeof FinalizationRegistry === "undefined" ? undefined2 : FinalizationRegistry,
    "%Function%": $Function,
    "%GeneratorFunction%": needsEval,
    "%Int8Array%": typeof Int8Array === "undefined" ? undefined2 : Int8Array,
    "%Int16Array%": typeof Int16Array === "undefined" ? undefined2 : Int16Array,
    "%Int32Array%": typeof Int32Array === "undefined" ? undefined2 : Int32Array,
    "%isFinite%": isFinite,
    "%isNaN%": isNaN,
    "%IteratorPrototype%": hasSymbols ? getProto(getProto([][Symbol.iterator]())) : undefined2,
    "%JSON%": typeof JSON === "object" ? JSON : undefined2,
    "%Map%": typeof Map === "undefined" ? undefined2 : Map,
    "%MapIteratorPrototype%": typeof Map === "undefined" || !hasSymbols ? undefined2 : getProto(new Map()[Symbol.iterator]()),
    "%Math%": Math,
    "%Number%": Number,
    "%Object%": Object,
    "%parseFloat%": parseFloat,
    "%parseInt%": parseInt,
    "%Promise%": typeof Promise === "undefined" ? undefined2 : Promise,
    "%Proxy%": typeof Proxy === "undefined" ? undefined2 : Proxy,
    "%RangeError%": RangeError,
    "%ReferenceError%": ReferenceError,
    "%Reflect%": typeof Reflect === "undefined" ? undefined2 : Reflect,
    "%RegExp%": RegExp,
    "%Set%": typeof Set === "undefined" ? undefined2 : Set,
    "%SetIteratorPrototype%": typeof Set === "undefined" || !hasSymbols ? undefined2 : getProto(new Set()[Symbol.iterator]()),
    "%SharedArrayBuffer%": typeof SharedArrayBuffer === "undefined" ? undefined2 : SharedArrayBuffer,
    "%String%": String,
    "%StringIteratorPrototype%": hasSymbols ? getProto(""[Symbol.iterator]()) : undefined2,
    "%Symbol%": hasSymbols ? Symbol : undefined2,
    "%SyntaxError%": $SyntaxError,
    "%ThrowTypeError%": ThrowTypeError,
    "%TypedArray%": TypedArray,
    "%TypeError%": $TypeError,
    "%Uint8Array%": typeof Uint8Array === "undefined" ? undefined2 : Uint8Array,
    "%Uint8ClampedArray%": typeof Uint8ClampedArray === "undefined" ? undefined2 : Uint8ClampedArray,
    "%Uint16Array%": typeof Uint16Array === "undefined" ? undefined2 : Uint16Array,
    "%Uint32Array%": typeof Uint32Array === "undefined" ? undefined2 : Uint32Array,
    "%URIError%": URIError,
    "%WeakMap%": typeof WeakMap === "undefined" ? undefined2 : WeakMap,
    "%WeakRef%": typeof WeakRef === "undefined" ? undefined2 : WeakRef,
    "%WeakSet%": typeof WeakSet === "undefined" ? undefined2 : WeakSet
  };
  var doEval = function doEval2(name) {
    var value;
    if (name === "%AsyncFunction%") {
      value = getEvalledConstructor("async function () {}");
    } else if (name === "%GeneratorFunction%") {
      value = getEvalledConstructor("function* () {}");
    } else if (name === "%AsyncGeneratorFunction%") {
      value = getEvalledConstructor("async function* () {}");
    } else if (name === "%AsyncGenerator%") {
      var fn = doEval2("%AsyncGeneratorFunction%");
      if (fn) {
        value = fn.prototype;
      }
    } else if (name === "%AsyncIteratorPrototype%") {
      var gen = doEval2("%AsyncGenerator%");
      if (gen) {
        value = getProto(gen.prototype);
      }
    }
    INTRINSICS[name] = value;
    return value;
  };
  var LEGACY_ALIASES = {
    "%ArrayBufferPrototype%": ["ArrayBuffer", "prototype"],
    "%ArrayPrototype%": ["Array", "prototype"],
    "%ArrayProto_entries%": ["Array", "prototype", "entries"],
    "%ArrayProto_forEach%": ["Array", "prototype", "forEach"],
    "%ArrayProto_keys%": ["Array", "prototype", "keys"],
    "%ArrayProto_values%": ["Array", "prototype", "values"],
    "%AsyncFunctionPrototype%": ["AsyncFunction", "prototype"],
    "%AsyncGenerator%": ["AsyncGeneratorFunction", "prototype"],
    "%AsyncGeneratorPrototype%": ["AsyncGeneratorFunction", "prototype", "prototype"],
    "%BooleanPrototype%": ["Boolean", "prototype"],
    "%DataViewPrototype%": ["DataView", "prototype"],
    "%DatePrototype%": ["Date", "prototype"],
    "%ErrorPrototype%": ["Error", "prototype"],
    "%EvalErrorPrototype%": ["EvalError", "prototype"],
    "%Float32ArrayPrototype%": ["Float32Array", "prototype"],
    "%Float64ArrayPrototype%": ["Float64Array", "prototype"],
    "%FunctionPrototype%": ["Function", "prototype"],
    "%Generator%": ["GeneratorFunction", "prototype"],
    "%GeneratorPrototype%": ["GeneratorFunction", "prototype", "prototype"],
    "%Int8ArrayPrototype%": ["Int8Array", "prototype"],
    "%Int16ArrayPrototype%": ["Int16Array", "prototype"],
    "%Int32ArrayPrototype%": ["Int32Array", "prototype"],
    "%JSONParse%": ["JSON", "parse"],
    "%JSONStringify%": ["JSON", "stringify"],
    "%MapPrototype%": ["Map", "prototype"],
    "%NumberPrototype%": ["Number", "prototype"],
    "%ObjectPrototype%": ["Object", "prototype"],
    "%ObjProto_toString%": ["Object", "prototype", "toString"],
    "%ObjProto_valueOf%": ["Object", "prototype", "valueOf"],
    "%PromisePrototype%": ["Promise", "prototype"],
    "%PromiseProto_then%": ["Promise", "prototype", "then"],
    "%Promise_all%": ["Promise", "all"],
    "%Promise_reject%": ["Promise", "reject"],
    "%Promise_resolve%": ["Promise", "resolve"],
    "%RangeErrorPrototype%": ["RangeError", "prototype"],
    "%ReferenceErrorPrototype%": ["ReferenceError", "prototype"],
    "%RegExpPrototype%": ["RegExp", "prototype"],
    "%SetPrototype%": ["Set", "prototype"],
    "%SharedArrayBufferPrototype%": ["SharedArrayBuffer", "prototype"],
    "%StringPrototype%": ["String", "prototype"],
    "%SymbolPrototype%": ["Symbol", "prototype"],
    "%SyntaxErrorPrototype%": ["SyntaxError", "prototype"],
    "%TypedArrayPrototype%": ["TypedArray", "prototype"],
    "%TypeErrorPrototype%": ["TypeError", "prototype"],
    "%Uint8ArrayPrototype%": ["Uint8Array", "prototype"],
    "%Uint8ClampedArrayPrototype%": ["Uint8ClampedArray", "prototype"],
    "%Uint16ArrayPrototype%": ["Uint16Array", "prototype"],
    "%Uint32ArrayPrototype%": ["Uint32Array", "prototype"],
    "%URIErrorPrototype%": ["URIError", "prototype"],
    "%WeakMapPrototype%": ["WeakMap", "prototype"],
    "%WeakSetPrototype%": ["WeakSet", "prototype"]
  };
  var bind = require_function_bind();
  var hasOwn = require_src20();
  var $concat = bind.call(Function.call, Array.prototype.concat);
  var $spliceApply = bind.call(Function.apply, Array.prototype.splice);
  var $replace = bind.call(Function.call, String.prototype.replace);
  var $strSlice = bind.call(Function.call, String.prototype.slice);
  var rePropName = /[^%.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|%$))/g;
  var reEscapeChar = /\\(\\)?/g;
  var stringToPath = function stringToPath2(string) {
    var first = $strSlice(string, 0, 1);
    var last = $strSlice(string, -1);
    if (first === "%" && last !== "%") {
      throw new $SyntaxError("invalid intrinsic syntax, expected closing `%`");
    } else if (last === "%" && first !== "%") {
      throw new $SyntaxError("invalid intrinsic syntax, expected opening `%`");
    }
    var result = [];
    $replace(string, rePropName, function(match, number, quote, subString) {
      result[result.length] = quote ? $replace(subString, reEscapeChar, "$1") : number || match;
    });
    return result;
  };
  var getBaseIntrinsic = function getBaseIntrinsic2(name, allowMissing) {
    var intrinsicName = name;
    var alias;
    if (hasOwn(LEGACY_ALIASES, intrinsicName)) {
      alias = LEGACY_ALIASES[intrinsicName];
      intrinsicName = "%" + alias[0] + "%";
    }
    if (hasOwn(INTRINSICS, intrinsicName)) {
      var value = INTRINSICS[intrinsicName];
      if (value === needsEval) {
        value = doEval(intrinsicName);
      }
      if (typeof value === "undefined" && !allowMissing) {
        throw new $TypeError("intrinsic " + name + " exists, but is not available. Please file an issue!");
      }
      return {
        alias,
        name: intrinsicName,
        value
      };
    }
    throw new $SyntaxError("intrinsic " + name + " does not exist!");
  };
  module2.exports = function GetIntrinsic(name, allowMissing) {
    if (typeof name !== "string" || name.length === 0) {
      throw new $TypeError("intrinsic name must be a non-empty string");
    }
    if (arguments.length > 1 && typeof allowMissing !== "boolean") {
      throw new $TypeError('"allowMissing" argument must be a boolean');
    }
    var parts = stringToPath(name);
    var intrinsicBaseName = parts.length > 0 ? parts[0] : "";
    var intrinsic = getBaseIntrinsic("%" + intrinsicBaseName + "%", allowMissing);
    var intrinsicRealName = intrinsic.name;
    var value = intrinsic.value;
    var skipFurtherCaching = false;
    var alias = intrinsic.alias;
    if (alias) {
      intrinsicBaseName = alias[0];
      $spliceApply(parts, $concat([0, 1], alias));
    }
    for (var i = 1, isOwn = true; i < parts.length; i += 1) {
      var part = parts[i];
      var first = $strSlice(part, 0, 1);
      var last = $strSlice(part, -1);
      if ((first === '"' || first === "'" || first === "`" || (last === '"' || last === "'" || last === "`")) && first !== last) {
        throw new $SyntaxError("property names with quotes must have matching quotes");
      }
      if (part === "constructor" || !isOwn) {
        skipFurtherCaching = true;
      }
      intrinsicBaseName += "." + part;
      intrinsicRealName = "%" + intrinsicBaseName + "%";
      if (hasOwn(INTRINSICS, intrinsicRealName)) {
        value = INTRINSICS[intrinsicRealName];
      } else if (value != null) {
        if (!(part in value)) {
          if (!allowMissing) {
            throw new $TypeError("base intrinsic for " + name + " exists, but the property is not available.");
          }
          return void 0;
        }
        if ($gOPD && i + 1 >= parts.length) {
          var desc = $gOPD(value, part);
          isOwn = !!desc;
          if (isOwn && "get" in desc && !("originalValue" in desc.get)) {
            value = desc.get;
          } else {
            value = value[part];
          }
        } else {
          isOwn = hasOwn(value, part);
          value = value[part];
        }
        if (isOwn && !skipFurtherCaching) {
          INTRINSICS[intrinsicRealName] = value;
        }
      }
    }
    return value;
  };
});

// node_modules/call-bind/index.js
var require_call_bind = __commonJS((exports2, module2) => {
  "use strict";
  var bind = require_function_bind();
  var GetIntrinsic = require_get_intrinsic();
  var $apply = GetIntrinsic("%Function.prototype.apply%");
  var $call = GetIntrinsic("%Function.prototype.call%");
  var $reflectApply = GetIntrinsic("%Reflect.apply%", true) || bind.call($call, $apply);
  var $gOPD = GetIntrinsic("%Object.getOwnPropertyDescriptor%", true);
  var $defineProperty = GetIntrinsic("%Object.defineProperty%", true);
  var $max = GetIntrinsic("%Math.max%");
  if ($defineProperty) {
    try {
      $defineProperty({}, "a", {value: 1});
    } catch (e) {
      $defineProperty = null;
    }
  }
  module2.exports = function callBind(originalFunction) {
    var func = $reflectApply(bind, $call, arguments);
    if ($gOPD && $defineProperty) {
      var desc = $gOPD(func, "length");
      if (desc.configurable) {
        $defineProperty(func, "length", {value: 1 + $max(0, originalFunction.length - (arguments.length - 1))});
      }
    }
    return func;
  };
  var applyBind = function applyBind2() {
    return $reflectApply(bind, $apply, arguments);
  };
  if ($defineProperty) {
    $defineProperty(module2.exports, "apply", {value: applyBind});
  } else {
    module2.exports.apply = applyBind;
  }
});

// node_modules/call-bind/callBound.js
var require_callBound = __commonJS((exports2, module2) => {
  "use strict";
  var GetIntrinsic = require_get_intrinsic();
  var callBind = require_call_bind();
  var $indexOf = callBind(GetIntrinsic("String.prototype.indexOf"));
  module2.exports = function callBoundIntrinsic(name, allowMissing) {
    var intrinsic = GetIntrinsic(name, !!allowMissing);
    if (typeof intrinsic === "function" && $indexOf(name, ".prototype.") > -1) {
      return callBind(intrinsic);
    }
    return intrinsic;
  };
});

// node_modules/is-arguments/index.js
var require_is_arguments = __commonJS((exports2, module2) => {
  "use strict";
  var hasToStringTag = typeof Symbol === "function" && typeof Symbol.toStringTag === "symbol";
  var callBound = require_callBound();
  var $toString = callBound("Object.prototype.toString");
  var isStandardArguments = function isArguments(value) {
    if (hasToStringTag && value && typeof value === "object" && Symbol.toStringTag in value) {
      return false;
    }
    return $toString(value) === "[object Arguments]";
  };
  var isLegacyArguments = function isArguments(value) {
    if (isStandardArguments(value)) {
      return true;
    }
    return value !== null && typeof value === "object" && typeof value.length === "number" && value.length >= 0 && $toString(value) !== "[object Array]" && $toString(value.callee) === "[object Function]";
  };
  var supportsStandardArguments = function() {
    return isStandardArguments(arguments);
  }();
  isStandardArguments.isLegacyArguments = isLegacyArguments;
  module2.exports = supportsStandardArguments ? isStandardArguments : isLegacyArguments;
});

// node_modules/is-generator-function/index.js
var require_is_generator_function = __commonJS((exports2, module2) => {
  "use strict";
  var toStr = Object.prototype.toString;
  var fnToStr = Function.prototype.toString;
  var isFnRegex = /^\s*(?:function)?\*/;
  var hasToStringTag = typeof Symbol === "function" && typeof Symbol.toStringTag === "symbol";
  var getProto = Object.getPrototypeOf;
  var getGeneratorFunc = function() {
    if (!hasToStringTag) {
      return false;
    }
    try {
      return Function("return function*() {}")();
    } catch (e) {
    }
  };
  var generatorFunc = getGeneratorFunc();
  var GeneratorFunction = getProto && generatorFunc ? getProto(generatorFunc) : false;
  module2.exports = function isGeneratorFunction(fn) {
    if (typeof fn !== "function") {
      return false;
    }
    if (isFnRegex.test(fnToStr.call(fn))) {
      return true;
    }
    if (!hasToStringTag) {
      var str = toStr.call(fn);
      return str === "[object GeneratorFunction]";
    }
    return getProto && getProto(fn) === GeneratorFunction;
  };
});

// node_modules/foreach/index.js
var require_foreach = __commonJS((exports2, module2) => {
  var hasOwn = Object.prototype.hasOwnProperty;
  var toString = Object.prototype.toString;
  module2.exports = function forEach(obj, fn, ctx) {
    if (toString.call(fn) !== "[object Function]") {
      throw new TypeError("iterator must be a function");
    }
    var l = obj.length;
    if (l === +l) {
      for (var i = 0; i < l; i++) {
        fn.call(ctx, obj[i], i, obj);
      }
    } else {
      for (var k in obj) {
        if (hasOwn.call(obj, k)) {
          fn.call(ctx, obj[k], k, obj);
        }
      }
    }
  };
});

// node_modules/array-filter/index.js
var require_array_filter = __commonJS((exports2, module2) => {
  module2.exports = function(arr, fn, self2) {
    if (arr.filter)
      return arr.filter(fn, self2);
    if (arr === void 0 || arr === null)
      throw new TypeError();
    if (typeof fn != "function")
      throw new TypeError();
    var ret = [];
    for (var i = 0; i < arr.length; i++) {
      if (!hasOwn.call(arr, i))
        continue;
      var val = arr[i];
      if (fn.call(self2, val, i, arr))
        ret.push(val);
    }
    return ret;
  };
  var hasOwn = Object.prototype.hasOwnProperty;
});

// node_modules/available-typed-arrays/index.js
var require_available_typed_arrays = __commonJS((exports2, module2) => {
  "use strict";
  var filter = require_array_filter();
  module2.exports = function availableTypedArrays() {
    return filter([
      "BigInt64Array",
      "BigUint64Array",
      "Float32Array",
      "Float64Array",
      "Int16Array",
      "Int32Array",
      "Int8Array",
      "Uint16Array",
      "Uint32Array",
      "Uint8Array",
      "Uint8ClampedArray"
    ], function(typedArray) {
      return typeof global[typedArray] === "function";
    });
  };
});

// node_modules/es-abstract/helpers/getOwnPropertyDescriptor.js
var require_getOwnPropertyDescriptor = __commonJS((exports2, module2) => {
  "use strict";
  var GetIntrinsic = require_get_intrinsic();
  var $gOPD = GetIntrinsic("%Object.getOwnPropertyDescriptor%");
  if ($gOPD) {
    try {
      $gOPD([], "length");
    } catch (e) {
      $gOPD = null;
    }
  }
  module2.exports = $gOPD;
});

// node_modules/is-typed-array/index.js
var require_is_typed_array = __commonJS((exports2, module2) => {
  "use strict";
  var forEach = require_foreach();
  var availableTypedArrays = require_available_typed_arrays();
  var callBound = require_callBound();
  var $toString = callBound("Object.prototype.toString");
  var hasSymbols = require_has_symbols()();
  var hasToStringTag = hasSymbols && typeof Symbol.toStringTag === "symbol";
  var typedArrays = availableTypedArrays();
  var $indexOf = callBound("Array.prototype.indexOf", true) || function indexOf(array, value) {
    for (var i = 0; i < array.length; i += 1) {
      if (array[i] === value) {
        return i;
      }
    }
    return -1;
  };
  var $slice = callBound("String.prototype.slice");
  var toStrTags = {};
  var gOPD = require_getOwnPropertyDescriptor();
  var getPrototypeOf = Object.getPrototypeOf;
  if (hasToStringTag && gOPD && getPrototypeOf) {
    forEach(typedArrays, function(typedArray) {
      var arr = new global[typedArray]();
      if (!(Symbol.toStringTag in arr)) {
        throw new EvalError("this engine has support for Symbol.toStringTag, but " + typedArray + " does not have the property! Please report this.");
      }
      var proto = getPrototypeOf(arr);
      var descriptor = gOPD(proto, Symbol.toStringTag);
      if (!descriptor) {
        var superProto = getPrototypeOf(proto);
        descriptor = gOPD(superProto, Symbol.toStringTag);
      }
      toStrTags[typedArray] = descriptor.get;
    });
  }
  var tryTypedArrays = function tryAllTypedArrays(value) {
    var anyTrue = false;
    forEach(toStrTags, function(getter, typedArray) {
      if (!anyTrue) {
        try {
          anyTrue = getter.call(value) === typedArray;
        } catch (e) {
        }
      }
    });
    return anyTrue;
  };
  module2.exports = function isTypedArray(value) {
    if (!value || typeof value !== "object") {
      return false;
    }
    if (!hasToStringTag) {
      var tag = $slice($toString(value), 8, -1);
      return $indexOf(typedArrays, tag) > -1;
    }
    if (!gOPD) {
      return false;
    }
    return tryTypedArrays(value);
  };
});

// node_modules/which-typed-array/index.js
var require_which_typed_array = __commonJS((exports2, module2) => {
  "use strict";
  var forEach = require_foreach();
  var availableTypedArrays = require_available_typed_arrays();
  var callBound = require_callBound();
  var $toString = callBound("Object.prototype.toString");
  var hasSymbols = require_has_symbols()();
  var hasToStringTag = hasSymbols && typeof Symbol.toStringTag === "symbol";
  var typedArrays = availableTypedArrays();
  var $slice = callBound("String.prototype.slice");
  var toStrTags = {};
  var gOPD = require_getOwnPropertyDescriptor();
  var getPrototypeOf = Object.getPrototypeOf;
  if (hasToStringTag && gOPD && getPrototypeOf) {
    forEach(typedArrays, function(typedArray) {
      if (typeof global[typedArray] === "function") {
        var arr = new global[typedArray]();
        if (!(Symbol.toStringTag in arr)) {
          throw new EvalError("this engine has support for Symbol.toStringTag, but " + typedArray + " does not have the property! Please report this.");
        }
        var proto = getPrototypeOf(arr);
        var descriptor = gOPD(proto, Symbol.toStringTag);
        if (!descriptor) {
          var superProto = getPrototypeOf(proto);
          descriptor = gOPD(superProto, Symbol.toStringTag);
        }
        toStrTags[typedArray] = descriptor.get;
      }
    });
  }
  var tryTypedArrays = function tryAllTypedArrays(value) {
    var foundName = false;
    forEach(toStrTags, function(getter, typedArray) {
      if (!foundName) {
        try {
          var name = getter.call(value);
          if (name === typedArray) {
            foundName = name;
          }
        } catch (e) {
        }
      }
    });
    return foundName;
  };
  var isTypedArray = require_is_typed_array();
  module2.exports = function whichTypedArray(value) {
    if (!isTypedArray(value)) {
      return false;
    }
    if (!hasToStringTag) {
      return $slice($toString(value), 8, -1);
    }
    return tryTypedArrays(value);
  };
});

// node_modules/util/support/types.js
var require_types = __commonJS((exports2) => {
  "use strict";
  var isArgumentsObject = require_is_arguments();
  var isGeneratorFunction = require_is_generator_function();
  var whichTypedArray = require_which_typed_array();
  var isTypedArray = require_is_typed_array();
  function uncurryThis(f) {
    return f.call.bind(f);
  }
  var BigIntSupported = typeof BigInt !== "undefined";
  var SymbolSupported = typeof Symbol !== "undefined";
  var ObjectToString = uncurryThis(Object.prototype.toString);
  var numberValue = uncurryThis(Number.prototype.valueOf);
  var stringValue = uncurryThis(String.prototype.valueOf);
  var booleanValue = uncurryThis(Boolean.prototype.valueOf);
  if (BigIntSupported) {
    bigIntValue = uncurryThis(BigInt.prototype.valueOf);
  }
  var bigIntValue;
  if (SymbolSupported) {
    symbolValue = uncurryThis(Symbol.prototype.valueOf);
  }
  var symbolValue;
  function checkBoxedPrimitive(value, prototypeValueOf) {
    if (typeof value !== "object") {
      return false;
    }
    try {
      prototypeValueOf(value);
      return true;
    } catch (e) {
      return false;
    }
  }
  exports2.isArgumentsObject = isArgumentsObject;
  exports2.isGeneratorFunction = isGeneratorFunction;
  exports2.isTypedArray = isTypedArray;
  function isPromise(input) {
    return typeof Promise !== "undefined" && input instanceof Promise || input !== null && typeof input === "object" && typeof input.then === "function" && typeof input.catch === "function";
  }
  exports2.isPromise = isPromise;
  function isArrayBufferView(value) {
    if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
      return ArrayBuffer.isView(value);
    }
    return isTypedArray(value) || isDataView(value);
  }
  exports2.isArrayBufferView = isArrayBufferView;
  function isUint8Array(value) {
    return whichTypedArray(value) === "Uint8Array";
  }
  exports2.isUint8Array = isUint8Array;
  function isUint8ClampedArray(value) {
    return whichTypedArray(value) === "Uint8ClampedArray";
  }
  exports2.isUint8ClampedArray = isUint8ClampedArray;
  function isUint16Array(value) {
    return whichTypedArray(value) === "Uint16Array";
  }
  exports2.isUint16Array = isUint16Array;
  function isUint32Array(value) {
    return whichTypedArray(value) === "Uint32Array";
  }
  exports2.isUint32Array = isUint32Array;
  function isInt8Array(value) {
    return whichTypedArray(value) === "Int8Array";
  }
  exports2.isInt8Array = isInt8Array;
  function isInt16Array(value) {
    return whichTypedArray(value) === "Int16Array";
  }
  exports2.isInt16Array = isInt16Array;
  function isInt32Array(value) {
    return whichTypedArray(value) === "Int32Array";
  }
  exports2.isInt32Array = isInt32Array;
  function isFloat32Array(value) {
    return whichTypedArray(value) === "Float32Array";
  }
  exports2.isFloat32Array = isFloat32Array;
  function isFloat64Array(value) {
    return whichTypedArray(value) === "Float64Array";
  }
  exports2.isFloat64Array = isFloat64Array;
  function isBigInt64Array(value) {
    return whichTypedArray(value) === "BigInt64Array";
  }
  exports2.isBigInt64Array = isBigInt64Array;
  function isBigUint64Array(value) {
    return whichTypedArray(value) === "BigUint64Array";
  }
  exports2.isBigUint64Array = isBigUint64Array;
  function isMapToString(value) {
    return ObjectToString(value) === "[object Map]";
  }
  isMapToString.working = typeof Map !== "undefined" && isMapToString(new Map());
  function isMap(value) {
    if (typeof Map === "undefined") {
      return false;
    }
    return isMapToString.working ? isMapToString(value) : value instanceof Map;
  }
  exports2.isMap = isMap;
  function isSetToString(value) {
    return ObjectToString(value) === "[object Set]";
  }
  isSetToString.working = typeof Set !== "undefined" && isSetToString(new Set());
  function isSet(value) {
    if (typeof Set === "undefined") {
      return false;
    }
    return isSetToString.working ? isSetToString(value) : value instanceof Set;
  }
  exports2.isSet = isSet;
  function isWeakMapToString(value) {
    return ObjectToString(value) === "[object WeakMap]";
  }
  isWeakMapToString.working = typeof WeakMap !== "undefined" && isWeakMapToString(new WeakMap());
  function isWeakMap(value) {
    if (typeof WeakMap === "undefined") {
      return false;
    }
    return isWeakMapToString.working ? isWeakMapToString(value) : value instanceof WeakMap;
  }
  exports2.isWeakMap = isWeakMap;
  function isWeakSetToString(value) {
    return ObjectToString(value) === "[object WeakSet]";
  }
  isWeakSetToString.working = typeof WeakSet !== "undefined" && isWeakSetToString(new WeakSet());
  function isWeakSet(value) {
    return isWeakSetToString(value);
  }
  exports2.isWeakSet = isWeakSet;
  function isArrayBufferToString(value) {
    return ObjectToString(value) === "[object ArrayBuffer]";
  }
  isArrayBufferToString.working = typeof ArrayBuffer !== "undefined" && isArrayBufferToString(new ArrayBuffer());
  function isArrayBuffer(value) {
    if (typeof ArrayBuffer === "undefined") {
      return false;
    }
    return isArrayBufferToString.working ? isArrayBufferToString(value) : value instanceof ArrayBuffer;
  }
  exports2.isArrayBuffer = isArrayBuffer;
  function isDataViewToString(value) {
    return ObjectToString(value) === "[object DataView]";
  }
  isDataViewToString.working = typeof ArrayBuffer !== "undefined" && typeof DataView !== "undefined" && isDataViewToString(new DataView(new ArrayBuffer(1), 0, 1));
  function isDataView(value) {
    if (typeof DataView === "undefined") {
      return false;
    }
    return isDataViewToString.working ? isDataViewToString(value) : value instanceof DataView;
  }
  exports2.isDataView = isDataView;
  function isSharedArrayBufferToString(value) {
    return ObjectToString(value) === "[object SharedArrayBuffer]";
  }
  isSharedArrayBufferToString.working = typeof SharedArrayBuffer !== "undefined" && isSharedArrayBufferToString(new SharedArrayBuffer());
  function isSharedArrayBuffer(value) {
    if (typeof SharedArrayBuffer === "undefined") {
      return false;
    }
    return isSharedArrayBufferToString.working ? isSharedArrayBufferToString(value) : value instanceof SharedArrayBuffer;
  }
  exports2.isSharedArrayBuffer = isSharedArrayBuffer;
  function isAsyncFunction(value) {
    return ObjectToString(value) === "[object AsyncFunction]";
  }
  exports2.isAsyncFunction = isAsyncFunction;
  function isMapIterator(value) {
    return ObjectToString(value) === "[object Map Iterator]";
  }
  exports2.isMapIterator = isMapIterator;
  function isSetIterator(value) {
    return ObjectToString(value) === "[object Set Iterator]";
  }
  exports2.isSetIterator = isSetIterator;
  function isGeneratorObject(value) {
    return ObjectToString(value) === "[object Generator]";
  }
  exports2.isGeneratorObject = isGeneratorObject;
  function isWebAssemblyCompiledModule(value) {
    return ObjectToString(value) === "[object WebAssembly.Module]";
  }
  exports2.isWebAssemblyCompiledModule = isWebAssemblyCompiledModule;
  function isNumberObject(value) {
    return checkBoxedPrimitive(value, numberValue);
  }
  exports2.isNumberObject = isNumberObject;
  function isStringObject(value) {
    return checkBoxedPrimitive(value, stringValue);
  }
  exports2.isStringObject = isStringObject;
  function isBooleanObject(value) {
    return checkBoxedPrimitive(value, booleanValue);
  }
  exports2.isBooleanObject = isBooleanObject;
  function isBigIntObject(value) {
    return BigIntSupported && checkBoxedPrimitive(value, bigIntValue);
  }
  exports2.isBigIntObject = isBigIntObject;
  function isSymbolObject(value) {
    return SymbolSupported && checkBoxedPrimitive(value, symbolValue);
  }
  exports2.isSymbolObject = isSymbolObject;
  function isBoxedPrimitive(value) {
    return isNumberObject(value) || isStringObject(value) || isBooleanObject(value) || isBigIntObject(value) || isSymbolObject(value);
  }
  exports2.isBoxedPrimitive = isBoxedPrimitive;
  function isAnyArrayBuffer(value) {
    return typeof Uint8Array !== "undefined" && (isArrayBuffer(value) || isSharedArrayBuffer(value));
  }
  exports2.isAnyArrayBuffer = isAnyArrayBuffer;
  ["isProxy", "isExternal", "isModuleNamespaceObject"].forEach(function(method) {
    Object.defineProperty(exports2, method, {
      enumerable: false,
      value: function() {
        throw new Error(method + " is not supported in userland");
      }
    });
  });
});

// node_modules/util/support/isBufferBrowser.js
var require_isBufferBrowser = __commonJS((exports2, module2) => {
  module2.exports = function isBuffer(arg) {
    return arg && typeof arg === "object" && typeof arg.copy === "function" && typeof arg.fill === "function" && typeof arg.readUInt8 === "function";
  };
});

// node_modules/util/util.js
var require_util10 = __commonJS((exports2) => {
  var getOwnPropertyDescriptors = Object.getOwnPropertyDescriptors || function getOwnPropertyDescriptors2(obj) {
    var keys = Object.keys(obj);
    var descriptors = {};
    for (var i = 0; i < keys.length; i++) {
      descriptors[keys[i]] = Object.getOwnPropertyDescriptor(obj, keys[i]);
    }
    return descriptors;
  };
  var formatRegExp = /%[sdj%]/g;
  exports2.format = function(f) {
    if (!isString(f)) {
      var objects = [];
      for (var i = 0; i < arguments.length; i++) {
        objects.push(inspect(arguments[i]));
      }
      return objects.join(" ");
    }
    var i = 1;
    var args = arguments;
    var len = args.length;
    var str = String(f).replace(formatRegExp, function(x2) {
      if (x2 === "%%")
        return "%";
      if (i >= len)
        return x2;
      switch (x2) {
        case "%s":
          return String(args[i++]);
        case "%d":
          return Number(args[i++]);
        case "%j":
          try {
            return JSON.stringify(args[i++]);
          } catch (_) {
            return "[Circular]";
          }
        default:
          return x2;
      }
    });
    for (var x = args[i]; i < len; x = args[++i]) {
      if (isNull(x) || !isObject(x)) {
        str += " " + x;
      } else {
        str += " " + inspect(x);
      }
    }
    return str;
  };
  exports2.deprecate = function(fn, msg) {
    if (typeof process !== "undefined" && process.noDeprecation === true) {
      return fn;
    }
    if (typeof process === "undefined") {
      return function() {
        return exports2.deprecate(fn, msg).apply(this, arguments);
      };
    }
    var warned = false;
    function deprecated() {
      if (!warned) {
        if (process.throwDeprecation) {
          throw new Error(msg);
        } else if (process.traceDeprecation) {
          console.trace(msg);
        } else {
          console.error(msg);
        }
        warned = true;
      }
      return fn.apply(this, arguments);
    }
    return deprecated;
  };
  var debugs = {};
  var debugEnvRegex = /^$/;
  if (process.env.NODE_DEBUG) {
    debugEnv = process.env.NODE_DEBUG;
    debugEnv = debugEnv.replace(/[|\\{}()[\]^$+?.]/g, "\\$&").replace(/\*/g, ".*").replace(/,/g, "$|^").toUpperCase();
    debugEnvRegex = new RegExp("^" + debugEnv + "$", "i");
  }
  var debugEnv;
  exports2.debuglog = function(set) {
    set = set.toUpperCase();
    if (!debugs[set]) {
      if (debugEnvRegex.test(set)) {
        var pid = process.pid;
        debugs[set] = function() {
          var msg = exports2.format.apply(exports2, arguments);
          console.error("%s %d: %s", set, pid, msg);
        };
      } else {
        debugs[set] = function() {
        };
      }
    }
    return debugs[set];
  };
  function inspect(obj, opts) {
    var ctx = {
      seen: [],
      stylize: stylizeNoColor
    };
    if (arguments.length >= 3)
      ctx.depth = arguments[2];
    if (arguments.length >= 4)
      ctx.colors = arguments[3];
    if (isBoolean(opts)) {
      ctx.showHidden = opts;
    } else if (opts) {
      exports2._extend(ctx, opts);
    }
    if (isUndefined(ctx.showHidden))
      ctx.showHidden = false;
    if (isUndefined(ctx.depth))
      ctx.depth = 2;
    if (isUndefined(ctx.colors))
      ctx.colors = false;
    if (isUndefined(ctx.customInspect))
      ctx.customInspect = true;
    if (ctx.colors)
      ctx.stylize = stylizeWithColor;
    return formatValue(ctx, obj, ctx.depth);
  }
  exports2.inspect = inspect;
  inspect.colors = {
    bold: [1, 22],
    italic: [3, 23],
    underline: [4, 24],
    inverse: [7, 27],
    white: [37, 39],
    grey: [90, 39],
    black: [30, 39],
    blue: [34, 39],
    cyan: [36, 39],
    green: [32, 39],
    magenta: [35, 39],
    red: [31, 39],
    yellow: [33, 39]
  };
  inspect.styles = {
    special: "cyan",
    number: "yellow",
    boolean: "yellow",
    undefined: "grey",
    null: "bold",
    string: "green",
    date: "magenta",
    regexp: "red"
  };
  function stylizeWithColor(str, styleType) {
    var style = inspect.styles[styleType];
    if (style) {
      return "[" + inspect.colors[style][0] + "m" + str + "[" + inspect.colors[style][1] + "m";
    } else {
      return str;
    }
  }
  function stylizeNoColor(str, styleType) {
    return str;
  }
  function arrayToHash(array) {
    var hash = {};
    array.forEach(function(val, idx) {
      hash[val] = true;
    });
    return hash;
  }
  function formatValue(ctx, value, recurseTimes) {
    if (ctx.customInspect && value && isFunction(value.inspect) && value.inspect !== exports2.inspect && !(value.constructor && value.constructor.prototype === value)) {
      var ret = value.inspect(recurseTimes, ctx);
      if (!isString(ret)) {
        ret = formatValue(ctx, ret, recurseTimes);
      }
      return ret;
    }
    var primitive = formatPrimitive(ctx, value);
    if (primitive) {
      return primitive;
    }
    var keys = Object.keys(value);
    var visibleKeys = arrayToHash(keys);
    if (ctx.showHidden) {
      keys = Object.getOwnPropertyNames(value);
    }
    if (isError(value) && (keys.indexOf("message") >= 0 || keys.indexOf("description") >= 0)) {
      return formatError(value);
    }
    if (keys.length === 0) {
      if (isFunction(value)) {
        var name = value.name ? ": " + value.name : "";
        return ctx.stylize("[Function" + name + "]", "special");
      }
      if (isRegExp(value)) {
        return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
      }
      if (isDate(value)) {
        return ctx.stylize(Date.prototype.toString.call(value), "date");
      }
      if (isError(value)) {
        return formatError(value);
      }
    }
    var base = "", array = false, braces = ["{", "}"];
    if (isArray(value)) {
      array = true;
      braces = ["[", "]"];
    }
    if (isFunction(value)) {
      var n = value.name ? ": " + value.name : "";
      base = " [Function" + n + "]";
    }
    if (isRegExp(value)) {
      base = " " + RegExp.prototype.toString.call(value);
    }
    if (isDate(value)) {
      base = " " + Date.prototype.toUTCString.call(value);
    }
    if (isError(value)) {
      base = " " + formatError(value);
    }
    if (keys.length === 0 && (!array || value.length == 0)) {
      return braces[0] + base + braces[1];
    }
    if (recurseTimes < 0) {
      if (isRegExp(value)) {
        return ctx.stylize(RegExp.prototype.toString.call(value), "regexp");
      } else {
        return ctx.stylize("[Object]", "special");
      }
    }
    ctx.seen.push(value);
    var output;
    if (array) {
      output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
    } else {
      output = keys.map(function(key) {
        return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
      });
    }
    ctx.seen.pop();
    return reduceToSingleString(output, base, braces);
  }
  function formatPrimitive(ctx, value) {
    if (isUndefined(value))
      return ctx.stylize("undefined", "undefined");
    if (isString(value)) {
      var simple = "'" + JSON.stringify(value).replace(/^"|"$/g, "").replace(/'/g, "\\'").replace(/\\"/g, '"') + "'";
      return ctx.stylize(simple, "string");
    }
    if (isNumber(value))
      return ctx.stylize("" + value, "number");
    if (isBoolean(value))
      return ctx.stylize("" + value, "boolean");
    if (isNull(value))
      return ctx.stylize("null", "null");
  }
  function formatError(value) {
    return "[" + Error.prototype.toString.call(value) + "]";
  }
  function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
    var output = [];
    for (var i = 0, l = value.length; i < l; ++i) {
      if (hasOwnProperty(value, String(i))) {
        output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, String(i), true));
      } else {
        output.push("");
      }
    }
    keys.forEach(function(key) {
      if (!key.match(/^\d+$/)) {
        output.push(formatProperty(ctx, value, recurseTimes, visibleKeys, key, true));
      }
    });
    return output;
  }
  function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
    var name, str, desc;
    desc = Object.getOwnPropertyDescriptor(value, key) || {value: value[key]};
    if (desc.get) {
      if (desc.set) {
        str = ctx.stylize("[Getter/Setter]", "special");
      } else {
        str = ctx.stylize("[Getter]", "special");
      }
    } else {
      if (desc.set) {
        str = ctx.stylize("[Setter]", "special");
      }
    }
    if (!hasOwnProperty(visibleKeys, key)) {
      name = "[" + key + "]";
    }
    if (!str) {
      if (ctx.seen.indexOf(desc.value) < 0) {
        if (isNull(recurseTimes)) {
          str = formatValue(ctx, desc.value, null);
        } else {
          str = formatValue(ctx, desc.value, recurseTimes - 1);
        }
        if (str.indexOf("\n") > -1) {
          if (array) {
            str = str.split("\n").map(function(line) {
              return "  " + line;
            }).join("\n").substr(2);
          } else {
            str = "\n" + str.split("\n").map(function(line) {
              return "   " + line;
            }).join("\n");
          }
        }
      } else {
        str = ctx.stylize("[Circular]", "special");
      }
    }
    if (isUndefined(name)) {
      if (array && key.match(/^\d+$/)) {
        return str;
      }
      name = JSON.stringify("" + key);
      if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
        name = name.substr(1, name.length - 2);
        name = ctx.stylize(name, "name");
      } else {
        name = name.replace(/'/g, "\\'").replace(/\\"/g, '"').replace(/(^"|"$)/g, "'");
        name = ctx.stylize(name, "string");
      }
    }
    return name + ": " + str;
  }
  function reduceToSingleString(output, base, braces) {
    var numLinesEst = 0;
    var length = output.reduce(function(prev, cur) {
      numLinesEst++;
      if (cur.indexOf("\n") >= 0)
        numLinesEst++;
      return prev + cur.replace(/\u001b\[\d\d?m/g, "").length + 1;
    }, 0);
    if (length > 60) {
      return braces[0] + (base === "" ? "" : base + "\n ") + " " + output.join(",\n  ") + " " + braces[1];
    }
    return braces[0] + base + " " + output.join(", ") + " " + braces[1];
  }
  exports2.types = require_types();
  function isArray(ar) {
    return Array.isArray(ar);
  }
  exports2.isArray = isArray;
  function isBoolean(arg) {
    return typeof arg === "boolean";
  }
  exports2.isBoolean = isBoolean;
  function isNull(arg) {
    return arg === null;
  }
  exports2.isNull = isNull;
  function isNullOrUndefined(arg) {
    return arg == null;
  }
  exports2.isNullOrUndefined = isNullOrUndefined;
  function isNumber(arg) {
    return typeof arg === "number";
  }
  exports2.isNumber = isNumber;
  function isString(arg) {
    return typeof arg === "string";
  }
  exports2.isString = isString;
  function isSymbol(arg) {
    return typeof arg === "symbol";
  }
  exports2.isSymbol = isSymbol;
  function isUndefined(arg) {
    return arg === void 0;
  }
  exports2.isUndefined = isUndefined;
  function isRegExp(re) {
    return isObject(re) && objectToString(re) === "[object RegExp]";
  }
  exports2.isRegExp = isRegExp;
  exports2.types.isRegExp = isRegExp;
  function isObject(arg) {
    return typeof arg === "object" && arg !== null;
  }
  exports2.isObject = isObject;
  function isDate(d) {
    return isObject(d) && objectToString(d) === "[object Date]";
  }
  exports2.isDate = isDate;
  exports2.types.isDate = isDate;
  function isError(e) {
    return isObject(e) && (objectToString(e) === "[object Error]" || e instanceof Error);
  }
  exports2.isError = isError;
  exports2.types.isNativeError = isError;
  function isFunction(arg) {
    return typeof arg === "function";
  }
  exports2.isFunction = isFunction;
  function isPrimitive(arg) {
    return arg === null || typeof arg === "boolean" || typeof arg === "number" || typeof arg === "string" || typeof arg === "symbol" || typeof arg === "undefined";
  }
  exports2.isPrimitive = isPrimitive;
  exports2.isBuffer = require_isBufferBrowser();
  function objectToString(o) {
    return Object.prototype.toString.call(o);
  }
  function pad(n) {
    return n < 10 ? "0" + n.toString(10) : n.toString(10);
  }
  var months = [
    "Jan",
    "Feb",
    "Mar",
    "Apr",
    "May",
    "Jun",
    "Jul",
    "Aug",
    "Sep",
    "Oct",
    "Nov",
    "Dec"
  ];
  function timestamp() {
    var d = new Date();
    var time = [
      pad(d.getHours()),
      pad(d.getMinutes()),
      pad(d.getSeconds())
    ].join(":");
    return [d.getDate(), months[d.getMonth()], time].join(" ");
  }
  exports2.log = function() {
    console.log("%s - %s", timestamp(), exports2.format.apply(exports2, arguments));
  };
  exports2.inherits = require_inherits_browser();
  exports2._extend = function(origin, add) {
    if (!add || !isObject(add))
      return origin;
    var keys = Object.keys(add);
    var i = keys.length;
    while (i--) {
      origin[keys[i]] = add[keys[i]];
    }
    return origin;
  };
  function hasOwnProperty(obj, prop) {
    return Object.prototype.hasOwnProperty.call(obj, prop);
  }
  var kCustomPromisifiedSymbol = typeof Symbol !== "undefined" ? Symbol("util.promisify.custom") : void 0;
  exports2.promisify = function promisify(original) {
    if (typeof original !== "function")
      throw new TypeError('The "original" argument must be of type Function');
    if (kCustomPromisifiedSymbol && original[kCustomPromisifiedSymbol]) {
      var fn = original[kCustomPromisifiedSymbol];
      if (typeof fn !== "function") {
        throw new TypeError('The "util.promisify.custom" argument must be of type Function');
      }
      Object.defineProperty(fn, kCustomPromisifiedSymbol, {
        value: fn,
        enumerable: false,
        writable: false,
        configurable: true
      });
      return fn;
    }
    function fn() {
      var promiseResolve, promiseReject;
      var promise = new Promise(function(resolve, reject) {
        promiseResolve = resolve;
        promiseReject = reject;
      });
      var args = [];
      for (var i = 0; i < arguments.length; i++) {
        args.push(arguments[i]);
      }
      args.push(function(err, value) {
        if (err) {
          promiseReject(err);
        } else {
          promiseResolve(value);
        }
      });
      try {
        original.apply(this, args);
      } catch (err) {
        promiseReject(err);
      }
      return promise;
    }
    Object.setPrototypeOf(fn, Object.getPrototypeOf(original));
    if (kCustomPromisifiedSymbol)
      Object.defineProperty(fn, kCustomPromisifiedSymbol, {
        value: fn,
        enumerable: false,
        writable: false,
        configurable: true
      });
    return Object.defineProperties(fn, getOwnPropertyDescriptors(original));
  };
  exports2.promisify.custom = kCustomPromisifiedSymbol;
  function callbackifyOnRejected(reason, cb) {
    if (!reason) {
      var newReason = new Error("Promise was rejected with a falsy value");
      newReason.reason = reason;
      reason = newReason;
    }
    return cb(reason);
  }
  function callbackify(original) {
    if (typeof original !== "function") {
      throw new TypeError('The "original" argument must be of type Function');
    }
    function callbackified() {
      var args = [];
      for (var i = 0; i < arguments.length; i++) {
        args.push(arguments[i]);
      }
      var maybeCb = args.pop();
      if (typeof maybeCb !== "function") {
        throw new TypeError("The last argument must be of type Function");
      }
      var self2 = this;
      var cb = function() {
        return maybeCb.apply(self2, arguments);
      };
      original.apply(this, args).then(function(ret) {
        process.nextTick(cb.bind(null, null, ret));
      }, function(rej) {
        process.nextTick(callbackifyOnRejected.bind(null, rej, cb));
      });
    }
    Object.setPrototypeOf(callbackified, Object.getPrototypeOf(original));
    Object.defineProperties(callbackified, getOwnPropertyDescriptors(original));
    return callbackified;
  }
  exports2.callbackify = callbackify;
});

// node_modules/nofilter/lib/index.js
var require_lib2 = __commonJS((exports2, module2) => {
  "use strict";
  var stream = require_stream_browserify();
  var util = require_util10();
  var NoFilter = class extends stream.Transform {
    constructor(input, inputEncoding, options) {
      if (options == null) {
        options = {};
      }
      let inp;
      let inpE;
      switch (typeof input) {
        case "object":
          if (Buffer.isBuffer(input)) {
            inp = input;
            if (inputEncoding != null && typeof inputEncoding === "object") {
              options = inputEncoding;
            }
          } else {
            options = input;
          }
          break;
        case "string":
          inp = input;
          if (inputEncoding != null && typeof inputEncoding === "object") {
            options = inputEncoding;
          } else {
            inpE = inputEncoding;
          }
          break;
      }
      if (options == null) {
        options = {};
      }
      if (inp == null) {
        inp = options.input;
      }
      if (inpE == null) {
        inpE = options.inputEncoding;
      }
      delete options.input;
      delete options.inputEncoding;
      const watchPipe = options.watchPipe != null ? options.watchPipe : true;
      delete options.watchPipe;
      const readError = !!options.readError;
      delete options.readError;
      super(options);
      this.readError = readError;
      if (watchPipe) {
        this.on("pipe", (readable) => {
          const om = readable._readableState.objectMode;
          if (this.length > 0 && om !== this._readableState.objectMode) {
            throw new Error("Do not switch objectMode in the middle of the stream");
          }
          this._readableState.objectMode = om;
          return this._writableState.objectMode = om;
        });
      }
      if (inp != null) {
        this.end(inp, inpE);
      }
    }
    static isNoFilter(obj) {
      return obj instanceof this;
    }
    static compare(nf1, nf2) {
      if (!(nf1 instanceof this)) {
        throw new TypeError("Arguments must be NoFilters");
      }
      if (nf1 === nf2) {
        return 0;
      } else {
        return nf1.compare(nf2);
      }
    }
    static concat(list, length) {
      if (!Array.isArray(list)) {
        throw new TypeError("list argument must be an Array of NoFilters");
      }
      if (list.length === 0 || length === 0) {
        return Buffer.alloc(0);
      }
      if (length == null) {
        length = list.reduce((tot, nf) => {
          if (!(nf instanceof NoFilter)) {
            throw new TypeError("list argument must be an Array of NoFilters");
          }
          return tot + nf.length;
        }, 0);
      }
      let allBufs = true;
      let allObjs = true;
      const bufs = list.map((nf) => {
        if (!(nf instanceof NoFilter)) {
          throw new TypeError("list argument must be an Array of NoFilters");
        }
        const buf = nf.slice();
        if (Buffer.isBuffer(buf)) {
          allObjs = false;
        } else {
          allBufs = false;
        }
        return buf;
      });
      if (allBufs) {
        return Buffer.concat(bufs, length);
      }
      if (allObjs) {
        return [].concat(...bufs).slice(0, length);
      }
      throw new Error("Concatenating mixed object and byte streams not supported");
    }
    _transform(chunk, encoding, callback) {
      if (!this._readableState.objectMode && !Buffer.isBuffer(chunk)) {
        chunk = Buffer.from(chunk, encoding);
      }
      this.push(chunk);
      callback();
    }
    _bufArray() {
      let bufs = this._readableState.buffer;
      if (!Array.isArray(bufs)) {
        let b = bufs.head;
        bufs = [];
        while (b != null) {
          bufs.push(b.data);
          b = b.next;
        }
      }
      return bufs;
    }
    read(size) {
      const buf = super.read(size);
      if (buf != null) {
        this.emit("read", buf);
        if (this.readError && buf.length < size) {
          throw new Error(`Read ${buf.length}, wanted ${size}`);
        }
      } else if (this.readError) {
        throw new Error(`No data available, wanted ${size}`);
      }
      return buf;
    }
    promise(cb) {
      let done = false;
      return new Promise((resolve, reject) => {
        this.on("finish", () => {
          const data = this.read();
          if (cb != null && !done) {
            done = true;
            cb(null, data);
          }
          resolve(data);
        });
        this.on("error", (er) => {
          if (cb != null && !done) {
            done = true;
            cb(er);
          }
          reject(er);
        });
      });
    }
    compare(other) {
      if (!(other instanceof NoFilter)) {
        throw new TypeError("Arguments must be NoFilters");
      }
      if (this === other) {
        return 0;
      } else {
        const buf1 = this.slice();
        const buf2 = other.slice();
        if (Buffer.isBuffer(buf1) && Buffer.isBuffer(buf2)) {
          return buf1.compare(buf2);
        }
        throw new Error("Cannot compare streams in object mode");
      }
    }
    equals(other) {
      return this.compare(other) === 0;
    }
    slice(start, end) {
      if (this._readableState.objectMode) {
        return this._bufArray().slice(start, end);
      }
      const bufs = this._bufArray();
      switch (bufs.length) {
        case 0:
          return Buffer.alloc(0);
        case 1:
          return bufs[0].slice(start, end);
        default:
          const b = Buffer.concat(bufs);
          return b.slice(start, end);
      }
    }
    get(index) {
      return this.slice()[index];
    }
    toJSON() {
      const b = this.slice();
      if (Buffer.isBuffer(b)) {
        return b.toJSON();
      } else {
        return b;
      }
    }
    toString(encoding, start, end) {
      const buf = this.slice(start, end);
      if (!Buffer.isBuffer(buf)) {
        return JSON.stringify(buf);
      }
      if ((!encoding || encoding === "utf8") && util.TextDecoder) {
        const td = new util.TextDecoder("utf8", {
          fatal: true,
          ignoreBOM: true
        });
        return td.decode(buf);
      }
      return buf.toString(encoding, start, end);
    }
    inspect(depth, options) {
      return this[util.inspect.custom](depth, options);
    }
    [util.inspect.custom](depth, options) {
      const bufs = this._bufArray();
      const hex = bufs.map((b) => {
        if (Buffer.isBuffer(b)) {
          if (options != null ? options.stylize : void 0) {
            return options.stylize(b.toString("hex"), "string");
          } else {
            return b.toString("hex");
          }
        } else {
          return util.inspect(b, options);
        }
      }).join(", ");
      return `${this.constructor.name} [${hex}]`;
    }
    get length() {
      return this._readableState.length;
    }
    writeBigInt(val) {
      let str = val.toString(16);
      if (val < 0) {
        const sz = BigInt(Math.floor(str.length / 2));
        const mask = BigInt(1) << sz * BigInt(8);
        val = mask + val;
        str = val.toString(16);
      }
      if (str.length % 2) {
        str = "0" + str;
      }
      return this.push(Buffer.from(str, "hex"));
    }
    readUBigInt(len) {
      const b = this.read(len);
      if (!Buffer.isBuffer(b)) {
        return null;
      }
      return BigInt("0x" + b.toString("hex"));
    }
    readBigInt(len) {
      const b = this.read(len);
      if (!Buffer.isBuffer(b)) {
        return null;
      }
      let ret = BigInt("0x" + b.toString("hex"));
      if (b[0] & 128) {
        const mask = BigInt(1) << BigInt(b.length) * BigInt(8);
        ret = ret - mask;
      }
      return ret;
    }
  };
  function _read_gen(meth, len) {
    return function(val) {
      const b = this.read(len);
      if (!Buffer.isBuffer(b)) {
        return null;
      }
      return b[meth].call(b, 0, true);
    };
  }
  function _write_gen(meth, len) {
    return function(val) {
      const b = Buffer.alloc(len);
      b[meth].call(b, val, 0, true);
      return this.push(b);
    };
  }
  Object.assign(NoFilter.prototype, {
    writeUInt8: _write_gen("writeUInt8", 1),
    writeUInt16LE: _write_gen("writeUInt16LE", 2),
    writeUInt16BE: _write_gen("writeUInt16BE", 2),
    writeUInt32LE: _write_gen("writeUInt32LE", 4),
    writeUInt32BE: _write_gen("writeUInt32BE", 4),
    writeInt8: _write_gen("writeInt8", 1),
    writeInt16LE: _write_gen("writeInt16LE", 2),
    writeInt16BE: _write_gen("writeInt16BE", 2),
    writeInt32LE: _write_gen("writeInt32LE", 4),
    writeInt32BE: _write_gen("writeInt32BE", 4),
    writeFloatLE: _write_gen("writeFloatLE", 4),
    writeFloatBE: _write_gen("writeFloatBE", 4),
    writeDoubleLE: _write_gen("writeDoubleLE", 8),
    writeDoubleBE: _write_gen("writeDoubleBE", 8),
    readUInt8: _read_gen("readUInt8", 1),
    readUInt16LE: _read_gen("readUInt16LE", 2),
    readUInt16BE: _read_gen("readUInt16BE", 2),
    readUInt32LE: _read_gen("readUInt32LE", 4),
    readUInt32BE: _read_gen("readUInt32BE", 4),
    readInt8: _read_gen("readInt8", 1),
    readInt16LE: _read_gen("readInt16LE", 2),
    readInt16BE: _read_gen("readInt16BE", 2),
    readInt32LE: _read_gen("readInt32LE", 4),
    readInt32BE: _read_gen("readInt32BE", 4),
    readFloatLE: _read_gen("readFloatLE", 4),
    readFloatBE: _read_gen("readFloatBE", 4),
    readDoubleLE: _read_gen("readDoubleLE", 8),
    readDoubleBE: _read_gen("readDoubleBE", 8)
  });
  module2.exports = NoFilter;
});

// node_modules/cbor/lib/utils.js
var require_utils9 = __commonJS((exports2) => {
  "use strict";
  var NoFilter = require_lib2();
  var stream = require_stream_browserify();
  var util = require_util10();
  var {BigNumber, NUMBYTES, SHIFT32, BI, SYMS} = require_constants5();
  var MAX_SAFE_HIGH = 2097151;
  var TD = typeof TextDecoder === "function" ? TextDecoder : util.TextDecoder;
  var td = new TD("utf8", {fatal: true, ignoreBOM: true});
  exports2.utf8 = (buf) => td.decode(buf);
  exports2.utf8.checksUTF8 = true;
  exports2.parseCBORint = function(ai, buf, bigInt = true) {
    switch (ai) {
      case NUMBYTES.ONE:
        return buf.readUInt8(0);
      case NUMBYTES.TWO:
        return buf.readUInt16BE(0);
      case NUMBYTES.FOUR:
        return buf.readUInt32BE(0);
      case NUMBYTES.EIGHT:
        const f = buf.readUInt32BE(0);
        const g = buf.readUInt32BE(4);
        if (f > MAX_SAFE_HIGH) {
          if (bigInt) {
            return BigInt(f) * BI.SHIFT32 + BigInt(g);
          }
          return new BigNumber(f).times(SHIFT32).plus(g);
        } else {
          return f * SHIFT32 + g;
        }
      default:
        throw new Error("Invalid additional info for int: " + ai);
    }
  };
  exports2.writeHalf = function writeHalf(buf, half) {
    const u32 = Buffer.allocUnsafe(4);
    u32.writeFloatBE(half, 0);
    const u = u32.readUInt32BE(0);
    if ((u & 8191) !== 0) {
      return false;
    }
    let s16 = u >> 16 & 32768;
    const exp = u >> 23 & 255;
    const mant = u & 8388607;
    if (exp >= 113 && exp <= 142) {
      s16 += (exp - 112 << 10) + (mant >> 13);
    } else if (exp >= 103 && exp < 113) {
      if (mant & (1 << 126 - exp) - 1) {
        return false;
      }
      s16 += mant + 8388608 >> 126 - exp;
    } else {
      return false;
    }
    buf.writeUInt16BE(s16);
    return true;
  };
  exports2.parseHalf = function parseHalf(buf) {
    const sign = buf[0] & 128 ? -1 : 1;
    const exp = (buf[0] & 124) >> 2;
    const mant = (buf[0] & 3) << 8 | buf[1];
    if (!exp) {
      return sign * 5960464477539063e-23 * mant;
    } else if (exp === 31) {
      return sign * (mant ? 0 / 0 : Infinity);
    } else {
      return sign * Math.pow(2, exp - 25) * (1024 + mant);
    }
  };
  exports2.parseCBORfloat = function parseCBORfloat(buf) {
    switch (buf.length) {
      case 2:
        return exports2.parseHalf(buf);
      case 4:
        return buf.readFloatBE(0);
      case 8:
        return buf.readDoubleBE(0);
      default:
        throw new Error("Invalid float size: " + buf.length);
    }
  };
  exports2.hex = function hex(s) {
    return Buffer.from(s.replace(/^0x/, ""), "hex");
  };
  exports2.bin = function bin(s) {
    s = s.replace(/\s/g, "");
    let start = 0;
    let end = s.length % 8 || 8;
    const chunks = [];
    while (end <= s.length) {
      chunks.push(parseInt(s.slice(start, end), 2));
      start = end;
      end += 8;
    }
    return Buffer.from(chunks);
  };
  exports2.arrayEqual = function arrayEqual(a, b) {
    if (a == null && b == null) {
      return true;
    }
    if (a == null || b == null) {
      return false;
    }
    return a.length === b.length && a.every((elem, i) => elem === b[i]);
  };
  exports2.bufferEqual = function bufferEqual(a, b) {
    if (a == null && b == null) {
      return true;
    }
    if (a == null || b == null) {
      return false;
    }
    if (!(Buffer.isBuffer(a) && Buffer.isBuffer(b) && a.length === b.length)) {
      return false;
    }
    const len = a.length;
    let ret = true;
    let i;
    let j;
    for (i = j = 0; j < len; i = ++j) {
      const byte = a[i];
      ret = ret && b[i] === byte;
    }
    return !!ret;
  };
  exports2.bufferToBignumber = function bufferToBignumber(buf) {
    return new BigNumber(buf.toString("hex"), 16);
  };
  exports2.bufferToBigInt = function bufferToBigInt(buf) {
    return BigInt("0x" + buf.toString("hex"));
  };
  exports2.cborValueToString = function cborValueToString(val, float_bytes = -1) {
    switch (typeof val) {
      case "symbol":
        switch (val) {
          case SYMS.NULL:
            return "null";
          case SYMS.UNDEFINED:
            return "undefined";
          case SYMS.BREAK:
            return "BREAK";
        }
        if (val.description) {
          return val.description;
        }
        const s = val.toString();
        const m = s.match(/^Symbol\((.*)\)/);
        if (m && m[1]) {
          return m[1];
        }
        return "Symbol";
      case "string":
        return JSON.stringify(val);
      case "bigint":
        return val.toString();
      case "number":
        if (float_bytes > 0) {
          return util.inspect(val) + "_" + float_bytes;
        }
        return util.inspect(val);
    }
    if (Buffer.isBuffer(val)) {
      const hex = val.toString("hex");
      return float_bytes === -Infinity ? hex : `h'${hex}'`;
    }
    if (BigNumber.isBigNumber(val)) {
      return val.toString();
    }
    return util.inspect(val);
  };
  exports2.guessEncoding = function guessEncoding(input, encoding) {
    if (typeof input == "string") {
      return new NoFilter(input, encoding != null ? encoding : "hex");
    } else if (Buffer.isBuffer(input)) {
      return new NoFilter(input);
    } else if (ArrayBuffer.isView(input)) {
      return new NoFilter(Buffer.from(input.buffer, input.byteOffset, input.byteLength));
    } else if (input instanceof ArrayBuffer) {
      return new NoFilter(Buffer.from(input));
    } else if (input instanceof stream.Readable) {
      return input;
    }
    throw new Error("Unknown input type");
  };
});

// node_modules/cbor/lib/simple.js
var require_simple2 = __commonJS((exports2, module2) => {
  "use strict";
  var util = require_util10();
  var constants = require_constants5();
  var MT = constants.MT;
  var SIMPLE = constants.SIMPLE;
  var SYMS = constants.SYMS;
  var Simple = class {
    constructor(value) {
      if (typeof value !== "number") {
        throw new Error("Invalid Simple type: " + typeof value);
      }
      if (value < 0 || value > 255 || (value | 0) !== value) {
        throw new Error("value must be a small positive integer: " + value);
      }
      this.value = value;
    }
    toString() {
      return "simple(" + this.value + ")";
    }
    [util.inspect.custom](depth, opts) {
      return "simple(" + this.value + ")";
    }
    inspect(depth, opts) {
      return "simple(" + this.value + ")";
    }
    encodeCBOR(gen) {
      return gen._pushInt(this.value, MT.SIMPLE_FLOAT);
    }
    static isSimple(obj) {
      return obj instanceof Simple;
    }
    static decode(val, has_parent = true, parent_indefinite = false) {
      switch (val) {
        case SIMPLE.FALSE:
          return false;
        case SIMPLE.TRUE:
          return true;
        case SIMPLE.NULL:
          if (has_parent) {
            return null;
          } else {
            return SYMS.NULL;
          }
        case SIMPLE.UNDEFINED:
          if (has_parent) {
            return void 0;
          } else {
            return SYMS.UNDEFINED;
          }
        case -1:
          if (!has_parent || !parent_indefinite) {
            throw new Error("Invalid BREAK");
          }
          return SYMS.BREAK;
        default:
          return new Simple(val);
      }
    }
  };
  module2.exports = Simple;
});

// node_modules/cbor/vendor/binary-parse-stream/index.js
var require_binary_parse_stream = __commonJS((exports2, module2) => {
  "use strict";
  var Stream = require_stream_browserify();
  var NoFilter = require_lib2();
  var TransformStream = Stream.Transform;
  var BinaryParseStream = class extends TransformStream {
    constructor(options) {
      super(options);
      this["_writableState"].objectMode = false;
      this["_readableState"].objectMode = true;
      this.bs = new NoFilter();
      this.__restart();
    }
    _transform(fresh, encoding, cb) {
      this.bs.write(fresh);
      while (this.bs.length >= this.__needed) {
        let ret;
        const chunk = this.__needed === null ? void 0 : this.bs.read(this.__needed);
        try {
          ret = this.__parser.next(chunk);
        } catch (e) {
          return cb(e);
        }
        if (this.__needed) {
          this.__fresh = false;
        }
        if (!ret.done) {
          this.__needed = ret.value || Infinity;
        } else {
          this.push(ret.value);
          this.__restart();
        }
      }
      return cb();
    }
    *_parse() {
      throw new Error("Must be implemented in subclass");
    }
    __restart() {
      this.__needed = null;
      this.__parser = this._parse();
      this.__fresh = true;
    }
    _flush(cb) {
      cb(this.__fresh ? null : new Error("unexpected end of input"));
    }
  };
  module2.exports = BinaryParseStream;
});

// node_modules/url/node_modules/punycode/punycode.js
var require_punycode = __commonJS((exports2, module2) => {
  /*! https://mths.be/punycode v1.3.2 by @mathias */
  (function(root) {
    var freeExports = typeof exports2 == "object" && exports2 && !exports2.nodeType && exports2;
    var freeModule = typeof module2 == "object" && module2 && !module2.nodeType && module2;
    var freeGlobal = typeof global == "object" && global;
    if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal || freeGlobal.self === freeGlobal) {
      root = freeGlobal;
    }
    var punycode, maxInt = 2147483647, base = 36, tMin = 1, tMax = 26, skew = 38, damp = 700, initialBias = 72, initialN = 128, delimiter = "-", regexPunycode = /^xn--/, regexNonASCII = /[^\x20-\x7E]/, regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, errors = {
      overflow: "Overflow: input needs wider integers to process",
      "not-basic": "Illegal input >= 0x80 (not a basic code point)",
      "invalid-input": "Invalid input"
    }, baseMinusTMin = base - tMin, floor = Math.floor, stringFromCharCode = String.fromCharCode, key;
    function error(type) {
      throw RangeError(errors[type]);
    }
    function map(array, fn) {
      var length = array.length;
      var result = [];
      while (length--) {
        result[length] = fn(array[length]);
      }
      return result;
    }
    function mapDomain(string, fn) {
      var parts = string.split("@");
      var result = "";
      if (parts.length > 1) {
        result = parts[0] + "@";
        string = parts[1];
      }
      string = string.replace(regexSeparators, ".");
      var labels = string.split(".");
      var encoded = map(labels, fn).join(".");
      return result + encoded;
    }
    function ucs2decode(string) {
      var output = [], counter = 0, length = string.length, value, extra;
      while (counter < length) {
        value = string.charCodeAt(counter++);
        if (value >= 55296 && value <= 56319 && counter < length) {
          extra = string.charCodeAt(counter++);
          if ((extra & 64512) == 56320) {
            output.push(((value & 1023) << 10) + (extra & 1023) + 65536);
          } else {
            output.push(value);
            counter--;
          }
        } else {
          output.push(value);
        }
      }
      return output;
    }
    function ucs2encode(array) {
      return map(array, function(value) {
        var output = "";
        if (value > 65535) {
          value -= 65536;
          output += stringFromCharCode(value >>> 10 & 1023 | 55296);
          value = 56320 | value & 1023;
        }
        output += stringFromCharCode(value);
        return output;
      }).join("");
    }
    function basicToDigit(codePoint) {
      if (codePoint - 48 < 10) {
        return codePoint - 22;
      }
      if (codePoint - 65 < 26) {
        return codePoint - 65;
      }
      if (codePoint - 97 < 26) {
        return codePoint - 97;
      }
      return base;
    }
    function digitToBasic(digit, flag) {
      return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
    }
    function adapt(delta, numPoints, firstTime) {
      var k = 0;
      delta = firstTime ? floor(delta / damp) : delta >> 1;
      delta += floor(delta / numPoints);
      for (; delta > baseMinusTMin * tMax >> 1; k += base) {
        delta = floor(delta / baseMinusTMin);
      }
      return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
    }
    function decode(input) {
      var output = [], inputLength = input.length, out, i = 0, n = initialN, bias = initialBias, basic, j, index, oldi, w, k, digit, t, baseMinusT;
      basic = input.lastIndexOf(delimiter);
      if (basic < 0) {
        basic = 0;
      }
      for (j = 0; j < basic; ++j) {
        if (input.charCodeAt(j) >= 128) {
          error("not-basic");
        }
        output.push(input.charCodeAt(j));
      }
      for (index = basic > 0 ? basic + 1 : 0; index < inputLength; ) {
        for (oldi = i, w = 1, k = base; ; k += base) {
          if (index >= inputLength) {
            error("invalid-input");
          }
          digit = basicToDigit(input.charCodeAt(index++));
          if (digit >= base || digit > floor((maxInt - i) / w)) {
            error("overflow");
          }
          i += digit * w;
          t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
          if (digit < t) {
            break;
          }
          baseMinusT = base - t;
          if (w > floor(maxInt / baseMinusT)) {
            error("overflow");
          }
          w *= baseMinusT;
        }
        out = output.length + 1;
        bias = adapt(i - oldi, out, oldi == 0);
        if (floor(i / out) > maxInt - n) {
          error("overflow");
        }
        n += floor(i / out);
        i %= out;
        output.splice(i++, 0, n);
      }
      return ucs2encode(output);
    }
    function encode(input) {
      var n, delta, handledCPCount, basicLength, bias, j, m, q, k, t, currentValue, output = [], inputLength, handledCPCountPlusOne, baseMinusT, qMinusT;
      input = ucs2decode(input);
      inputLength = input.length;
      n = initialN;
      delta = 0;
      bias = initialBias;
      for (j = 0; j < inputLength; ++j) {
        currentValue = input[j];
        if (currentValue < 128) {
          output.push(stringFromCharCode(currentValue));
        }
      }
      handledCPCount = basicLength = output.length;
      if (basicLength) {
        output.push(delimiter);
      }
      while (handledCPCount < inputLength) {
        for (m = maxInt, j = 0; j < inputLength; ++j) {
          currentValue = input[j];
          if (currentValue >= n && currentValue < m) {
            m = currentValue;
          }
        }
        handledCPCountPlusOne = handledCPCount + 1;
        if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
          error("overflow");
        }
        delta += (m - n) * handledCPCountPlusOne;
        n = m;
        for (j = 0; j < inputLength; ++j) {
          currentValue = input[j];
          if (currentValue < n && ++delta > maxInt) {
            error("overflow");
          }
          if (currentValue == n) {
            for (q = delta, k = base; ; k += base) {
              t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
              if (q < t) {
                break;
              }
              qMinusT = q - t;
              baseMinusT = base - t;
              output.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0)));
              q = floor(qMinusT / baseMinusT);
            }
            output.push(stringFromCharCode(digitToBasic(q, 0)));
            bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
            delta = 0;
            ++handledCPCount;
          }
        }
        ++delta;
        ++n;
      }
      return output.join("");
    }
    function toUnicode(input) {
      return mapDomain(input, function(string) {
        return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;
      });
    }
    function toASCII(input) {
      return mapDomain(input, function(string) {
        return regexNonASCII.test(string) ? "xn--" + encode(string) : string;
      });
    }
    punycode = {
      version: "1.3.2",
      ucs2: {
        decode: ucs2decode,
        encode: ucs2encode
      },
      decode,
      encode,
      toASCII,
      toUnicode
    };
    if (typeof define == "function" && typeof define.amd == "object" && define.amd) {
      define("punycode", function() {
        return punycode;
      });
    } else if (freeExports && freeModule) {
      if (module2.exports == freeExports) {
        freeModule.exports = punycode;
      } else {
        for (key in punycode) {
          punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);
        }
      }
    } else {
      root.punycode = punycode;
    }
  })(exports2);
});

// node_modules/url/util.js
var require_util11 = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = {
    isString: function(arg) {
      return typeof arg === "string";
    },
    isObject: function(arg) {
      return typeof arg === "object" && arg !== null;
    },
    isNull: function(arg) {
      return arg === null;
    },
    isNullOrUndefined: function(arg) {
      return arg == null;
    }
  };
});

// node_modules/querystring/decode.js
var require_decode5 = __commonJS((exports2, module2) => {
  "use strict";
  function hasOwnProperty(obj, prop) {
    return Object.prototype.hasOwnProperty.call(obj, prop);
  }
  module2.exports = function(qs, sep, eq, options) {
    sep = sep || "&";
    eq = eq || "=";
    var obj = {};
    if (typeof qs !== "string" || qs.length === 0) {
      return obj;
    }
    var regexp = /\+/g;
    qs = qs.split(sep);
    var maxKeys = 1e3;
    if (options && typeof options.maxKeys === "number") {
      maxKeys = options.maxKeys;
    }
    var len = qs.length;
    if (maxKeys > 0 && len > maxKeys) {
      len = maxKeys;
    }
    for (var i = 0; i < len; ++i) {
      var x = qs[i].replace(regexp, "%20"), idx = x.indexOf(eq), kstr, vstr, k, v;
      if (idx >= 0) {
        kstr = x.substr(0, idx);
        vstr = x.substr(idx + 1);
      } else {
        kstr = x;
        vstr = "";
      }
      k = decodeURIComponent(kstr);
      v = decodeURIComponent(vstr);
      if (!hasOwnProperty(obj, k)) {
        obj[k] = v;
      } else if (Array.isArray(obj[k])) {
        obj[k].push(v);
      } else {
        obj[k] = [obj[k], v];
      }
    }
    return obj;
  };
});

// node_modules/querystring/encode.js
var require_encode5 = __commonJS((exports2, module2) => {
  "use strict";
  var stringifyPrimitive = function(v) {
    switch (typeof v) {
      case "string":
        return v;
      case "boolean":
        return v ? "true" : "false";
      case "number":
        return isFinite(v) ? v : "";
      default:
        return "";
    }
  };
  module2.exports = function(obj, sep, eq, name) {
    sep = sep || "&";
    eq = eq || "=";
    if (obj === null) {
      obj = void 0;
    }
    if (typeof obj === "object") {
      return Object.keys(obj).map(function(k) {
        var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
        if (Array.isArray(obj[k])) {
          return obj[k].map(function(v) {
            return ks + encodeURIComponent(stringifyPrimitive(v));
          }).join(sep);
        } else {
          return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
        }
      }).join(sep);
    }
    if (!name)
      return "";
    return encodeURIComponent(stringifyPrimitive(name)) + eq + encodeURIComponent(stringifyPrimitive(obj));
  };
});

// node_modules/querystring/index.js
var require_querystring = __commonJS((exports2) => {
  "use strict";
  exports2.decode = exports2.parse = require_decode5();
  exports2.encode = exports2.stringify = require_encode5();
});

// node_modules/url/url.js
var require_url = __commonJS((exports2) => {
  "use strict";
  var punycode = require_punycode();
  var util = require_util11();
  exports2.parse = urlParse;
  exports2.resolve = urlResolve;
  exports2.resolveObject = urlResolveObject;
  exports2.format = urlFormat;
  exports2.Url = Url;
  function Url() {
    this.protocol = null;
    this.slashes = null;
    this.auth = null;
    this.host = null;
    this.port = null;
    this.hostname = null;
    this.hash = null;
    this.search = null;
    this.query = null;
    this.pathname = null;
    this.path = null;
    this.href = null;
  }
  var protocolPattern = /^([a-z0-9.+-]+:)/i;
  var portPattern = /:[0-9]*$/;
  var simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/;
  var delims = ["<", ">", '"', "`", " ", "\r", "\n", "	"];
  var unwise = ["{", "}", "|", "\\", "^", "`"].concat(delims);
  var autoEscape = ["'"].concat(unwise);
  var nonHostChars = ["%", "/", "?", ";", "#"].concat(autoEscape);
  var hostEndingChars = ["/", "?", "#"];
  var hostnameMaxLen = 255;
  var hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/;
  var hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/;
  var unsafeProtocol = {
    javascript: true,
    "javascript:": true
  };
  var hostlessProtocol = {
    javascript: true,
    "javascript:": true
  };
  var slashedProtocol = {
    http: true,
    https: true,
    ftp: true,
    gopher: true,
    file: true,
    "http:": true,
    "https:": true,
    "ftp:": true,
    "gopher:": true,
    "file:": true
  };
  var querystring = require_querystring();
  function urlParse(url, parseQueryString, slashesDenoteHost) {
    if (url && util.isObject(url) && url instanceof Url)
      return url;
    var u = new Url();
    u.parse(url, parseQueryString, slashesDenoteHost);
    return u;
  }
  Url.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {
    if (!util.isString(url)) {
      throw new TypeError("Parameter 'url' must be a string, not " + typeof url);
    }
    var queryIndex = url.indexOf("?"), splitter = queryIndex !== -1 && queryIndex < url.indexOf("#") ? "?" : "#", uSplit = url.split(splitter), slashRegex = /\\/g;
    uSplit[0] = uSplit[0].replace(slashRegex, "/");
    url = uSplit.join(splitter);
    var rest = url;
    rest = rest.trim();
    if (!slashesDenoteHost && url.split("#").length === 1) {
      var simplePath = simplePathPattern.exec(rest);
      if (simplePath) {
        this.path = rest;
        this.href = rest;
        this.pathname = simplePath[1];
        if (simplePath[2]) {
          this.search = simplePath[2];
          if (parseQueryString) {
            this.query = querystring.parse(this.search.substr(1));
          } else {
            this.query = this.search.substr(1);
          }
        } else if (parseQueryString) {
          this.search = "";
          this.query = {};
        }
        return this;
      }
    }
    var proto = protocolPattern.exec(rest);
    if (proto) {
      proto = proto[0];
      var lowerProto = proto.toLowerCase();
      this.protocol = lowerProto;
      rest = rest.substr(proto.length);
    }
    if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
      var slashes = rest.substr(0, 2) === "//";
      if (slashes && !(proto && hostlessProtocol[proto])) {
        rest = rest.substr(2);
        this.slashes = true;
      }
    }
    if (!hostlessProtocol[proto] && (slashes || proto && !slashedProtocol[proto])) {
      var hostEnd = -1;
      for (var i = 0; i < hostEndingChars.length; i++) {
        var hec = rest.indexOf(hostEndingChars[i]);
        if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
          hostEnd = hec;
      }
      var auth, atSign;
      if (hostEnd === -1) {
        atSign = rest.lastIndexOf("@");
      } else {
        atSign = rest.lastIndexOf("@", hostEnd);
      }
      if (atSign !== -1) {
        auth = rest.slice(0, atSign);
        rest = rest.slice(atSign + 1);
        this.auth = decodeURIComponent(auth);
      }
      hostEnd = -1;
      for (var i = 0; i < nonHostChars.length; i++) {
        var hec = rest.indexOf(nonHostChars[i]);
        if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
          hostEnd = hec;
      }
      if (hostEnd === -1)
        hostEnd = rest.length;
      this.host = rest.slice(0, hostEnd);
      rest = rest.slice(hostEnd);
      this.parseHost();
      this.hostname = this.hostname || "";
      var ipv6Hostname = this.hostname[0] === "[" && this.hostname[this.hostname.length - 1] === "]";
      if (!ipv6Hostname) {
        var hostparts = this.hostname.split(/\./);
        for (var i = 0, l = hostparts.length; i < l; i++) {
          var part = hostparts[i];
          if (!part)
            continue;
          if (!part.match(hostnamePartPattern)) {
            var newpart = "";
            for (var j = 0, k = part.length; j < k; j++) {
              if (part.charCodeAt(j) > 127) {
                newpart += "x";
              } else {
                newpart += part[j];
              }
            }
            if (!newpart.match(hostnamePartPattern)) {
              var validParts = hostparts.slice(0, i);
              var notHost = hostparts.slice(i + 1);
              var bit = part.match(hostnamePartStart);
              if (bit) {
                validParts.push(bit[1]);
                notHost.unshift(bit[2]);
              }
              if (notHost.length) {
                rest = "/" + notHost.join(".") + rest;
              }
              this.hostname = validParts.join(".");
              break;
            }
          }
        }
      }
      if (this.hostname.length > hostnameMaxLen) {
        this.hostname = "";
      } else {
        this.hostname = this.hostname.toLowerCase();
      }
      if (!ipv6Hostname) {
        this.hostname = punycode.toASCII(this.hostname);
      }
      var p = this.port ? ":" + this.port : "";
      var h = this.hostname || "";
      this.host = h + p;
      this.href += this.host;
      if (ipv6Hostname) {
        this.hostname = this.hostname.substr(1, this.hostname.length - 2);
        if (rest[0] !== "/") {
          rest = "/" + rest;
        }
      }
    }
    if (!unsafeProtocol[lowerProto]) {
      for (var i = 0, l = autoEscape.length; i < l; i++) {
        var ae = autoEscape[i];
        if (rest.indexOf(ae) === -1)
          continue;
        var esc = encodeURIComponent(ae);
        if (esc === ae) {
          esc = escape(ae);
        }
        rest = rest.split(ae).join(esc);
      }
    }
    var hash = rest.indexOf("#");
    if (hash !== -1) {
      this.hash = rest.substr(hash);
      rest = rest.slice(0, hash);
    }
    var qm = rest.indexOf("?");
    if (qm !== -1) {
      this.search = rest.substr(qm);
      this.query = rest.substr(qm + 1);
      if (parseQueryString) {
        this.query = querystring.parse(this.query);
      }
      rest = rest.slice(0, qm);
    } else if (parseQueryString) {
      this.search = "";
      this.query = {};
    }
    if (rest)
      this.pathname = rest;
    if (slashedProtocol[lowerProto] && this.hostname && !this.pathname) {
      this.pathname = "/";
    }
    if (this.pathname || this.search) {
      var p = this.pathname || "";
      var s = this.search || "";
      this.path = p + s;
    }
    this.href = this.format();
    return this;
  };
  function urlFormat(obj) {
    if (util.isString(obj))
      obj = urlParse(obj);
    if (!(obj instanceof Url))
      return Url.prototype.format.call(obj);
    return obj.format();
  }
  Url.prototype.format = function() {
    var auth = this.auth || "";
    if (auth) {
      auth = encodeURIComponent(auth);
      auth = auth.replace(/%3A/i, ":");
      auth += "@";
    }
    var protocol = this.protocol || "", pathname = this.pathname || "", hash = this.hash || "", host = false, query = "";
    if (this.host) {
      host = auth + this.host;
    } else if (this.hostname) {
      host = auth + (this.hostname.indexOf(":") === -1 ? this.hostname : "[" + this.hostname + "]");
      if (this.port) {
        host += ":" + this.port;
      }
    }
    if (this.query && util.isObject(this.query) && Object.keys(this.query).length) {
      query = querystring.stringify(this.query);
    }
    var search = this.search || query && "?" + query || "";
    if (protocol && protocol.substr(-1) !== ":")
      protocol += ":";
    if (this.slashes || (!protocol || slashedProtocol[protocol]) && host !== false) {
      host = "//" + (host || "");
      if (pathname && pathname.charAt(0) !== "/")
        pathname = "/" + pathname;
    } else if (!host) {
      host = "";
    }
    if (hash && hash.charAt(0) !== "#")
      hash = "#" + hash;
    if (search && search.charAt(0) !== "?")
      search = "?" + search;
    pathname = pathname.replace(/[?#]/g, function(match) {
      return encodeURIComponent(match);
    });
    search = search.replace("#", "%23");
    return protocol + host + pathname + search + hash;
  };
  function urlResolve(source, relative) {
    return urlParse(source, false, true).resolve(relative);
  }
  Url.prototype.resolve = function(relative) {
    return this.resolveObject(urlParse(relative, false, true)).format();
  };
  function urlResolveObject(source, relative) {
    if (!source)
      return relative;
    return urlParse(source, false, true).resolveObject(relative);
  }
  Url.prototype.resolveObject = function(relative) {
    if (util.isString(relative)) {
      var rel = new Url();
      rel.parse(relative, false, true);
      relative = rel;
    }
    var result = new Url();
    var tkeys = Object.keys(this);
    for (var tk = 0; tk < tkeys.length; tk++) {
      var tkey = tkeys[tk];
      result[tkey] = this[tkey];
    }
    result.hash = relative.hash;
    if (relative.href === "") {
      result.href = result.format();
      return result;
    }
    if (relative.slashes && !relative.protocol) {
      var rkeys = Object.keys(relative);
      for (var rk = 0; rk < rkeys.length; rk++) {
        var rkey = rkeys[rk];
        if (rkey !== "protocol")
          result[rkey] = relative[rkey];
      }
      if (slashedProtocol[result.protocol] && result.hostname && !result.pathname) {
        result.path = result.pathname = "/";
      }
      result.href = result.format();
      return result;
    }
    if (relative.protocol && relative.protocol !== result.protocol) {
      if (!slashedProtocol[relative.protocol]) {
        var keys = Object.keys(relative);
        for (var v = 0; v < keys.length; v++) {
          var k = keys[v];
          result[k] = relative[k];
        }
        result.href = result.format();
        return result;
      }
      result.protocol = relative.protocol;
      if (!relative.host && !hostlessProtocol[relative.protocol]) {
        var relPath = (relative.pathname || "").split("/");
        while (relPath.length && !(relative.host = relPath.shift()))
          ;
        if (!relative.host)
          relative.host = "";
        if (!relative.hostname)
          relative.hostname = "";
        if (relPath[0] !== "")
          relPath.unshift("");
        if (relPath.length < 2)
          relPath.unshift("");
        result.pathname = relPath.join("/");
      } else {
        result.pathname = relative.pathname;
      }
      result.search = relative.search;
      result.query = relative.query;
      result.host = relative.host || "";
      result.auth = relative.auth;
      result.hostname = relative.hostname || relative.host;
      result.port = relative.port;
      if (result.pathname || result.search) {
        var p = result.pathname || "";
        var s = result.search || "";
        result.path = p + s;
      }
      result.slashes = result.slashes || relative.slashes;
      result.href = result.format();
      return result;
    }
    var isSourceAbs = result.pathname && result.pathname.charAt(0) === "/", isRelAbs = relative.host || relative.pathname && relative.pathname.charAt(0) === "/", mustEndAbs = isRelAbs || isSourceAbs || result.host && relative.pathname, removeAllDots = mustEndAbs, srcPath = result.pathname && result.pathname.split("/") || [], relPath = relative.pathname && relative.pathname.split("/") || [], psychotic = result.protocol && !slashedProtocol[result.protocol];
    if (psychotic) {
      result.hostname = "";
      result.port = null;
      if (result.host) {
        if (srcPath[0] === "")
          srcPath[0] = result.host;
        else
          srcPath.unshift(result.host);
      }
      result.host = "";
      if (relative.protocol) {
        relative.hostname = null;
        relative.port = null;
        if (relative.host) {
          if (relPath[0] === "")
            relPath[0] = relative.host;
          else
            relPath.unshift(relative.host);
        }
        relative.host = null;
      }
      mustEndAbs = mustEndAbs && (relPath[0] === "" || srcPath[0] === "");
    }
    if (isRelAbs) {
      result.host = relative.host || relative.host === "" ? relative.host : result.host;
      result.hostname = relative.hostname || relative.hostname === "" ? relative.hostname : result.hostname;
      result.search = relative.search;
      result.query = relative.query;
      srcPath = relPath;
    } else if (relPath.length) {
      if (!srcPath)
        srcPath = [];
      srcPath.pop();
      srcPath = srcPath.concat(relPath);
      result.search = relative.search;
      result.query = relative.query;
    } else if (!util.isNullOrUndefined(relative.search)) {
      if (psychotic) {
        result.hostname = result.host = srcPath.shift();
        var authInHost = result.host && result.host.indexOf("@") > 0 ? result.host.split("@") : false;
        if (authInHost) {
          result.auth = authInHost.shift();
          result.host = result.hostname = authInHost.shift();
        }
      }
      result.search = relative.search;
      result.query = relative.query;
      if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
        result.path = (result.pathname ? result.pathname : "") + (result.search ? result.search : "");
      }
      result.href = result.format();
      return result;
    }
    if (!srcPath.length) {
      result.pathname = null;
      if (result.search) {
        result.path = "/" + result.search;
      } else {
        result.path = null;
      }
      result.href = result.format();
      return result;
    }
    var last = srcPath.slice(-1)[0];
    var hasTrailingSlash = (result.host || relative.host || srcPath.length > 1) && (last === "." || last === "..") || last === "";
    var up = 0;
    for (var i = srcPath.length; i >= 0; i--) {
      last = srcPath[i];
      if (last === ".") {
        srcPath.splice(i, 1);
      } else if (last === "..") {
        srcPath.splice(i, 1);
        up++;
      } else if (up) {
        srcPath.splice(i, 1);
        up--;
      }
    }
    if (!mustEndAbs && !removeAllDots) {
      for (; up--; up) {
        srcPath.unshift("..");
      }
    }
    if (mustEndAbs && srcPath[0] !== "" && (!srcPath[0] || srcPath[0].charAt(0) !== "/")) {
      srcPath.unshift("");
    }
    if (hasTrailingSlash && srcPath.join("/").substr(-1) !== "/") {
      srcPath.push("");
    }
    var isAbsolute = srcPath[0] === "" || srcPath[0] && srcPath[0].charAt(0) === "/";
    if (psychotic) {
      result.hostname = result.host = isAbsolute ? "" : srcPath.length ? srcPath.shift() : "";
      var authInHost = result.host && result.host.indexOf("@") > 0 ? result.host.split("@") : false;
      if (authInHost) {
        result.auth = authInHost.shift();
        result.host = result.hostname = authInHost.shift();
      }
    }
    mustEndAbs = mustEndAbs || result.host && srcPath.length;
    if (mustEndAbs && !isAbsolute) {
      srcPath.unshift("");
    }
    if (!srcPath.length) {
      result.pathname = null;
      result.path = null;
    } else {
      result.pathname = srcPath.join("/");
    }
    if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
      result.path = (result.pathname ? result.pathname : "") + (result.search ? result.search : "");
    }
    result.auth = relative.auth || result.auth;
    result.slashes = result.slashes || relative.slashes;
    result.href = result.format();
    return result;
  };
  Url.prototype.parseHost = function() {
    var host = this.host;
    var port = portPattern.exec(host);
    if (port) {
      port = port[0];
      if (port !== ":") {
        this.port = port.substr(1);
      }
      host = host.substr(0, host.length - port.length);
    }
    if (host)
      this.hostname = host;
  };
});

// node_modules/cbor/lib/tagged.js
var require_tagged2 = __commonJS((exports2, module2) => {
  "use strict";
  var url = require_url();
  var {BigNumber, BN} = require_constants5();
  var utils = require_utils9();
  var Tagged = class {
    constructor(tag, value, err) {
      this.tag = tag;
      this.value = value;
      this.err = err;
      if (typeof this.tag !== "number") {
        throw new Error("Invalid tag type (" + typeof this.tag + ")");
      }
      if (this.tag < 0 || (this.tag | 0) !== this.tag) {
        throw new Error("Tag must be a positive integer: " + this.tag);
      }
    }
    toString() {
      return `${this.tag}(${JSON.stringify(this.value)})`;
    }
    encodeCBOR(gen) {
      gen._pushTag(this.tag);
      return gen.pushAny(this.value);
    }
    convert(converters) {
      let f = converters != null ? converters[this.tag] : void 0;
      if (typeof f !== "function") {
        f = Tagged["_tag_" + this.tag];
        if (typeof f !== "function") {
          return this;
        }
      }
      try {
        return f.call(Tagged, this.value);
      } catch (error) {
        this.err = error;
        return this;
      }
    }
    static _tag_0(v) {
      return new Date(v);
    }
    static _tag_1(v) {
      return new Date(v * 1e3);
    }
    static _tag_2(v) {
      return utils.bufferToBignumber(v);
    }
    static _tag_3(v) {
      return BN.MINUS_ONE.minus(utils.bufferToBignumber(v));
    }
    static _tag_4(v) {
      return new BigNumber(v[1]).shiftedBy(v[0]);
    }
    static _tag_5(v) {
      return BN.TWO.pow(v[0]).times(v[1]);
    }
    static _tag_32(v) {
      return url.parse(v);
    }
    static _tag_35(v) {
      return new RegExp(v);
    }
  };
  module2.exports = Tagged;
});

// node_modules/cbor/lib/decoder.js
var require_decoder2 = __commonJS((exports2, module2) => {
  "use strict";
  var stream = require_stream_browserify();
  var BinaryParseStream = require_binary_parse_stream();
  var Tagged = require_tagged2();
  var Simple = require_simple2();
  var utils = require_utils9();
  var NoFilter = require_lib2();
  var {BigNumber, MT, NUMBYTES, SIMPLE, SYMS, BI, BN} = require_constants5();
  var COUNT = Symbol("count");
  var PENDING_KEY = Symbol("pending_key");
  var MAJOR = Symbol("major type");
  var ERROR = Symbol("error");
  var NOT_FOUND = Symbol("not found");
  function parentArray(parent, typ, count) {
    const a = [];
    a[COUNT] = count;
    a[SYMS.PARENT] = parent;
    a[MAJOR] = typ;
    return a;
  }
  function parentBufferStream(parent, typ) {
    const b = new NoFilter();
    b[COUNT] = -1;
    b[SYMS.PARENT] = parent;
    b[MAJOR] = typ;
    return b;
  }
  function _tag_2(v) {
    return utils.bufferToBigInt(v);
  }
  function _tag_3(v) {
    return BI.MINUS_ONE - utils.bufferToBigInt(v);
  }
  var UnexpectedDataError = class extends Error {
    constructor(byte, value) {
      super(`Unexpected data: 0x${byte.toString(16)}`);
      this.name = "UnexpectedDataError";
      this.byte = byte;
      this.value = value;
    }
  };
  function normalizeOptions(opts, cb) {
    switch (typeof opts) {
      case "function":
        return {options: {}, cb: opts};
      case "string":
        return {options: {encoding: opts}, cb};
      case "object":
        return {options: opts || {}, cb};
      default:
        throw new TypeError("Unknown option type");
    }
  }
  var Decoder = class extends BinaryParseStream {
    constructor(options = {}) {
      const {
        tags = {},
        max_depth = -1,
        bigint = true,
        preferWeb = false,
        required = false,
        encoding = "hex",
        extendedResults = false,
        ...superOpts
      } = options;
      super({defaultEncoding: encoding, ...superOpts});
      this.running = true;
      this.max_depth = max_depth;
      this.tags = tags;
      this.preferWeb = preferWeb;
      this.extendedResults = extendedResults;
      this.bigint = bigint;
      if (extendedResults) {
        this.bs.on("read", this._onRead.bind(this));
        this.valueBytes = new NoFilter();
      }
      if (bigint) {
        if (this.tags[2] == null) {
          this.tags[2] = _tag_2;
        }
        if (this.tags[3] == null) {
          this.tags[3] = _tag_3;
        }
      }
    }
    static nullcheck(val) {
      switch (val) {
        case SYMS.NULL:
          return null;
        case SYMS.UNDEFINED:
          return void 0;
        case NOT_FOUND:
          throw new Error("Value not found");
        default:
          return val;
      }
    }
    static decodeFirstSync(input, options = {}) {
      if (input == null) {
        throw new TypeError("input required");
      }
      ({options} = normalizeOptions(options));
      const {encoding = "hex", ...opts} = options;
      const c = new Decoder(opts);
      const s = utils.guessEncoding(input, encoding);
      const parser = c._parse();
      let state = parser.next();
      while (!state.done) {
        const b = s.read(state.value);
        if (b == null || b.length !== state.value) {
          throw new Error("Insufficient data");
        }
        if (c.extendedResults) {
          c.valueBytes.write(b);
        }
        state = parser.next(b);
      }
      let val;
      if (!c.extendedResults) {
        val = Decoder.nullcheck(state.value);
        if (s.length > 0) {
          const nextByte = s.read(1);
          s.unshift(nextByte);
          throw new UnexpectedDataError(nextByte[0], val);
        }
      } else {
        val = state.value;
        val.unused = s.read();
      }
      return val;
    }
    static decodeAllSync(input, options = {}) {
      if (input == null) {
        throw new TypeError("input required");
      }
      ({options} = normalizeOptions(options));
      const {encoding = "hex", ...opts} = options;
      const c = new Decoder(opts);
      const s = utils.guessEncoding(input, encoding);
      const res = [];
      while (s.length > 0) {
        const parser = c._parse();
        let state = parser.next();
        while (!state.done) {
          const b = s.read(state.value);
          if (b == null || b.length !== state.value) {
            throw new Error("Insufficient data");
          }
          if (c.extendedResults) {
            c.valueBytes.write(b);
          }
          state = parser.next(b);
        }
        res.push(Decoder.nullcheck(state.value));
      }
      return res;
    }
    static decodeFirst(input, options = {}, cb) {
      if (input == null) {
        throw new TypeError("input required");
      }
      ({options, cb} = normalizeOptions(options, cb));
      const {encoding = "hex", required = false, ...opts} = options;
      const c = new Decoder(opts);
      let v = NOT_FOUND;
      const s = utils.guessEncoding(input, encoding);
      const p = new Promise((resolve, reject) => {
        c.on("data", (val) => {
          v = Decoder.nullcheck(val);
          c.close();
        });
        c.once("error", (er) => {
          if (c.extendedResults && er instanceof UnexpectedDataError) {
            v.unused = c.bs.slice();
            return resolve(v);
          }
          if (v !== NOT_FOUND) {
            er["value"] = v;
          }
          v = ERROR;
          c.close();
          return reject(er);
        });
        c.once("end", () => {
          switch (v) {
            case NOT_FOUND:
              if (required) {
                return reject(new Error("No CBOR found"));
              } else {
                return resolve(v);
              }
            case ERROR:
              return void 0;
            default:
              return resolve(v);
          }
        });
      });
      if (typeof cb === "function") {
        p.then((v2) => cb(null, v2), cb);
      }
      s.pipe(c);
      return p;
    }
    static decodeAll(input, options = {}, cb) {
      if (input == null) {
        throw new TypeError("input required");
      }
      ({options, cb} = normalizeOptions(options, cb));
      const {encoding = "hex", ...opts} = options;
      const c = new Decoder(opts);
      const vals = [];
      c.on("data", (val) => {
        return vals.push(Decoder.nullcheck(val));
      });
      const p = new Promise((resolve, reject) => {
        c.on("error", reject);
        c.on("end", () => resolve(vals));
      });
      if (typeof cb === "function") {
        p.then((v) => cb(void 0, v), (er) => cb(er, void 0));
      }
      utils.guessEncoding(input, encoding).pipe(c);
      return p;
    }
    close() {
      this.running = false;
      this.__fresh = true;
    }
    _onRead(data) {
      this.valueBytes.write(data);
    }
    *_parse() {
      let parent = null;
      let depth = 0;
      let val = null;
      while (true) {
        if (this.max_depth >= 0 && depth > this.max_depth) {
          throw new Error("Maximum depth " + this.max_depth + " exceeded");
        }
        const octet = (yield 1)[0];
        if (!this.running) {
          this.bs.unshift(Buffer.from([octet]));
          throw new UnexpectedDataError(octet);
        }
        const mt = octet >> 5;
        const ai = octet & 31;
        const parent_major = parent != null ? parent[MAJOR] : void 0;
        const parent_length = parent != null ? parent.length : void 0;
        switch (ai) {
          case NUMBYTES.ONE:
            this.emit("more-bytes", mt, 1, parent_major, parent_length);
            val = (yield 1)[0];
            break;
          case NUMBYTES.TWO:
          case NUMBYTES.FOUR:
          case NUMBYTES.EIGHT:
            const numbytes = 1 << ai - 24;
            this.emit("more-bytes", mt, numbytes, parent_major, parent_length);
            const buf = yield numbytes;
            val = mt === MT.SIMPLE_FLOAT ? buf : utils.parseCBORint(ai, buf, this.bigint);
            break;
          case 28:
          case 29:
          case 30:
            this.running = false;
            throw new Error("Additional info not implemented: " + ai);
          case NUMBYTES.INDEFINITE:
            switch (mt) {
              case MT.POS_INT:
              case MT.NEG_INT:
              case MT.TAG:
                throw new Error(`Invalid indefinite encoding for MT ${mt}`);
            }
            val = -1;
            break;
          default:
            val = ai;
        }
        switch (mt) {
          case MT.POS_INT:
            break;
          case MT.NEG_INT:
            if (val === Number.MAX_SAFE_INTEGER) {
              val = this.bigint ? BI.NEG_MAX : BN.NEG_MAX;
            } else if (val instanceof BigNumber) {
              val = BN.MINUS_ONE.minus(val);
            } else {
              val = typeof val === "bigint" ? BI.MINUS_ONE - val : -1 - val;
            }
            break;
          case MT.BYTE_STRING:
          case MT.UTF8_STRING:
            switch (val) {
              case 0:
                this.emit("start-string", mt, val, parent_major, parent_length);
                if (mt === MT.UTF8_STRING) {
                  val = "";
                } else {
                  val = this.preferWeb ? new Uint8Array(0) : Buffer.allocUnsafe(0);
                }
                break;
              case -1:
                this.emit("start", mt, SYMS.STREAM, parent_major, parent_length);
                parent = parentBufferStream(parent, mt);
                depth++;
                continue;
              default:
                this.emit("start-string", mt, val, parent_major, parent_length);
                val = yield val;
                if (mt === MT.UTF8_STRING) {
                  val = utils.utf8(val);
                } else if (this.preferWeb) {
                  val = new Uint8Array(val.buffer, val.byteOffset, val.length);
                }
            }
            break;
          case MT.ARRAY:
          case MT.MAP:
            switch (val) {
              case 0:
                val = mt === MT.MAP ? {} : [];
                break;
              case -1:
                this.emit("start", mt, SYMS.STREAM, parent_major, parent_length);
                parent = parentArray(parent, mt, -1);
                depth++;
                continue;
              default:
                this.emit("start", mt, val, parent_major, parent_length);
                parent = parentArray(parent, mt, val * (mt - 3));
                depth++;
                continue;
            }
            break;
          case MT.TAG:
            this.emit("start", mt, val, parent_major, parent_length);
            parent = parentArray(parent, mt, 1);
            parent.push(val);
            depth++;
            continue;
          case MT.SIMPLE_FLOAT:
            if (typeof val === "number") {
              if (ai === NUMBYTES.ONE && val < 32) {
                throw new Error(`Invalid two-byte encoding of simple value ${val}`);
              }
              const hasParent = parent != null;
              val = Simple.decode(val, hasParent, hasParent && parent[COUNT] < 0);
            } else {
              val = utils.parseCBORfloat(val);
            }
        }
        this.emit("value", val, parent_major, parent_length, ai);
        let again = false;
        while (parent != null) {
          switch (false) {
            case val !== SYMS.BREAK:
              parent[COUNT] = 1;
              break;
            case !Array.isArray(parent):
              parent.push(val);
              break;
            case !(parent instanceof NoFilter):
              const pm = parent[MAJOR];
              if (pm != null && pm !== mt) {
                this.running = false;
                throw new Error("Invalid major type in indefinite encoding");
              }
              parent.write(val);
          }
          if (--parent[COUNT] !== 0) {
            again = true;
            break;
          }
          --depth;
          delete parent[COUNT];
          if (Array.isArray(parent)) {
            switch (parent[MAJOR]) {
              case MT.ARRAY:
                val = parent;
                break;
              case MT.MAP:
                let allstrings = true;
                if (parent.length % 2 !== 0) {
                  throw new Error("Invalid map length: " + parent.length);
                }
                for (let i = 0, len = parent.length; i < len; i += 2) {
                  if (typeof parent[i] !== "string") {
                    allstrings = false;
                    break;
                  }
                }
                if (allstrings) {
                  val = {};
                  for (let i = 0, len = parent.length; i < len; i += 2) {
                    val[parent[i]] = parent[i + 1];
                  }
                } else {
                  val = new Map();
                  for (let i = 0, len = parent.length; i < len; i += 2) {
                    val.set(parent[i], parent[i + 1]);
                  }
                }
                break;
              case MT.TAG:
                const t = new Tagged(parent[0], parent[1]);
                val = t.convert(this.tags);
                break;
            }
          } else if (parent instanceof NoFilter) {
            switch (parent[MAJOR]) {
              case MT.BYTE_STRING:
                val = parent.slice();
                if (this.preferWeb) {
                  val = new Uint8Array(val.buffer, val.byteOffset, val.length);
                }
                break;
              case MT.UTF8_STRING:
                val = parent.toString("utf-8");
                break;
            }
          }
          this.emit("stop", parent[MAJOR]);
          const old = parent;
          parent = parent[SYMS.PARENT];
          delete old[SYMS.PARENT];
          delete old[MAJOR];
        }
        if (!again) {
          if (this.extendedResults) {
            const bytes = this.valueBytes.slice();
            const ret = {
              value: Decoder.nullcheck(val),
              bytes,
              length: bytes.length
            };
            this.valueBytes = new NoFilter();
            return ret;
          }
          return val;
        }
      }
    }
  };
  Decoder.NOT_FOUND = NOT_FOUND;
  module2.exports = Decoder;
});

// node_modules/cbor/lib/commented.js
var require_commented = __commonJS((exports2, module2) => {
  "use strict";
  var stream = require_stream_browserify();
  var util = require_util10();
  var utils = require_utils9();
  var Simple = require_simple2();
  var Decoder = require_decoder2();
  var NoFilter = require_lib2();
  var {BigNumber, MT, NUMBYTES, SYMS} = require_constants5();
  function plural(c) {
    if (c > 1) {
      return "s";
    } else {
      return "";
    }
  }
  function normalizeOptions(opts, cb) {
    switch (typeof opts) {
      case "function":
        return {options: {}, cb: opts};
      case "string":
        return {options: {encoding: opts}, cb};
      case "number":
        return {options: {max_depth: opts}, cb};
      case "object":
        return {options: opts || {}, cb};
      default:
        throw new TypeError("Unknown option type");
    }
  }
  var Commented = class extends stream.Transform {
    constructor(options = {}) {
      const {
        depth = 1,
        max_depth = 10,
        no_summary = false,
        tags = {},
        bigint,
        preferWeb,
        encoding,
        ...superOpts
      } = options;
      super({
        ...superOpts,
        readableObjectMode: false,
        writableObjectMode: false
      });
      this.depth = depth;
      this.max_depth = max_depth;
      this.all = new NoFilter();
      if (!tags[24]) {
        tags[24] = this._tag_24.bind(this);
      }
      this.parser = new Decoder({
        tags,
        max_depth,
        bigint,
        preferWeb,
        encoding
      });
      this.parser.on("value", this._on_value.bind(this));
      this.parser.on("start", this._on_start.bind(this));
      this.parser.on("start-string", this._on_start_string.bind(this));
      this.parser.on("stop", this._on_stop.bind(this));
      this.parser.on("more-bytes", this._on_more.bind(this));
      this.parser.on("error", this._on_error.bind(this));
      if (!no_summary) {
        this.parser.on("data", this._on_data.bind(this));
      }
      this.parser.bs.on("read", this._on_read.bind(this));
    }
    _tag_24(v) {
      const c = new Commented({depth: this.depth + 1, no_summary: true});
      c.on("data", (b) => this.push(b));
      c.on("error", (er) => this.emit("error", er));
      c.end(v);
    }
    _transform(fresh, encoding, cb) {
      this.parser.write(fresh, encoding, cb);
    }
    _flush(cb) {
      return this.parser._flush(cb);
    }
    static comment(input, options = {}, cb) {
      if (input == null) {
        throw new Error("input required");
      }
      ({options, cb} = normalizeOptions(options, cb));
      const bs = new NoFilter();
      const {encoding = "hex", ...opts} = options;
      const d = new Commented(opts);
      let p = null;
      if (typeof cb === "function") {
        d.on("end", () => {
          cb(null, bs.toString("utf8"));
        });
        d.on("error", cb);
      } else {
        p = new Promise((resolve, reject) => {
          d.on("end", () => {
            resolve(bs.toString("utf8"));
          });
          return d.on("error", reject);
        });
      }
      d.pipe(bs);
      utils.guessEncoding(input, encoding).pipe(d);
      return p;
    }
    _on_error(er) {
      this.push("ERROR: ");
      this.push(er.toString());
      this.push("\n");
    }
    _on_read(buf) {
      this.all.write(buf);
      const hex = buf.toString("hex");
      this.push(new Array(this.depth + 1).join("  "));
      this.push(hex);
      let ind = (this.max_depth - this.depth) * 2;
      ind -= hex.length;
      if (ind < 1) {
        ind = 1;
      }
      this.push(new Array(ind + 1).join(" "));
      return this.push("-- ");
    }
    _on_more(mt, len, parent_mt, pos) {
      this.depth++;
      let desc = "";
      switch (mt) {
        case MT.POS_INT:
          desc = "Positive number,";
          break;
        case MT.NEG_INT:
          desc = "Negative number,";
          break;
        case MT.ARRAY:
          desc = "Array, length";
          break;
        case MT.MAP:
          desc = "Map, count";
          break;
        case MT.BYTE_STRING:
          desc = "Bytes, length";
          break;
        case MT.UTF8_STRING:
          desc = "String, length";
          break;
        case MT.SIMPLE_FLOAT:
          if (len === 1) {
            desc = "Simple value,";
          } else {
            desc = "Float,";
          }
          break;
      }
      return this.push(desc + " next " + len + " byte" + plural(len) + "\n");
    }
    _on_start_string(mt, tag, parent_mt, pos) {
      this.depth++;
      let desc = "";
      switch (mt) {
        case MT.BYTE_STRING:
          desc = "Bytes, length: " + tag;
          break;
        case MT.UTF8_STRING:
          desc = "String, length: " + tag.toString();
          break;
      }
      return this.push(desc + "\n");
    }
    _on_start(mt, tag, parent_mt, pos) {
      this.depth++;
      switch (parent_mt) {
        case MT.ARRAY:
          this.push(`[${pos}], `);
          break;
        case MT.MAP:
          if (pos % 2) {
            this.push(`{Val:${Math.floor(pos / 2)}}, `);
          } else {
            this.push(`{Key:${Math.floor(pos / 2)}}, `);
          }
          break;
      }
      switch (mt) {
        case MT.TAG:
          this.push(`Tag #${tag}`);
          if (tag == 24) {
            this.push(" Encoded CBOR data item");
          }
          break;
        case MT.ARRAY:
          if (tag === SYMS.STREAM) {
            this.push("Array (streaming)");
          } else {
            this.push(`Array, ${tag} item${plural(tag)}`);
          }
          break;
        case MT.MAP:
          if (tag === SYMS.STREAM) {
            this.push("Map (streaming)");
          } else {
            this.push(`Map, ${tag} pair${plural(tag)}`);
          }
          break;
        case MT.BYTE_STRING:
          this.push("Bytes (streaming)");
          break;
        case MT.UTF8_STRING:
          this.push("String (streaming)");
          break;
      }
      return this.push("\n");
    }
    _on_stop(mt) {
      return this.depth--;
    }
    _on_value(val, parent_mt, pos, ai) {
      if (val !== SYMS.BREAK) {
        switch (parent_mt) {
          case MT.ARRAY:
            this.push(`[${pos}], `);
            break;
          case MT.MAP:
            if (pos % 2) {
              this.push(`{Val:${Math.floor(pos / 2)}}, `);
            } else {
              this.push(`{Key:${Math.floor(pos / 2)}}, `);
            }
            break;
        }
      }
      const str = utils.cborValueToString(val, -Infinity);
      if (typeof val === "string" || Buffer.isBuffer(val)) {
        if (val.length > 0) {
          this.push(str);
          this.push("\n");
        }
        this.depth--;
      } else {
        this.push(str);
        this.push("\n");
      }
      switch (ai) {
        case NUMBYTES.ONE:
        case NUMBYTES.TWO:
        case NUMBYTES.FOUR:
        case NUMBYTES.EIGHT:
          this.depth--;
      }
    }
    _on_data() {
      this.push("0x");
      this.push(this.all.read().toString("hex"));
      return this.push("\n");
    }
  };
  module2.exports = Commented;
});

// node_modules/cbor/lib/diagnose.js
var require_diagnose2 = __commonJS((exports2, module2) => {
  "use strict";
  var stream = require_stream_browserify();
  var util = require_util10();
  var Decoder = require_decoder2();
  var Simple = require_simple2();
  var utils = require_utils9();
  var NoFilter = require_lib2();
  var {BigNumber, MT, SYMS} = require_constants5();
  function normalizeOptions(opts, cb) {
    switch (typeof opts) {
      case "function":
        return {options: {}, cb: opts};
      case "string":
        return {options: {encoding: opts}, cb};
      case "object":
        return {options: opts || {}, cb};
      default:
        throw new TypeError("Unknown option type");
    }
  }
  var Diagnose = class extends stream.Transform {
    constructor(options = {}) {
      const {
        separator = "\n",
        stream_errors = false,
        tags,
        max_depth,
        bigint,
        preferWeb,
        encoding,
        ...superOpts
      } = options;
      super({
        ...superOpts,
        readableObjectMode: false,
        writableObjectMode: false
      });
      this.float_bytes = -1;
      this.separator = separator;
      this.stream_errors = stream_errors;
      this.parser = new Decoder({
        tags,
        max_depth,
        bigint,
        preferWeb,
        encoding
      });
      this.parser.on("more-bytes", this._on_more.bind(this));
      this.parser.on("value", this._on_value.bind(this));
      this.parser.on("start", this._on_start.bind(this));
      this.parser.on("stop", this._on_stop.bind(this));
      this.parser.on("data", this._on_data.bind(this));
      this.parser.on("error", this._on_error.bind(this));
    }
    _transform(fresh, encoding, cb) {
      return this.parser.write(fresh, encoding, cb);
    }
    _flush(cb) {
      return this.parser._flush((er) => {
        if (this.stream_errors) {
          if (er) {
            this._on_error(er);
          }
          return cb();
        } else {
          return cb(er);
        }
      });
    }
    static diagnose(input, options = {}, cb) {
      if (input == null) {
        throw new Error("input required");
      }
      ({options, cb} = normalizeOptions(options, cb));
      const {encoding = "hex", ...opts} = options;
      const bs = new NoFilter();
      const d = new Diagnose(opts);
      let p = null;
      if (typeof cb === "function") {
        d.on("end", () => cb(null, bs.toString("utf8")));
        d.on("error", cb);
      } else {
        p = new Promise((resolve, reject) => {
          d.on("end", () => resolve(bs.toString("utf8")));
          return d.on("error", reject);
        });
      }
      d.pipe(bs);
      utils.guessEncoding(input, encoding).pipe(d);
      return p;
    }
    _on_error(er) {
      if (this.stream_errors) {
        return this.push(er.toString());
      } else {
        return this.emit("error", er);
      }
    }
    _on_more(mt, len, parent_mt, pos) {
      if (mt === MT.SIMPLE_FLOAT) {
        return this.float_bytes = {
          2: 1,
          4: 2,
          8: 3
        }[len];
      }
    }
    _fore(parent_mt, pos) {
      switch (parent_mt) {
        case MT.BYTE_STRING:
        case MT.UTF8_STRING:
        case MT.ARRAY:
          if (pos > 0) {
            return this.push(", ");
          }
          break;
        case MT.MAP:
          if (pos > 0) {
            if (pos % 2) {
              return this.push(": ");
            } else {
              return this.push(", ");
            }
          }
      }
    }
    _on_value(val, parent_mt, pos) {
      if (val === SYMS.BREAK) {
        return;
      }
      this._fore(parent_mt, pos);
      const fb = this.float_bytes;
      this.float_bytes = -1;
      return this.push(utils.cborValueToString(val, fb));
    }
    _on_start(mt, tag, parent_mt, pos) {
      this._fore(parent_mt, pos);
      switch (mt) {
        case MT.TAG:
          this.push(`${tag}(`);
          break;
        case MT.ARRAY:
          this.push("[");
          break;
        case MT.MAP:
          this.push("{");
          break;
        case MT.BYTE_STRING:
        case MT.UTF8_STRING:
          this.push("(");
          break;
      }
      if (tag === SYMS.STREAM) {
        return this.push("_ ");
      }
    }
    _on_stop(mt) {
      switch (mt) {
        case MT.TAG:
          return this.push(")");
        case MT.ARRAY:
          return this.push("]");
        case MT.MAP:
          return this.push("}");
        case MT.BYTE_STRING:
        case MT.UTF8_STRING:
          return this.push(")");
      }
    }
    _on_data() {
      return this.push(this.separator);
    }
  };
  module2.exports = Diagnose;
});

// node_modules/cbor/lib/encoder.js
var require_encoder3 = __commonJS((exports2, module2) => {
  "use strict";
  var stream = require_stream_browserify();
  var url = require_url();
  var NoFilter = require_lib2();
  var Tagged = require_tagged2();
  var Simple = require_simple2();
  var utils = require_utils9();
  var {
    BigNumber,
    MT,
    NUMBYTES,
    SHIFT32,
    SIMPLE,
    SYMS,
    TAG,
    BI,
    BN
  } = require_constants5();
  var HALF = MT.SIMPLE_FLOAT << 5 | NUMBYTES.TWO;
  var FLOAT = MT.SIMPLE_FLOAT << 5 | NUMBYTES.FOUR;
  var DOUBLE = MT.SIMPLE_FLOAT << 5 | NUMBYTES.EIGHT;
  var TRUE = MT.SIMPLE_FLOAT << 5 | SIMPLE.TRUE;
  var FALSE = MT.SIMPLE_FLOAT << 5 | SIMPLE.FALSE;
  var UNDEFINED = MT.SIMPLE_FLOAT << 5 | SIMPLE.UNDEFINED;
  var NULL = MT.SIMPLE_FLOAT << 5 | SIMPLE.NULL;
  var BREAK = Buffer.from([255]);
  var BUF_NAN = Buffer.from("f97e00", "hex");
  var BUF_INF_NEG = Buffer.from("f9fc00", "hex");
  var BUF_INF_POS = Buffer.from("f97c00", "hex");
  var BUF_NEG_ZERO = Buffer.from("f98000", "hex");
  var LOOP_DETECT = Symbol("CBOR_LOOP_DETECT");
  function parseDateType(str) {
    if (!str) {
      return "number";
    }
    switch (str.toLowerCase()) {
      case "number":
        return "number";
      case "float":
        return "float";
      case "int":
        return "int";
      case "string":
        return "string";
    }
    throw new TypeError(`dateType invalid, got "${str}"`);
  }
  var Encoder = class extends stream.Transform {
    constructor(options = {}) {
      const {
        canonical = false,
        encodeUndefined,
        disallowUndefinedKeys = false,
        dateType = "number",
        collapseBigIntegers = false,
        detectLoops = false,
        genTypes = [],
        ...superOpts
      } = options;
      super({
        ...superOpts,
        readableObjectMode: false,
        writableObjectMode: true
      });
      this.canonical = canonical;
      this.encodeUndefined = encodeUndefined;
      this.disallowUndefinedKeys = disallowUndefinedKeys;
      this.dateType = parseDateType(dateType);
      this.collapseBigIntegers = this.canonical ? true : collapseBigIntegers;
      if (typeof detectLoops === "symbol") {
        this.detectLoops = detectLoops;
      } else {
        this.detectLoops = detectLoops ? Symbol("CBOR_DETECT") : null;
      }
      this.semanticTypes = {
        Array: this._pushArray,
        Date: this._pushDate,
        Buffer: this._pushBuffer,
        Map: this._pushMap,
        NoFilter: this._pushNoFilter,
        RegExp: this._pushRegexp,
        Set: this._pushSet,
        BigNumber: this._pushBigNumber,
        ArrayBuffer: this._pushUint8Array,
        Uint8ClampedArray: this._pushUint8Array,
        Uint8Array: this._pushUint8Array,
        Uint16Array: this._pushArray,
        Uint32Array: this._pushArray,
        Int8Array: this._pushArray,
        Int16Array: this._pushArray,
        Int32Array: this._pushArray,
        Float32Array: this._pushFloat32Array,
        Float64Array: this._pushFloat64Array,
        Url: this._pushUrl,
        URL: this._pushURL
      };
      if (Array.isArray(genTypes)) {
        for (let i = 0, len = genTypes.length; i < len; i += 2) {
          this.addSemanticType(genTypes[i], genTypes[i + 1]);
        }
      } else {
        for (const [k, v] of Object.entries(genTypes)) {
          this.addSemanticType(k, v);
        }
      }
    }
    _transform(fresh, encoding, cb) {
      const ret = this.pushAny(fresh);
      return cb(ret === false ? new Error("Push Error") : void 0);
    }
    _flush(cb) {
      return cb();
    }
    addSemanticType(type, fun) {
      const typeName = typeof type === "string" ? type : type.name;
      const old = this.semanticTypes[typeName];
      if (fun) {
        if (typeof fun !== "function") {
          throw new TypeError("fun must be of type function");
        }
        this.semanticTypes[typeName] = fun;
      } else if (old) {
        delete this.semanticTypes[typeName];
      }
      return old;
    }
    _pushUInt8(val) {
      const b = Buffer.allocUnsafe(1);
      b.writeUInt8(val, 0);
      return this.push(b);
    }
    _pushUInt16BE(val) {
      const b = Buffer.allocUnsafe(2);
      b.writeUInt16BE(val, 0);
      return this.push(b);
    }
    _pushUInt32BE(val) {
      const b = Buffer.allocUnsafe(4);
      b.writeUInt32BE(val, 0);
      return this.push(b);
    }
    _pushFloatBE(val) {
      const b = Buffer.allocUnsafe(4);
      b.writeFloatBE(val, 0);
      return this.push(b);
    }
    _pushDoubleBE(val) {
      const b = Buffer.allocUnsafe(8);
      b.writeDoubleBE(val, 0);
      return this.push(b);
    }
    _pushNaN() {
      return this.push(BUF_NAN);
    }
    _pushInfinity(obj) {
      const half = obj < 0 ? BUF_INF_NEG : BUF_INF_POS;
      return this.push(half);
    }
    _pushFloat(obj) {
      if (this.canonical) {
        const b2 = Buffer.allocUnsafe(2);
        if (utils.writeHalf(b2, obj)) {
          return this._pushUInt8(HALF) && this.push(b2);
        }
      }
      if (Math.fround(obj) === obj) {
        return this._pushUInt8(FLOAT) && this._pushFloatBE(obj);
      }
      return this._pushUInt8(DOUBLE) && this._pushDoubleBE(obj);
    }
    _pushInt(obj, mt, orig) {
      const m = mt << 5;
      switch (false) {
        case !(obj < 24):
          return this._pushUInt8(m | obj);
        case !(obj <= 255):
          return this._pushUInt8(m | NUMBYTES.ONE) && this._pushUInt8(obj);
        case !(obj <= 65535):
          return this._pushUInt8(m | NUMBYTES.TWO) && this._pushUInt16BE(obj);
        case !(obj <= 4294967295):
          return this._pushUInt8(m | NUMBYTES.FOUR) && this._pushUInt32BE(obj);
        case !(obj <= Number.MAX_SAFE_INTEGER):
          return this._pushUInt8(m | NUMBYTES.EIGHT) && this._pushUInt32BE(Math.floor(obj / SHIFT32)) && this._pushUInt32BE(obj % SHIFT32);
        default:
          if (mt === MT.NEG_INT) {
            return this._pushFloat(orig);
          } else {
            return this._pushFloat(obj);
          }
      }
    }
    _pushIntNum(obj) {
      if (Object.is(obj, -0)) {
        return this.push(BUF_NEG_ZERO);
      }
      if (obj < 0) {
        return this._pushInt(-obj - 1, MT.NEG_INT, obj);
      } else {
        return this._pushInt(obj, MT.POS_INT);
      }
    }
    _pushNumber(obj) {
      switch (false) {
        case !isNaN(obj):
          return this._pushNaN();
        case isFinite(obj):
          return this._pushInfinity(obj);
        case Math.round(obj) !== obj:
          return this._pushIntNum(obj);
        default:
          return this._pushFloat(obj);
      }
    }
    _pushString(obj) {
      const len = Buffer.byteLength(obj, "utf8");
      return this._pushInt(len, MT.UTF8_STRING) && this.push(obj, "utf8");
    }
    _pushBoolean(obj) {
      return this._pushUInt8(obj ? TRUE : FALSE);
    }
    _pushUndefined(obj) {
      switch (typeof this.encodeUndefined) {
        case "undefined":
          return this._pushUInt8(UNDEFINED);
        case "function":
          return this.pushAny(this.encodeUndefined.call(this, obj));
        case "object":
          if (Buffer.isBuffer(this.encodeUndefined)) {
            return this.push(this.encodeUndefined);
          }
      }
      return this.pushAny(this.encodeUndefined);
    }
    _pushNull(obj) {
      return this._pushUInt8(NULL);
    }
    _pushArray(gen, obj, opts) {
      opts = Object.assign({
        indefinite: false
      }, opts);
      const len = obj.length;
      if (opts.indefinite) {
        if (!gen._pushUInt8(MT.ARRAY << 5 | NUMBYTES.INDEFINITE)) {
          return false;
        }
      } else if (!gen._pushInt(len, MT.ARRAY)) {
        return false;
      }
      for (let j = 0; j < len; j++) {
        if (!gen.pushAny(obj[j])) {
          return false;
        }
      }
      if (opts.indefinite) {
        if (!gen.push(BREAK)) {
          return false;
        }
      }
      return true;
    }
    _pushTag(tag) {
      return this._pushInt(tag, MT.TAG);
    }
    _pushDate(gen, obj) {
      switch (gen.dateType) {
        case "string":
          return gen._pushTag(TAG.DATE_STRING) && gen._pushString(obj.toISOString());
        case "int":
        case "integer":
          return gen._pushTag(TAG.DATE_EPOCH) && gen._pushIntNum(Math.round(obj / 1e3));
        case "float":
          return gen._pushTag(TAG.DATE_EPOCH) && gen._pushFloat(obj / 1e3);
        case "number":
        default:
          return gen._pushTag(TAG.DATE_EPOCH) && gen.pushAny(obj / 1e3);
      }
    }
    _pushBuffer(gen, obj) {
      return gen._pushInt(obj.length, MT.BYTE_STRING) && gen.push(obj);
    }
    _pushNoFilter(gen, obj) {
      return gen._pushBuffer(gen, obj.slice());
    }
    _pushRegexp(gen, obj) {
      return gen._pushTag(TAG.REGEXP) && gen.pushAny(obj.source);
    }
    _pushSet(gen, obj) {
      if (!gen._pushInt(obj.size, MT.ARRAY)) {
        return false;
      }
      for (const x of obj) {
        if (!gen.pushAny(x)) {
          return false;
        }
      }
      return true;
    }
    _pushUrl(gen, obj) {
      return gen._pushTag(TAG.URI) && gen.pushAny(obj.format());
    }
    _pushURL(gen, obj) {
      return gen._pushTag(TAG.URI) && gen.pushAny(obj.toString());
    }
    _pushBigint(obj) {
      let m = MT.POS_INT;
      let tag = TAG.POS_BIGINT;
      if (obj.isNegative()) {
        obj = obj.negated().minus(1);
        m = MT.NEG_INT;
        tag = TAG.NEG_BIGINT;
      }
      if (this.collapseBigIntegers && obj.lte(BN.MAXINT64)) {
        if (obj.lte(BN.MAXINT32)) {
          return this._pushInt(obj.toNumber(), m);
        }
        return this._pushUInt8(m << 5 | NUMBYTES.EIGHT) && this._pushUInt32BE(obj.dividedToIntegerBy(BN.SHIFT32).toNumber()) && this._pushUInt32BE(obj.mod(BN.SHIFT32).toNumber());
      }
      let str = obj.toString(16);
      if (str.length % 2) {
        str = "0" + str;
      }
      const buf = Buffer.from(str, "hex");
      return this._pushTag(tag) && this._pushBuffer(this, buf);
    }
    _pushJSBigint(obj) {
      let m = MT.POS_INT;
      let tag = TAG.POS_BIGINT;
      if (obj < 0) {
        obj = -obj + BI.MINUS_ONE;
        m = MT.NEG_INT;
        tag = TAG.NEG_BIGINT;
      }
      if (this.collapseBigIntegers && obj <= BI.MAXINT64) {
        if (obj <= 4294967295) {
          return this._pushInt(Number(obj), m);
        }
        return this._pushUInt8(m << 5 | NUMBYTES.EIGHT) && this._pushUInt32BE(Number(obj / BI.SHIFT32)) && this._pushUInt32BE(Number(obj % BI.SHIFT32));
      }
      let str = obj.toString(16);
      if (str.length % 2) {
        str = "0" + str;
      }
      const buf = Buffer.from(str, "hex");
      return this._pushTag(tag) && this._pushBuffer(this, buf);
    }
    _pushBigNumber(gen, obj) {
      if (obj.isNaN()) {
        return gen._pushNaN();
      }
      if (!obj.isFinite()) {
        return gen._pushInfinity(obj.isNegative() ? -Infinity : Infinity);
      }
      if (obj.isInteger()) {
        return gen._pushBigint(obj);
      }
      if (!(gen._pushTag(TAG.DECIMAL_FRAC) && gen._pushInt(2, MT.ARRAY))) {
        return false;
      }
      const dec = obj.decimalPlaces();
      const slide = obj.shiftedBy(dec);
      if (!gen._pushIntNum(-dec)) {
        return false;
      }
      if (slide.abs().isLessThan(BN.MAXINT)) {
        return gen._pushIntNum(slide.toNumber());
      } else {
        return gen._pushBigint(slide);
      }
    }
    _pushMap(gen, obj, opts) {
      opts = Object.assign({
        indefinite: false
      }, opts);
      if (opts.indefinite) {
        if (!gen._pushUInt8(MT.MAP << 5 | NUMBYTES.INDEFINITE)) {
          return false;
        }
      } else if (!gen._pushInt(obj.size, MT.MAP)) {
        return false;
      }
      if (gen.canonical) {
        const entries = [...obj.entries()];
        const enc = new Encoder({
          genTypes: this.semanticTypes,
          canonical: this.canonical,
          detectLoops: this.detectLoops,
          dateType: this.dateType,
          disallowUndefinedKeys: this.disallowUndefinedKeys,
          collapseBigIntegers: this.collapseBigIntegers
        });
        const bs = new NoFilter({highWaterMark: this.readableHighWaterMark});
        enc.pipe(bs);
        entries.sort(([a], [b]) => {
          enc.pushAny(a);
          const a_cbor = bs.read();
          enc.pushAny(b);
          const b_cbor = bs.read();
          return a_cbor.compare(b_cbor);
        });
        for (const [k, v] of entries) {
          if (gen.disallowUndefinedKeys && typeof k === "undefined") {
            throw new Error("Invalid Map key: undefined");
          }
          if (!(gen.pushAny(k) && gen.pushAny(v))) {
            return false;
          }
        }
      } else {
        for (const [k, v] of obj) {
          if (gen.disallowUndefinedKeys && typeof k === "undefined") {
            throw new Error("Invalid Map key: undefined");
          }
          if (!(gen.pushAny(k) && gen.pushAny(v))) {
            return false;
          }
        }
      }
      if (opts.indefinite) {
        if (!gen.push(BREAK)) {
          return false;
        }
      }
      return true;
    }
    _pushUint8Array(gen, obj) {
      return gen._pushBuffer(gen, Buffer.from(obj));
    }
    _pushFloat32Array(gen, obj) {
      const len = obj.length;
      if (!gen._pushInt(len, MT.ARRAY)) {
        return false;
      }
      for (let j = 0; j < len; j++) {
        if (!gen._pushUInt8(FLOAT) || !gen._pushFloatBE(obj[j])) {
          return false;
        }
      }
      return true;
    }
    _pushFloat64Array(gen, obj) {
      const len = obj.length;
      if (!gen._pushInt(len, MT.ARRAY)) {
        return false;
      }
      for (let j = 0; j < len; j++) {
        if (!gen._pushUInt8(DOUBLE) || !gen._pushDoubleBE(obj[j])) {
          return false;
        }
      }
      return true;
    }
    removeLoopDetectors(obj) {
      if (!this.detectLoops) {
        return false;
      }
      return Encoder.removeLoopDetectors(obj, this.detectLoops);
    }
    static removeLoopDetectors(obj, detector = null) {
      if (typeof obj !== "object" || !obj) {
        return false;
      }
      const dl = obj[LOOP_DETECT];
      if (!dl) {
        return false;
      }
      if (detector == null) {
        detector = dl;
      } else {
        if (detector !== dl) {
          return false;
        }
      }
      delete obj[LOOP_DETECT];
      if (Array.isArray(obj)) {
        for (const i of obj) {
          this.removeLoopDetectors(i, detector);
        }
      } else {
        for (const k in obj) {
          this.removeLoopDetectors(obj[k], detector);
        }
      }
      return true;
    }
    _pushObject(obj, opts) {
      if (!obj) {
        return this._pushNull(obj);
      }
      opts = Object.assign({
        indefinite: false,
        skipTypes: false
      }, opts);
      if (!opts.indefinite) {
        if (this.detectLoops) {
          if (obj[LOOP_DETECT] === this.detectLoops) {
            throw new Error("Loop detected while CBOR encoding");
          } else {
            obj[LOOP_DETECT] = this.detectLoops;
          }
        }
      }
      if (!opts.skipTypes) {
        const f = obj.encodeCBOR;
        if (typeof f === "function") {
          return f.call(obj, this);
        }
        const converter = this.semanticTypes[obj.constructor.name];
        if (converter) {
          return converter.call(obj, this, obj);
        }
      }
      const keys = Object.keys(obj).filter((k) => typeof obj[k] !== "function");
      const cbor_keys = {};
      if (this.canonical) {
        keys.sort((a, b) => {
          const a_cbor = cbor_keys[a] || (cbor_keys[a] = Encoder.encode(a));
          const b_cbor = cbor_keys[b] || (cbor_keys[b] = Encoder.encode(b));
          return a_cbor.compare(b_cbor);
        });
      }
      if (opts.indefinite) {
        if (!this._pushUInt8(MT.MAP << 5 | NUMBYTES.INDEFINITE)) {
          return false;
        }
      } else if (!this._pushInt(keys.length, MT.MAP)) {
        return false;
      }
      let ck;
      for (let j = 0, len2 = keys.length; j < len2; j++) {
        const k = keys[j];
        if (this.canonical && (ck = cbor_keys[k])) {
          if (!this.push(ck)) {
            return false;
          }
        } else {
          if (!this._pushString(k)) {
            return false;
          }
        }
        if (!this.pushAny(obj[k])) {
          return false;
        }
      }
      if (opts.indefinite) {
        if (!this.push(BREAK)) {
          return false;
        }
      }
      return true;
    }
    pushAny(obj) {
      switch (typeof obj) {
        case "number":
          return this._pushNumber(obj);
        case "bigint":
          return this._pushJSBigint(obj);
        case "string":
          return this._pushString(obj);
        case "boolean":
          return this._pushBoolean(obj);
        case "undefined":
          return this._pushUndefined(obj);
        case "object":
          return this._pushObject(obj);
        case "symbol":
          switch (obj) {
            case SYMS.NULL:
              return this._pushNull(null);
            case SYMS.UNDEFINED:
              return this._pushUndefined(void 0);
            default:
              throw new Error("Unknown symbol: " + obj.toString());
          }
        default:
          throw new Error("Unknown type: " + typeof obj + ", " + (!!obj.toString ? obj.toString() : ""));
      }
    }
    _pushAny(obj) {
      return this.pushAny(obj);
    }
    _encodeAll(objs) {
      const bs = new NoFilter({highWaterMark: this.readableHighWaterMark});
      this.pipe(bs);
      for (const o of objs) {
        this.pushAny(o);
      }
      this.end();
      return bs.read();
    }
    static encodeIndefinite(gen, obj, options = {}) {
      if (obj == null) {
        if (this == null) {
          throw new Error("No object to encode");
        }
        obj = this;
      }
      const {chunkSize = 4096, ...opts} = options;
      let ret = true;
      const objType = typeof obj;
      if (objType === "string") {
        ret = ret && gen._pushUInt8(MT.UTF8_STRING << 5 | NUMBYTES.INDEFINITE);
        let offset = 0;
        while (offset < obj.length) {
          const endIndex = offset + chunkSize;
          ret = ret && gen._pushString(obj.slice(offset, endIndex));
          offset = endIndex;
        }
        ret = ret && gen.push(BREAK);
      } else if (Buffer.isBuffer(obj)) {
        ret = ret && gen._pushUInt8(MT.BYTE_STRING << 5 | NUMBYTES.INDEFINITE);
        let offset = 0;
        while (offset < obj.length) {
          const endIndex = offset + chunkSize;
          ret = ret && gen._pushBuffer(gen, obj.slice(offset, endIndex));
          offset = endIndex;
        }
        ret = ret && gen.push(BREAK);
      } else if (Array.isArray(obj)) {
        ret = ret && gen._pushArray(gen, obj, {
          indefinite: true
        });
      } else if (obj instanceof Map) {
        ret = ret && gen._pushMap(gen, obj, {
          indefinite: true
        });
      } else {
        if (objType !== "object") {
          throw new Error("Invalid indefinite encoding");
        }
        ret = ret && gen._pushObject(obj, {
          indefinite: true,
          skipTypes: true
        });
      }
      return ret;
    }
    static encode(...objs) {
      return new Encoder()._encodeAll(objs);
    }
    static encodeCanonical(...objs) {
      return new Encoder({
        canonical: true
      })._encodeAll(objs);
    }
    static encodeOne(obj, options) {
      return new Encoder(options)._encodeAll([obj]);
    }
    static encodeAsync(obj, options) {
      return new Promise((resolve, reject) => {
        const bufs = [];
        const enc = new Encoder(options);
        enc.on("data", (buf) => bufs.push(buf));
        enc.on("error", reject);
        enc.on("finish", () => resolve(Buffer.concat(bufs)));
        enc.pushAny(obj);
        enc.end();
      });
    }
  };
  module2.exports = Encoder;
});

// node_modules/cbor/lib/map.js
var require_map = __commonJS((exports2, module2) => {
  "use strict";
  var encoder = require_encoder3();
  var decoder = require_decoder2();
  var constants = require_constants5();
  var MT = constants.MT;
  var CborMap = class extends Map {
    constructor(iterable) {
      super(iterable);
    }
    static _encode(key) {
      return encoder.encodeCanonical(key).toString("base64");
    }
    static _decode(key) {
      return decoder.decodeFirstSync(key, "base64");
    }
    get(key) {
      return super.get(CborMap._encode(key));
    }
    set(key, val) {
      return super.set(CborMap._encode(key), val);
    }
    delete(key) {
      return super.delete(CborMap._encode(key));
    }
    has(key) {
      return super.has(CborMap._encode(key));
    }
    *keys() {
      for (const k of super.keys()) {
        yield CborMap._decode(k);
      }
    }
    *entries() {
      for (const kv of super.entries()) {
        yield [CborMap._decode(kv[0]), kv[1]];
      }
    }
    [Symbol.iterator]() {
      return this.entries();
    }
    forEach(fun, thisArg) {
      if (typeof fun !== "function") {
        throw new TypeError("Must be function");
      }
      for (const kv of super.entries()) {
        fun.call(this, kv[1], CborMap._decode(kv[0]), this);
      }
    }
    encodeCBOR(gen) {
      if (!gen._pushInt(this.size, MT.MAP)) {
        return false;
      }
      if (gen.canonical) {
        const entries = Array.from(super.entries()).map((kv) => [Buffer.from(kv[0], "base64"), kv[1]]);
        entries.sort((a, b) => a[0].compare(b[0]));
        for (const kv of entries) {
          if (!(gen.push(kv[0]) && gen.pushAny(kv[1]))) {
            return false;
          }
        }
      } else {
        for (const kv of super.entries()) {
          if (!(gen.push(Buffer.from(kv[0], "base64")) && gen.pushAny(kv[1]))) {
            return false;
          }
        }
      }
      return true;
    }
  };
  module2.exports = CborMap;
});

// node_modules/cbor/lib/cbor.js
var require_cbor = __commonJS((exports2) => {
  "use strict";
  exports2.BigNumber = require_constants5().BigNumber;
  exports2.Commented = require_commented();
  exports2.Diagnose = require_diagnose2();
  exports2.Decoder = require_decoder2();
  exports2.Encoder = require_encoder3();
  exports2.Simple = require_simple2();
  exports2.Tagged = require_tagged2();
  exports2.Map = require_map();
  exports2.comment = exports2.Commented.comment;
  exports2.decodeAll = exports2.Decoder.decodeAll;
  exports2.decodeFirst = exports2.Decoder.decodeFirst;
  exports2.decodeAllSync = exports2.Decoder.decodeAllSync;
  exports2.decodeFirstSync = exports2.Decoder.decodeFirstSync;
  exports2.diagnose = exports2.Diagnose.diagnose;
  exports2.encode = exports2.Encoder.encode;
  exports2.encodeCanonical = exports2.Encoder.encodeCanonical;
  exports2.encodeOne = exports2.Encoder.encodeOne;
  exports2.encodeAsync = exports2.Encoder.encodeAsync;
  exports2.decode = exports2.Decoder.decodeFirstSync;
  exports2.leveldb = {
    decode: exports2.Decoder.decodeFirstSync,
    encode: exports2.Encoder.encode,
    buffer: true,
    name: "cbor"
  };
  exports2.hasBigInt = true;
});

// node_modules/ipfs-core/src/components/pin/pin-manager.js
var require_pin_manager = __commonJS((exports2, module2) => {
  "use strict";
  var CID = require_src7();
  var errCode = require_err_code();
  var dagCborLinks = require_dag_cbor_links();
  var debug = require_browser4();
  var first = require_it_first();
  var all = require_it_all();
  var cbor = require_cbor();
  var multibase = require_src4();
  var multicodec = require_src6();
  function invalidPinTypeErr(type) {
    const errMsg = `Invalid type '${type}', must be one of {direct, indirect, recursive, all}`;
    return errCode(new Error(errMsg), "ERR_INVALID_PIN_TYPE");
  }
  var encoder = multibase.encoding("base32upper");
  function cidToKey(cid) {
    return `/${encoder.encode(cid.multihash)}`;
  }
  function keyToMultihash(key) {
    return encoder.decode(key.toString().slice(1));
  }
  var PinTypes = {
    direct: "direct",
    recursive: "recursive",
    indirect: "indirect",
    all: "all"
  };
  var PinManager = class {
    constructor({repo, dagReader}) {
      this.repo = repo;
      this.dag = dagReader;
      this.log = debug("ipfs:pin");
      this.directPins = new Set();
      this.recursivePins = new Set();
    }
    async *_walkDag(cid, {preload = false}) {
      const {value: node} = await this.dag.get(cid, {preload});
      if (cid.codec === "dag-pb") {
        for (const link of node.Links) {
          yield link.Hash;
          yield* this._walkDag(link.Hash, {preload});
        }
      } else if (cid.codec === "dag-cbor") {
        for (const [, childCid] of dagCborLinks(node)) {
          yield childCid;
          yield* this._walkDag(childCid, {preload});
        }
      }
    }
    async pinDirectly(cid, options = {}) {
      await this.dag.get(cid, options);
      const pin = {
        depth: 0
      };
      if (cid.version !== 0) {
        pin.version = cid.version;
      }
      if (cid.codec !== "dag-pb") {
        pin.codec = multicodec.getNumber(cid.codec);
      }
      if (options.metadata) {
        pin.metadata = options.metadata;
      }
      return this.repo.pins.put(cidToKey(cid), cbor.encode(pin));
    }
    async unpin(cid, options) {
      return this.repo.pins.delete(cidToKey(cid));
    }
    async pinRecursively(cid, options = {}) {
      await this.fetchCompleteDag(cid, options);
      const pin = {
        depth: Infinity
      };
      if (cid.version !== 0) {
        pin.version = cid.version;
      }
      if (cid.codec !== "dag-pb") {
        pin.codec = multicodec.getNumber(cid.codec);
      }
      if (options.metadata) {
        pin.metadata = options.metadata;
      }
      await this.repo.pins.put(cidToKey(cid), cbor.encode(pin));
    }
    async *directKeys(options) {
      for await (const entry of this.repo.pins.query({
        filters: [(entry2) => {
          const pin = cbor.decode(entry2.value);
          return pin.depth === 0;
        }]
      })) {
        const pin = cbor.decode(entry.value);
        const version = pin.version || 0;
        const codec = pin.codec ? multicodec.getName(pin.codec) : "dag-pb";
        const multihash = keyToMultihash(entry.key);
        yield {
          cid: new CID(version, codec, multihash),
          metadata: pin.metadata
        };
      }
    }
    async *recursiveKeys(options) {
      for await (const entry of this.repo.pins.query({
        filters: [(entry2) => {
          const pin = cbor.decode(entry2.value);
          return pin.depth === Infinity;
        }]
      })) {
        const pin = cbor.decode(entry.value);
        const version = pin.version || 0;
        const codec = pin.codec ? multicodec.getName(pin.codec) : "dag-pb";
        const multihash = keyToMultihash(entry.key);
        yield {
          cid: new CID(version, codec, multihash),
          metadata: pin.metadata
        };
      }
    }
    async *indirectKeys({preload}) {
      for await (const {cid} of this.recursiveKeys()) {
        for await (const childCid of this._walkDag(cid, {preload})) {
          const types = [
            PinTypes.recursive
          ];
          const result = await this.isPinnedWithType(childCid, types);
          if (result.pinned) {
            continue;
          }
          yield childCid;
        }
      }
    }
    async isPinnedWithType(cid, types, options) {
      if (!Array.isArray(types)) {
        types = [types];
      }
      const all2 = types.includes(PinTypes.all);
      const direct = types.includes(PinTypes.direct);
      const recursive = types.includes(PinTypes.recursive);
      const indirect = types.includes(PinTypes.indirect);
      if (recursive || direct || all2) {
        const result = await first(this.repo.pins.query({
          prefix: cidToKey(cid),
          filters: [(entry) => {
            if (all2) {
              return true;
            }
            const pin = cbor.decode(entry.value);
            return types.includes(pin.depth === 0 ? PinTypes.direct : PinTypes.recursive);
          }],
          limit: 1
        }));
        if (result) {
          const pin = cbor.decode(result.value);
          return {
            cid,
            pinned: true,
            reason: pin.depth === 0 ? PinTypes.direct : PinTypes.recursive,
            metadata: pin.metadata
          };
        }
      }
      const self2 = this;
      async function* findChild(key, source) {
        for await (const {cid: parentCid} of source) {
          for await (const childCid of self2._walkDag(parentCid, {preload: false})) {
            if (childCid.equals(key)) {
              yield parentCid;
              return;
            }
          }
        }
      }
      if (all2 || indirect) {
        const parentCid = await first(findChild(cid, this.recursiveKeys()));
        if (parentCid) {
          return {
            cid,
            pinned: true,
            reason: PinTypes.indirect,
            parent: parentCid
          };
        }
      }
      return {
        cid,
        pinned: false
      };
    }
    async fetchCompleteDag(cid, options) {
      await all(this._walkDag(cid, {preload: options.preload}));
    }
    static checkPinType(type) {
      if (typeof type !== "string" || !Object.keys(PinTypes).includes(type)) {
        throw invalidPinTypeErr(type);
      }
      return true;
    }
  };
  PinManager.PinTypes = PinTypes;
  module2.exports = PinManager;
});

// node_modules/ipfs-core-utils/src/pins/normalise-input.js
var require_normalise_input = __commonJS((exports2, module2) => {
  "use strict";
  var errCode = require_err_code();
  var CID = require_src7();
  module2.exports = async function* normaliseInput(input) {
    if (input === null || input === void 0) {
      throw errCode(new Error(`Unexpected input: ${input}`), "ERR_UNEXPECTED_INPUT");
    }
    if (CID.isCID(input)) {
      yield toPin({cid: input});
      return;
    }
    if (input instanceof String || typeof input === "string") {
      yield toPin({path: input});
      return;
    }
    if (input.cid != null || input.path != null) {
      return yield toPin(input);
    }
    if (input[Symbol.iterator]) {
      const iterator = input[Symbol.iterator]();
      const first = iterator.next();
      if (first.done)
        return iterator;
      if (CID.isCID(first.value) || first.value instanceof String || typeof first.value === "string") {
        yield toPin({cid: first.value});
        for (const cid of iterator) {
          yield toPin({cid});
        }
        return;
      }
      if (first.value.cid != null || first.value.path != null) {
        yield toPin(first.value);
        for (const obj of iterator) {
          yield toPin(obj);
        }
        return;
      }
      throw errCode(new Error("Unexpected input: " + typeof input), "ERR_UNEXPECTED_INPUT");
    }
    if (input[Symbol.asyncIterator]) {
      const iterator = input[Symbol.asyncIterator]();
      const first = await iterator.next();
      if (first.done)
        return iterator;
      if (CID.isCID(first.value) || first.value instanceof String || typeof first.value === "string") {
        yield toPin({cid: first.value});
        for await (const cid of iterator) {
          yield toPin({cid});
        }
        return;
      }
      if (first.value.cid != null || first.value.path != null) {
        yield toPin(first.value);
        for await (const obj of iterator) {
          yield toPin(obj);
        }
        return;
      }
      throw errCode(new Error("Unexpected input: " + typeof input), "ERR_UNEXPECTED_INPUT");
    }
    throw errCode(new Error("Unexpected input: " + typeof input), "ERR_UNEXPECTED_INPUT");
  };
  function toPin(input) {
    const pin = {
      path: input.path == null ? input.cid : `${input.path}`,
      recursive: input.recursive !== false
    };
    if (input.metadata != null) {
      pin.metadata = input.metadata;
    }
    return pin;
  }
});

// node_modules/ipfs-core/src/components/pin/add-all.js
var require_add_all = __commonJS((exports2, module2) => {
  "use strict";
  var {resolvePath} = require_utils7();
  var PinManager = require_pin_manager();
  var {PinTypes} = PinManager;
  var withTimeoutOption = require_with_timeout_option();
  var normaliseInput = require_normalise_input();
  module2.exports = ({pinManager, gcLock, dagReader}) => {
    async function* addAll(source, options = {}) {
      const pinAdd = async function* () {
        for await (const {path, recursive, metadata} of normaliseInput(source)) {
          const cid = await resolvePath(dagReader, path);
          const {reason} = await pinManager.isPinnedWithType(cid, [PinTypes.recursive, PinTypes.direct]);
          if (reason === "recursive" && !recursive) {
            throw new Error(`${cid} already pinned recursively`);
          }
          if (recursive) {
            await pinManager.pinRecursively(cid, {metadata});
          } else {
            await pinManager.pinDirectly(cid, {metadata});
          }
          yield cid;
        }
      };
      const lock = Boolean(options.lock);
      if (!lock) {
        yield* pinAdd();
        return;
      }
      const release = await gcLock.readLock();
      try {
        yield* pinAdd();
      } finally {
        release();
      }
    }
    return withTimeoutOption(addAll);
  };
});

// node_modules/ipfs-core/src/components/pin/ls.js
var require_ls = __commonJS((exports2, module2) => {
  "use strict";
  var PinManager = require_pin_manager();
  var {PinTypes} = PinManager;
  var normaliseInput = require_normalise_input();
  var {resolvePath} = require_utils7();
  var withTimeoutOption = require_with_timeout_option();
  function toPin(type, cid, metadata) {
    const output = {
      type,
      cid
    };
    if (metadata) {
      output.metadata = metadata;
    }
    return output;
  }
  module2.exports = ({pinManager, dagReader}) => {
    async function* ls(options = {}) {
      let type = PinTypes.all;
      if (options.type) {
        type = options.type;
        if (typeof options.type === "string") {
          type = options.type.toLowerCase();
        }
        PinManager.checkPinType(type);
      } else {
        options.type = PinTypes.all;
      }
      if (options.paths) {
        let matched = false;
        for await (const {path} of normaliseInput(options.paths)) {
          const cid = await resolvePath(dagReader, path);
          const {reason, pinned, parent, metadata} = await pinManager.isPinnedWithType(cid, type);
          if (!pinned) {
            throw new Error(`path '${path}' is not pinned`);
          }
          switch (reason) {
            case PinTypes.direct:
            case PinTypes.recursive:
              matched = true;
              yield toPin(reason, cid, metadata);
              break;
            default:
              matched = true;
              yield toPin(`${PinTypes.indirect} through ${parent}`, cid, metadata);
          }
        }
        if (!matched) {
          throw new Error("No match found");
        }
        return;
      }
      if (type === PinTypes.recursive || type === PinTypes.all) {
        for await (const {cid, metadata} of pinManager.recursiveKeys()) {
          yield toPin(PinTypes.recursive, cid, metadata);
        }
      }
      if (type === PinTypes.indirect || type === PinTypes.all) {
        for await (const cid of pinManager.indirectKeys(options)) {
          yield toPin(PinTypes.indirect, cid);
        }
      }
      if (type === PinTypes.direct || type === PinTypes.all) {
        for await (const {cid, metadata} of pinManager.directKeys()) {
          yield toPin(PinTypes.direct, cid, metadata);
        }
      }
    }
    return withTimeoutOption(ls);
  };
});

// node_modules/ipfs-core/src/components/pin/rm.js
var require_rm = __commonJS((exports2, module2) => {
  "use strict";
  var last = require_it_last();
  module2.exports = ({rmAll}) => async (path, options) => await last(rmAll({path, ...options}, options));
});

// node_modules/ipfs-core/src/components/pin/rm-all.js
var require_rm_all = __commonJS((exports2, module2) => {
  "use strict";
  var normaliseInput = require_normalise_input();
  var {resolvePath} = require_utils7();
  var withTimeoutOption = require_with_timeout_option();
  var {PinTypes} = require_pin_manager();
  module2.exports = ({pinManager, gcLock, dagReader}) => {
    async function* rmAll(source, _options = {}) {
      const release = await gcLock.readLock();
      try {
        for await (const {path, recursive} of normaliseInput(source)) {
          const cid = await resolvePath(dagReader, path);
          const {pinned, reason} = await pinManager.isPinnedWithType(cid, PinTypes.all);
          if (!pinned) {
            throw new Error(`${cid} is not pinned`);
          }
          switch (reason) {
            case PinTypes.recursive:
              if (!recursive) {
                throw new Error(`${cid} is pinned recursively`);
              }
              await pinManager.unpin(cid);
              yield cid;
              break;
            case PinTypes.direct:
              await pinManager.unpin(cid);
              yield cid;
              break;
            default:
              throw new Error(`${cid} is pinned indirectly under ${reason}`);
          }
        }
      } finally {
        release();
      }
    }
    return withTimeoutOption(rmAll);
  };
});

// node_modules/ipfs-core/src/components/pin/index.js
var require_pin = __commonJS((exports2, module2) => {
  "use strict";
  var createAdd = require_add();
  var createAddAll = require_add_all();
  var createLs = require_ls();
  var createRm = require_rm();
  var createRmAll = require_rm_all();
  var PinAPI = class {
    constructor({gcLock, dagReader, pinManager}) {
      const addAll = createAddAll({gcLock, dagReader, pinManager});
      this.addAll = addAll;
      this.add = createAdd({addAll});
      const rmAll = createRmAll({gcLock, dagReader, pinManager});
      this.rmAll = rmAll;
      this.rm = createRm({rmAll});
      this.ls = createLs({dagReader, pinManager});
    }
  };
  module2.exports = PinAPI;
});

// node_modules/ipfs-core/node_modules/uint8arrays/to-string.js
var require_to_string5 = __commonJS((exports2, module2) => {
  "use strict";
  var {encoding: getCodec} = require_src4();
  var {TextDecoder: TextDecoder2} = require_lib_browser();
  var utf8Decoder = new TextDecoder2("utf8");
  function uint8ArrayToAsciiString(array) {
    let string = "";
    for (let i = 0; i < array.length; i++) {
      string += String.fromCharCode(array[i]);
    }
    return string;
  }
  function toString(array, encoding = "utf8") {
    if (encoding === "utf8" || encoding === "utf-8") {
      return utf8Decoder.decode(array);
    }
    if (encoding === "ascii") {
      return uint8ArrayToAsciiString(array);
    }
    return getCodec(encoding).encode(array);
  }
  module2.exports = toString;
});

// node_modules/timestamp-nano/timestamp.js
var require_timestamp = __commonJS((exports2, module2) => {
  /**
   * Timestamp for 64-bit time_t, nanosecond precision and strftime
   *
   * @author Yusuke Kawasaki
   * @license MIT
   * @see https://github.com/kawanet/timestamp-nano
   */
  var Timestamp = function() {
    if (typeof module2 !== "undefined")
      module2.exports = Timestamp2;
    var SEC_DAY = 24 * 3600;
    var YEAR_SLOT = 3200;
    var DAY_SLOT = (365 * 400 + 97) * YEAR_SLOT / 400;
    var SEC_SLOT = SEC_DAY * DAY_SLOT;
    var MSEC_SLOT = SEC_SLOT * 1e3;
    var MAX_MSEC = 1e3 * 1e4 * 1e4 * SEC_DAY;
    var BIT24 = 16777216;
    var BIT32 = 65536 * 65536;
    var DEC6 = 1e3 * 1e3;
    var DEC9 = 1e3 * 1e3 * 1e3;
    var ZERO9 = "000000000";
    var trunc = Math.trunc || Math_trunc;
    var P = Timestamp2.prototype;
    Timestamp2.fromDate = fromDate;
    Timestamp2.fromInt64BE = buildFromInt64(0, 1, 2, 3, 0, 4);
    Timestamp2.fromInt64LE = buildFromInt64(3, 2, 1, 0, 4, 0);
    Timestamp2.fromString = fromString;
    Timestamp2.fromTimeT = fromTimeT;
    P.year = 0;
    P.time = 0;
    P.nano = 0;
    P.addNano = addNano;
    P.getNano = getNano;
    P.getTimeT = getTimeT;
    P.getYear = getYear;
    P.toDate = toDate;
    P.toJSON = toJSON;
    P.toString = toString;
    P.writeInt64BE = buildWriteInt64(0, 1, 2, 3, 0, 4);
    P.writeInt64LE = buildWriteInt64(3, 2, 1, 0, 4, 0);
    var FMT_JSON = "%Y-%m-%dT%H:%M:%S.%NZ";
    var FMT_MONTH = [
      "Jan",
      "Feb",
      "Mar",
      "Apr",
      "May",
      "Jun",
      "Jul",
      "Aug",
      "Sep",
      "Oct",
      "Nov",
      "Dec"
    ];
    var FMT_DAY = [
      "Sun",
      "Mon",
      "Tue",
      "Wed",
      "Thu",
      "Fri",
      "Sat"
    ];
    var FMT_STRING = {
      "%": "%",
      F: "%Y-%m-%d",
      n: "\n",
      R: "%H:%M",
      T: "%H:%M:%S",
      t: "	",
      X: "%T",
      Z: "GMT",
      z: "+0000"
    };
    return Timestamp2;
    function Timestamp2(time, nano, year) {
      var ts = this;
      if (!(ts instanceof Timestamp2))
        return new Timestamp2(time, nano, year);
      ts.time = +time || 0;
      ts.nano = +nano || 0;
      ts.year = +year || 0;
      normalize(ts);
    }
    function getYear() {
      var year = this.toDate().getUTCFullYear();
      return year + this.year;
    }
    function normalize(ts) {
      var year = ts.year;
      var time = ts.time;
      var nano = ts.nano;
      var changed;
      var slot;
      if (nano < 0 || DEC6 <= nano) {
        var n = Math.floor(nano / DEC6);
        nano -= n * DEC6;
        time += n;
        changed = 1;
      }
      var y = year % YEAR_SLOT;
      if (time < -MAX_MSEC || MAX_MSEC < time || y) {
        slot = trunc(time / MSEC_SLOT);
        if (slot) {
          year += slot * YEAR_SLOT;
          time -= slot * MSEC_SLOT;
        }
        var dt = newDate(time);
        dt.setUTCFullYear(y + dt.getUTCFullYear());
        year -= y;
        time = +dt;
        slot = trunc(year / YEAR_SLOT);
        var total = time + slot * MSEC_SLOT;
        if (slot && -MAX_MSEC <= total && total <= MAX_MSEC) {
          year -= slot * YEAR_SLOT;
          time = total;
        }
        changed = 1;
      }
      if (changed) {
        ts.year = year;
        ts.time = time;
        ts.nano = nano;
      }
      return ts;
    }
    function toDate() {
      var ts = normalize(this);
      return newDate(ts.time);
    }
    function newDate(time) {
      var dt = new Date(0);
      dt.setTime(time);
      return dt;
    }
    function addNano(nano) {
      this.nano += +nano || 0;
      return this;
    }
    function getNano() {
      var ts = normalize(this);
      return (ts.time % 1e3 * DEC6 + +ts.nano + DEC9) % DEC9;
    }
    function fromString(string) {
      var time;
      var ts = new Timestamp2();
      string += "";
      var array = string.replace(/^\s*[+\-]?\d+/, function(match) {
        var year = +match;
        var y = 1970 + (year - 1970) % 400;
        ts.year = year - y;
        return y;
      }).replace(/(?:Z|([+\-]\d{2}):?(\d{2}))$/, function(match, hour, min) {
        if (hour < 0)
          min *= -1;
        time = (+hour * 60 + +min) * 6e4;
        return "";
      }).replace(/\.\d+$/, function(match) {
        ts.nano = +(match + ZERO9).substr(1, 9);
        return "";
      }).split(/\D+/);
      if (array.length > 1) {
        array[1]--;
      } else {
        array[1] = 0;
      }
      ts.time = time = Date.UTC.apply(Date, array) - (time || 0);
      if (isNaN(time)) {
        throw new TypeError("Invalid Date");
      }
      return normalize(ts);
    }
    function fromDate(date) {
      return new Timestamp2(+date);
    }
    function fromTimeT(time) {
      return fromTime(time, 0);
    }
    function fromTime(low, high) {
      high |= 0;
      high *= BIT32;
      low = +low || 0;
      var slot = trunc(high / SEC_SLOT) + trunc(low / SEC_SLOT);
      var second = high % SEC_SLOT + low % SEC_SLOT;
      var offset = trunc(second / SEC_SLOT);
      if (offset) {
        slot += offset;
        second -= offset * SEC_SLOT;
      }
      return new Timestamp2(second * 1e3, 0, slot * YEAR_SLOT);
    }
    function getTimeT() {
      var ts = normalize(this);
      var time = Math.floor(ts.time / 1e3);
      var year = ts.year;
      if (year)
        time += year * DAY_SLOT * SEC_DAY / YEAR_SLOT;
      return time;
    }
    function toJSON() {
      return this.toString().replace(/0{1,6}Z$/, "Z");
    }
    function toString(format) {
      var ts = this;
      var dt = ts.toDate();
      var map = {
        H,
        L,
        M,
        N,
        S,
        Y,
        a,
        b,
        d,
        e,
        m
      };
      return strftime(format || FMT_JSON);
      function strftime(format2) {
        return format2.replace(/%./g, function(match) {
          var m2 = match[1];
          var c = FMT_STRING[m2];
          var f = map[m2];
          return c ? strftime(c) : f ? f() : match;
        });
      }
      function Y() {
        var year = ts.getYear();
        if (year > 999999) {
          return "+" + year;
        } else if (year > 9999) {
          return "+" + pad(year, 6);
        } else if (year >= 0) {
          return pad(year, 4);
        } else if (year >= -999999) {
          return "-" + pad(-year, 6);
        } else {
          return year;
        }
      }
      function m() {
        return pad2(dt.getUTCMonth() + 1);
      }
      function d() {
        return pad2(dt.getUTCDate());
      }
      function e() {
        return padS(dt.getUTCDate());
      }
      function H() {
        return pad2(dt.getUTCHours());
      }
      function M() {
        return pad2(dt.getUTCMinutes());
      }
      function S() {
        return pad2(dt.getUTCSeconds());
      }
      function L() {
        return pad(dt.getUTCMilliseconds(), 3);
      }
      function N() {
        return pad(ts.getNano(), 9);
      }
      function a() {
        return FMT_DAY[dt.getUTCDay()];
      }
      function b() {
        return FMT_MONTH[dt.getUTCMonth()];
      }
    }
    function buildWriteInt64(pos0, pos1, pos2, pos3, posH, posL) {
      return writeInt64;
      function writeInt64(buffer, offset) {
        var ts = normalize(this);
        if (!buffer)
          buffer = new Array(8);
        checkRange(buffer, offset |= 0);
        var second = Math.floor(ts.time / 1e3);
        var day = ts.year * (DAY_SLOT * SEC_DAY / YEAR_SLOT);
        var high = trunc(day / BIT32) + trunc(second / BIT32);
        var low = day % BIT32 + second % BIT32;
        var slot = Math.floor(low / BIT32);
        if (slot) {
          high += slot;
          low -= slot * BIT32;
        }
        writeUint32(buffer, offset + posH, high);
        writeUint32(buffer, offset + posL, low);
        return buffer;
      }
      function writeUint32(buffer, offset, value) {
        buffer[offset + pos0] = value >> 24 & 255;
        buffer[offset + pos1] = value >> 16 & 255;
        buffer[offset + pos2] = value >> 8 & 255;
        buffer[offset + pos3] = value & 255;
      }
    }
    function buildFromInt64(pos0, pos1, pos2, pos3, posH, posL) {
      return fromInt64;
      function fromInt64(buffer, offset) {
        checkRange(buffer, offset |= 0);
        var high = readUint32(buffer, offset + posH);
        var low = readUint32(buffer, offset + posL);
        return fromTime(low, high);
      }
      function readUint32(buffer, offset) {
        return buffer[offset + pos0] * BIT24 + (buffer[offset + pos1] << 16 | buffer[offset + pos2] << 8 | buffer[offset + pos3]);
      }
    }
    function checkRange(buffer, offset) {
      var last = buffer && buffer.length;
      if (last == null)
        throw new TypeError("Invalid Buffer");
      if (last < offset + 8)
        throw new RangeError("Out of range");
    }
    function Math_trunc(x) {
      var n = x - x % 1;
      return n === 0 && (x < 0 || x === 0 && 1 / x !== 1 / 0) ? -0 : n;
    }
    function padS(v) {
      return (v > 9 ? "" : " ") + (v | 0);
    }
    function pad2(v) {
      return (v > 9 ? "" : "0") + (v | 0);
    }
    function pad(v, len) {
      return (ZERO9 + (v | 0)).substr(-len);
    }
  }();
});

// node_modules/ipns/node_modules/uint8arrays/from-string.js
var require_from_string4 = __commonJS((exports2, module2) => {
  "use strict";
  var {encoding: getCodec} = require_src4();
  var {TextEncoder: TextEncoder2} = require_lib_browser();
  var utf8Encoder = new TextEncoder2();
  function asciiStringToUint8Array(string) {
    const array = new Uint8Array(string.length);
    for (let i = 0; i < string.length; i++) {
      array[i] = string.charCodeAt(i);
    }
    return array;
  }
  function fromString(string, encoding = "utf8") {
    if (encoding === "utf8" || encoding === "utf-8") {
      return utf8Encoder.encode(string);
    }
    if (encoding === "ascii") {
      return asciiStringToUint8Array(string);
    }
    return getCodec(encoding).decode(string);
  }
  module2.exports = fromString;
});

// node_modules/ipns/node_modules/uint8arrays/to-string.js
var require_to_string6 = __commonJS((exports2, module2) => {
  "use strict";
  var {encoding: getCodec} = require_src4();
  var {TextDecoder: TextDecoder2} = require_lib_browser();
  var utf8Decoder = new TextDecoder2("utf8");
  function uint8ArrayToAsciiString(array) {
    let string = "";
    for (let i = 0; i < array.length; i++) {
      string += String.fromCharCode(array[i]);
    }
    return string;
  }
  function toString(array, encoding = "utf8") {
    if (encoding === "utf8" || encoding === "utf-8") {
      return utf8Decoder.decode(array);
    }
    if (encoding === "ascii") {
      return uint8ArrayToAsciiString(array);
    }
    return getCodec(encoding).encode(array);
  }
  module2.exports = toString;
});

// node_modules/ipns/node_modules/uint8arrays/concat.js
var require_concat4 = __commonJS((exports2, module2) => {
  "use strict";
  function concat(arrays, length) {
    if (!length) {
      length = arrays.reduce((acc, curr) => acc + curr.length, 0);
    }
    const output = new Uint8Array(length);
    let offset = 0;
    for (const arr of arrays) {
      output.set(arr, offset);
      offset += arr.length;
    }
    return output;
  }
  module2.exports = concat;
});

// node_modules/ipns/src/pb/ipns.proto.js
var require_ipns_proto = __commonJS((exports2, module2) => {
  "use strict";
  var protons = require_src8();
  var message = `
message IpnsEntry {
  enum ValidityType {
		EOL = 0; // setting an EOL says "this record is valid until..."
	}

  required bytes value = 1;
	required bytes signature = 2;

	optional ValidityType validityType = 3;
	optional bytes validity = 4;

	optional uint64 sequence = 5;

	optional uint64 ttl = 6;

	// in order for nodes to properly validate a record upon receipt, they need the public
	// key associated with it. For old RSA keys, its easiest if we just send this as part of
	// the record itself. For newer ed25519 keys, the public key can be embedded in the
	// peerID, making this field unnecessary.
	optional bytes pubKey = 7;
}
`;
  module2.exports = protons(message).IpnsEntry;
});

// node_modules/ipns/src/utils.js
var require_utils10 = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports.toRFC3339 = (time) => {
    const year = time.getUTCFullYear();
    const month = String(time.getUTCMonth() + 1).padStart(2, "0");
    const day = String(time.getUTCDate()).padStart(2, "0");
    const hour = String(time.getUTCHours()).padStart(2, "0");
    const minute = String(time.getUTCMinutes()).padStart(2, "0");
    const seconds = String(time.getUTCSeconds()).padStart(2, "0");
    const milliseconds = time.getUTCMilliseconds();
    const nanoseconds = milliseconds * 1e3 * 1e3;
    return `${year}-${month}-${day}T${hour}:${minute}:${seconds}.${nanoseconds}Z`;
  };
  module2.exports.parseRFC3339 = (time) => {
    const rfc3339Matcher = new RegExp("(\\d{4})-(\\d{2})-(\\d{2})T(\\d{2}):(\\d{2}):(\\d{2})\\.(\\d+)Z");
    const m = String(time).trim().match(rfc3339Matcher);
    if (!m) {
      throw new Error("Invalid format");
    }
    const year = parseInt(m[1], 10);
    const month = parseInt(m[2], 10) - 1;
    const date = parseInt(m[3], 10);
    const hour = parseInt(m[4], 10);
    const minute = parseInt(m[5], 10);
    const second = parseInt(m[6], 10);
    const millisecond = parseInt(m[7].slice(0, -6), 10);
    return new Date(Date.UTC(year, month, date, hour, minute, second, millisecond));
  };
});

// node_modules/ipns/src/errors.js
var require_errors5 = __commonJS((exports2) => {
  "use strict";
  exports2.ERR_IPNS_EXPIRED_RECORD = "ERR_IPNS_EXPIRED_RECORD";
  exports2.ERR_UNRECOGNIZED_VALIDITY = "ERR_UNRECOGNIZED_VALIDITY";
  exports2.ERR_SIGNATURE_CREATION = "ERR_SIGNATURE_CREATION";
  exports2.ERR_SIGNATURE_VERIFICATION = "ERR_SIGNATURE_VERIFICATION";
  exports2.ERR_UNRECOGNIZED_FORMAT = "ERR_UNRECOGNIZED_FORMAT";
  exports2.ERR_PEER_ID_FROM_PUBLIC_KEY = "ERR_PEER_ID_FROM_PUBLIC_KEY";
  exports2.ERR_PUBLIC_KEY_FROM_ID = "ERR_PUBLIC_KEY_FROM_ID";
  exports2.ERR_UNDEFINED_PARAMETER = "ERR_UNDEFINED_PARAMETER";
});

// node_modules/ipns/src/index.js
var require_src21 = __commonJS((exports2, module2) => {
  "use strict";
  var NanoDate = require_timestamp();
  var {Key} = require_src15();
  var crypto2 = require_src10();
  var PeerId = require_src9();
  var multihash = require_src5();
  var errCode = require_err_code();
  var multibase = require_src4();
  var uint8ArrayFromString = require_from_string4();
  var uint8ArrayToString = require_to_string6();
  var uint8ArrayConcat = require_concat4();
  var debug = require_browser4();
  var log = debug("jsipns");
  log.error = debug("jsipns:error");
  var ipnsEntryProto = require_ipns_proto();
  var {parseRFC3339} = require_utils10();
  var ERRORS = require_errors5();
  var ID_MULTIHASH_CODE = multihash.names.id;
  var namespace = "/ipns/";
  var create = (privateKey, value, seq, lifetime) => {
    const isoValidity = new NanoDate(Date.now() + Number(lifetime)).toString();
    const validityType = ipnsEntryProto.ValidityType.EOL;
    return _create(privateKey, value, seq, isoValidity, validityType);
  };
  var createWithExpiration = (privateKey, value, seq, expiration) => {
    const validityType = ipnsEntryProto.ValidityType.EOL;
    return _create(privateKey, value, seq, expiration, validityType);
  };
  var _create = async (privateKey, value, seq, isoValidity, validityType) => {
    const signature = await sign(privateKey, value, validityType, isoValidity);
    const entry = {
      value: uint8ArrayFromString(value),
      signature,
      validityType,
      validity: uint8ArrayFromString(isoValidity),
      sequence: seq
    };
    log(`ipns entry for ${value} created`);
    return entry;
  };
  var validate = async (publicKey, entry) => {
    const {value, validityType, validity} = entry;
    const dataForSignature = ipnsEntryDataForSig(value, validityType, validity);
    let isValid;
    try {
      isValid = await publicKey.verify(dataForSignature, entry.signature);
    } catch (err) {
      isValid = false;
    }
    if (!isValid) {
      log.error("record signature verification failed");
      throw errCode(new Error("record signature verification failed"), ERRORS.ERR_SIGNATURE_VERIFICATION);
    }
    if (validityType === ipnsEntryProto.ValidityType.EOL) {
      let validityDate;
      try {
        validityDate = parseRFC3339(uint8ArrayToString(validity));
      } catch (e) {
        log.error("unrecognized validity format (not an rfc3339 format)");
        throw errCode(new Error("unrecognized validity format (not an rfc3339 format)"), ERRORS.ERR_UNRECOGNIZED_FORMAT);
      }
      if (validityDate < Date.now()) {
        log.error("record has expired");
        throw errCode(new Error("record has expired"), ERRORS.ERR_IPNS_EXPIRED_RECORD);
      }
    } else if (validityType) {
      log.error("unrecognized validity type");
      throw errCode(new Error("unrecognized validity type"), ERRORS.ERR_UNRECOGNIZED_VALIDITY);
    }
    log(`ipns entry for ${value} is valid`);
  };
  var embedPublicKey = async (publicKey, entry) => {
    if (!publicKey || !publicKey.bytes || !entry) {
      const error = new Error("one or more of the provided parameters are not defined");
      log.error(error);
      throw errCode(error, ERRORS.ERR_UNDEFINED_PARAMETER);
    }
    let peerId;
    try {
      peerId = await PeerId.createFromPubKey(publicKey.bytes);
    } catch (err) {
      throw errCode(err, ERRORS.ERR_PEER_ID_FROM_PUBLIC_KEY);
    }
    let extractedPublicKey;
    try {
      extractedPublicKey = extractPublicKeyFromId(peerId);
    } catch (err) {
      log.error(err);
      throw errCode(err, ERRORS.ERR_PUBLIC_KEY_FROM_ID);
    }
    if (extractedPublicKey) {
      return null;
    }
    try {
      entry.pubKey = crypto2.keys.marshalPublicKey(publicKey);
    } catch (err) {
      log.error(err);
      throw err;
    }
    return entry;
  };
  var extractPublicKey = (peerId, entry) => {
    if (!entry || !peerId) {
      const error = new Error("one or more of the provided parameters are not defined");
      log.error(error);
      throw errCode(error, ERRORS.ERR_UNDEFINED_PARAMETER);
    }
    if (entry.pubKey) {
      let pubKey;
      try {
        pubKey = crypto2.keys.unmarshalPublicKey(entry.pubKey);
      } catch (err) {
        log.error(err);
        throw err;
      }
      return pubKey;
    }
    if (peerId.pubKey) {
      return peerId.pubKey;
    }
    throw Object.assign(new Error("no public key is available"), {code: ERRORS.ERR_UNDEFINED_PARAMETER});
  };
  var rawStdEncoding = (key) => multibase.encode("base32", key).toString().slice(1).toUpperCase();
  var getLocalKey = (key) => new Key(`/ipns/${rawStdEncoding(key)}`);
  var getIdKeys = (pid) => {
    const pkBuffer = uint8ArrayFromString("/pk/");
    const ipnsBuffer = uint8ArrayFromString("/ipns/");
    return {
      routingPubKey: new Key(uint8ArrayConcat([pkBuffer, pid]), false),
      pkKey: new Key(rawStdEncoding(uint8ArrayConcat([pkBuffer, pid]))),
      routingKey: new Key(uint8ArrayConcat([ipnsBuffer, pid]), false),
      ipnsKey: new Key(rawStdEncoding(uint8ArrayConcat([ipnsBuffer, pid])))
    };
  };
  var sign = (privateKey, value, validityType, validity) => {
    try {
      const dataForSignature = ipnsEntryDataForSig(value, validityType, validity);
      return privateKey.sign(dataForSignature);
    } catch (error) {
      log.error("record signature creation failed");
      throw errCode(new Error("record signature creation failed: " + error.message), ERRORS.ERR_SIGNATURE_CREATION);
    }
  };
  var getValidityType = (validityType) => {
    if (validityType.toString() === "0") {
      return "EOL";
    }
    const error = new Error(`unrecognized validity type ${validityType.toString()}`);
    log.error(error);
    throw errCode(error, ERRORS.ERR_UNRECOGNIZED_VALIDITY);
  };
  var ipnsEntryDataForSig = (value, validityType, validity) => {
    if (!(value instanceof Uint8Array)) {
      value = uint8ArrayFromString(value);
    }
    if (!(validity instanceof Uint8Array)) {
      validity = uint8ArrayFromString(validity);
    }
    const validityTypeBuffer = uint8ArrayFromString(getValidityType(validityType));
    return uint8ArrayConcat([value, validity, validityTypeBuffer]);
  };
  var extractPublicKeyFromId = (peerId) => {
    const decodedId = multihash.decode(peerId.id);
    if (decodedId.code !== ID_MULTIHASH_CODE) {
      return null;
    }
    return crypto2.keys.unmarshalPublicKey(decodedId.digest);
  };
  var marshal = ipnsEntryProto.encode;
  var unmarshal = ipnsEntryProto.decode;
  var validator = {
    validate: async (marshalledData, key) => {
      const receivedEntry = unmarshal(marshalledData);
      const bufferId = key.slice("/ipns/".length);
      const peerId = PeerId.createFromBytes(bufferId);
      const pubKey = extractPublicKey(peerId, receivedEntry);
      await validate(pubKey, receivedEntry);
      return true;
    },
    select: (dataA, dataB) => {
      const entryA = unmarshal(dataA);
      const entryB = unmarshal(dataB);
      return entryA.sequence > entryB.sequence ? 0 : 1;
    }
  };
  module2.exports = {
    create,
    createWithExpiration,
    validate,
    embedPublicKey,
    extractPublicKey,
    getLocalKey,
    getIdKeys,
    marshal,
    unmarshal,
    validator,
    namespace,
    namespaceLength: namespace.length
  };
});

// node_modules/ipfs-core/src/ipns/publisher.js
var require_publisher = __commonJS((exports2, module2) => {
  "use strict";
  var PeerId = require_src9();
  var {Key, Errors} = require_src15();
  var errcode = require_err_code();
  var debug = require_browser4();
  var log = Object.assign(debug("ipfs:ipns:publisher"), {
    error: debug("ipfs:ipns:publisher:error")
  });
  var uint8ArrayToString = require_to_string5();
  var ipns = require_src21();
  var ERR_NOT_FOUND = Errors.notFoundError().code;
  var defaultRecordLifetime = 60 * 60 * 1e3;
  var IpnsPublisher = class {
    constructor(routing, datastore) {
      this._routing = routing;
      this._datastore = datastore;
    }
    async publishWithEOL(privKey, value, lifetime) {
      if (!privKey || !privKey.bytes) {
        throw errcode(new Error("invalid private key"), "ERR_INVALID_PRIVATE_KEY");
      }
      const peerId = await PeerId.createFromPrivKey(privKey.bytes);
      const record = await this._updateOrCreateRecord(privKey, value, lifetime, peerId);
      return this._putRecordToRouting(record, peerId);
    }
    publish(privKey, value) {
      return this.publishWithEOL(privKey, value, defaultRecordLifetime);
    }
    async _putRecordToRouting(record, peerId) {
      if (!PeerId.isPeerId(peerId)) {
        const errMsg = "peerId received is not valid";
        log.error(errMsg);
        throw errcode(new Error(errMsg), "ERR_INVALID_PEER_ID");
      }
      const publicKey = peerId._pubKey;
      const embedPublicKeyRecord = await ipns.embedPublicKey(publicKey, record);
      const keys = ipns.getIdKeys(peerId.toBytes());
      await this._publishEntry(keys.routingKey, embedPublicKeyRecord || record);
      await this._publishPublicKey(keys.routingPubKey, publicKey);
      return embedPublicKeyRecord || record;
    }
    async _publishEntry(key, entry) {
      if (!Key.isKey(key)) {
        const errMsg = "datastore key does not have a valid format";
        log.error(errMsg);
        throw errcode(new Error(errMsg), "ERR_INVALID_DATASTORE_KEY");
      }
      let entryData;
      try {
        entryData = ipns.marshal(entry);
      } catch (err) {
        log.error(err);
        throw err;
      }
      try {
        const res = await this._routing.put(key.uint8Array(), entryData);
        log(`ipns record for ${uint8ArrayToString(key.uint8Array(), "base64")} was stored in the routing`);
        return res;
      } catch (err) {
        const errMsg = `ipns record for ${uint8ArrayToString(key.uint8Array(), "base64")} could not be stored in the routing`;
        log.error(errMsg);
        log.error(err);
        throw errcode(new Error(errMsg), "ERR_PUTTING_TO_ROUTING");
      }
    }
    async _publishPublicKey(key, publicKey) {
      if (!Key.isKey(key)) {
        const errMsg = "datastore key does not have a valid format";
        log.error(errMsg);
        throw errcode(new Error(errMsg), "ERR_INVALID_DATASTORE_KEY");
      }
      if (!publicKey || !publicKey.bytes) {
        const errMsg = "one or more of the provided parameters are not defined";
        log.error(errMsg);
        throw errcode(new Error(errMsg), "ERR_UNDEFINED_PARAMETER");
      }
      try {
        const res = await this._routing.put(key.uint8Array(), publicKey.bytes);
        log(`public key for ${uint8ArrayToString(key.uint8Array(), "base64")} was stored in the routing`);
        return res;
      } catch (err) {
        const errMsg = `public key for ${uint8ArrayToString(key.uint8Array(), "base64")} could not be stored in the routing`;
        log.error(errMsg);
        log.error(err);
        throw errcode(new Error(errMsg), "ERR_PUTTING_TO_ROUTING");
      }
    }
    async _getPublished(peerId, options = {}) {
      if (!PeerId.isPeerId(peerId)) {
        const errMsg = "peerId received is not valid";
        log.error(errMsg);
        throw errcode(new Error(errMsg), "ERR_INVALID_PEER_ID");
      }
      const checkRouting = options.checkRouting !== false;
      try {
        const dsVal = await this._datastore.get(ipns.getLocalKey(peerId.id));
        return this._unmarshalData(dsVal);
      } catch (err) {
        if (err.code !== ERR_NOT_FOUND) {
          const errMsg = `unexpected error getting the ipns record ${peerId.id} from datastore`;
          log.error(errMsg);
          throw errcode(new Error(errMsg), "ERR_UNEXPECTED_DATASTORE_RESPONSE");
        }
        if (!checkRouting) {
          throw errcode(err);
        }
        try {
          const keys = ipns.getIdKeys(peerId.toBytes());
          const res = await this._routing.get(keys.routingKey.uint8Array());
          return this._unmarshalData(res);
        } catch (err2) {
          log.error(err2);
          throw err2;
        }
      }
    }
    _unmarshalData(data) {
      try {
        return ipns.unmarshal(data);
      } catch (err) {
        throw errcode(err, "ERR_INVALID_RECORD_DATA");
      }
    }
    async _updateOrCreateRecord(privKey, value, validity, peerId) {
      if (!PeerId.isPeerId(peerId)) {
        const errMsg = "peerId received is not valid";
        log.error(errMsg);
        throw errcode(new Error(errMsg), "ERR_INVALID_PEER_ID");
      }
      const getPublishedOptions = {
        checkRouting: true
      };
      let record;
      try {
        record = await this._getPublished(peerId, getPublishedOptions);
      } catch (err) {
        if (err.code !== ERR_NOT_FOUND) {
          const errMsg = `unexpected error when determining the last published IPNS record for ${peerId.id} ${err.stack}`;
          log.error(errMsg);
          throw errcode(new Error(errMsg), "ERR_DETERMINING_PUBLISHED_RECORD");
        }
      }
      let seqNumber = 0;
      if (record && record.sequence !== void 0) {
        seqNumber = record.value.toString() !== value ? record.sequence + 1 : record.sequence;
      }
      let entryData;
      try {
        entryData = await ipns.create(privKey, value, seqNumber, validity);
      } catch (err) {
        const errMsg = `ipns record for ${value} could not be created`;
        log.error(err);
        throw errcode(new Error(errMsg), "ERR_CREATING_IPNS_RECORD");
      }
      try {
        const data = ipns.marshal(entryData);
        await this._datastore.put(ipns.getLocalKey(peerId.id), data);
        log(`ipns record for ${value} was stored in the datastore`);
        return entryData;
      } catch (err) {
        const errMsg = `ipns record for ${value} could not be stored in the datastore`;
        log.error(errMsg);
        throw errcode(new Error(errMsg), "ERR_STORING_IN_DATASTORE");
      }
    }
  };
  IpnsPublisher.defaultRecordLifetime = defaultRecordLifetime;
  exports2 = module2.exports = IpnsPublisher;
});

// node_modules/ipfs-core/src/ipns/republisher.js
var require_republisher = __commonJS((exports2, module2) => {
  "use strict";
  var ipns = require_src21();
  var crypto2 = require_src10();
  var PeerId = require_src9();
  var errcode = require_err_code();
  var debug = require_browser4();
  var log = Object.assign(debug("ipfs:ipns:republisher"), {
    error: debug("ipfs:ipns:republisher:error")
  });
  var minute = 60 * 1e3;
  var hour = 60 * minute;
  var defaultBroadcastInterval = 4 * hour;
  var defaultRecordLifetime = 24 * hour;
  var IpnsRepublisher = class {
    constructor(publisher, datastore, peerId, keychain, options = {}) {
      this._publisher = publisher;
      this._datastore = datastore;
      this._peerId = peerId;
      this._keychain = keychain;
      this._options = options;
      this._republishHandle = null;
    }
    async start() {
      if (this._republishHandle) {
        throw errcode(new Error("republisher is already running"), "ERR_REPUBLISH_ALREADY_RUNNING");
      }
      const republishHandle = {
        _task: null,
        _inflightTask: null,
        _timeoutId: null,
        runPeriodically: (period) => {
          republishHandle._timeoutId = setTimeout(async () => {
            republishHandle._timeoutId = null;
            try {
              republishHandle._inflightTask = republishHandle._task();
              await republishHandle._inflightTask;
              if (republishHandle._task) {
                republishHandle.runPeriodically(period);
              }
            } catch (err) {
              log.error(err);
            }
          }, period());
        },
        cancel: async () => {
          if (republishHandle._timeoutId != null) {
            clearTimeout(republishHandle._timeoutId);
          }
          republishHandle._task = null;
          await republishHandle._inflightTask;
        }
      };
      const {privKey} = this._peerId;
      const {pass} = this._options;
      let firstRun = true;
      republishHandle._task = () => this._republishEntries(privKey, pass);
      republishHandle.runPeriodically(() => {
        if (firstRun) {
          firstRun = false;
          return this._options.initialBroadcastInterval || minute;
        }
        return this._options.broadcastInterval || defaultBroadcastInterval;
      });
      this._republishHandle = republishHandle;
    }
    async stop() {
      const republishHandle = this._republishHandle;
      if (!republishHandle) {
        throw errcode(new Error("republisher is not running"), "ERR_REPUBLISH_NOT_RUNNING");
      }
      this._republishHandle = null;
      await republishHandle.cancel();
    }
    async _republishEntries(privateKey, pass) {
      try {
        await this._republishEntry(privateKey);
      } catch (err) {
        const errMsg = "cannot republish entry for the node's private key";
        log.error(errMsg);
        return;
      }
      if (pass) {
        try {
          const keys = await this._keychain.listKeys();
          for (const key of keys) {
            const pem = await this._keychain.exportKey(key.name, pass);
            const privKey = await crypto2.keys.import(pem, pass);
            await this._republishEntry(privKey);
          }
        } catch (err) {
          log.error(err);
        }
      }
    }
    async _republishEntry(privateKey) {
      if (!privateKey || !privateKey.bytes) {
        throw errcode(new Error("invalid private key"), "ERR_INVALID_PRIVATE_KEY");
      }
      try {
        const peerId = await PeerId.createFromPrivKey(privateKey.bytes);
        const value = await this._getPreviousValue(peerId);
        await this._publisher.publishWithEOL(privateKey, value, defaultRecordLifetime);
      } catch (err) {
        if (err.code === "ERR_NO_ENTRY_FOUND") {
          return;
        }
        throw err;
      }
    }
    async _getPreviousValue(peerId) {
      if (!PeerId.isPeerId(peerId)) {
        throw errcode(new Error("invalid peer ID"), "ERR_INVALID_PEER_ID");
      }
      try {
        const dsVal = await this._datastore.get(ipns.getLocalKey(peerId.id));
        if (!(dsVal instanceof Uint8Array)) {
          throw errcode(new Error("found ipns record that we couldn't process"), "ERR_INVALID_IPNS_RECORD");
        }
        try {
          const record = ipns.unmarshal(dsVal);
          return record.value;
        } catch (err) {
          log.error(err);
          throw errcode(new Error("found ipns record that we couldn't convert to a value"), "ERR_INVALID_IPNS_RECORD");
        }
      } catch (err) {
        if (err && err.notFound) {
          throw errcode(new Error(`no previous entry for record with id: ${peerId.id}`), "ERR_NO_ENTRY_FOUND");
        }
        throw err;
      }
    }
  };
  exports2 = module2.exports = IpnsRepublisher;
});

// node_modules/ipfs-core/src/ipns/resolver.js
var require_resolver3 = __commonJS((exports2, module2) => {
  "use strict";
  var ipns = require_src21();
  var PeerId = require_src9();
  var errcode = require_err_code();
  var debug = require_browser4();
  var log = Object.assign(debug("ipfs:ipns:resolver"), {
    error: debug("ipfs:ipns:resolver:error")
  });
  var uint8ArrayToString = require_to_string5();
  var {Errors} = require_src15();
  var ERR_NOT_FOUND = Errors.notFoundError().code;
  var defaultMaximumRecursiveDepth = 32;
  var IpnsResolver = class {
    constructor(routing) {
      this._routing = routing;
    }
    async resolve(name, options = {}) {
      if (typeof name !== "string") {
        throw errcode(new Error("invalid name"), "ERR_INVALID_NAME");
      }
      const recursive = options.recursive && options.recursive.toString() === "true";
      const nameSegments = name.split("/");
      if (nameSegments.length !== 3 || nameSegments[0] !== "") {
        throw errcode(new Error("invalid name"), "ERR_INVALID_NAME");
      }
      const key = nameSegments[2];
      let depth;
      if (recursive) {
        depth = defaultMaximumRecursiveDepth;
      }
      const res = await this.resolver(key, depth);
      log(`${name} was locally resolved correctly`);
      return res;
    }
    async resolver(name, depth) {
      if (depth === 0) {
        const errMsg = `could not resolve name (recursion limit of ${defaultMaximumRecursiveDepth} exceeded)`;
        log.error(errMsg);
        throw errcode(new Error(errMsg), "ERR_RESOLVE_RECURSION_LIMIT");
      }
      const res = await this._resolveName(name);
      const nameSegments = res.split("/");
      if (nameSegments[1] === "ipfs" || !depth) {
        return res;
      }
      return this.resolver(nameSegments[2], depth - 1);
    }
    async _resolveName(name) {
      const peerId = PeerId.createFromCID(name);
      const {routingKey} = ipns.getIdKeys(peerId.toBytes());
      let record;
      try {
        record = await this._routing.get(routingKey.uint8Array());
      } catch (err) {
        log.error("could not get record from routing", err);
        if (err.code === ERR_NOT_FOUND) {
          throw errcode(new Error(`record requested for ${name} was not found in the network`), "ERR_NO_RECORD_FOUND");
        }
        throw errcode(new Error(`unexpected error getting the ipns record ${peerId.toString()}`), "ERR_UNEXPECTED_ERROR_GETTING_RECORD");
      }
      let ipnsEntry;
      try {
        ipnsEntry = ipns.unmarshal(record);
      } catch (err) {
        log.error("could not unmarshal record", err);
        throw errcode(new Error("found ipns record that we couldn't convert to a value"), "ERR_INVALID_RECORD_RECEIVED");
      }
      return this._validateRecord(peerId, ipnsEntry);
    }
    async _validateRecord(peerId, ipnsEntry) {
      const pubKey = await ipns.extractPublicKey(peerId, ipnsEntry);
      await ipns.validate(pubKey, ipnsEntry);
      return uint8ArrayToString(ipnsEntry.value);
    }
  };
  exports2 = module2.exports = IpnsResolver;
});

// node_modules/ipfs-core/src/ipns/index.js
var require_ipns = __commonJS((exports2, module2) => {
  "use strict";
  var {createFromPrivKey} = require_src9();
  var errcode = require_err_code();
  var debug = require_browser4();
  var log = Object.assign(debug("ipfs:ipns"), {
    error: debug("ipfs:ipns:error")
  });
  var IpnsPublisher = require_publisher();
  var IpnsRepublisher = require_republisher();
  var IpnsResolver = require_resolver3();
  var {normalizePath} = require_utils7();
  var TLRU = require_tlru();
  var defaultRecordTtl = 60 * 1e3;
  var IPNS = class {
    constructor(routing, datastore, peerId, keychain, options) {
      this.publisher = new IpnsPublisher(routing, datastore);
      this.republisher = new IpnsRepublisher(this.publisher, datastore, peerId, keychain, options);
      this.resolver = new IpnsResolver(routing);
      this.cache = new TLRU(1e3);
      this.routing = routing;
    }
    async publish(privKey, value, lifetime = IpnsPublisher.defaultRecordLifetime) {
      try {
        value = normalizePath(value);
        const peerId = await createFromPrivKey(privKey.bytes);
        await this.publisher.publishWithEOL(privKey, value, lifetime);
        log(`IPNS value ${value} was published correctly`);
        const id = peerId.toB58String();
        const ttEol = parseFloat(lifetime);
        const ttl = ttEol < defaultRecordTtl ? ttEol : defaultRecordTtl;
        this.cache.set(id, value, ttl);
        log(`IPNS value ${value} was cached correctly`);
        return {
          name: id,
          value
        };
      } catch (err) {
        log.error(err);
        throw err;
      }
    }
    async resolve(name, options = {}) {
      if (typeof name !== "string") {
        throw errcode(new Error("name received is not valid"), "ERR_INVALID_NAME");
      }
      if (!options.nocache && !options.recursive) {
        const id = name.split("/")[2];
        const result = this.cache.get(id);
        if (result) {
          return result;
        }
      }
      try {
        const result = await this.resolver.resolve(name, options);
        log(`IPNS record from ${name} was resolved correctly`);
        return result;
      } catch (err) {
        log.error(err);
        throw err;
      }
    }
    async initializeKeyspace(privKey, value) {
      return this.publish(privKey, value, IpnsPublisher.defaultRecordLifetime);
    }
  };
  module2.exports = IPNS;
});

// node_modules/datastore-core/src/keytransform.js
var require_keytransform = __commonJS((exports2, module2) => {
  "use strict";
  var {Adapter, utils} = require_src15();
  var map = utils.map;
  var KeyTransformDatastore = class extends Adapter {
    constructor(child, transform) {
      super();
      this.child = child;
      this.transform = transform;
    }
    open() {
      return this.child.open();
    }
    put(key, val, options) {
      return this.child.put(this.transform.convert(key), val, options);
    }
    get(key, options) {
      return this.child.get(this.transform.convert(key), options);
    }
    has(key, options) {
      return this.child.has(this.transform.convert(key), options);
    }
    delete(key, options) {
      return this.child.delete(this.transform.convert(key), options);
    }
    batch() {
      const b = this.child.batch();
      return {
        put: (key, value) => {
          b.put(this.transform.convert(key), value);
        },
        delete: (key) => {
          b.delete(this.transform.convert(key));
        },
        commit: (options) => {
          return b.commit(options);
        }
      };
    }
    query(q, options) {
      return map(this.child.query(q, options), (e) => {
        e.key = this.transform.invert(e.key);
        return e;
      });
    }
    close() {
      return this.child.close();
    }
  };
  module2.exports = KeyTransformDatastore;
});

// node_modules/datastore-core/src/shard-readme.js
var require_shard_readme = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = `This is a repository of IPLD objects. Each IPLD object is in a single file,
named <base32 encoding of cid>.data. Where <base32 encoding of cid> is the
"base32" encoding of the CID (as specified in
https://github.com/multiformats/multibase) without the 'B' prefix.
All the object files are placed in a tree of directories, based on a
function of the CID. This is a form of sharding similar to
the objects directory in git repositories. Previously, we used
prefixes, we now use the next-to-last two charters.
    func NextToLast(base32cid string) {
      nextToLastLen := 2
      offset := len(base32cid) - nextToLastLen - 1
      return str[offset : offset+nextToLastLen]
    }
For example, an object with a base58 CIDv1 of
    zb2rhYSxw4ZjuzgCnWSt19Q94ERaeFhu9uSqRgjSdx9bsgM6f
has a base32 CIDv1 of
    BAFKREIA22FLID5AJ2KU7URG47MDLROZIH6YF2KALU2PWEFPVI37YLKRSCA
and will be placed at
    SC/AFKREIA22FLID5AJ2KU7URG47MDLROZIH6YF2KALU2PWEFPVI37YLKRSCA.data
with 'SC' being the last-to-next two characters and the 'B' at the
beginning of the CIDv1 string is the multibase prefix that is not
stored in the filename.
`;
});

// node_modules/datastore-core/src/shard.js
var require_shard = __commonJS((exports2, module2) => {
  "use strict";
  var {Key, utils: {utf8Decoder}} = require_src15();
  var readme = require_shard_readme();
  var PREFIX = "/repo/flatfs/shard/";
  var SHARDING_FN = "SHARDING";
  var README_FN = "_README";
  var ShardBase = class {
    constructor(param) {
      this.param = param;
      this.name = "base";
      this._padding = "";
    }
    fun(s) {
      return "implement me";
    }
    toString() {
      return `${PREFIX}v1/${this.name}/${this.param}`;
    }
  };
  var Prefix = class extends ShardBase {
    constructor(prefixLen) {
      super(prefixLen);
      this._padding = "".padStart(prefixLen, "_");
      this.name = "prefix";
    }
    fun(noslash) {
      return (noslash + this._padding).slice(0, this.param);
    }
  };
  var Suffix = class extends ShardBase {
    constructor(suffixLen) {
      super(suffixLen);
      this._padding = "".padStart(suffixLen, "_");
      this.name = "suffix";
    }
    fun(noslash) {
      const s = this._padding + noslash;
      return s.slice(s.length - this.param);
    }
  };
  var NextToLast = class extends ShardBase {
    constructor(suffixLen) {
      super(suffixLen);
      this._padding = "".padStart(suffixLen + 1, "_");
      this.name = "next-to-last";
    }
    fun(noslash) {
      const s = this._padding + noslash;
      const offset = s.length - this.param - 1;
      return s.slice(offset, offset + this.param);
    }
  };
  function parseShardFun(str) {
    str = str.trim();
    if (str.length === 0) {
      throw new Error("empty shard string");
    }
    if (!str.startsWith(PREFIX)) {
      throw new Error(`invalid or no path prefix: ${str}`);
    }
    const parts = str.slice(PREFIX.length).split("/");
    const version = parts[0];
    if (version !== "v1") {
      throw new Error(`expect 'v1' version, got '${version}'`);
    }
    const name = parts[1];
    if (!parts[2]) {
      throw new Error("missing param");
    }
    const param = parseInt(parts[2], 10);
    switch (name) {
      case "prefix":
        return new Prefix(param);
      case "suffix":
        return new Suffix(param);
      case "next-to-last":
        return new NextToLast(param);
      default:
        throw new Error(`unkown sharding function: ${name}`);
    }
  }
  var readShardFun = async (path, store) => {
    const key = new Key(path).child(new Key(SHARDING_FN));
    const get = typeof store.getRaw === "function" ? store.getRaw.bind(store) : store.get.bind(store);
    const res = await get(key);
    return parseShardFun(utf8Decoder.decode(res || "").trim());
  };
  module2.exports = {
    readme,
    parseShardFun,
    readShardFun,
    Prefix,
    Suffix,
    NextToLast,
    README_FN,
    SHARDING_FN,
    PREFIX
  };
});

// node_modules/datastore-core/src/sharding.js
var require_sharding = __commonJS((exports2, module2) => {
  "use strict";
  var {Adapter, Key, utils: {utf8Encoder}} = require_src15();
  var sh = require_shard();
  var KeytransformStore = require_keytransform();
  var shardKey = new Key(sh.SHARDING_FN);
  var shardReadmeKey = new Key(sh.README_FN);
  var ShardingDatastore = class extends Adapter {
    constructor(store, shard) {
      super();
      this.child = new KeytransformStore(store, {
        convert: this._convertKey.bind(this),
        invert: this._invertKey.bind(this)
      });
      this.shard = shard;
    }
    async open() {
      await this.child.open();
      this.shard = await ShardingDatastore.create(this.child, this.shard);
    }
    _convertKey(key) {
      const s = key.toString();
      if (s === shardKey.toString() || s === shardReadmeKey.toString()) {
        return key;
      }
      const parent = new Key(this.shard.fun(s));
      return parent.child(key);
    }
    _invertKey(key) {
      const s = key.toString();
      if (s === shardKey.toString() || s === shardReadmeKey.toString()) {
        return key;
      }
      return Key.withNamespaces(key.list().slice(1));
    }
    static async createOrOpen(store, shard) {
      try {
        await ShardingDatastore.create(store, shard);
      } catch (err) {
        if (err && err.message !== "datastore exists")
          throw err;
      }
      return ShardingDatastore.open(store);
    }
    static async open(store) {
      const shard = await sh.readShardFun("/", store);
      return new ShardingDatastore(store, shard);
    }
    static async create(store, shard) {
      const hasShard = await store.has(shardKey);
      if (!hasShard) {
        const put = typeof store.putRaw === "function" ? store.putRaw.bind(store) : store.put.bind(store);
        await Promise.all([
          put(shardKey, utf8Encoder.encode(shard.toString() + "\n")),
          put(shardReadmeKey, utf8Encoder.encode(sh.readme))
        ]);
        return shard;
      }
      const diskShard = await sh.readShardFun("/", store);
      const a = (diskShard || "").toString();
      const b = shard.toString();
      if (a !== b) {
        throw new Error(`specified fun ${b} does not match repo shard fun ${a}`);
      }
      return diskShard;
    }
    put(key, val, options) {
      return this.child.put(key, val, options);
    }
    get(key, options) {
      return this.child.get(key, options);
    }
    has(key, options) {
      return this.child.has(key, options);
    }
    delete(key, options) {
      return this.child.delete(key, options);
    }
    batch() {
      return this.child.batch();
    }
    query(q, options) {
      const tq = {
        keysOnly: q.keysOnly,
        offset: q.offset,
        limit: q.limit,
        orders: [],
        filters: [
          (e) => e.key.toString() !== shardKey.toString(),
          (e) => e.key.toString() !== shardReadmeKey.toString()
        ]
      };
      const {prefix} = q;
      if (prefix != null) {
        tq.filters.push((e) => {
          return this._invertKey(e.key).toString().startsWith(prefix);
        });
      }
      if (q.filters != null) {
        const filters = q.filters.map((f) => (e) => {
          return f(Object.assign({}, e, {
            key: this._invertKey(e.key)
          }));
        });
        tq.filters = tq.filters.concat(filters);
      }
      if (q.orders != null) {
        tq.orders = q.orders.map((o) => async (res) => {
          res.forEach((e) => {
            e.key = this._invertKey(e.key);
          });
          const ordered = await o(res);
          ordered.forEach((e) => {
            e.key = this._convertKey(e.key);
          });
          return ordered;
        });
      }
      return this.child.query(tq, options);
    }
    close() {
      return this.child.close();
    }
  };
  module2.exports = ShardingDatastore;
});

// node_modules/datastore-core/src/mount.js
var require_mount = __commonJS((exports2, module2) => {
  "use strict";
  var {
    Adapter,
    Key,
    Errors,
    utils: {
      filter,
      take,
      sortAll,
      replaceStartWith
    }
  } = require_src15();
  var Keytransform = require_keytransform();
  var MountDatastore = class extends Adapter {
    constructor(mounts) {
      super();
      this.mounts = mounts.slice();
    }
    async open() {
      await Promise.all(this.mounts.map((m) => m.datastore.open()));
    }
    _lookup(key) {
      for (const mount of this.mounts) {
        if (mount.prefix.toString() === key.toString() || mount.prefix.isAncestorOf(key)) {
          const s = replaceStartWith(key.toString(), mount.prefix.toString());
          return {
            datastore: mount.datastore,
            mountpoint: mount.prefix,
            rest: new Key(s)
          };
        }
      }
    }
    put(key, value, options) {
      const match = this._lookup(key);
      if (match == null) {
        throw Errors.dbWriteFailedError(new Error("No datastore mounted for this key"));
      }
      return match.datastore.put(match.rest, value, options);
    }
    get(key, options) {
      const match = this._lookup(key);
      if (match == null) {
        throw Errors.notFoundError(new Error("No datastore mounted for this key"));
      }
      return match.datastore.get(match.rest, options);
    }
    has(key, options) {
      const match = this._lookup(key);
      if (match == null) {
        return Promise.resolve(false);
      }
      return match.datastore.has(match.rest, options);
    }
    delete(key, options) {
      const match = this._lookup(key);
      if (match == null) {
        throw Errors.dbDeleteFailedError(new Error("No datastore mounted for this key"));
      }
      return match.datastore.delete(match.rest, options);
    }
    async close() {
      await Promise.all(this.mounts.map((m) => {
        return m.datastore.close();
      }));
    }
    batch() {
      const batchMounts = {};
      const lookup = (key) => {
        const match = this._lookup(key);
        if (match == null) {
          throw new Error("No datastore mounted for this key");
        }
        const m = match.mountpoint.toString();
        if (batchMounts[m] == null) {
          batchMounts[m] = match.datastore.batch();
        }
        return {
          batch: batchMounts[m],
          rest: match.rest
        };
      };
      return {
        put: (key, value) => {
          const match = lookup(key);
          match.batch.put(match.rest, value);
        },
        delete: (key) => {
          const match = lookup(key);
          match.batch.delete(match.rest);
        },
        commit: async (options) => {
          await Promise.all(Object.keys(batchMounts).map((p) => batchMounts[p].commit(options)));
        }
      };
    }
    query(q, options) {
      const qs = this.mounts.map((m) => {
        const ks = new Keytransform(m.datastore, {
          convert: (key) => {
            throw new Error("should never be called");
          },
          invert: (key) => {
            return m.prefix.child(key);
          }
        });
        let prefix;
        if (q.prefix != null) {
          prefix = replaceStartWith(q.prefix, m.prefix.toString());
        }
        return ks.query({
          prefix,
          filters: q.filters,
          keysOnly: q.keysOnly
        }, options);
      });
      let it = _many(qs);
      if (q.filters)
        q.filters.forEach((f) => {
          it = filter(it, f);
        });
      if (q.orders)
        q.orders.forEach((o) => {
          it = sortAll(it, o);
        });
      if (q.offset != null) {
        let i = 0;
        it = filter(it, () => i++ >= q.offset);
      }
      if (q.limit != null)
        it = take(it, q.limit);
      return it;
    }
  };
  function _many(iterable) {
    return async function* () {
      for (let i = 0; i < iterable.length; i++) {
        for await (const v of iterable[i]) {
          yield v;
        }
      }
    }();
  }
  module2.exports = MountDatastore;
});

// node_modules/datastore-core/src/tiered.js
var require_tiered = __commonJS((exports2, module2) => {
  "use strict";
  var {Adapter, Errors} = require_src15();
  var log = require_browser4()("datastore:core:tiered");
  var TieredDatastore = class extends Adapter {
    constructor(stores) {
      super();
      this.stores = stores.slice();
    }
    async open() {
      try {
        await Promise.all(this.stores.map((store) => store.open()));
      } catch (err) {
        throw Errors.dbOpenFailedError();
      }
    }
    async put(key, value) {
      try {
        await Promise.all(this.stores.map((store) => store.put(key, value)));
      } catch (err) {
        throw Errors.dbWriteFailedError();
      }
    }
    async get(key, options) {
      for (const store of this.stores) {
        try {
          const res = await store.get(key, options);
          if (res)
            return res;
        } catch (err) {
          log(err);
        }
      }
      throw Errors.notFoundError();
    }
    async has(key, options) {
      for (const s of this.stores) {
        if (await s.has(key, options)) {
          return true;
        }
      }
      return false;
    }
    async delete(key, options) {
      try {
        await Promise.all(this.stores.map((store) => store.delete(key, options)));
      } catch (err) {
        throw Errors.dbDeleteFailedError();
      }
    }
    async close() {
      await Promise.all(this.stores.map((store) => store.close()));
    }
    batch() {
      const batches = this.stores.map((store) => store.batch());
      return {
        put: (key, value) => {
          batches.forEach((b) => b.put(key, value));
        },
        delete: (key) => {
          batches.forEach((b) => b.delete(key));
        },
        commit: async (options) => {
          for (const batch of batches) {
            await batch.commit(options);
          }
        }
      };
    }
    query(q, options) {
      return this.stores[this.stores.length - 1].query(q, options);
    }
  };
  module2.exports = TieredDatastore;
});

// node_modules/datastore-core/src/namespace.js
var require_namespace = __commonJS((exports2, module2) => {
  "use strict";
  var Key = require_src15().Key;
  var KeytransformDatastore = require_keytransform();
  var NamespaceDatastore = class extends KeytransformDatastore {
    constructor(child, prefix) {
      super(child, {
        convert(key) {
          return prefix.child(key);
        },
        invert(key) {
          if (prefix.toString() === "/") {
            return key;
          }
          if (!prefix.isAncestorOf(key)) {
            throw new Error(`Expected prefix: (${prefix.toString()}) in key: ${key.toString()}`);
          }
          return new Key(key.toString().slice(prefix.toString().length), false);
        }
      });
      this.prefix = prefix;
    }
    query(q, options) {
      if (q.prefix && this.prefix.toString() !== "/") {
        return super.query(Object.assign({}, q, {
          prefix: this.prefix.child(new Key(q.prefix)).toString()
        }));
      }
      return super.query(q, options);
    }
  };
  module2.exports = NamespaceDatastore;
});

// node_modules/datastore-core/src/index.js
var require_src22 = __commonJS((exports2, module2) => {
  "use strict";
  var KeytransformDatastore = require_keytransform();
  var ShardingDatastore = require_sharding();
  var MountDatastore = require_mount();
  var TieredDatastore = require_tiered();
  var NamespaceDatastore = require_namespace();
  var shard = require_shard();
  module2.exports = {
    KeytransformDatastore,
    ShardingDatastore,
    MountDatastore,
    TieredDatastore,
    NamespaceDatastore,
    shard
  };
});

// node_modules/dlv/dist/dlv.umd.js
var require_dlv_umd = __commonJS((exports2, module2) => {
  !function(t, n) {
    typeof exports2 == "object" && typeof module2 != "undefined" ? module2.exports = function(t2, n2, e, i, o) {
      for (n2 = n2.split ? n2.split(".") : n2, i = 0; i < n2.length; i++)
        t2 = t2 ? t2[n2[i]] : o;
      return t2 === o ? e : t2;
    } : typeof define == "function" && define.amd ? define(function() {
      return function(t2, n2, e, i, o) {
        for (n2 = n2.split ? n2.split(".") : n2, i = 0; i < n2.length; i++)
          t2 = t2 ? t2[n2[i]] : o;
        return t2 === o ? e : t2;
      };
    }) : t.dlv = function(t2, n2, e, i, o) {
      for (n2 = n2.split ? n2.split(".") : n2, i = 0; i < n2.length; i++)
        t2 = t2 ? t2[n2[i]] : o;
      return t2 === o ? e : t2;
    };
  }(exports2);
});

// node_modules/datastore-pubsub/node_modules/ipfs-utils/src/temp-dir.browser.js
var require_temp_dir_browser2 = __commonJS((exports2, module2) => {
  "use strict";
  var {nanoid} = require_index_browser2();
  var tempdir = (transform = (d) => d) => {
    return transform(nanoid());
  };
  module2.exports = tempdir;
});

// node_modules/datastore-pubsub/node_modules/ipfs-utils/src/globalthis.js
var require_globalthis2 = __commonJS((exports2, module2) => {
  (function() {
    if (typeof globalThis === "object")
      return;
    Object.defineProperty(Object.prototype, "__magic__", {
      get: function() {
        return this;
      },
      configurable: true
    });
    __magic__.globalThis = __magic__;
    delete Object.prototype.__magic__;
  })();
  module2.exports = globalThis;
});

// node_modules/datastore-pubsub/node_modules/ipfs-utils/src/text-encoder.browser.js
var require_text_encoder_browser = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = require_globalthis2().TextEncoder;
});

// node_modules/datastore-pubsub/node_modules/ipfs-utils/src/text-decoder.browser.js
var require_text_decoder_browser = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = require_globalthis2().TextDecoder;
});

// node_modules/datastore-pubsub/node_modules/interface-datastore/src/utils.js
var require_utils11 = __commonJS((exports2) => {
  "use strict";
  var tempdir = require_temp_dir_browser2();
  var TextEncoder2 = require_text_encoder_browser();
  var TextDecoder2 = require_text_decoder_browser();
  exports2.utf8Encoder = new TextEncoder2("utf8");
  exports2.utf8Decoder = new TextDecoder2("utf8");
  exports2.filter = (iterable, filterer) => {
    return async function* () {
      for await (const value of iterable) {
        const keep = await filterer(value);
        if (!keep)
          continue;
        yield value;
      }
    }();
  };
  exports2.sortAll = (iterable, sorter) => {
    return async function* () {
      let values = [];
      for await (const value of iterable)
        values.push(value);
      values = await sorter(values);
      for (const value of values)
        yield value;
    }();
  };
  exports2.take = (iterable, n) => {
    return async function* () {
      if (n <= 0)
        return;
      let i = 0;
      for await (const value of iterable) {
        yield value;
        i++;
        if (i >= n)
          return;
      }
    }();
  };
  exports2.map = (iterable, mapper) => {
    return async function* () {
      for await (const value of iterable) {
        yield mapper(value);
      }
    }();
  };
  exports2.replaceStartWith = function(s, r) {
    const matcher = new RegExp("^" + r);
    return s.replace(matcher, "");
  };
  exports2.tmpdir = tempdir;
});

// node_modules/datastore-pubsub/node_modules/interface-datastore/src/key.js
var require_key4 = __commonJS((exports2, module2) => {
  "use strict";
  var {nanoid} = require_index_browser2();
  var withIs = require_class_is();
  var {utf8Encoder, utf8Decoder} = require_utils11();
  var TextDecoder2 = require_text_decoder_browser();
  var pathSepS = "/";
  var pathSepB = utf8Encoder.encode(pathSepS);
  var pathSep = pathSepB[0];
  var Key = class {
    constructor(s, clean) {
      if (typeof s === "string") {
        this._buf = utf8Encoder.encode(s);
      } else if (s instanceof Uint8Array) {
        this._buf = s;
      } else {
        throw new Error("Invalid key, should be String of Uint8Array");
      }
      if (clean == null) {
        clean = true;
      }
      if (clean) {
        this.clean();
      }
      if (this._buf.byteLength === 0 || this._buf[0] !== pathSep) {
        throw new Error("Invalid key");
      }
    }
    toString(encoding = "utf8") {
      if (encoding === "utf8" || encoding === "utf-8") {
        return utf8Decoder.decode(this._buf);
      }
      return new TextDecoder2(encoding).decode(this._buf);
    }
    uint8Array() {
      return this._buf;
    }
    get [Symbol.toStringTag]() {
      return `Key(${this.toString()})`;
    }
    static withNamespaces(list) {
      return new _Key(list.join(pathSepS));
    }
    static random() {
      return new _Key(nanoid().replace(/-/g, ""));
    }
    clean() {
      if (!this._buf || this._buf.byteLength === 0) {
        this._buf = pathSepB;
      }
      if (this._buf[0] !== pathSep) {
        const bytes = new Uint8Array(this._buf.byteLength + 1);
        bytes.fill(pathSep, 0, 1);
        bytes.set(this._buf, 1);
        this._buf = bytes;
      }
      while (this._buf.byteLength > 1 && this._buf[this._buf.byteLength - 1] === pathSep) {
        this._buf = this._buf.subarray(0, -1);
      }
    }
    less(key) {
      const list1 = this.list();
      const list2 = key.list();
      for (let i = 0; i < list1.length; i++) {
        if (list2.length < i + 1) {
          return false;
        }
        const c1 = list1[i];
        const c2 = list2[i];
        if (c1 < c2) {
          return true;
        } else if (c1 > c2) {
          return false;
        }
      }
      return list1.length < list2.length;
    }
    reverse() {
      return Key.withNamespaces(this.list().slice().reverse());
    }
    namespaces() {
      return this.list();
    }
    baseNamespace() {
      const ns = this.namespaces();
      return ns[ns.length - 1];
    }
    list() {
      return this.toString().split(pathSepS).slice(1);
    }
    type() {
      return namespaceType(this.baseNamespace());
    }
    name() {
      return namespaceValue(this.baseNamespace());
    }
    instance(s) {
      return new _Key(this.toString() + ":" + s);
    }
    path() {
      let p = this.parent().toString();
      if (!p.endsWith(pathSepS)) {
        p += pathSepS;
      }
      p += this.type();
      return new _Key(p);
    }
    parent() {
      const list = this.list();
      if (list.length === 1) {
        return new _Key(pathSepS);
      }
      return new _Key(list.slice(0, -1).join(pathSepS));
    }
    child(key) {
      if (this.toString() === pathSepS) {
        return key;
      } else if (key.toString() === pathSepS) {
        return this;
      }
      return new _Key(this.toString() + key.toString(), false);
    }
    isAncestorOf(other) {
      if (other.toString() === this.toString()) {
        return false;
      }
      return other.toString().startsWith(this.toString());
    }
    isDecendantOf(other) {
      if (other.toString() === this.toString()) {
        return false;
      }
      return this.toString().startsWith(other.toString());
    }
    isTopLevel() {
      return this.list().length === 1;
    }
    concat(...keys) {
      return Key.withNamespaces([...this.namespaces(), ...flatten(keys.map((key) => key.namespaces()))]);
    }
  };
  function namespaceType(ns) {
    const parts = ns.split(":");
    if (parts.length < 2) {
      return "";
    }
    return parts.slice(0, -1).join(":");
  }
  function namespaceValue(ns) {
    const parts = ns.split(":");
    return parts[parts.length - 1];
  }
  function flatten(arr) {
    return [].concat(...arr);
  }
  var _Key = withIs(Key, {className: "Key", symbolName: "@ipfs/interface-datastore/key"});
  module2.exports = _Key;
});

// node_modules/datastore-pubsub/node_modules/interface-datastore/src/adapter.js
var require_adapter2 = __commonJS((exports2, module2) => {
  "use strict";
  var {filter, sortAll, take, map} = require_utils11();
  var drain = require_it_drain();
  var InterfaceDatastoreAdapter = class {
    async open() {
    }
    async close() {
    }
    async put(key, val, options = {}) {
    }
    async *putMany(source, options = {}) {
      for await (const {key, value} of source) {
        await this.put(key, value, options);
        yield {key, value};
      }
    }
    async get(key, options = {}) {
    }
    async *getMany(source, options = {}) {
      for await (const key of source) {
        yield this.get(key, options);
      }
    }
    async has(key) {
    }
    async delete(key, options = {}) {
    }
    async *deleteMany(source, options = {}) {
      for await (const key of source) {
        await this.delete(key, options);
        yield key;
      }
    }
    batch() {
      let puts = [];
      let dels = [];
      return {
        put(key, value) {
          puts.push({key, value});
        },
        delete(key) {
          dels.push(key);
        },
        commit: async (options) => {
          await drain(this.putMany(puts, options));
          puts = [];
          await drain(this.deleteMany(dels, options));
          dels = [];
        }
      };
    }
    async *_all(q, options) {
    }
    async *query(q, options) {
      let it = this._all(q, options);
      if (q.prefix != null) {
        it = filter(it, (e) => e.key.toString().startsWith(q.prefix));
      }
      if (Array.isArray(q.filters)) {
        it = q.filters.reduce((it2, f) => filter(it2, f), it);
      }
      if (Array.isArray(q.orders)) {
        it = q.orders.reduce((it2, f) => sortAll(it2, f), it);
      }
      if (q.offset != null) {
        let i = 0;
        it = filter(it, () => i++ >= q.offset);
      }
      if (q.limit != null) {
        it = take(it, q.limit);
      }
      if (q.keysOnly === true) {
        it = map(it, (e) => ({key: e.key}));
      }
      yield* it;
    }
  };
  module2.exports = InterfaceDatastoreAdapter;
});

// node_modules/datastore-pubsub/node_modules/interface-datastore/src/errors.js
var require_errors6 = __commonJS((exports2, module2) => {
  "use strict";
  var errcode = require_err_code();
  module2.exports.dbOpenFailedError = (err) => {
    err = err || new Error("Cannot open database");
    return errcode(err, "ERR_DB_OPEN_FAILED");
  };
  module2.exports.dbDeleteFailedError = (err) => {
    err = err || new Error("Delete failed");
    return errcode(err, "ERR_DB_DELETE_FAILED");
  };
  module2.exports.dbWriteFailedError = (err) => {
    err = err || new Error("Write failed");
    return errcode(err, "ERR_DB_WRITE_FAILED");
  };
  module2.exports.notFoundError = (err) => {
    err = err || new Error("Not Found");
    return errcode(err, "ERR_NOT_FOUND");
  };
  module2.exports.abortedError = (err) => {
    err = err || new Error("Aborted");
    return errcode(err, "ERR_ABORTED");
  };
});

// node_modules/datastore-pubsub/node_modules/interface-datastore/src/memory.js
var require_memory2 = __commonJS((exports2, module2) => {
  "use strict";
  var Key = require_key4();
  var Adapter = require_adapter2();
  var Errors = require_errors6();
  var MemoryDatastore = class extends Adapter {
    constructor() {
      super();
      this.data = {};
    }
    async put(key, val) {
      this.data[key.toString()] = val;
    }
    async get(key) {
      const exists = await this.has(key);
      if (!exists)
        throw Errors.notFoundError();
      return this.data[key.toString()];
    }
    async has(key) {
      return this.data[key.toString()] !== void 0;
    }
    async delete(key) {
      delete this.data[key.toString()];
    }
    *_all() {
      yield* Object.entries(this.data).map(([key, value]) => ({key: new Key(key), value}));
    }
  };
  module2.exports = MemoryDatastore;
});

// node_modules/datastore-pubsub/node_modules/interface-datastore/src/index.js
var require_src23 = __commonJS((exports2) => {
  "use strict";
  var Key = require_key4();
  var MemoryDatastore = require_memory2();
  var utils = require_utils11();
  var Errors = require_errors6();
  var Adapter = require_adapter2();
  exports2.Key = Key;
  exports2.MemoryDatastore = MemoryDatastore;
  exports2.utils = utils;
  exports2.Errors = Errors;
  exports2.Adapter = Adapter;
});

// node_modules/datastore-pubsub/node_modules/uint8arrays/to-string.js
var require_to_string7 = __commonJS((exports2, module2) => {
  "use strict";
  var {encoding: getCodec} = require_src4();
  var {TextDecoder: TextDecoder2} = require_lib_browser();
  var utf8Decoder = new TextDecoder2("utf8");
  function uint8ArrayToAsciiString(array) {
    let string = "";
    for (let i = 0; i < array.length; i++) {
      string += String.fromCharCode(array[i]);
    }
    return string;
  }
  function toString(array, encoding = "utf8") {
    if (encoding === "utf8" || encoding === "utf-8") {
      return utf8Decoder.decode(array);
    }
    if (encoding === "ascii") {
      return uint8ArrayToAsciiString(array);
    }
    return getCodec(encoding).encode(array);
  }
  module2.exports = toString;
});

// node_modules/datastore-pubsub/node_modules/uint8arrays/from-string.js
var require_from_string5 = __commonJS((exports2, module2) => {
  "use strict";
  var {encoding: getCodec} = require_src4();
  var {TextEncoder: TextEncoder2} = require_lib_browser();
  var utf8Encoder = new TextEncoder2();
  function asciiStringToUint8Array(string) {
    const array = new Uint8Array(string.length);
    for (let i = 0; i < string.length; i++) {
      array[i] = string.charCodeAt(i);
    }
    return array;
  }
  function fromString(string, encoding = "utf8") {
    if (encoding === "utf8" || encoding === "utf-8") {
      return utf8Encoder.encode(string);
    }
    if (encoding === "ascii") {
      return asciiStringToUint8Array(string);
    }
    return getCodec(encoding).decode(string);
  }
  module2.exports = fromString;
});

// node_modules/datastore-pubsub/src/utils.js
var require_utils12 = __commonJS((exports2, module2) => {
  "use strict";
  var errcode = require_err_code();
  var uint8ArrayToString = require_to_string7();
  var uint8ArrayFromString = require_from_string5();
  var namespace = "/record/";
  module2.exports.encodeBase32 = (buf) => {
    return uint8ArrayToString(buf, "base32");
  };
  module2.exports.keyToTopic = (key) => {
    if (typeof key === "string" || key instanceof String) {
      key = uint8ArrayFromString(key);
    }
    const b64url = uint8ArrayToString(key, "base64url");
    return `${namespace}${b64url}`;
  };
  module2.exports.topicToKey = (topic) => {
    if (topic.substring(0, namespace.length) !== namespace) {
      throw errcode(new Error("topic received is not from a record"), "ERR_TOPIC_IS_NOT_FROM_RECORD_NAMESPACE");
    }
    const key = topic.substring(namespace.length);
    return uint8ArrayFromString(key, "base64url");
  };
});

// node_modules/datastore-pubsub/src/index.js
var require_src24 = __commonJS((exports2, module2) => {
  "use strict";
  var {Key, Adapter} = require_src23();
  var {encodeBase32, keyToTopic, topicToKey} = require_utils12();
  var errcode = require_err_code();
  var debug = require_browser4();
  var log = debug("datastore-pubsub:publisher");
  log.error = debug("datastore-pubsub:publisher:error");
  var DatastorePubsub = class extends Adapter {
    constructor(pubsub, datastore, peerId, validator, subscriptionKeyFn) {
      super();
      if (!validator) {
        throw errcode(new TypeError("missing validator"), "ERR_INVALID_PARAMETERS");
      }
      if (typeof validator.validate !== "function") {
        throw errcode(new TypeError("missing validate function"), "ERR_INVALID_PARAMETERS");
      }
      if (typeof validator.select !== "function") {
        throw errcode(new TypeError("missing select function"), "ERR_INVALID_PARAMETERS");
      }
      if (subscriptionKeyFn && typeof subscriptionKeyFn !== "function") {
        throw errcode(new TypeError("invalid subscriptionKeyFn received"), "ERR_INVALID_PARAMETERS");
      }
      this._pubsub = pubsub;
      this._datastore = datastore;
      this._peerId = peerId;
      this._validator = validator;
      this._handleSubscriptionKeyFn = subscriptionKeyFn;
      this._onMessage = this._onMessage.bind(this);
    }
    async put(key, val) {
      if (!(key instanceof Uint8Array)) {
        const errMsg = "datastore key does not have a valid format";
        log.error(errMsg);
        throw errcode(new Error(errMsg), "ERR_INVALID_DATASTORE_KEY");
      }
      if (!(val instanceof Uint8Array)) {
        const errMsg = "received value is not a Uint8Array";
        log.error(errMsg);
        throw errcode(new Error(errMsg), "ERR_INVALID_VALUE_RECEIVED");
      }
      const stringifiedTopic = keyToTopic(key);
      log(`publish value for topic ${stringifiedTopic}`);
      return this._pubsub.publish(stringifiedTopic, val);
    }
    async get(key) {
      if (!(key instanceof Uint8Array)) {
        const errMsg = "datastore key does not have a valid format";
        log.error(errMsg);
        throw errcode(new Error(errMsg), "ERR_INVALID_DATASTORE_KEY");
      }
      const stringifiedTopic = keyToTopic(key);
      const subscriptions = await this._pubsub.getTopics();
      if (subscriptions && Array.isArray(subscriptions) && subscriptions.indexOf(stringifiedTopic) > -1) {
        return this._getLocal(key);
      }
      try {
        await this._pubsub.subscribe(stringifiedTopic, this._onMessage);
      } catch (err) {
        const errMsg = `cannot subscribe topic ${stringifiedTopic}`;
        log.error(errMsg);
        throw errcode(new Error(errMsg), "ERR_SUBSCRIBING_TOPIC");
      }
      log(`subscribed values for key ${stringifiedTopic}`);
      return this._getLocal(key);
    }
    unsubscribe(key) {
      const stringifiedTopic = keyToTopic(key);
      return this._pubsub.unsubscribe(stringifiedTopic, this._onMessage);
    }
    async _getLocal(key) {
      const routingKey = new Key("/" + encodeBase32(key), false);
      let dsVal;
      try {
        dsVal = await this._datastore.get(routingKey);
      } catch (err) {
        if (err.code !== "ERR_NOT_FOUND") {
          const errMsg2 = `unexpected error getting the ipns record for ${routingKey.toString()}`;
          log.error(errMsg2);
          throw errcode(new Error(errMsg2), "ERR_UNEXPECTED_ERROR_GETTING_RECORD");
        }
        const errMsg = `local record requested was not found for ${routingKey.toString()}`;
        log.error(errMsg);
        throw errcode(new Error(errMsg), "ERR_NOT_FOUND");
      }
      if (!(dsVal instanceof Uint8Array)) {
        const errMsg = "found record that we couldn't convert to a value";
        log.error(errMsg);
        throw errcode(new Error(errMsg), "ERR_INVALID_RECORD_RECEIVED");
      }
      return dsVal;
    }
    async _onMessage(msg) {
      const {data, from, topicIDs} = msg;
      let key;
      try {
        key = topicToKey(topicIDs[0]);
      } catch (err) {
        log.error(err);
        return;
      }
      log(`message received for topic ${topicIDs[0]}`);
      if (from === this._peerId.toB58String()) {
        log("message discarded as it is from the same peer");
        return;
      }
      if (this._handleSubscriptionKeyFn) {
        let res;
        try {
          res = await this._handleSubscriptionKeyFn(key);
        } catch (err) {
          log.error("message discarded by the subscriptionKeyFn");
          return;
        }
        key = res;
      }
      try {
        await this._storeIfSubscriptionIsBetter(key, data);
      } catch (err) {
        log.error(err);
      }
    }
    async _storeIfSubscriptionIsBetter(key, data) {
      let isBetter = false;
      try {
        isBetter = await this._isBetter(key, data);
      } catch (err) {
        if (err.code !== "ERR_NOT_VALID_RECORD") {
          throw err;
        }
      }
      if (isBetter) {
        await this._storeRecord(key, data);
      }
    }
    async _validateRecord(value, peerId) {
      return this._validator.validate(value, peerId);
    }
    async _selectRecord(receivedRecord, currentRecord) {
      const res = await this._validator.select(receivedRecord, currentRecord);
      return res === 0;
    }
    async _isBetter(key, val) {
      let error, valid;
      try {
        valid = await this._validateRecord(val, key);
      } catch (err) {
        error = err;
      }
      if (error || !valid) {
        const errMsg = "record received through pubsub is not valid";
        log.error(errMsg);
        throw errcode(new Error(errMsg), "ERR_NOT_VALID_RECORD");
      }
      const dsKey = new Key(key);
      let currentRecord;
      try {
        currentRecord = await this._getLocal(dsKey.uint8Array());
      } catch (err) {
        return true;
      }
      if (currentRecord.equals(val)) {
        return false;
      }
      return this._selectRecord(val, currentRecord);
    }
    async _storeRecord(key, data) {
      const routingKey = new Key("/" + encodeBase32(key), false);
      await this._datastore.put(routingKey, data);
      log(`record for ${keyToTopic(key)} was stored in the datastore`);
    }
    open() {
      const errMsg = "open function was not implemented yet";
      log.error(errMsg);
      throw errcode(new Error(errMsg), "ERR_NOT_IMPLEMENTED_YET");
    }
    has(key) {
      const errMsg = "has function was not implemented yet";
      log.error(errMsg);
      throw errcode(new Error(errMsg), "ERR_NOT_IMPLEMENTED_YET");
    }
    delete(key) {
      const errMsg = "delete function was not implemented yet";
      log.error(errMsg);
      throw errcode(new Error(errMsg), "ERR_NOT_IMPLEMENTED_YET");
    }
    close() {
      const errMsg = "close function was not implemented yet";
      log.error(errMsg);
      throw errcode(new Error(errMsg), "ERR_NOT_IMPLEMENTED_YET");
    }
    batch() {
      const errMsg = "batch function was not implemented yet";
      log.error(errMsg);
      throw errcode(new Error(errMsg), "ERR_NOT_IMPLEMENTED_YET");
    }
    query() {
      const errMsg = "query function was not implemented yet";
      log.error(errMsg);
      throw errcode(new Error(errMsg), "ERR_NOT_IMPLEMENTED_YET");
    }
  };
  exports2 = module2.exports = DatastorePubsub;
});

// node_modules/ipfs-core/node_modules/uint8arrays/from-string.js
var require_from_string6 = __commonJS((exports2, module2) => {
  "use strict";
  var {encoding: getCodec} = require_src4();
  var {TextEncoder: TextEncoder2} = require_lib_browser();
  var utf8Encoder = new TextEncoder2();
  function asciiStringToUint8Array(string) {
    const array = new Uint8Array(string.length);
    for (let i = 0; i < string.length; i++) {
      array[i] = string.charCodeAt(i);
    }
    return array;
  }
  function fromString(string, encoding = "utf8") {
    if (encoding === "utf8" || encoding === "utf-8") {
      return utf8Encoder.encode(string);
    }
    if (encoding === "ascii") {
      return asciiStringToUint8Array(string);
    }
    return getCodec(encoding).decode(string);
  }
  module2.exports = fromString;
});

// node_modules/ipfs-core/src/ipns/routing/pubsub-datastore.js
var require_pubsub_datastore = __commonJS((exports2, module2) => {
  "use strict";
  var ipns = require_src21();
  var {toB58String} = require_src14().multihash;
  var PubsubDatastore = require_src24();
  var uint8ArrayToString = require_to_string5();
  var uint8ArrayFromString = require_from_string6();
  var withIs = require_class_is();
  var errcode = require_err_code();
  var debug = require_browser4();
  var log = Object.assign(debug("ipfs:ipns:pubsub"), {
    error: debug("ipfs:ipns:pubsub:error")
  });
  var IpnsPubsubDatastore = class {
    constructor(pubsub, localDatastore, peerId) {
      this._pubsub = pubsub;
      this._subscriptions = {};
      this._handleSubscriptionKey = this._handleSubscriptionKey.bind(this);
      this._pubsubDs = new PubsubDatastore(pubsub, localDatastore, peerId, ipns.validator, this._handleSubscriptionKey);
    }
    async put(key, value) {
      return this._pubsubDs.put(key, value);
    }
    async get(key) {
      let res;
      let err;
      try {
        res = await this._pubsubDs.get(key);
      } catch (e) {
        err = e;
      }
      const ns = key.slice(0, ipns.namespaceLength);
      if (uint8ArrayToString(ns) === ipns.namespace) {
        const stringifiedTopic = toB58String(key);
        const id = toB58String(key.slice(ipns.namespaceLength));
        this._subscriptions[stringifiedTopic] = id;
        log(`subscribed to pubsub topic ${stringifiedTopic}, id ${id}`);
      }
      if (err) {
        throw err;
      }
      return res;
    }
    _handleSubscriptionKey(key) {
      if (key instanceof Uint8Array) {
        key = uint8ArrayToString(key, "base58btc");
      }
      const subscriber = this._subscriptions[key];
      if (!subscriber) {
        throw errcode(new Error(`key ${key} does not correspond to a subscription`), "ERR_INVALID_KEY");
      }
      let keys;
      try {
        keys = ipns.getIdKeys(uint8ArrayFromString(subscriber, "base58btc"));
      } catch (err) {
        log.error(err);
        throw err;
      }
      return keys.routingKey.uint8Array();
    }
    getSubscriptions() {
      const subscriptions = Object.values(this._subscriptions).filter(Boolean);
      return subscriptions.map((sub) => `${ipns.namespace}${sub}`);
    }
    async cancel(name) {
      if (typeof name !== "string") {
        throw errcode(new Error("invalid subscription name"), "ERR_INVALID_SUBSCRIPTION_NAME");
      }
      if (name.startsWith(ipns.namespace)) {
        name = name.substring(ipns.namespaceLength);
      }
      const stringifiedTopic = Object.keys(this._subscriptions).find((key) => this._subscriptions[key] === name);
      if (!stringifiedTopic) {
        return {
          canceled: false
        };
      }
      const bufTopic = uint8ArrayFromString(stringifiedTopic);
      this._pubsubDs.unsubscribe(bufTopic);
      this._subscriptions[stringifiedTopic] = void 0;
      log(`unsubscribed pubsub ${stringifiedTopic}: ${name}`);
      return {
        canceled: true
      };
    }
  };
  exports2 = module2.exports = withIs(IpnsPubsubDatastore, {className: "IpnsPubsubDatastore", symbolName: "@js-ipfs/ipns/IpnsPubsubDatastore"});
});

// node_modules/libp2p-record/src/record.proto.js
var require_record_proto = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = `// Record represents a dht record that contains a value
// for a key value pair
message Record {
  // The key that references this record
  bytes key = 1;

  // The actual value this record is storing
  bytes value = 2;

  // Note: These fields were removed from the Record message
  // hash of the authors public key
  // optional bytes author = 3;
  // A PKI signature for the key+value+author
  // optional bytes signature = 4;

  // Time the record was received, set by receiver
  optional string timeReceived = 5;
}`;
});

// node_modules/libp2p-record/src/utils.js
var require_utils13 = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports.toRFC3339 = (time) => {
    const year = time.getUTCFullYear();
    const month = String(time.getUTCMonth() + 1).padStart(2, "0");
    const day = String(time.getUTCDate()).padStart(2, "0");
    const hour = String(time.getUTCHours()).padStart(2, "0");
    const minute = String(time.getUTCMinutes()).padStart(2, "0");
    const seconds = String(time.getUTCSeconds()).padStart(2, "0");
    const milliseconds = time.getUTCMilliseconds();
    const nanoseconds = milliseconds * 1e3 * 1e3;
    return `${year}-${month}-${day}T${hour}:${minute}:${seconds}.${nanoseconds}Z`;
  };
  module2.exports.parseRFC3339 = (time) => {
    const rfc3339Matcher = new RegExp("(\\d{4})-(\\d{2})-(\\d{2})T(\\d{2}):(\\d{2}):(\\d{2})\\.(\\d+)Z");
    const m = String(time).trim().match(rfc3339Matcher);
    if (!m) {
      throw new Error("Invalid format");
    }
    const year = parseInt(m[1], 10);
    const month = parseInt(m[2], 10) - 1;
    const date = parseInt(m[3], 10);
    const hour = parseInt(m[4], 10);
    const minute = parseInt(m[5], 10);
    const second = parseInt(m[6], 10);
    const millisecond = parseInt(m[7].slice(0, -6), 10);
    return new Date(Date.UTC(year, month, date, hour, minute, second, millisecond));
  };
});

// node_modules/libp2p-record/src/record.js
var require_record = __commonJS((exports2, module2) => {
  "use strict";
  var protons = require_src8();
  var pb = protons(require_record_proto()).Record;
  var utils = require_utils13();
  var Record = class {
    constructor(key, value, recvtime) {
      if (!(key instanceof Uint8Array)) {
        throw new Error("key must be a Uint8Array");
      }
      if (!(value instanceof Uint8Array)) {
        throw new Error("value must be a Uint8Array");
      }
      this.key = key;
      this.value = value;
      this.timeReceived = recvtime;
    }
    serialize() {
      return pb.encode(this.prepareSerialize());
    }
    prepareSerialize() {
      return {
        key: this.key,
        value: this.value,
        timeReceived: this.timeReceived && utils.toRFC3339(this.timeReceived)
      };
    }
    static deserialize(raw) {
      const dec = pb.decode(raw);
      return Record.fromDeserialized(dec);
    }
    static fromDeserialized(obj) {
      let recvtime;
      if (obj.timeReceived) {
        recvtime = utils.parseRFC3339(obj.timeReceived);
      }
      const rec = new Record(obj.key, obj.value, recvtime);
      return rec;
    }
  };
  module2.exports = Record;
});

// node_modules/libp2p-record/src/validators/public-key.js
var require_public_key = __commonJS((exports2, module2) => {
  "use strict";
  var multihashing = require_src14();
  var errcode = require_err_code();
  var uint8ArrayToString = require_to_string2();
  var uint8ArrayEquals = require_equals2();
  var validatePublicKeyRecord = async (key, publicKey) => {
    if (!(key instanceof Uint8Array)) {
      throw errcode(new Error('"key" must be a Uint8Array'), "ERR_INVALID_RECORD_KEY_NOT_BUFFER");
    }
    if (key.byteLength < 5) {
      throw errcode(new Error("invalid public key record"), "ERR_INVALID_RECORD_KEY_TOO_SHORT");
    }
    const prefix = uint8ArrayToString(key.subarray(0, 4));
    if (prefix !== "/pk/") {
      throw errcode(new Error("key was not prefixed with /pk/"), "ERR_INVALID_RECORD_KEY_BAD_PREFIX");
    }
    const keyhash = key.slice(4);
    const publicKeyHash = await multihashing(publicKey, "sha2-256");
    if (!uint8ArrayEquals(keyhash, publicKeyHash)) {
      throw errcode(new Error("public key does not match passed in key"), "ERR_INVALID_RECORD_HASH_MISMATCH");
    }
  };
  module2.exports = {
    func: validatePublicKeyRecord,
    sign: false
  };
});

// node_modules/libp2p-record/src/validators/index.js
var require_validators = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = {
    pk: require_public_key()
  };
});

// node_modules/libp2p-record/src/validator.js
var require_validator = __commonJS((exports2, module2) => {
  "use strict";
  var errcode = require_err_code();
  var uint8ArrayToString = require_to_string2();
  var verifyRecord = (validators, record) => {
    const key = record.key;
    const keyString = uint8ArrayToString(key);
    const parts = keyString.split("/");
    if (parts.length < 3) {
      return;
    }
    const validator = validators[parts[1].toString()];
    if (!validator) {
      const errMsg = "Invalid record keytype";
      throw errcode(new Error(errMsg), "ERR_INVALID_RECORD_KEY_TYPE");
    }
    return validator.func(key, record.value);
  };
  module2.exports = {
    verifyRecord,
    validators: require_validators()
  };
});

// node_modules/libp2p-record/src/selectors/public-key.js
var require_public_key2 = __commonJS((exports2, module2) => {
  "use strict";
  var publicKeySelector = (k, records) => {
    return 0;
  };
  module2.exports = publicKeySelector;
});

// node_modules/libp2p-record/src/selectors/index.js
var require_selectors = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = {
    pk: require_public_key2()
  };
});

// node_modules/libp2p-record/src/selection.js
var require_selection = __commonJS((exports2, module2) => {
  "use strict";
  var errcode = require_err_code();
  var uint8ArrayToString = require_to_string2();
  var bestRecord = (selectors, k, records) => {
    if (records.length === 0) {
      const errMsg = "No records given";
      throw errcode(new Error(errMsg), "ERR_NO_RECORDS_RECEIVED");
    }
    const kStr = uint8ArrayToString(k);
    const parts = kStr.split("/");
    if (parts.length < 3) {
      const errMsg = "Record key does not have a selector function";
      throw errcode(new Error(errMsg), "ERR_NO_SELECTOR_FUNCTION_FOR_RECORD_KEY");
    }
    const selector = selectors[parts[1].toString()];
    if (!selector) {
      const errMsg = `Unrecognized key prefix: ${parts[1]}`;
      throw errcode(new Error(errMsg), "ERR_UNRECOGNIZED_KEY_PREFIX");
    }
    return selector(k, records);
  };
  module2.exports = {
    bestRecord,
    selectors: require_selectors()
  };
});

// node_modules/libp2p-record/src/index.js
var require_src25 = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = {
    Record: require_record(),
    validator: require_validator(),
    selection: require_selection()
  };
});

// node_modules/ipfs-core/src/ipns/routing/utils.js
var require_utils14 = __commonJS((exports2, module2) => {
  "use strict";
  var ipns = require_src21();
  var uint8ArrayToString = require_to_string5();
  module2.exports = {
    encodeBase32: (buf) => uint8ArrayToString(buf, "base32upper"),
    validator: {
      func: (key, record, cb) => ipns.validator.validate(record, key, cb)
    },
    selector: (_k, records) => ipns.validator.select(records[0], records[1])
  };
});

// node_modules/ipfs-core/src/ipns/routing/offline-datastore.js
var require_offline_datastore = __commonJS((exports2, module2) => {
  "use strict";
  var {Key} = require_src15();
  var {Record} = require_src25();
  var {encodeBase32} = require_utils14();
  var errcode = require_err_code();
  var debug = require_browser4();
  var log = Object.assign(debug("ipfs:ipns:offline-datastore"), {
    error: debug("ipfs:ipns:offline-datastore:error")
  });
  var OfflineDatastore = class {
    constructor(repo) {
      this._repo = repo;
    }
    async put(key, value) {
      if (!(key instanceof Uint8Array)) {
        throw errcode(new Error("Offline datastore key must be a Uint8Array"), "ERR_INVALID_KEY");
      }
      if (!(value instanceof Uint8Array)) {
        throw errcode(new Error("Offline datastore value must be a Uint8Array"), "ERR_INVALID_VALUE");
      }
      let routingKey;
      try {
        routingKey = this._routingKey(key);
      } catch (err) {
        log.error(err);
        throw errcode(new Error("Not possible to generate the routing key"), "ERR_GENERATING_ROUTING_KEY");
      }
      const record = new Record(key, value);
      return this._repo.datastore.put(routingKey, record.serialize());
    }
    async get(key) {
      if (!(key instanceof Uint8Array)) {
        throw errcode(new Error("Offline datastore key must be a Uint8Array"), "ERR_INVALID_KEY");
      }
      let routingKey;
      try {
        routingKey = this._routingKey(key);
      } catch (err) {
        log.error(err);
        throw errcode(new Error("Not possible to generate the routing key"), "ERR_GENERATING_ROUTING_KEY");
      }
      const res = await this._repo.datastore.get(routingKey);
      let record;
      try {
        record = Record.deserialize(res);
      } catch (err) {
        log.error(err);
        throw err;
      }
      return record.value;
    }
    _routingKey(key) {
      return new Key("/" + encodeBase32(key), false);
    }
  };
  exports2 = module2.exports = OfflineDatastore;
});

// node_modules/ipfs-core/src/ipns/routing/config.js
var require_config = __commonJS((exports2, module2) => {
  "use strict";
  var {TieredDatastore} = require_src22();
  var get = require_dlv_umd();
  var PubsubDatastore = require_pubsub_datastore();
  var OfflineDatastore = require_offline_datastore();
  module2.exports = ({libp2p, repo, peerId, options}) => {
    const ipnsStores = [];
    let pubsubDs;
    if (get(options, "EXPERIMENTAL.ipnsPubsub", false)) {
      const pubsub = libp2p.pubsub;
      const localDatastore = repo.datastore;
      pubsubDs = new PubsubDatastore(pubsub, localDatastore, peerId);
      ipnsStores.push(pubsubDs);
    }
    if (get(options, "offline") || !get(options, "libp2p.config.dht.enabled", false)) {
      const offlineDatastore = new OfflineDatastore(repo);
      ipnsStores.push(offlineDatastore);
    } else {
      ipnsStores.push(libp2p._dht);
    }
    return new TieredDatastore(ipnsStores);
  };
});

// node_modules/ipfs-core/src/components/ipns.js
var require_ipns2 = __commonJS((exports2, module2) => {
  "use strict";
  var IPNS = require_ipns();
  var routingConfig = require_config();
  var OfflineDatastore = require_offline_datastore();
  var {NotInitializedError, AlreadyInitializedError} = require_errors3();
  var log = require_browser4()("ipfs:components:ipns");
  var IPNSAPI = class {
    constructor(options = {}) {
      this.options = options;
      this.offline = null;
      this.online = null;
    }
    getIPNS() {
      const ipns = this.online || this.offline;
      if (ipns) {
        return ipns;
      } else {
        throw new NotInitializedError();
      }
    }
    get routing() {
      return this.getIPNS().routing;
    }
    startOffline({repo, peerId, keychain}) {
      if (this.offline != null) {
        throw new AlreadyInitializedError();
      }
      log("initializing IPNS keyspace");
      const routing = new OfflineDatastore(repo);
      const ipns = new IPNS(routing, repo.datastore, peerId, keychain, this.options);
      this.offline = ipns;
    }
    async startOnline({libp2p, repo, peerId, keychain}) {
      if (this.online != null) {
        throw new AlreadyInitializedError();
      }
      const routing = routingConfig({libp2p, repo, peerId, options: this.options});
      const ipns = new IPNS(routing, repo.datastore, peerId, keychain, this.options);
      await ipns.republisher.start();
      this.online = ipns;
    }
    async stop() {
      const ipns = this.online;
      if (ipns) {
        await ipns.republisher.stop();
        this.online = null;
      }
    }
    publish(privKey, value, lifetime) {
      return this.getIPNS().publish(privKey, value, lifetime);
    }
    resolve(name, options) {
      return this.getIPNS().resolve(name, options);
    }
    initializeKeyspace(privKey, value) {
      return this.getIPNS().initializeKeyspace(privKey, value);
    }
  };
  module2.exports = IPNSAPI;
});

// node_modules/ipfs-core/src/components/name/utils.js
var require_utils15 = __commonJS((exports2) => {
  "use strict";
  var isIPFS = require_src13();
  exports2.resolvePath = ({ipns, dagReader}, name) => {
    if (isIPFS.ipnsPath(name)) {
      return ipns.resolve(name);
    }
    return dagReader.get(name.substring("/ipfs/".length));
  };
});

// node_modules/ipfs-core/src/components/name/publish.js
var require_publish = __commonJS((exports2, module2) => {
  "use strict";
  var debug = require_browser4();
  var {default: parseDuration} = require_parse_duration();
  var crypto2 = require_src10();
  var errcode = require_err_code();
  var log = Object.assign(debug("ipfs:name:publish"), {
    error: debug("ipfs:name:publish:error")
  });
  var {OFFLINE_ERROR, normalizePath} = require_utils7();
  var withTimeoutOption = require_with_timeout_option();
  var {resolvePath} = require_utils15();
  module2.exports = ({ipns, dagReader, peerId, isOnline, keychain}) => {
    const lookupKey = async (keyName) => {
      if (keyName === "self") {
        return peerId.privKey;
      }
      try {
        const pem = await keychain.exportKey(keyName, "temp");
        const privateKey = await crypto2.keys.import(pem, "temp");
        return privateKey;
      } catch (err) {
        log.error(err);
        throw errcode(err, "ERR_CANNOT_GET_KEY");
      }
    };
    async function publish(value, options = {}) {
      const resolve = !(options.resolve === false);
      const lifetime = options.lifetime || "24h";
      const key = options.key || "self";
      if (!isOnline()) {
        throw errcode(new Error(OFFLINE_ERROR), "OFFLINE_ERROR");
      }
      try {
        value = normalizePath(value);
      } catch (err) {
        log.error(err);
        throw err;
      }
      let pubLifetime = 0;
      try {
        pubLifetime = parseDuration(lifetime) || 0;
        pubLifetime = parseFloat(pubLifetime.toFixed(6));
      } catch (err) {
        log.error(err);
        throw err;
      }
      const results = await Promise.all([
        lookupKey(key),
        resolve ? resolvePath({ipns, dagReader}, value) : Promise.resolve()
      ]);
      return ipns.publish(results[0], value, pubLifetime);
    }
    return withTimeoutOption(publish);
  };
});

// node_modules/is-domain-name/index.js
var require_is_domain_name = __commonJS((exports2, module2) => {
  "use strict";
  var domainNameRegex = /^(?:[a-z0-9](?:[a-z0-9\-]{0,61}[a-z0-9])?\.){0,126}(?:[a-z0-9](?:[a-z0-9\-]{0,61}[a-z0-9]))\.?$/i;
  module2.exports = function isDomainName(domainName, rootDot) {
    if (rootDot == null)
      rootDot = false;
    if (domainName.length < 2)
      return false;
    if (domainName.length > 255)
      return false;
    var lastChar = domainName[domainName.length - 1];
    if (rootDot) {
      if (lastChar !== ".")
        return false;
    } else {
      if (lastChar === ".")
        return false;
    }
    return domainNameRegex.test(domainName);
  };
});

// node_modules/ipfs-core/src/components/name/resolve.js
var require_resolve2 = __commonJS((exports2, module2) => {
  "use strict";
  var debug = require_browser4();
  var errcode = require_err_code();
  var {mergeOptions} = require_utils7();
  var CID = require_src7();
  var isDomain = require_is_domain_name();
  var log = Object.assign(debug("ipfs:name:resolve"), {
    error: debug("ipfs:name:resolve:error")
  });
  var {OFFLINE_ERROR} = require_utils7();
  var withTimeoutOption = require_with_timeout_option();
  var appendRemainder = (result, remainder) => remainder.length > 0 ? result + "/" + remainder.join("/") : result;
  module2.exports = ({dns, ipns, peerId, isOnline, options: {offline}}) => {
    async function* resolve(name, options = {}) {
      options = mergeOptions({
        nocache: false,
        recursive: true
      }, options);
      if (offline && options && options.nocache) {
        throw errcode(new Error("cannot specify both offline and nocache"), "ERR_NOCACHE_AND_OFFLINE");
      }
      if (!name) {
        name = peerId.toB58String();
      }
      if (!name.startsWith("/ipns/")) {
        name = `/ipns/${name}`;
      }
      const [namespace, hash, ...remainder] = name.slice(1).split("/");
      try {
        new CID(hash);
      } catch (err) {
        if (isDomain(hash)) {
          yield appendRemainder(await dns(hash, options), remainder);
          return;
        }
        log.error(err);
        throw errcode(new Error("Invalid IPNS name"), "ERR_IPNS_INVALID_NAME");
      }
      if (!isOnline() && !offline) {
        throw errcode(new Error(OFFLINE_ERROR), "OFFLINE_ERROR");
      }
      yield appendRemainder(await ipns.resolve(`/${namespace}/${hash}`, options), remainder);
    }
    return withTimeoutOption(resolve);
  };
});

// node_modules/ipfs-core/src/components/name/pubsub/utils.js
var require_utils16 = __commonJS((exports2) => {
  "use strict";
  var IpnsPubsubDatastore = require_pubsub_datastore();
  var errcode = require_err_code();
  exports2.getPubsubRouting = (ipns, options) => {
    if (!ipns || !(options && options.ipnsPubsub)) {
      throw errcode(new Error("IPNS pubsub subsystem is not enabled"), "ERR_IPNS_PUBSUB_NOT_ENABLED");
    }
    if (IpnsPubsubDatastore.isIpnsPubsubDatastore(ipns.routing)) {
      return ipns.routing;
    }
    const pubsub = (ipns.routing.stores || []).find((s) => IpnsPubsubDatastore.isIpnsPubsubDatastore(s));
    if (!pubsub) {
      throw errcode(new Error("IPNS pubsub datastore not found"), "ERR_PUBSUB_DATASTORE_NOT_FOUND");
    }
    return pubsub;
  };
});

// node_modules/ipfs-core/src/components/name/pubsub/cancel.js
var require_cancel = __commonJS((exports2, module2) => {
  "use strict";
  var {getPubsubRouting} = require_utils16();
  var withTimeoutOption = require_with_timeout_option();
  module2.exports = ({ipns, options: routingOptions}) => {
    async function cancel(name, options) {
      const pubsub = getPubsubRouting(ipns, routingOptions);
      return pubsub.cancel(name, options);
    }
    return withTimeoutOption(cancel);
  };
});

// node_modules/ipfs-core/src/components/name/pubsub/state.js
var require_state2 = __commonJS((exports2, module2) => {
  "use strict";
  var {getPubsubRouting} = require_utils16();
  var withTimeoutOption = require_with_timeout_option();
  module2.exports = ({ipns, options: routingOptions}) => {
    async function state(_options) {
      try {
        return {enabled: Boolean(getPubsubRouting(ipns, routingOptions))};
      } catch (err) {
        return {enabled: false};
      }
    }
    return withTimeoutOption(state);
  };
});

// node_modules/ipfs-core/src/components/name/pubsub/subs.js
var require_subs = __commonJS((exports2, module2) => {
  "use strict";
  var {getPubsubRouting} = require_utils16();
  var withTimeoutOption = require_with_timeout_option();
  module2.exports = ({ipns, options: routingOptions}) => {
    async function subs(options) {
      const pubsub = getPubsubRouting(ipns, routingOptions);
      return pubsub.getSubscriptions(options);
    }
    return withTimeoutOption(subs);
  };
});

// node_modules/ipfs-core/src/components/name/pubsub/index.js
var require_pubsub = __commonJS((exports2, module2) => {
  "use strict";
  var createCancelAPI = require_cancel();
  var createStateAPI = require_state2();
  var createSubsAPI = require_subs();
  var PubSubAPI = class {
    constructor({ipns, options}) {
      this.cancel = createCancelAPI({ipns, options});
      this.state = createStateAPI({ipns, options});
      this.subs = createSubsAPI({ipns, options});
    }
  };
  module2.exports = PubSubAPI;
});

// node_modules/ipfs-core/src/components/name/index.js
var require_name = __commonJS((exports2, module2) => {
  "use strict";
  var createPublishAPI = require_publish();
  var createResolveAPI = require_resolve2();
  var PubSubAPI = require_pubsub();
  var NameAPI = class {
    constructor({dns, ipns, dagReader, peerId, isOnline, keychain, options}) {
      this.publish = createPublishAPI({ipns, dagReader, peerId, isOnline, keychain});
      this.resolve = createResolveAPI({dns, ipns, peerId, isOnline, options});
      this.pubsub = new PubSubAPI({ipns, options: options.EXPERIMENTAL});
    }
  };
  module2.exports = NameAPI;
});

// node_modules/ipfs-core/src/components/refs/index.js
var require_refs = __commonJS((exports2, module2) => {
  "use strict";
  var isIpfs = require_src13();
  var CID = require_src7();
  var {DAGNode} = require_src16();
  var {normalizeCidPath} = require_utils7();
  var {Errors} = require_src15();
  var ERR_NOT_FOUND = Errors.notFoundError().code;
  var withTimeoutOption = require_with_timeout_option();
  var Format = {
    default: "<dst>",
    edges: "<src> -> <dst>"
  };
  module2.exports = function({ipld, resolve, preload}) {
    async function* refs(ipfsPath, options = {}) {
      if (options.maxDepth === 0) {
        return;
      }
      if (options.edges && options.format && options.format !== Format.default) {
        throw new Error("Cannot set edges to true and also specify format");
      }
      options.format = options.edges ? Format.edges : options.format || Format.default;
      if (typeof options.maxDepth !== "number") {
        options.maxDepth = options.recursive ? Infinity : 1;
      }
      const rawPaths = Array.isArray(ipfsPath) ? ipfsPath : [ipfsPath];
      const paths = rawPaths.map((p) => getFullPath(preload, p, options));
      for (const path of paths) {
        yield* refsStream(resolve, ipld, path, options);
      }
    }
    return withTimeoutOption(refs);
  };
  module2.exports.Format = Format;
  function getFullPath(preload, ipfsPath, options) {
    const path = normalizeCidPath(ipfsPath);
    const pathComponents = path.split("/");
    const cid = pathComponents[0];
    if (!isIpfs.cid(cid)) {
      throw new Error(`Error resolving path '${path}': '${cid}' is not a valid CID`);
    }
    if (options.preload !== false) {
      preload(cid);
    }
    return "/ipfs/" + path;
  }
  async function* refsStream(resolve, ipld, path, options) {
    const resPath = await resolve(path);
    const parts = resPath.split("/");
    const cid = parts[2];
    for await (const obj of objectStream(ipld, cid, options.maxDepth, options.unique)) {
      if (!obj.parent) {
        continue;
      }
      if (obj.isDuplicate) {
        continue;
      }
      yield {
        ref: formatLink(obj.parent.cid, obj.node.cid, obj.node.name, options.format)
      };
    }
  }
  function formatLink(srcCid, dstCid, linkName, format) {
    let out = format.replace(/<src>/g, srcCid.toString());
    out = out.replace(/<dst>/g, dstCid.toString());
    out = out.replace(/<linkname>/g, linkName);
    return out;
  }
  async function* objectStream(ipld, rootCid, maxDepth, uniqueOnly) {
    const seen = new Set();
    async function* traverseLevel(parent, depth) {
      const nextLevelDepth = depth + 1;
      if (nextLevelDepth > maxDepth) {
        return;
      }
      try {
        for (const link of await getLinks(ipld, parent.cid)) {
          yield {
            parent,
            node: link,
            isDuplicate: uniqueOnly && seen.has(link.cid.toString())
          };
          if (uniqueOnly) {
            seen.add(link.cid.toString());
          }
          yield* traverseLevel(link, nextLevelDepth);
        }
      } catch (err) {
        if (err.code === ERR_NOT_FOUND) {
          err.message = `Could not find object with CID: ${parent.cid}`;
        }
        throw err;
      }
    }
    yield* traverseLevel({cid: rootCid}, 0);
  }
  async function getLinks(ipld, cid) {
    const node = await ipld.get(new CID(cid));
    if (DAGNode.isDAGNode(node)) {
      return node.Links.map(({Name, Hash}) => ({name: Name, cid: new CID(Hash)}));
    }
    return getNodeLinks(node);
  }
  function getNodeLinks(node, path = "") {
    let links = [];
    for (const [name, value] of Object.entries(node)) {
      if (CID.isCID(value)) {
        links.push({
          name: path + name,
          cid: value
        });
      } else if (typeof value === "object") {
        links = links.concat(getNodeLinks(value, path + name + "/"));
      }
    }
    return links;
  }
});

// node_modules/ipfs-core/src/components/refs/local.js
var require_local = __commonJS((exports2, module2) => {
  "use strict";
  var withTimeoutOption = require_with_timeout_option();
  module2.exports = function({repo}) {
    async function* refsLocal(options = {}) {
      for await (const cid of repo.blocks.query({keysOnly: true, signal: options.signal})) {
        yield {ref: cid.toString()};
      }
    }
    return withTimeoutOption(refsLocal);
  };
});

// node_modules/ipfs-core/src/components/bitswap/wantlist.js
var require_wantlist = __commonJS((exports2, module2) => {
  "use strict";
  var withTimeoutOption = require_with_timeout_option();
  module2.exports = ({network}) => {
    async function wantlist(options = {}) {
      const {bitswap} = await network.use(options);
      const list = bitswap.getWantlist(options);
      return Array.from(list).map((e) => e[1].cid);
    }
    return withTimeoutOption(wantlist);
  };
});

// node_modules/ipfs-core/src/components/bitswap/wantlist-for-peer.js
var require_wantlist_for_peer = __commonJS((exports2, module2) => {
  "use strict";
  var PeerId = require_src9();
  var withTimeoutOption = require_with_timeout_option();
  module2.exports = ({network}) => {
    async function wantlistForPeer(peerId, options = {}) {
      const {bitswap} = await network.use(options);
      const list = bitswap.wantlistForPeer(PeerId.createFromCID(peerId), options);
      return Array.from(list).map((e) => e[1].cid);
    }
    return withTimeoutOption(wantlistForPeer);
  };
});

// node_modules/ipfs-core/src/components/bitswap/unwant.js
var require_unwant = __commonJS((exports2, module2) => {
  "use strict";
  var CID = require_src7();
  var errCode = require_err_code();
  var withTimeoutOption = require_with_timeout_option();
  module2.exports = ({network}) => {
    async function unwant(cids, options) {
      const {bitswap} = await network.use(options);
      if (!Array.isArray(cids)) {
        cids = [cids];
      }
      try {
        cids = cids.map((cid) => new CID(cid));
      } catch (err) {
        throw errCode(err, "ERR_INVALID_CID");
      }
      return bitswap.unwant(cids, options);
    }
    return withTimeoutOption(unwant);
  };
});

// node_modules/ipfs-core/src/components/bitswap/stat.js
var require_stat = __commonJS((exports2, module2) => {
  "use strict";
  var {default: Big} = require_bignumber();
  var CID = require_src7();
  var withTimeoutOption = require_with_timeout_option();
  module2.exports = ({network}) => {
    async function stat(options) {
      const {bitswap} = await network.use(options);
      const snapshot = bitswap.stat().snapshot;
      return {
        provideBufLen: parseInt(snapshot.providesBufferLength.toString()),
        blocksReceived: new Big(snapshot.blocksReceived),
        wantlist: Array.from(bitswap.getWantlist()).map((e) => e[1].cid),
        peers: bitswap.peers().map((id) => new CID(id.toB58String())),
        dupBlksReceived: new Big(snapshot.dupBlksReceived),
        dupDataReceived: new Big(snapshot.dupDataReceived),
        dataReceived: new Big(snapshot.dataReceived),
        blocksSent: new Big(snapshot.blocksSent),
        dataSent: new Big(snapshot.dataSent)
      };
    }
    return withTimeoutOption(stat);
  };
});

// node_modules/ipfs-core/src/components/bitswap/index.js
var require_bitswap = __commonJS((exports2, module2) => {
  "use strict";
  var createWantlist = require_wantlist();
  var createWantlistForPeer = require_wantlist_for_peer();
  var createUnwant = require_unwant();
  var createStat = require_stat();
  var BitswapAPI = class {
    constructor({network}) {
      this.wantlist = createWantlist({network});
      this.wantlistForPeer = createWantlistForPeer({network});
      this.unwant = createUnwant({network});
      this.stat = createStat({network});
    }
  };
  module2.exports = BitswapAPI;
});

// node_modules/ipfs-core/src/components/bootstrap/utils.js
var require_utils17 = __commonJS((exports2) => {
  "use strict";
  var isMultiaddr = require_src12().IPFS.matches;
  exports2.isValidMultiaddr = (ma) => {
    try {
      return isMultiaddr(ma);
    } catch (err) {
      return false;
    }
  };
});

// node_modules/ipfs-core/src/components/bootstrap/add.js
var require_add2 = __commonJS((exports2, module2) => {
  "use strict";
  var {isValidMultiaddr} = require_utils17();
  var withTimeoutOption = require_with_timeout_option();
  module2.exports = ({repo}) => {
    async function add(multiaddr, options = {}) {
      if (!isValidMultiaddr(multiaddr)) {
        throw new Error(`${multiaddr} is not a valid Multiaddr`);
      }
      const config = await repo.config.getAll(options);
      if (config.Bootstrap.indexOf(multiaddr.toString()) === -1) {
        config.Bootstrap.push(multiaddr.toString());
      }
      await repo.config.replace(config);
      return {
        Peers: [multiaddr]
      };
    }
    return withTimeoutOption(add);
  };
});

// node_modules/ipfs-core/src/components/bootstrap/clear.js
var require_clear = __commonJS((exports2, module2) => {
  "use strict";
  var withTimeoutOption = require_with_timeout_option();
  var Multiaddr = require_src11();
  module2.exports = ({repo}) => {
    async function clear(options = {}) {
      const config = await repo.config.getAll(options);
      const removed = config.Bootstrap || [];
      config.Bootstrap = [];
      await repo.config.replace(config);
      return {Peers: removed.map((ma) => new Multiaddr(ma))};
    }
    return withTimeoutOption(clear);
  };
});

// node_modules/ipfs-core/src/components/bootstrap/list.js
var require_list = __commonJS((exports2, module2) => {
  "use strict";
  var withTimeoutOption = require_with_timeout_option();
  var Multiaddr = require_src11();
  module2.exports = ({repo}) => {
    async function list(options) {
      const peers = await repo.config.get("Bootstrap", options);
      return {Peers: (peers || []).map((ma) => new Multiaddr(ma))};
    }
    return withTimeoutOption(list);
  };
});

// node_modules/ipfs-core/src/runtime/config-browser.js
var require_config_browser = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = () => ({
    Addresses: {
      Swarm: [],
      Announce: [],
      API: "",
      Gateway: "",
      RPC: "",
      Delegates: [
        "/dns4/node0.delegate.ipfs.io/tcp/443/https",
        "/dns4/node1.delegate.ipfs.io/tcp/443/https",
        "/dns4/node2.delegate.ipfs.io/tcp/443/https",
        "/dns4/node3.delegate.ipfs.io/tcp/443/https"
      ]
    },
    Discovery: {
      MDNS: {
        Enabled: false,
        Interval: 10
      },
      webRTCStar: {
        Enabled: true
      }
    },
    Bootstrap: [
      "/dnsaddr/bootstrap.libp2p.io/p2p/QmNnooDu7bfjPFoTZYxMNLWUQJyrVwtbZg5gBMjTezGAJN",
      "/dnsaddr/bootstrap.libp2p.io/p2p/QmbLHAnMoJPWSCR5Zhtx6BHJX9KiKNN6tpvbUcqanj75Nb",
      "/dnsaddr/bootstrap.libp2p.io/p2p/QmZa1sAxajnQjVM8WjWXoMbmPd7NsWhfKsPkErzpm9wGkp",
      "/dnsaddr/bootstrap.libp2p.io/p2p/QmQCU2EcMqAqQPR2i9bChDtGNJchTbq5TbXJJ16u19uLTa",
      "/dnsaddr/bootstrap.libp2p.io/p2p/QmcZf59bWwK5XFi76CZX8cbJ4BhTzzA3gU1ZjYZcYW3dwt",
      "/dns4/node0.preload.ipfs.io/tcp/443/wss/p2p/QmZMxNdpMkewiVZLMRxaNxUeZpDUb34pWjZ1kZvsd16Zic",
      "/dns4/node1.preload.ipfs.io/tcp/443/wss/p2p/Qmbut9Ywz9YEDrz8ySBSgWyJk41Uvm2QJPhwDJzJyGFsD6",
      "/dns4/node2.preload.ipfs.io/tcp/443/wss/p2p/QmV7gnbW5VTcJ3oyM2Xk1rdFBJ3kTkvxc87UFGsun29STS",
      "/dns4/node3.preload.ipfs.io/tcp/443/wss/p2p/QmY7JB6MQXhxHvq7dBDh4HpbH29v4yE9JRadAVpndvzySN"
    ],
    Pubsub: {
      Enabled: true
    },
    Swarm: {
      ConnMgr: {
        LowWater: 200,
        HighWater: 500
      },
      DisableNatPortMap: true
    },
    Routing: {
      Type: "none"
    }
  });
});

// node_modules/ipfs-core/src/components/bootstrap/reset.js
var require_reset = __commonJS((exports2, module2) => {
  "use strict";
  var defaultConfig = require_config_browser();
  var withTimeoutOption = require_with_timeout_option();
  var Multiaddr = require_src11();
  module2.exports = ({repo}) => {
    async function reset(options = {}) {
      const config = await repo.config.getAll(options);
      config.Bootstrap = defaultConfig().Bootstrap;
      await repo.config.replace(config);
      return {
        Peers: defaultConfig().Bootstrap.map((ma) => new Multiaddr(ma))
      };
    }
    return withTimeoutOption(reset);
  };
});

// node_modules/ipfs-core/src/components/bootstrap/rm.js
var require_rm2 = __commonJS((exports2, module2) => {
  "use strict";
  var {isValidMultiaddr} = require_utils17();
  var withTimeoutOption = require_with_timeout_option();
  module2.exports = ({repo}) => {
    async function rm(multiaddr, options = {}) {
      if (!isValidMultiaddr(multiaddr)) {
        throw new Error(`${multiaddr} is not a valid Multiaddr`);
      }
      const config = await repo.config.getAll(options);
      config.Bootstrap = (config.Bootstrap || []).filter((ma) => ma.toString() !== multiaddr.toString());
      await repo.config.replace(config);
      return {Peers: [multiaddr]};
    }
    return withTimeoutOption(rm);
  };
});

// node_modules/ipfs-core/src/components/bootstrap/index.js
var require_bootstrap = __commonJS((exports2, module2) => {
  "use strict";
  var createAdd = require_add2();
  var createClear = require_clear();
  var createList = require_list();
  var createReset = require_reset();
  var createRm = require_rm2();
  var BootstrapAPI = class {
    constructor({repo}) {
      this.add = createAdd({repo});
      this.list = createList({repo});
      this.rm = createRm({repo});
      this.clear = createClear({repo});
      this.reset = createReset({repo});
    }
  };
  module2.exports = BootstrapAPI;
});

// node_modules/ipfs-core/src/components/block/utils.js
var require_utils18 = __commonJS((exports2) => {
  "use strict";
  var CID = require_src7();
  var errCode = require_err_code();
  exports2.cleanCid = (cid) => {
    if (CID.isCID(cid)) {
      return cid;
    }
    try {
      return new CID(cid);
    } catch (err) {
      throw errCode(err, "ERR_INVALID_CID");
    }
  };
});

// node_modules/ipfs-core/src/components/block/get.js
var require_get = __commonJS((exports2, module2) => {
  "use strict";
  var {cleanCid} = require_utils18();
  var withTimeoutOption = require_with_timeout_option();
  module2.exports = ({blockService, preload}) => {
    async function get(cid, options = {}) {
      cid = cleanCid(cid);
      if (options.preload !== false) {
        preload(cid);
      }
      return blockService.get(cid, options);
    }
    return withTimeoutOption(get);
  };
});

// node_modules/ipld-block/package.json
var require_package2 = __commonJS((exports2, module2) => {
  module2.exports = {
    name: "ipld-block",
    version: "0.11.0",
    description: "JavaScript Implementation of IPLD Block",
    leadMaintainer: "Volker Mische <volker.mische@gmail.com>",
    main: "src/index.js",
    scripts: {
      lint: "aegir lint",
      check: "tsc --noEmit --noErrorTruncation",
      build: "npm run build:js && npm run build:types",
      "build:js": "aegir build",
      "build:types": "tsc --emitDeclarationOnly --declarationDir dist",
      test: "aegir test",
      "test:node": "aegir test --target node",
      "test:browser": "aegir test --target browser",
      release: "aegir release --docs",
      "release-minor": "aegir release --type minor --docs",
      "release-major": "aegir release --type major --docs",
      coverage: "aegir coverage",
      "coverage-publish": "aegir coverage --provider coveralls",
      docs: "aegir docs",
      prepare: "npm run build:types"
    },
    "pre-push": [
      "lint",
      "test"
    ],
    repository: {
      type: "git",
      url: "git+https://github.com/ipld/js-ipld-block.git"
    },
    keywords: [
      "IPLD"
    ],
    license: "MIT",
    bugs: {
      url: "https://github.com/ipld/js-ipld-block/issues"
    },
    homepage: "https://github.com/ipld/js-ipld-block#readme",
    devDependencies: {
      aegir: "^27.0.0",
      uint8arrays: "^1.0.0",
      typescript: "^4.0.3"
    },
    dependencies: {
      cids: "^1.0.0"
    },
    engines: {
      node: ">=6.0.0",
      npm: ">=3.0.0"
    },
    typesVersions: {
      "*": {
        "*": [
          "dist/*"
        ]
      }
    },
    contributors: [
      "David Dias <daviddias.p@gmail.com>",
      "Volker Mische <volker.mische@gmail.com>",
      "Friedel Ziegelmayer <dignifiedquire@gmail.com>",
      "Irakli Gozalishvili <contact@gozala.io>",
      "achingbrain <alex@achingbrain.net>",
      "\u1D20\u026A\u1D04\u1D1B\u1D0F\u0280 \u0299\u1D0A\u1D07\u029F\u1D0B\u029C\u1D0F\u029F\u1D0D <victorbjelkholm@gmail.com>",
      "Alan Shaw <alan.shaw@protocol.ai>",
      "Charlie <the_charlie_daly@hotmail.co.uk>",
      "Diogo Silva <fsdiogo@gmail.com>",
      "Hugo Dias <hugomrdias@gmail.com>",
      "Mikeal Rogers <mikeal.rogers@gmail.com>",
      "Richard Littauer <richard.littauer@gmail.com>",
      "Richard Schneider <makaretu@gmail.com>",
      "Xmader <xmader@outlook.com>"
    ]
  };
});

// node_modules/ipld-block/src/index.js
var require_src26 = __commonJS((exports2, module2) => {
  "use strict";
  var CID = require_src7();
  var {version} = require_package2();
  var blockSymbol = Symbol.for("@ipld/js-ipld-block/block");
  var readonly = {writable: false, configurable: false, enumerable: true};
  var Block = class {
    constructor(data, cid) {
      if (!data || !(data instanceof Uint8Array)) {
        throw new Error("first argument  must be a Uint8Array");
      }
      if (!cid || !CID.isCID(cid)) {
        throw new Error("second argument must be a CID");
      }
      this.data = data;
      this.cid = cid;
      Object.defineProperties(this, {
        data: readonly,
        cid: readonly
      });
    }
    get _data() {
      deprecateData();
      return this.data;
    }
    get _cid() {
      deprecateCID();
      return this.cid;
    }
    get [Symbol.toStringTag]() {
      return "Block";
    }
    get [blockSymbol]() {
      return true;
    }
    static isBlock(other) {
      return Boolean(other && other[blockSymbol]);
    }
  };
  var deprecate = (range, message) => {
    let warned = false;
    return () => {
      if (range.test(version)) {
        if (!warned) {
          warned = true;
          console.warn(message);
        }
      } else {
        throw new Error(message);
      }
    };
  };
  var deprecateCID = deprecate(/^0\.10|^0\.11/, "block._cid is deprecated and will be removed in 0.12 release. Please use block.cid instead");
  var deprecateData = deprecate(/^0\.10|^0.11/, "block._data is deprecated and will be removed in 0.12 release. Please use block.data instead");
  module2.exports = Block;
});

// node_modules/ipfs-core/src/components/block/put.js
var require_put = __commonJS((exports2, module2) => {
  "use strict";
  var Block = require_src26();
  var multihashing = require_src14();
  var CID = require_src7();
  var isIPFS = require_src13();
  var withTimeoutOption = require_with_timeout_option();
  module2.exports = ({blockService, pin, gcLock, preload}) => {
    async function put(block, options = {}) {
      if (Array.isArray(block)) {
        throw new Error("Array is not supported");
      }
      if (!Block.isBlock(block)) {
        const bytes = block;
        if (options.cid && isIPFS.cid(options.cid)) {
          const cid = CID.isCID(options.cid) ? options.cid : new CID(options.cid);
          block = new Block(bytes, cid);
        } else {
          const mhtype = options.mhtype || "sha2-256";
          const format = options.format || "dag-pb";
          let cidVersion = 1;
          if (options.version == null) {
            cidVersion = mhtype === "sha2-256" && format === "dag-pb" ? 0 : 1;
          } else {
            cidVersion = options.version;
          }
          const multihash = await multihashing(block, mhtype);
          const cid = new CID(cidVersion, format, multihash);
          block = new Block(bytes, cid);
        }
      }
      const release = await gcLock.readLock();
      try {
        await blockService.put(block, {
          signal: options.signal
        });
        if (options.preload !== false) {
          preload(block.cid);
        }
        if (options.pin === true) {
          await pin.add(block.cid, {
            recursive: true,
            signal: options.signal
          });
        }
        return block;
      } finally {
        release();
      }
    }
    return withTimeoutOption(put);
  };
});

// node_modules/streaming-iterables/dist/index.mjs
var require_dist2 = __commonJS((exports2) => {
  __export(exports2, {
    batch: () => batch,
    buffer: () => buffer,
    collect: () => collect,
    concat: () => concat,
    consume: () => consume,
    filter: () => filter,
    flatMap: () => flatMap,
    flatTransform: () => flatTransform,
    flatten: () => flatten,
    fromStream: () => fromStream,
    getIterator: () => getIterator,
    map: () => map,
    merge: () => merge,
    parallelFlatMap: () => parallelFlatMap,
    parallelMap: () => parallelMap,
    parallelMerge: () => parallelMerge,
    pipeline: () => pipeline,
    reduce: () => reduce,
    take: () => take,
    tap: () => tap,
    time: () => time,
    transform: () => transform,
    writeToStream: () => writeToStream
  });
  async function* _batch(size, iterable) {
    let dataBatch = [];
    for await (const data of iterable) {
      dataBatch.push(data);
      if (dataBatch.length === size) {
        yield dataBatch;
        dataBatch = [];
      }
    }
    if (dataBatch.length > 0) {
      yield dataBatch;
    }
  }
  function* _syncBatch(size, iterable) {
    let dataBatch = [];
    for (const data of iterable) {
      dataBatch.push(data);
      if (dataBatch.length === size) {
        yield dataBatch;
        dataBatch = [];
      }
    }
    if (dataBatch.length > 0) {
      yield dataBatch;
    }
  }
  function batch(size, iterable) {
    if (iterable === void 0) {
      return (curriedIterable) => batch(size, curriedIterable);
    }
    if (iterable[Symbol.asyncIterator]) {
      return _batch(size, iterable);
    }
    return _syncBatch(size, iterable);
  }
  function getIterator(iterable) {
    if (typeof iterable.next === "function") {
      return iterable;
    }
    if (typeof iterable[Symbol.iterator] === "function") {
      return iterable[Symbol.iterator]();
    }
    if (typeof iterable[Symbol.asyncIterator] === "function") {
      return iterable[Symbol.asyncIterator]();
    }
    throw new TypeError('"values" does not to conform to any of the iterator or iterable protocols');
  }
  function defer() {
    let reject;
    let resolve;
    const promise = new Promise((resolveFunc, rejectFunc) => {
      resolve = resolveFunc;
      reject = rejectFunc;
    });
    return {
      promise,
      reject,
      resolve
    };
  }
  function _buffer(size, iterable) {
    const iterator = getIterator(iterable);
    const resultQueue = [];
    const readQueue = [];
    let reading = false;
    let ended = false;
    function fulfillReadQueue() {
      while (readQueue.length > 0 && resultQueue.length > 0) {
        const readDeferred = readQueue.shift();
        const {error, value} = resultQueue.shift();
        if (error) {
          readDeferred.reject(error);
        } else {
          readDeferred.resolve({done: false, value});
        }
      }
      while (readQueue.length > 0 && ended) {
        const {resolve} = readQueue.shift();
        resolve({done: true, value: void 0});
      }
    }
    async function fillQueue() {
      if (ended) {
        return;
      }
      if (reading) {
        return;
      }
      if (resultQueue.length >= size) {
        return;
      }
      reading = true;
      try {
        const {done, value} = await iterator.next();
        if (done) {
          ended = true;
        } else {
          resultQueue.push({value});
        }
      } catch (error) {
        ended = true;
        resultQueue.push({error});
      }
      fulfillReadQueue();
      reading = false;
      fillQueue();
    }
    async function next() {
      if (resultQueue.length > 0) {
        const {error, value} = resultQueue.shift();
        if (error) {
          throw error;
        }
        fillQueue();
        return {done: false, value};
      }
      if (ended) {
        return {done: true, value: void 0};
      }
      const deferred = defer();
      readQueue.push(deferred);
      fillQueue();
      return deferred.promise;
    }
    const asyncIterableIterator = {
      next,
      [Symbol.asyncIterator]: () => asyncIterableIterator
    };
    return asyncIterableIterator;
  }
  function* syncBuffer(size, iterable) {
    const valueQueue = [];
    let e;
    try {
      for (const value of iterable) {
        valueQueue.push(value);
        if (valueQueue.length <= size) {
          continue;
        }
        yield valueQueue.shift();
      }
    } catch (error) {
      e = error;
    }
    for (const value of valueQueue) {
      yield value;
    }
    if (e) {
      throw e;
    }
  }
  function buffer(size, iterable) {
    if (iterable === void 0) {
      return (curriedIterable) => buffer(size, curriedIterable);
    }
    if (size === 0) {
      return iterable;
    }
    if (iterable[Symbol.asyncIterator]) {
      return _buffer(size, iterable);
    }
    return syncBuffer(size, iterable);
  }
  async function _collect(iterable) {
    const values = [];
    for await (const value of iterable) {
      values.push(value);
    }
    return values;
  }
  function collect(iterable) {
    if (iterable[Symbol.asyncIterator]) {
      return _collect(iterable);
    }
    return Array.from(iterable);
  }
  async function* _concat(iterables) {
    for await (const iterable of iterables) {
      yield* iterable;
    }
  }
  function* _syncConcat(iterables) {
    for (const iterable of iterables) {
      yield* iterable;
    }
  }
  function concat(...iterables) {
    const hasAnyAsync = iterables.find((itr) => itr[Symbol.asyncIterator] !== void 0);
    if (hasAnyAsync) {
      return _concat(iterables);
    } else {
      return _syncConcat(iterables);
    }
  }
  async function _consume(iterable) {
    for await (const val of iterable) {
    }
  }
  function consume(iterable) {
    if (iterable[Symbol.asyncIterator]) {
      return _consume(iterable);
    }
    for (const val of iterable) {
    }
  }
  async function* _filter(filterFunc, iterable) {
    for await (const data of iterable) {
      if (await filterFunc(data)) {
        yield data;
      }
    }
  }
  function filter(filterFunc, iterable) {
    if (iterable === void 0) {
      return (curriedIterable) => _filter(filterFunc, curriedIterable);
    }
    return _filter(filterFunc, iterable);
  }
  async function* flatten(iterable) {
    for await (const maybeItr of iterable) {
      if (maybeItr && typeof maybeItr !== "string" && (maybeItr[Symbol.iterator] || maybeItr[Symbol.asyncIterator])) {
        yield* flatten(maybeItr);
      } else {
        yield maybeItr;
      }
    }
  }
  async function* _map(func, iterable) {
    for await (const val of iterable) {
      yield await func(val);
    }
  }
  function map(func, iterable) {
    if (iterable === void 0) {
      return (curriedIterable) => _map(func, curriedIterable);
    }
    return _map(func, iterable);
  }
  function flatMap(func, iterable) {
    if (iterable === void 0) {
      return (curriedIterable) => flatMap(func, curriedIterable);
    }
    return filter((i) => i !== void 0 && i !== null, flatten(map(func, iterable)));
  }
  function _flatTransform(concurrency, func, iterable) {
    const iterator = getIterator(iterable);
    const resultQueue = [];
    const readQueue = [];
    let ended = false;
    let reading = false;
    let inflightCount = 0;
    let lastError = null;
    function fulfillReadQueue() {
      while (readQueue.length > 0 && resultQueue.length > 0) {
        const {resolve} = readQueue.shift();
        const value = resultQueue.shift();
        resolve({done: false, value});
      }
      while (readQueue.length > 0 && inflightCount === 0 && ended) {
        const {resolve, reject} = readQueue.shift();
        if (lastError) {
          reject(lastError);
          lastError = null;
        } else {
          resolve({done: true, value: void 0});
        }
      }
    }
    async function fillQueue() {
      if (ended) {
        fulfillReadQueue();
        return;
      }
      if (reading) {
        return;
      }
      if (inflightCount + resultQueue.length >= concurrency) {
        return;
      }
      reading = true;
      inflightCount++;
      try {
        const {done, value} = await iterator.next();
        if (done) {
          ended = true;
          inflightCount--;
          fulfillReadQueue();
        } else {
          mapAndQueue(value);
        }
      } catch (error) {
        ended = true;
        inflightCount--;
        lastError = error;
        fulfillReadQueue();
      }
      reading = false;
      fillQueue();
    }
    async function mapAndQueue(itrValue) {
      try {
        const value = await func(itrValue);
        if (value && value[Symbol.asyncIterator]) {
          for await (const asyncVal of value) {
            resultQueue.push(asyncVal);
          }
        } else {
          resultQueue.push(value);
        }
      } catch (error) {
        ended = true;
        lastError = error;
      }
      inflightCount--;
      fulfillReadQueue();
      fillQueue();
    }
    async function next() {
      if (resultQueue.length === 0) {
        const deferred = defer();
        readQueue.push(deferred);
        fillQueue();
        return deferred.promise;
      }
      const value = resultQueue.shift();
      fillQueue();
      return {done: false, value};
    }
    const asyncIterableIterator = {
      next,
      [Symbol.asyncIterator]: () => asyncIterableIterator
    };
    return asyncIterableIterator;
  }
  function flatTransform(concurrency, func, iterable) {
    if (func === void 0) {
      return (curriedFunc, curriedIterable) => curriedIterable ? flatTransform(concurrency, curriedFunc, curriedIterable) : flatTransform(concurrency, curriedFunc);
    }
    if (iterable === void 0) {
      return (curriedIterable) => flatTransform(concurrency, func, curriedIterable);
    }
    return filter((i) => i !== void 0 && i !== null, flatten(_flatTransform(concurrency, func, iterable)));
  }
  async function onceReadable(stream) {
    return new Promise((resolve) => {
      stream.once("readable", () => {
        resolve();
      });
    });
  }
  async function* _fromStream(stream) {
    while (true) {
      const data = stream.read();
      if (data !== null) {
        yield data;
        continue;
      }
      if (stream._readableState.ended) {
        break;
      }
      await onceReadable(stream);
    }
  }
  function fromStream(stream) {
    if (typeof stream[Symbol.asyncIterator] === "function") {
      return stream;
    }
    return _fromStream(stream);
  }
  async function* merge(...iterables) {
    const sources = new Set(iterables.map(getIterator));
    while (sources.size > 0) {
      for (const iterator of sources) {
        const nextVal = await iterator.next();
        if (nextVal.done) {
          sources.delete(iterator);
        } else {
          yield nextVal.value;
        }
      }
    }
  }
  function pipeline(firstFn, ...fns) {
    let previousFn = firstFn();
    for (const func of fns) {
      previousFn = func(previousFn);
    }
    return previousFn;
  }
  async function* _parallelMap(concurrency, func, iterable) {
    let transformError = null;
    const wrapFunc = (value) => ({
      value: func(value)
    });
    const stopOnError = async function* (source) {
      for await (const value of source) {
        if (transformError) {
          return;
        }
        yield value;
      }
    };
    const output = pipeline(() => iterable, buffer(1), stopOnError, map(wrapFunc), buffer(concurrency - 1));
    const itr = getIterator(output);
    while (true) {
      const {value, done} = await itr.next();
      if (done) {
        break;
      }
      try {
        const val = await value.value;
        if (!transformError) {
          yield val;
        }
      } catch (error) {
        transformError = error;
      }
    }
    if (transformError) {
      throw transformError;
    }
  }
  function parallelMap(concurrency, func, iterable) {
    if (func === void 0) {
      return (curriedFunc, curriedIterable) => parallelMap(concurrency, curriedFunc, curriedIterable);
    }
    if (iterable === void 0) {
      return (curriedIterable) => parallelMap(concurrency, func, curriedIterable);
    }
    if (concurrency === 1) {
      return map(func, iterable);
    }
    return _parallelMap(concurrency, func, iterable);
  }
  function parallelFlatMap(concurrency, func, iterable) {
    if (func === void 0) {
      return (curriedFunc, curriedIterable) => curriedIterable ? parallelFlatMap(concurrency, curriedFunc, curriedIterable) : parallelFlatMap(concurrency, curriedFunc);
    }
    if (iterable === void 0) {
      return (curriedIterable) => parallelFlatMap(concurrency, func, curriedIterable);
    }
    return filter((i) => i !== void 0 && i !== null, flatten(parallelMap(concurrency, func, iterable)));
  }
  async function* parallelMerge(...iterables) {
    const inputs = iterables.map(getIterator);
    const concurrentWork = new Set();
    const values = new Map();
    let lastError = null;
    let errCb = null;
    let valueCb = null;
    const notifyError = (err) => {
      lastError = err;
      if (errCb) {
        errCb(err);
      }
    };
    const notifyDone = (value) => {
      if (valueCb) {
        valueCb(value);
      }
    };
    const waitForQueue = () => new Promise((resolve, reject) => {
      if (lastError) {
        reject(lastError);
      }
      if (values.size > 0) {
        return resolve();
      }
      valueCb = resolve;
      errCb = reject;
    });
    const queueNext = (input) => {
      const nextVal = Promise.resolve(input.next()).then(async ({done, value}) => {
        if (!done) {
          values.set(input, value);
        }
        concurrentWork.delete(nextVal);
      });
      concurrentWork.add(nextVal);
      nextVal.then(notifyDone, notifyError);
    };
    for (const input of inputs) {
      queueNext(input);
    }
    while (true) {
      if (concurrentWork.size === 0 && values.size === 0) {
        return;
      }
      await waitForQueue();
      for (const [input, value] of values) {
        values.delete(input);
        yield value;
        queueNext(input);
      }
    }
  }
  async function _reduce(func, start, iterable) {
    let value = start;
    for await (const nextItem of iterable) {
      value = await func(value, nextItem);
    }
    return value;
  }
  function reduce(func, start, iterable) {
    if (start === void 0) {
      return (curriedStart, curriedIterable) => curriedIterable ? _reduce(func, curriedStart, curriedIterable) : reduce(func, curriedStart);
    }
    if (iterable === void 0) {
      return (curriedIterable) => reduce(func, start, curriedIterable);
    }
    return _reduce(func, start, iterable);
  }
  async function* _take(count, iterable) {
    let taken = 0;
    for await (const val of iterable) {
      yield await val;
      taken++;
      if (taken >= count) {
        break;
      }
    }
  }
  function* _syncTake(count, iterable) {
    let taken = 0;
    for (const val of iterable) {
      yield val;
      taken++;
      if (taken >= count) {
        break;
      }
    }
  }
  function take(count, iterable) {
    if (iterable === void 0) {
      return (curriedIterable) => take(count, curriedIterable);
    }
    if (iterable[Symbol.asyncIterator]) {
      return _take(count, iterable);
    }
    return _syncTake(count, iterable);
  }
  async function* _asyncTap(func, iterable) {
    for await (const val of iterable) {
      await func(val);
      yield val;
    }
  }
  function tap(func, iterable) {
    if (iterable === void 0) {
      return (curriedIterable) => _asyncTap(func, curriedIterable);
    }
    return _asyncTap(func, iterable);
  }
  function addTime(a, b) {
    let seconds = a[0] + b[0];
    let nanoseconds = a[1] + b[1];
    if (nanoseconds >= 1e9) {
      const remainder = nanoseconds % 1e9;
      seconds += (nanoseconds - remainder) / 1e9;
      nanoseconds = remainder;
    }
    return [seconds, nanoseconds];
  }
  async function* _asyncTime(config, iterable) {
    const itr = iterable[Symbol.asyncIterator]();
    let total = [0, 0];
    while (true) {
      const start = process.hrtime();
      const {value, done} = await itr.next();
      const delta = process.hrtime(start);
      total = addTime(total, delta);
      if (config.progress) {
        config.progress(delta, total);
      }
      if (done) {
        if (config.total) {
          config.total(total);
        }
        return value;
      }
      yield value;
    }
  }
  function* _syncTime(config, iterable) {
    const itr = iterable[Symbol.iterator]();
    let total = [0, 0];
    while (true) {
      const start = process.hrtime();
      const {value, done} = itr.next();
      const delta = process.hrtime(start);
      total = addTime(total, delta);
      if (config.progress) {
        config.progress(delta, total);
      }
      if (done) {
        if (config.total) {
          config.total(total);
        }
        return value;
      }
      yield value;
    }
  }
  function time(config = {}, iterable) {
    if (iterable === void 0) {
      return (curriedIterable) => time(config, curriedIterable);
    }
    if (iterable[Symbol.asyncIterator] !== void 0) {
      return _asyncTime(config, iterable);
    } else {
      return _syncTime(config, iterable);
    }
  }
  function _transform(concurrency, func, iterable) {
    const iterator = getIterator(iterable);
    const resultQueue = [];
    const readQueue = [];
    let ended = false;
    let reading = false;
    let inflightCount = 0;
    let lastError = null;
    function fulfillReadQueue() {
      while (readQueue.length > 0 && resultQueue.length > 0) {
        const {resolve} = readQueue.shift();
        const value = resultQueue.shift();
        resolve({done: false, value});
      }
      while (readQueue.length > 0 && inflightCount === 0 && ended) {
        const {resolve, reject} = readQueue.shift();
        if (lastError) {
          reject(lastError);
          lastError = null;
        } else {
          resolve({done: true, value: void 0});
        }
      }
    }
    async function fillQueue() {
      if (ended) {
        fulfillReadQueue();
        return;
      }
      if (reading) {
        return;
      }
      if (inflightCount + resultQueue.length >= concurrency) {
        return;
      }
      reading = true;
      inflightCount++;
      try {
        const {done, value} = await iterator.next();
        if (done) {
          ended = true;
          inflightCount--;
          fulfillReadQueue();
        } else {
          mapAndQueue(value);
        }
      } catch (error) {
        ended = true;
        inflightCount--;
        lastError = error;
        fulfillReadQueue();
      }
      reading = false;
      fillQueue();
    }
    async function mapAndQueue(itrValue) {
      try {
        const value = await func(itrValue);
        resultQueue.push(value);
      } catch (error) {
        ended = true;
        lastError = error;
      }
      inflightCount--;
      fulfillReadQueue();
      fillQueue();
    }
    async function next() {
      if (resultQueue.length === 0) {
        const deferred = defer();
        readQueue.push(deferred);
        fillQueue();
        return deferred.promise;
      }
      const value = resultQueue.shift();
      fillQueue();
      return {done: false, value};
    }
    const asyncIterableIterator = {
      next,
      [Symbol.asyncIterator]: () => asyncIterableIterator
    };
    return asyncIterableIterator;
  }
  function transform(concurrency, func, iterable) {
    if (func === void 0) {
      return (curriedFunc, curriedIterable) => curriedIterable ? transform(concurrency, curriedFunc, curriedIterable) : transform(concurrency, curriedFunc);
    }
    if (iterable === void 0) {
      return (curriedIterable) => transform(concurrency, func, curriedIterable);
    }
    return _transform(concurrency, func, iterable);
  }
  async function _writeToStream(stream, iterable) {
    let lastError = null;
    let errCb = null;
    let drainCb = null;
    const notifyError = (err) => {
      lastError = err;
      if (errCb) {
        errCb(err);
      }
    };
    const notifyDrain = () => {
      if (drainCb) {
        drainCb();
      }
    };
    const cleanup = () => {
      stream.removeListener("error", notifyError);
      stream.removeListener("drain", notifyDrain);
    };
    stream.once("error", notifyError);
    const waitForDrain = () => new Promise((resolve, reject) => {
      if (lastError) {
        return reject(lastError);
      }
      stream.once("drain", notifyDrain);
      drainCb = resolve;
      errCb = reject;
    });
    for await (const value of iterable) {
      if (stream.write(value) === false) {
        await waitForDrain();
      }
      if (lastError) {
        break;
      }
    }
    cleanup();
    if (lastError) {
      throw lastError;
    }
  }
  function writeToStream(stream, iterable) {
    if (iterable === void 0) {
      return (curriedIterable) => _writeToStream(stream, curriedIterable);
    }
    return _writeToStream(stream, iterable);
  }
});

// node_modules/it-pipe/index.js
var require_it_pipe = __commonJS((exports2, module2) => {
  var rawPipe = (...fns) => {
    let res;
    while (fns.length) {
      res = fns.shift()(res);
    }
    return res;
  };
  var isIterable = (obj) => obj && (typeof obj[Symbol.asyncIterator] === "function" || typeof obj[Symbol.iterator] === "function" || typeof obj.next === "function");
  var isDuplex = (obj) => obj && typeof obj.sink === "function" && isIterable(obj.source);
  var duplexPipelineFn = (duplex) => (source) => {
    duplex.sink(source);
    return duplex.source;
  };
  var pipe = (...fns) => {
    if (isDuplex(fns[0])) {
      const duplex = fns[0];
      fns[0] = () => duplex.source;
    } else if (isIterable(fns[0])) {
      const source = fns[0];
      fns[0] = () => source;
    }
    if (fns.length > 1) {
      if (isDuplex(fns[fns.length - 1])) {
        fns[fns.length - 1] = fns[fns.length - 1].sink;
      }
    }
    if (fns.length > 2) {
      for (let i = 1; i < fns.length - 1; i++) {
        if (isDuplex(fns[i])) {
          fns[i] = duplexPipelineFn(fns[i]);
        }
      }
    }
    return rawPipe(...fns);
  };
  module2.exports = pipe;
  module2.exports.pipe = pipe;
  module2.exports.rawPipe = rawPipe;
  module2.exports.isIterable = isIterable;
  module2.exports.isDuplex = isDuplex;
});

// node_modules/ipfs-core/src/components/block/rm.js
var require_rm3 = __commonJS((exports2, module2) => {
  "use strict";
  var CID = require_src7();
  var errCode = require_err_code();
  var {parallelMap, filter} = require_dist2();
  var {pipe} = require_it_pipe();
  var {PinTypes} = require_pin_manager();
  var {cleanCid} = require_utils18();
  var withTimeoutOption = require_with_timeout_option();
  var BLOCK_RM_CONCURRENCY = 8;
  module2.exports = ({blockService, gcLock, pinManager}) => {
    async function* rm(cids, options = {}) {
      if (!Array.isArray(cids)) {
        cids = [cids];
      }
      const release = await gcLock.writeLock();
      try {
        yield* pipe(cids, parallelMap(BLOCK_RM_CONCURRENCY, async (cid) => {
          cid = cleanCid(cid);
          const result = {cid};
          try {
            const pinResult = await pinManager.isPinnedWithType(cid, PinTypes.all);
            if (pinResult.pinned) {
              if (CID.isCID(pinResult.reason)) {
                throw errCode(new Error(`pinned via ${pinResult.reason}`));
              }
              throw errCode(new Error(`pinned: ${pinResult.reason}`));
            }
            const has = await blockService._repo.blocks.has(cid);
            if (!has) {
              throw errCode(new Error("block not found"), "ERR_BLOCK_NOT_FOUND");
            }
            await blockService.delete(cid);
          } catch (err) {
            if (!options.force) {
              err.message = `cannot remove ${cid}: ${err.message}`;
              result.error = err;
            }
          }
          return result;
        }), filter(() => !options.quiet));
      } finally {
        release();
      }
    }
    return withTimeoutOption(rm);
  };
});

// node_modules/ipfs-core/src/components/block/stat.js
var require_stat2 = __commonJS((exports2, module2) => {
  "use strict";
  var {cleanCid} = require_utils18();
  var withTimeoutOption = require_with_timeout_option();
  module2.exports = ({blockService, preload}) => {
    async function stat(cid, options = {}) {
      cid = cleanCid(cid);
      if (options.preload !== false) {
        preload(cid);
      }
      const block = await blockService.get(cid);
      return {cid, size: block.data.length};
    }
    return withTimeoutOption(stat);
  };
});

// node_modules/ipfs-core/src/components/block/index.js
var require_block = __commonJS((exports2, module2) => {
  "use strict";
  var createGet = require_get();
  var createPut = require_put();
  var createRm = require_rm3();
  var createStat = require_stat2();
  var BlockAPI = class {
    constructor({blockService, preload, gcLock, pinManager, pin}) {
      this.get = createGet({blockService, preload});
      this.put = createPut({blockService, preload, gcLock, pin});
      this.rm = createRm({blockService, gcLock, pinManager});
      this.stat = createStat({blockService, preload});
    }
  };
  module2.exports = BlockAPI;
});

// node_modules/ipfs-core/src/components/add.js
var require_add3 = __commonJS((exports2, module2) => {
  "use strict";
  var last = require_it_last();
  module2.exports = ({addAll}) => {
    async function add(entry, options) {
      const source = entry;
      const result = await last(addAll(source, options));
      if (result == null) {
        throw Error("Failed to add a file, if you see this please report a bug");
      }
      return result;
    }
    return add;
  };
});

// node_modules/it-batch/index.js
var require_it_batch = __commonJS((exports2, module2) => {
  "use strict";
  async function* batch(source, size) {
    size = parseInt(size);
    if (isNaN(size) || size < 1) {
      size = 1;
    }
    let things = [];
    for await (const thing of source) {
      things.push(thing);
      while (things.length >= size) {
        yield things.slice(0, size);
        things = things.slice(size);
      }
    }
    while (things.length) {
      yield things.slice(0, size);
      things = things.slice(size);
    }
  }
  module2.exports = batch;
});

// node_modules/it-parallel-batch/index.js
var require_it_parallel_batch = __commonJS((exports2, module2) => {
  "use strict";
  var batch = require_it_batch();
  async function* parallelBatch(source, size) {
    size = parseInt(size);
    if (isNaN(size) || size < 1) {
      size = 1;
    }
    for await (const tasks of batch(source, size)) {
      const things = tasks.map((p) => {
        return p().then((value) => ({ok: true, value}), (err) => ({ok: false, err}));
      });
      for (let i = 0; i < things.length; i++) {
        const result = await things[i];
        if (result.ok) {
          yield result.value;
        } else {
          throw result.err;
        }
      }
    }
  }
  module2.exports = parallelBatch;
});

// node_modules/ipfs-unixfs-importer/src/utils/persist.js
var require_persist = __commonJS((exports2, module2) => {
  "use strict";
  var mh = require_src14();
  var CID = require_src7();
  var persist = async (buffer, block, options) => {
    if (!options.codec) {
      options.codec = "dag-pb";
    }
    if (!options.cidVersion) {
      options.cidVersion = 0;
    }
    if (!options.hashAlg) {
      options.hashAlg = "sha2-256";
    }
    if (options.hashAlg !== "sha2-256") {
      options.cidVersion = 1;
    }
    const multihash = await mh(buffer, options.hashAlg);
    const cid = new CID(options.cidVersion, options.codec, multihash);
    if (!options.onlyHash) {
      await block.put(buffer, {
        ...options,
        cid
      });
    }
    return cid;
  };
  module2.exports = persist;
});

// node_modules/ipfs-unixfs-importer/src/dag-builder/dir.js
var require_dir = __commonJS((exports2, module2) => {
  "use strict";
  var UnixFS = require_src17();
  var persist = require_persist();
  var {
    DAGNode
  } = require_src16();
  var dirBuilder = async (item, block, options) => {
    const unixfs = new UnixFS({
      type: "directory",
      mtime: item.mtime,
      mode: item.mode
    });
    const buffer = new DAGNode(unixfs.marshal()).serialize();
    const cid = await persist(buffer, block, options);
    const path = item.path;
    return {
      cid,
      path,
      unixfs,
      size: buffer.length
    };
  };
  module2.exports = dirBuilder;
});

// node_modules/ipfs-unixfs-importer/src/dag-builder/file/flat.js
var require_flat = __commonJS((exports2, module2) => {
  "use strict";
  var all = require_it_all();
  module2.exports = async function* (source, reduce) {
    yield await reduce(await all(source));
  };
});

// node_modules/ipfs-unixfs-importer/src/dag-builder/file/balanced.js
var require_balanced = __commonJS((exports2, module2) => {
  "use strict";
  var batch = require_it_batch();
  async function* balanced(source, reduce, options) {
    yield await reduceToParents(source, reduce, options);
  }
  async function reduceToParents(source, reduce, options) {
    const roots = [];
    for await (const chunked of batch(source, options.maxChildrenPerNode)) {
      roots.push(await reduce(chunked));
    }
    if (roots.length > 1) {
      return reduceToParents(roots, reduce, options);
    }
    return roots[0];
  }
  module2.exports = balanced;
});

// node_modules/ipfs-unixfs-importer/src/dag-builder/file/trickle.js
var require_trickle = __commonJS((exports2, module2) => {
  "use strict";
  var batch = require_it_batch();
  module2.exports = function* trickleReduceToRoot(source, reduce, options) {
    yield trickleStream(source, reduce, options);
  };
  async function trickleStream(source, reduce, options) {
    let root;
    let iteration = 0;
    let maxDepth = 1;
    let subTree = root = new Root(options.layerRepeat);
    for await (const layer of batch(source, options.maxChildrenPerNode)) {
      if (subTree.isFull()) {
        if (subTree !== root) {
          root.addChild(await subTree.reduce(reduce));
        }
        if (iteration && iteration % options.layerRepeat === 0) {
          maxDepth++;
        }
        subTree = new SubTree(maxDepth, options.layerRepeat, iteration);
        iteration++;
      }
      subTree.append(layer);
    }
    if (subTree && subTree !== root) {
      root.addChild(await subTree.reduce(reduce));
    }
    return root.reduce(reduce);
  }
  var SubTree = class {
    constructor(maxDepth, layerRepeat, iteration) {
      this.maxDepth = maxDepth;
      this.layerRepeat = layerRepeat;
      this.currentDepth = 1;
      this.iteration = iteration;
      this.root = this.node = this.parent = {
        children: [],
        depth: this.currentDepth,
        maxDepth,
        maxChildren: (this.maxDepth - this.currentDepth) * this.layerRepeat
      };
    }
    isFull() {
      if (!this.root.data) {
        return false;
      }
      if (this.currentDepth < this.maxDepth && this.node.maxChildren) {
        this._addNextNodeToParent(this.node);
        return false;
      }
      const distantRelative = this._findParent(this.node, this.currentDepth);
      if (distantRelative) {
        this._addNextNodeToParent(distantRelative);
        return false;
      }
      return true;
    }
    _addNextNodeToParent(parent) {
      this.parent = parent;
      const nextNode = {
        children: [],
        depth: parent.depth + 1,
        parent,
        maxDepth: this.maxDepth,
        maxChildren: Math.floor(parent.children.length / this.layerRepeat) * this.layerRepeat
      };
      parent.children.push(nextNode);
      this.currentDepth = nextNode.depth;
      this.node = nextNode;
    }
    append(layer) {
      this.node.data = layer;
    }
    reduce(reduce) {
      return this._reduce(this.root, reduce);
    }
    async _reduce(node, reduce) {
      let children = [];
      if (node.children.length) {
        children = await Promise.all(node.children.filter((child) => child.data).map((child) => this._reduce(child, reduce)));
      }
      return reduce(node.data.concat(children));
    }
    _findParent(node, depth) {
      const parent = node.parent;
      if (!parent || parent.depth === 0) {
        return;
      }
      if (parent.children.length === parent.maxChildren || !parent.maxChildren) {
        return this._findParent(parent, depth);
      }
      return parent;
    }
  };
  var Root = class extends SubTree {
    constructor(layerRepeat) {
      super(0, layerRepeat);
      this.root.depth = 0;
      this.currentDepth = 1;
    }
    addChild(child) {
      this.root.children.push(child);
    }
    reduce(reduce) {
      return reduce(this.root.data.concat(this.root.children));
    }
  };
});

// node_modules/ipfs-unixfs-importer/src/dag-builder/file/buffer-importer.js
var require_buffer_importer = __commonJS((exports2, module2) => {
  "use strict";
  var UnixFS = require_src17();
  var persist = require_persist();
  var {
    DAGNode
  } = require_src16();
  async function* bufferImporter(file, source, block, options) {
    for await (let buffer of source) {
      yield async () => {
        options.progress(buffer.length, file.path);
        let unixfs;
        const opts = {
          ...options
        };
        if (options.rawLeaves) {
          opts.codec = "raw";
          opts.cidVersion = 1;
        } else {
          unixfs = new UnixFS({
            type: options.leafType,
            data: buffer,
            mtime: file.mtime,
            mode: file.mode
          });
          buffer = new DAGNode(unixfs.marshal()).serialize();
        }
        return {
          cid: await persist(buffer, block, opts),
          unixfs,
          size: buffer.length
        };
      };
    }
  }
  module2.exports = bufferImporter;
});

// node_modules/ipfs-unixfs-importer/src/dag-builder/file/index.js
var require_file = __commonJS((exports2, module2) => {
  "use strict";
  var errCode = require_err_code();
  var UnixFS = require_src17();
  var persist = require_persist();
  var {
    DAGNode,
    DAGLink
  } = require_src16();
  var all = require_it_all();
  var parallelBatch = require_it_parallel_batch();
  var mh = require_src14().multihash;
  var dagBuilders = {
    flat: require_flat(),
    balanced: require_balanced(),
    trickle: require_trickle()
  };
  async function* buildFileBatch(file, source, block, options) {
    let count = -1;
    let previous;
    let bufferImporter;
    if (typeof options.bufferImporter === "function") {
      bufferImporter = options.bufferImporter;
    } else {
      bufferImporter = require_buffer_importer();
    }
    for await (const entry of parallelBatch(bufferImporter(file, source, block, options), options.blockWriteConcurrency)) {
      count++;
      if (count === 0) {
        previous = entry;
        continue;
      } else if (count === 1) {
        yield previous;
        previous = null;
      }
      yield entry;
    }
    if (previous) {
      previous.single = true;
      yield previous;
    }
  }
  var reduce = (file, block, options) => {
    return async function(leaves) {
      if (leaves.length === 1 && leaves[0].single && options.reduceSingleLeafToSelf) {
        const leaf = leaves[0];
        if (leaf.cid.codec === "raw" && (file.mtime !== void 0 || file.mode !== void 0)) {
          let {data: buffer2} = await block.get(leaf.cid, options);
          leaf.unixfs = new UnixFS({
            type: "file",
            mtime: file.mtime,
            mode: file.mode,
            data: buffer2
          });
          const multihash = mh.decode(leaf.cid.multihash);
          buffer2 = new DAGNode(leaf.unixfs.marshal()).serialize();
          leaf.cid = await persist(buffer2, block, {
            ...options,
            codec: "dag-pb",
            hashAlg: multihash.name,
            cidVersion: options.cidVersion
          });
          leaf.size = buffer2.length;
        }
        return {
          cid: leaf.cid,
          path: file.path,
          unixfs: leaf.unixfs,
          size: leaf.size
        };
      }
      const f = new UnixFS({
        type: "file",
        mtime: file.mtime,
        mode: file.mode
      });
      const links = leaves.filter((leaf) => {
        if (leaf.cid.codec === "raw" && leaf.size) {
          return true;
        }
        if (!leaf.unixfs.data && leaf.unixfs.fileSize()) {
          return true;
        }
        return Boolean(leaf.unixfs.data.length);
      }).map((leaf) => {
        if (leaf.cid.codec === "raw") {
          f.addBlockSize(leaf.size);
          return new DAGLink(leaf.name, leaf.size, leaf.cid);
        }
        if (!leaf.unixfs.data) {
          f.addBlockSize(leaf.unixfs.fileSize());
        } else {
          f.addBlockSize(leaf.unixfs.data.length);
        }
        return new DAGLink(leaf.name, leaf.size, leaf.cid);
      });
      const node = new DAGNode(f.marshal(), links);
      const buffer = node.serialize();
      const cid = await persist(buffer, block, options);
      return {
        cid,
        path: file.path,
        unixfs: f,
        size: buffer.length + node.Links.reduce((acc, curr) => acc + curr.Tsize, 0)
      };
    };
  };
  var fileBuilder = async (file, source, block, options) => {
    const dagBuilder = dagBuilders[options.strategy];
    if (!dagBuilder) {
      throw errCode(new Error(`Unknown importer build strategy name: ${options.strategy}`), "ERR_BAD_STRATEGY");
    }
    const roots = await all(dagBuilder(buildFileBatch(file, source, block, options), reduce(file, block, options), options));
    if (roots.length > 1) {
      throw errCode(new Error("expected a maximum of 1 roots and got " + roots.length), "ETOOMANYROOTS");
    }
    return roots[0];
  };
  module2.exports = fileBuilder;
});

// node_modules/bl/BufferList.js
var require_BufferList = __commonJS((exports2, module2) => {
  "use strict";
  var {Buffer: Buffer2} = require_buffer();
  var symbol = Symbol.for("BufferList");
  function BufferList(buf) {
    if (!(this instanceof BufferList)) {
      return new BufferList(buf);
    }
    BufferList._init.call(this, buf);
  }
  BufferList._init = function _init(buf) {
    Object.defineProperty(this, symbol, {value: true});
    this._bufs = [];
    this.length = 0;
    if (buf) {
      this.append(buf);
    }
  };
  BufferList.prototype._new = function _new(buf) {
    return new BufferList(buf);
  };
  BufferList.prototype._offset = function _offset(offset) {
    if (offset === 0) {
      return [0, 0];
    }
    let tot = 0;
    for (let i = 0; i < this._bufs.length; i++) {
      const _t = tot + this._bufs[i].length;
      if (offset < _t || i === this._bufs.length - 1) {
        return [i, offset - tot];
      }
      tot = _t;
    }
  };
  BufferList.prototype._reverseOffset = function(blOffset) {
    const bufferId = blOffset[0];
    let offset = blOffset[1];
    for (let i = 0; i < bufferId; i++) {
      offset += this._bufs[i].length;
    }
    return offset;
  };
  BufferList.prototype.get = function get(index) {
    if (index > this.length || index < 0) {
      return void 0;
    }
    const offset = this._offset(index);
    return this._bufs[offset[0]][offset[1]];
  };
  BufferList.prototype.slice = function slice(start, end) {
    if (typeof start === "number" && start < 0) {
      start += this.length;
    }
    if (typeof end === "number" && end < 0) {
      end += this.length;
    }
    return this.copy(null, 0, start, end);
  };
  BufferList.prototype.copy = function copy(dst, dstStart, srcStart, srcEnd) {
    if (typeof srcStart !== "number" || srcStart < 0) {
      srcStart = 0;
    }
    if (typeof srcEnd !== "number" || srcEnd > this.length) {
      srcEnd = this.length;
    }
    if (srcStart >= this.length) {
      return dst || Buffer2.alloc(0);
    }
    if (srcEnd <= 0) {
      return dst || Buffer2.alloc(0);
    }
    const copy2 = !!dst;
    const off = this._offset(srcStart);
    const len = srcEnd - srcStart;
    let bytes = len;
    let bufoff = copy2 && dstStart || 0;
    let start = off[1];
    if (srcStart === 0 && srcEnd === this.length) {
      if (!copy2) {
        return this._bufs.length === 1 ? this._bufs[0] : Buffer2.concat(this._bufs, this.length);
      }
      for (let i = 0; i < this._bufs.length; i++) {
        this._bufs[i].copy(dst, bufoff);
        bufoff += this._bufs[i].length;
      }
      return dst;
    }
    if (bytes <= this._bufs[off[0]].length - start) {
      return copy2 ? this._bufs[off[0]].copy(dst, dstStart, start, start + bytes) : this._bufs[off[0]].slice(start, start + bytes);
    }
    if (!copy2) {
      dst = Buffer2.allocUnsafe(len);
    }
    for (let i = off[0]; i < this._bufs.length; i++) {
      const l = this._bufs[i].length - start;
      if (bytes > l) {
        this._bufs[i].copy(dst, bufoff, start);
        bufoff += l;
      } else {
        this._bufs[i].copy(dst, bufoff, start, start + bytes);
        bufoff += l;
        break;
      }
      bytes -= l;
      if (start) {
        start = 0;
      }
    }
    if (dst.length > bufoff)
      return dst.slice(0, bufoff);
    return dst;
  };
  BufferList.prototype.shallowSlice = function shallowSlice(start, end) {
    start = start || 0;
    end = typeof end !== "number" ? this.length : end;
    if (start < 0) {
      start += this.length;
    }
    if (end < 0) {
      end += this.length;
    }
    if (start === end) {
      return this._new();
    }
    const startOffset = this._offset(start);
    const endOffset = this._offset(end);
    const buffers = this._bufs.slice(startOffset[0], endOffset[0] + 1);
    if (endOffset[1] === 0) {
      buffers.pop();
    } else {
      buffers[buffers.length - 1] = buffers[buffers.length - 1].slice(0, endOffset[1]);
    }
    if (startOffset[1] !== 0) {
      buffers[0] = buffers[0].slice(startOffset[1]);
    }
    return this._new(buffers);
  };
  BufferList.prototype.toString = function toString(encoding, start, end) {
    return this.slice(start, end).toString(encoding);
  };
  BufferList.prototype.consume = function consume(bytes) {
    bytes = Math.trunc(bytes);
    if (Number.isNaN(bytes) || bytes <= 0)
      return this;
    while (this._bufs.length) {
      if (bytes >= this._bufs[0].length) {
        bytes -= this._bufs[0].length;
        this.length -= this._bufs[0].length;
        this._bufs.shift();
      } else {
        this._bufs[0] = this._bufs[0].slice(bytes);
        this.length -= bytes;
        break;
      }
    }
    return this;
  };
  BufferList.prototype.duplicate = function duplicate() {
    const copy = this._new();
    for (let i = 0; i < this._bufs.length; i++) {
      copy.append(this._bufs[i]);
    }
    return copy;
  };
  BufferList.prototype.append = function append(buf) {
    if (buf == null) {
      return this;
    }
    if (buf.buffer) {
      this._appendBuffer(Buffer2.from(buf.buffer, buf.byteOffset, buf.byteLength));
    } else if (Array.isArray(buf)) {
      for (let i = 0; i < buf.length; i++) {
        this.append(buf[i]);
      }
    } else if (this._isBufferList(buf)) {
      for (let i = 0; i < buf._bufs.length; i++) {
        this.append(buf._bufs[i]);
      }
    } else {
      if (typeof buf === "number") {
        buf = buf.toString();
      }
      this._appendBuffer(Buffer2.from(buf));
    }
    return this;
  };
  BufferList.prototype._appendBuffer = function appendBuffer(buf) {
    this._bufs.push(buf);
    this.length += buf.length;
  };
  BufferList.prototype.indexOf = function(search, offset, encoding) {
    if (encoding === void 0 && typeof offset === "string") {
      encoding = offset;
      offset = void 0;
    }
    if (typeof search === "function" || Array.isArray(search)) {
      throw new TypeError('The "value" argument must be one of type string, Buffer, BufferList, or Uint8Array.');
    } else if (typeof search === "number") {
      search = Buffer2.from([search]);
    } else if (typeof search === "string") {
      search = Buffer2.from(search, encoding);
    } else if (this._isBufferList(search)) {
      search = search.slice();
    } else if (Array.isArray(search.buffer)) {
      search = Buffer2.from(search.buffer, search.byteOffset, search.byteLength);
    } else if (!Buffer2.isBuffer(search)) {
      search = Buffer2.from(search);
    }
    offset = Number(offset || 0);
    if (isNaN(offset)) {
      offset = 0;
    }
    if (offset < 0) {
      offset = this.length + offset;
    }
    if (offset < 0) {
      offset = 0;
    }
    if (search.length === 0) {
      return offset > this.length ? this.length : offset;
    }
    const blOffset = this._offset(offset);
    let blIndex = blOffset[0];
    let buffOffset = blOffset[1];
    for (; blIndex < this._bufs.length; blIndex++) {
      const buff = this._bufs[blIndex];
      while (buffOffset < buff.length) {
        const availableWindow = buff.length - buffOffset;
        if (availableWindow >= search.length) {
          const nativeSearchResult = buff.indexOf(search, buffOffset);
          if (nativeSearchResult !== -1) {
            return this._reverseOffset([blIndex, nativeSearchResult]);
          }
          buffOffset = buff.length - search.length + 1;
        } else {
          const revOffset = this._reverseOffset([blIndex, buffOffset]);
          if (this._match(revOffset, search)) {
            return revOffset;
          }
          buffOffset++;
        }
      }
      buffOffset = 0;
    }
    return -1;
  };
  BufferList.prototype._match = function(offset, search) {
    if (this.length - offset < search.length) {
      return false;
    }
    for (let searchOffset = 0; searchOffset < search.length; searchOffset++) {
      if (this.get(offset + searchOffset) !== search[searchOffset]) {
        return false;
      }
    }
    return true;
  };
  (function() {
    const methods = {
      readDoubleBE: 8,
      readDoubleLE: 8,
      readFloatBE: 4,
      readFloatLE: 4,
      readInt32BE: 4,
      readInt32LE: 4,
      readUInt32BE: 4,
      readUInt32LE: 4,
      readInt16BE: 2,
      readInt16LE: 2,
      readUInt16BE: 2,
      readUInt16LE: 2,
      readInt8: 1,
      readUInt8: 1,
      readIntBE: null,
      readIntLE: null,
      readUIntBE: null,
      readUIntLE: null
    };
    for (const m in methods) {
      (function(m2) {
        if (methods[m2] === null) {
          BufferList.prototype[m2] = function(offset, byteLength) {
            return this.slice(offset, offset + byteLength)[m2](0, byteLength);
          };
        } else {
          BufferList.prototype[m2] = function(offset) {
            return this.slice(offset, offset + methods[m2])[m2](0);
          };
        }
      })(m);
    }
  })();
  BufferList.prototype._isBufferList = function _isBufferList(b) {
    return b instanceof BufferList || BufferList.isBufferList(b);
  };
  BufferList.isBufferList = function isBufferList(b) {
    return b != null && b[symbol];
  };
  module2.exports = BufferList;
});

// node_modules/rabin-wasm/src/rabin.js
var require_rabin = __commonJS((exports2, module2) => {
  var Rabin = class {
    constructor(asModule, bits = 12, min = 8 * 1024, max = 32 * 1024, windowSize = 64, polynomial) {
      this.bits = bits;
      this.min = min;
      this.max = max;
      this.asModule = asModule;
      this.rabin = new asModule.Rabin(bits, min, max, windowSize, polynomial);
      this.polynomial = polynomial;
    }
    fingerprint(buf) {
      const {
        __retain,
        __release,
        __allocArray,
        __getInt32Array,
        Int32Array_ID,
        Uint8Array_ID
      } = this.asModule;
      const lengths = new Int32Array(Math.ceil(buf.length / this.min));
      const lengthsPtr = __retain(__allocArray(Int32Array_ID, lengths));
      const pointer = __retain(__allocArray(Uint8Array_ID, buf));
      const out = this.rabin.fingerprint(pointer, lengthsPtr);
      const processed = __getInt32Array(out);
      __release(pointer);
      __release(lengthsPtr);
      const cleanArr = [];
      for (let i = 0; i < processed.length; i++) {
        if (processed[i] === 0)
          break;
        cleanArr[i] = processed[i];
      }
      return cleanArr;
    }
  };
  module2.exports = Rabin;
});

// node_modules/@assemblyscript/loader/index.js
var require_loader = __commonJS((exports2) => {
  "use strict";
  var ID_OFFSET = -8;
  var SIZE_OFFSET = -4;
  var ARRAYBUFFER_ID = 0;
  var STRING_ID = 1;
  var ARRAYBUFFERVIEW = 1 << 0;
  var ARRAY = 1 << 1;
  var SET = 1 << 2;
  var MAP = 1 << 3;
  var VAL_ALIGN_OFFSET = 5;
  var VAL_ALIGN = 1 << VAL_ALIGN_OFFSET;
  var VAL_SIGNED = 1 << 10;
  var VAL_FLOAT = 1 << 11;
  var VAL_NULLABLE = 1 << 12;
  var VAL_MANAGED = 1 << 13;
  var KEY_ALIGN_OFFSET = 14;
  var KEY_ALIGN = 1 << KEY_ALIGN_OFFSET;
  var KEY_SIGNED = 1 << 19;
  var KEY_FLOAT = 1 << 20;
  var KEY_NULLABLE = 1 << 21;
  var KEY_MANAGED = 1 << 22;
  var ARRAYBUFFERVIEW_BUFFER_OFFSET = 0;
  var ARRAYBUFFERVIEW_DATASTART_OFFSET = 4;
  var ARRAYBUFFERVIEW_DATALENGTH_OFFSET = 8;
  var ARRAYBUFFERVIEW_SIZE = 12;
  var ARRAY_LENGTH_OFFSET = 12;
  var ARRAY_SIZE = 16;
  var BIGINT = typeof BigUint64Array !== "undefined";
  var THIS = Symbol();
  var CHUNKSIZE = 1024;
  function getStringImpl(buffer, ptr) {
    const U32 = new Uint32Array(buffer);
    const U16 = new Uint16Array(buffer);
    var length = U32[ptr + SIZE_OFFSET >>> 2] >>> 1;
    var offset = ptr >>> 1;
    if (length <= CHUNKSIZE)
      return String.fromCharCode.apply(String, U16.subarray(offset, offset + length));
    const parts = [];
    do {
      const last = U16[offset + CHUNKSIZE - 1];
      const size = last >= 55296 && last < 56320 ? CHUNKSIZE - 1 : CHUNKSIZE;
      parts.push(String.fromCharCode.apply(String, U16.subarray(offset, offset += size)));
      length -= size;
    } while (length > CHUNKSIZE);
    return parts.join("") + String.fromCharCode.apply(String, U16.subarray(offset, offset + length));
  }
  function preInstantiate(imports) {
    const baseModule = {};
    function getString(memory, ptr) {
      if (!memory)
        return "<yet unknown>";
      return getStringImpl(memory.buffer, ptr);
    }
    const env = imports.env = imports.env || {};
    env.abort = env.abort || function abort(mesg, file, line, colm) {
      const memory = baseModule.memory || env.memory;
      throw Error("abort: " + getString(memory, mesg) + " at " + getString(memory, file) + ":" + line + ":" + colm);
    };
    env.trace = env.trace || function trace(mesg, n) {
      const memory = baseModule.memory || env.memory;
      console.log("trace: " + getString(memory, mesg) + (n ? " " : "") + Array.prototype.slice.call(arguments, 2, 2 + n).join(", "));
    };
    imports.Math = imports.Math || Math;
    imports.Date = imports.Date || Date;
    return baseModule;
  }
  function postInstantiate(baseModule, instance) {
    const rawExports = instance.exports;
    const memory = rawExports.memory;
    const table = rawExports.table;
    const alloc = rawExports["__alloc"];
    const retain = rawExports["__retain"];
    const rttiBase = rawExports["__rtti_base"] || ~0;
    function getInfo(id) {
      const U32 = new Uint32Array(memory.buffer);
      const count = U32[rttiBase >>> 2];
      if ((id >>>= 0) >= count)
        throw Error("invalid id: " + id);
      return U32[(rttiBase + 4 >>> 2) + id * 2];
    }
    function getBase(id) {
      const U32 = new Uint32Array(memory.buffer);
      const count = U32[rttiBase >>> 2];
      if ((id >>>= 0) >= count)
        throw Error("invalid id: " + id);
      return U32[(rttiBase + 4 >>> 2) + id * 2 + 1];
    }
    function getValueAlign(info) {
      return 31 - Math.clz32(info >>> VAL_ALIGN_OFFSET & 31);
    }
    function getKeyAlign(info) {
      return 31 - Math.clz32(info >>> KEY_ALIGN_OFFSET & 31);
    }
    function __allocString(str) {
      const length = str.length;
      const ptr = alloc(length << 1, STRING_ID);
      const U16 = new Uint16Array(memory.buffer);
      for (var i = 0, p = ptr >>> 1; i < length; ++i)
        U16[p + i] = str.charCodeAt(i);
      return ptr;
    }
    baseModule.__allocString = __allocString;
    function __getString(ptr) {
      const buffer = memory.buffer;
      const id = new Uint32Array(buffer)[ptr + ID_OFFSET >>> 2];
      if (id !== STRING_ID)
        throw Error("not a string: " + ptr);
      return getStringImpl(buffer, ptr);
    }
    baseModule.__getString = __getString;
    function getView(alignLog2, signed, float) {
      const buffer = memory.buffer;
      if (float) {
        switch (alignLog2) {
          case 2:
            return new Float32Array(buffer);
          case 3:
            return new Float64Array(buffer);
        }
      } else {
        switch (alignLog2) {
          case 0:
            return new (signed ? Int8Array : Uint8Array)(buffer);
          case 1:
            return new (signed ? Int16Array : Uint16Array)(buffer);
          case 2:
            return new (signed ? Int32Array : Uint32Array)(buffer);
          case 3:
            return new (signed ? BigInt64Array : BigUint64Array)(buffer);
        }
      }
      throw Error("unsupported align: " + alignLog2);
    }
    function __allocArray(id, values) {
      const info = getInfo(id);
      if (!(info & (ARRAYBUFFERVIEW | ARRAY)))
        throw Error("not an array: " + id + " @ " + info);
      const align = getValueAlign(info);
      const length = values.length;
      const buf = alloc(length << align, ARRAYBUFFER_ID);
      const arr = alloc(info & ARRAY ? ARRAY_SIZE : ARRAYBUFFERVIEW_SIZE, id);
      const U32 = new Uint32Array(memory.buffer);
      U32[arr + ARRAYBUFFERVIEW_BUFFER_OFFSET >>> 2] = retain(buf);
      U32[arr + ARRAYBUFFERVIEW_DATASTART_OFFSET >>> 2] = buf;
      U32[arr + ARRAYBUFFERVIEW_DATALENGTH_OFFSET >>> 2] = length << align;
      if (info & ARRAY)
        U32[arr + ARRAY_LENGTH_OFFSET >>> 2] = length;
      const view = getView(align, info & VAL_SIGNED, info & VAL_FLOAT);
      if (info & VAL_MANAGED) {
        for (let i = 0; i < length; ++i)
          view[(buf >>> align) + i] = retain(values[i]);
      } else {
        view.set(values, buf >>> align);
      }
      return arr;
    }
    baseModule.__allocArray = __allocArray;
    function __getArrayView(arr) {
      const U32 = new Uint32Array(memory.buffer);
      const id = U32[arr + ID_OFFSET >>> 2];
      const info = getInfo(id);
      if (!(info & ARRAYBUFFERVIEW))
        throw Error("not an array: " + id);
      const align = getValueAlign(info);
      var buf = U32[arr + ARRAYBUFFERVIEW_DATASTART_OFFSET >>> 2];
      const length = info & ARRAY ? U32[arr + ARRAY_LENGTH_OFFSET >>> 2] : U32[buf + SIZE_OFFSET >>> 2] >>> align;
      return getView(align, info & VAL_SIGNED, info & VAL_FLOAT).subarray(buf >>>= align, buf + length);
    }
    baseModule.__getArrayView = __getArrayView;
    function __getArray(arr) {
      const input = __getArrayView(arr);
      const len = input.length;
      const out = new Array(len);
      for (let i = 0; i < len; i++)
        out[i] = input[i];
      return out;
    }
    baseModule.__getArray = __getArray;
    function __getArrayBuffer(ptr) {
      const buffer = memory.buffer;
      const length = new Uint32Array(buffer)[ptr + SIZE_OFFSET >>> 2];
      return buffer.slice(ptr, ptr + length);
    }
    baseModule.__getArrayBuffer = __getArrayBuffer;
    function getTypedArray(Type, alignLog2, ptr) {
      return new Type(getTypedArrayView(Type, alignLog2, ptr));
    }
    function getTypedArrayView(Type, alignLog2, ptr) {
      const buffer = memory.buffer;
      const U32 = new Uint32Array(buffer);
      const bufPtr = U32[ptr + ARRAYBUFFERVIEW_DATASTART_OFFSET >>> 2];
      return new Type(buffer, bufPtr, U32[bufPtr + SIZE_OFFSET >>> 2] >>> alignLog2);
    }
    baseModule.__getInt8Array = getTypedArray.bind(null, Int8Array, 0);
    baseModule.__getInt8ArrayView = getTypedArrayView.bind(null, Int8Array, 0);
    baseModule.__getUint8Array = getTypedArray.bind(null, Uint8Array, 0);
    baseModule.__getUint8ArrayView = getTypedArrayView.bind(null, Uint8Array, 0);
    baseModule.__getUint8ClampedArray = getTypedArray.bind(null, Uint8ClampedArray, 0);
    baseModule.__getUint8ClampedArrayView = getTypedArrayView.bind(null, Uint8ClampedArray, 0);
    baseModule.__getInt16Array = getTypedArray.bind(null, Int16Array, 1);
    baseModule.__getInt16ArrayView = getTypedArrayView.bind(null, Int16Array, 1);
    baseModule.__getUint16Array = getTypedArray.bind(null, Uint16Array, 1);
    baseModule.__getUint16ArrayView = getTypedArrayView.bind(null, Uint16Array, 1);
    baseModule.__getInt32Array = getTypedArray.bind(null, Int32Array, 2);
    baseModule.__getInt32ArrayView = getTypedArrayView.bind(null, Int32Array, 2);
    baseModule.__getUint32Array = getTypedArray.bind(null, Uint32Array, 2);
    baseModule.__getUint32ArrayView = getTypedArrayView.bind(null, Uint32Array, 2);
    if (BIGINT) {
      baseModule.__getInt64Array = getTypedArray.bind(null, BigInt64Array, 3);
      baseModule.__getInt64ArrayView = getTypedArrayView.bind(null, BigInt64Array, 3);
      baseModule.__getUint64Array = getTypedArray.bind(null, BigUint64Array, 3);
      baseModule.__getUint64ArrayView = getTypedArrayView.bind(null, BigUint64Array, 3);
    }
    baseModule.__getFloat32Array = getTypedArray.bind(null, Float32Array, 2);
    baseModule.__getFloat32ArrayView = getTypedArrayView.bind(null, Float32Array, 2);
    baseModule.__getFloat64Array = getTypedArray.bind(null, Float64Array, 3);
    baseModule.__getFloat64ArrayView = getTypedArrayView.bind(null, Float64Array, 3);
    function __instanceof(ptr, baseId) {
      const U32 = new Uint32Array(memory.buffer);
      var id = U32[ptr + ID_OFFSET >>> 2];
      if (id <= U32[rttiBase >>> 2]) {
        do
          if (id == baseId)
            return true;
        while (id = getBase(id));
      }
      return false;
    }
    baseModule.__instanceof = __instanceof;
    baseModule.memory = baseModule.memory || memory;
    baseModule.table = baseModule.table || table;
    return demangle(rawExports, baseModule);
  }
  function isResponse(o) {
    return typeof Response !== "undefined" && o instanceof Response;
  }
  async function instantiate(source, imports) {
    if (isResponse(source = await source))
      return instantiateStreaming(source, imports);
    return postInstantiate(preInstantiate(imports || (imports = {})), await WebAssembly.instantiate(source instanceof WebAssembly.Module ? source : await WebAssembly.compile(source), imports));
  }
  exports2.instantiate = instantiate;
  function instantiateSync(source, imports) {
    return postInstantiate(preInstantiate(imports || (imports = {})), new WebAssembly.Instance(source instanceof WebAssembly.Module ? source : new WebAssembly.Module(source), imports));
  }
  exports2.instantiateSync = instantiateSync;
  async function instantiateStreaming(source, imports) {
    if (!WebAssembly.instantiateStreaming) {
      return instantiate(isResponse(source = await source) ? source.arrayBuffer() : source, imports);
    }
    return postInstantiate(preInstantiate(imports || (imports = {})), (await WebAssembly.instantiateStreaming(source, imports)).instance);
  }
  exports2.instantiateStreaming = instantiateStreaming;
  function demangle(exports3, baseModule) {
    var module3 = baseModule ? Object.create(baseModule) : {};
    var setArgumentsLength = exports3["__argumentsLength"] ? function(length) {
      exports3["__argumentsLength"].value = length;
    } : exports3["__setArgumentsLength"] || exports3["__setargc"] || function() {
    };
    for (let internalName in exports3) {
      if (!Object.prototype.hasOwnProperty.call(exports3, internalName))
        continue;
      const elem = exports3[internalName];
      let parts = internalName.split(".");
      let curr = module3;
      while (parts.length > 1) {
        let part = parts.shift();
        if (!Object.prototype.hasOwnProperty.call(curr, part))
          curr[part] = {};
        curr = curr[part];
      }
      let name = parts[0];
      let hash = name.indexOf("#");
      if (hash >= 0) {
        let className = name.substring(0, hash);
        let classElem = curr[className];
        if (typeof classElem === "undefined" || !classElem.prototype) {
          let ctor = function(...args) {
            return ctor.wrap(ctor.prototype.constructor(0, ...args));
          };
          ctor.prototype = {
            valueOf: function valueOf() {
              return this[THIS];
            }
          };
          ctor.wrap = function(thisValue) {
            return Object.create(ctor.prototype, {[THIS]: {value: thisValue, writable: false}});
          };
          if (classElem)
            Object.getOwnPropertyNames(classElem).forEach((name2) => Object.defineProperty(ctor, name2, Object.getOwnPropertyDescriptor(classElem, name2)));
          curr[className] = ctor;
        }
        name = name.substring(hash + 1);
        curr = curr[className].prototype;
        if (/^(get|set):/.test(name)) {
          if (!Object.prototype.hasOwnProperty.call(curr, name = name.substring(4))) {
            let getter = exports3[internalName.replace("set:", "get:")];
            let setter = exports3[internalName.replace("get:", "set:")];
            Object.defineProperty(curr, name, {
              get: function() {
                return getter(this[THIS]);
              },
              set: function(value) {
                setter(this[THIS], value);
              },
              enumerable: true
            });
          }
        } else {
          if (name === "constructor") {
            (curr[name] = (...args) => {
              setArgumentsLength(args.length);
              return elem(...args);
            }).original = elem;
          } else {
            (curr[name] = function(...args) {
              setArgumentsLength(args.length);
              return elem(this[THIS], ...args);
            }).original = elem;
          }
        }
      } else {
        if (/^(get|set):/.test(name)) {
          if (!Object.prototype.hasOwnProperty.call(curr, name = name.substring(4))) {
            Object.defineProperty(curr, name, {
              get: exports3[internalName.replace("set:", "get:")],
              set: exports3[internalName.replace("get:", "set:")],
              enumerable: true
            });
          }
        } else if (typeof elem === "function" && elem !== setArgumentsLength) {
          (curr[name] = (...args) => {
            setArgumentsLength(args.length);
            return elem(...args);
          }).original = elem;
        } else {
          curr[name] = elem;
        }
      }
    }
    return module3;
  }
  exports2.demangle = demangle;
});

// node_modules/rabin-wasm/dist/rabin-wasm.js
var require_rabin_wasm = __commonJS((exports2, module2) => {
  var {instantiate} = require_loader();
  loadWebAssembly.supported = typeof WebAssembly !== "undefined";
  function loadWebAssembly(imp = {}) {
    if (!loadWebAssembly.supported)
      return null;
    var wasm = new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 78, 14, 96, 2, 127, 126, 0, 96, 1, 127, 1, 126, 96, 2, 127, 127, 0, 96, 1, 127, 1, 127, 96, 1, 127, 0, 96, 3, 127, 127, 127, 0, 96, 2, 127, 127, 1, 127, 96, 3, 127, 127, 127, 1, 127, 96, 0, 0, 96, 0, 1, 127, 96, 4, 127, 127, 127, 127, 0, 96, 5, 127, 127, 127, 127, 127, 1, 127, 96, 1, 126, 1, 127, 96, 2, 126, 126, 1, 126, 2, 13, 1, 3, 101, 110, 118, 5, 97, 98, 111, 114, 116, 0, 10, 3, 54, 53, 2, 2, 5, 9, 3, 6, 2, 5, 7, 6, 3, 4, 2, 7, 9, 12, 13, 5, 6, 11, 3, 2, 3, 2, 3, 2, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 7, 8, 8, 4, 4, 5, 3, 1, 0, 1, 6, 47, 9, 127, 1, 65, 0, 11, 127, 1, 65, 0, 11, 127, 0, 65, 3, 11, 127, 0, 65, 4, 11, 127, 1, 65, 0, 11, 127, 1, 65, 0, 11, 127, 1, 65, 0, 11, 127, 0, 65, 240, 2, 11, 127, 0, 65, 6, 11, 7, 240, 5, 41, 6, 109, 101, 109, 111, 114, 121, 2, 0, 7, 95, 95, 97, 108, 108, 111, 99, 0, 10, 8, 95, 95, 114, 101, 116, 97, 105, 110, 0, 11, 9, 95, 95, 114, 101, 108, 101, 97, 115, 101, 0, 12, 9, 95, 95, 99, 111, 108, 108, 101, 99, 116, 0, 51, 11, 95, 95, 114, 116, 116, 105, 95, 98, 97, 115, 101, 3, 7, 13, 73, 110, 116, 51, 50, 65, 114, 114, 97, 121, 95, 73, 68, 3, 2, 13, 85, 105, 110, 116, 56, 65, 114, 114, 97, 121, 95, 73, 68, 3, 3, 6, 100, 101, 103, 114, 101, 101, 0, 16, 3, 109, 111, 100, 0, 17, 5, 82, 97, 98, 105, 110, 3, 8, 16, 82, 97, 98, 105, 110, 35, 103, 101, 116, 58, 119, 105, 110, 100, 111, 119, 0, 21, 16, 82, 97, 98, 105, 110, 35, 115, 101, 116, 58, 119, 105, 110, 100, 111, 119, 0, 22, 21, 82, 97, 98, 105, 110, 35, 103, 101, 116, 58, 119, 105, 110, 100, 111, 119, 95, 115, 105, 122, 101, 0, 23, 21, 82, 97, 98, 105, 110, 35, 115, 101, 116, 58, 119, 105, 110, 100, 111, 119, 95, 115, 105, 122, 101, 0, 24, 14, 82, 97, 98, 105, 110, 35, 103, 101, 116, 58, 119, 112, 111, 115, 0, 25, 14, 82, 97, 98, 105, 110, 35, 115, 101, 116, 58, 119, 112, 111, 115, 0, 26, 15, 82, 97, 98, 105, 110, 35, 103, 101, 116, 58, 99, 111, 117, 110, 116, 0, 27, 15, 82, 97, 98, 105, 110, 35, 115, 101, 116, 58, 99, 111, 117, 110, 116, 0, 28, 13, 82, 97, 98, 105, 110, 35, 103, 101, 116, 58, 112, 111, 115, 0, 29, 13, 82, 97, 98, 105, 110, 35, 115, 101, 116, 58, 112, 111, 115, 0, 30, 15, 82, 97, 98, 105, 110, 35, 103, 101, 116, 58, 115, 116, 97, 114, 116, 0, 31, 15, 82, 97, 98, 105, 110, 35, 115, 101, 116, 58, 115, 116, 97, 114, 116, 0, 32, 16, 82, 97, 98, 105, 110, 35, 103, 101, 116, 58, 100, 105, 103, 101, 115, 116, 0, 33, 16, 82, 97, 98, 105, 110, 35, 115, 101, 116, 58, 100, 105, 103, 101, 115, 116, 0, 34, 21, 82, 97, 98, 105, 110, 35, 103, 101, 116, 58, 99, 104, 117, 110, 107, 95, 115, 116, 97, 114, 116, 0, 35, 21, 82, 97, 98, 105, 110, 35, 115, 101, 116, 58, 99, 104, 117, 110, 107, 95, 115, 116, 97, 114, 116, 0, 36, 22, 82, 97, 98, 105, 110, 35, 103, 101, 116, 58, 99, 104, 117, 110, 107, 95, 108, 101, 110, 103, 116, 104, 0, 37, 22, 82, 97, 98, 105, 110, 35, 115, 101, 116, 58, 99, 104, 117, 110, 107, 95, 108, 101, 110, 103, 116, 104, 0, 38, 31, 82, 97, 98, 105, 110, 35, 103, 101, 116, 58, 99, 104, 117, 110, 107, 95, 99, 117, 116, 95, 102, 105, 110, 103, 101, 114, 112, 114, 105, 110, 116, 0, 39, 31, 82, 97, 98, 105, 110, 35, 115, 101, 116, 58, 99, 104, 117, 110, 107, 95, 99, 117, 116, 95, 102, 105, 110, 103, 101, 114, 112, 114, 105, 110, 116, 0, 40, 20, 82, 97, 98, 105, 110, 35, 103, 101, 116, 58, 112, 111, 108, 121, 110, 111, 109, 105, 97, 108, 0, 41, 20, 82, 97, 98, 105, 110, 35, 115, 101, 116, 58, 112, 111, 108, 121, 110, 111, 109, 105, 97, 108, 0, 42, 17, 82, 97, 98, 105, 110, 35, 103, 101, 116, 58, 109, 105, 110, 115, 105, 122, 101, 0, 43, 17, 82, 97, 98, 105, 110, 35, 115, 101, 116, 58, 109, 105, 110, 115, 105, 122, 101, 0, 44, 17, 82, 97, 98, 105, 110, 35, 103, 101, 116, 58, 109, 97, 120, 115, 105, 122, 101, 0, 45, 17, 82, 97, 98, 105, 110, 35, 115, 101, 116, 58, 109, 97, 120, 115, 105, 122, 101, 0, 46, 14, 82, 97, 98, 105, 110, 35, 103, 101, 116, 58, 109, 97, 115, 107, 0, 47, 14, 82, 97, 98, 105, 110, 35, 115, 101, 116, 58, 109, 97, 115, 107, 0, 48, 17, 82, 97, 98, 105, 110, 35, 99, 111, 110, 115, 116, 114, 117, 99, 116, 111, 114, 0, 20, 17, 82, 97, 98, 105, 110, 35, 102, 105, 110, 103, 101, 114, 112, 114, 105, 110, 116, 0, 49, 8, 1, 50, 10, 249, 35, 53, 199, 1, 1, 4, 127, 32, 1, 40, 2, 0, 65, 124, 113, 34, 2, 65, 128, 2, 73, 4, 127, 32, 2, 65, 4, 118, 33, 4, 65, 0, 5, 32, 2, 65, 31, 32, 2, 103, 107, 34, 3, 65, 4, 107, 118, 65, 16, 115, 33, 4, 32, 3, 65, 7, 107, 11, 33, 3, 32, 1, 40, 2, 20, 33, 2, 32, 1, 40, 2, 16, 34, 5, 4, 64, 32, 5, 32, 2, 54, 2, 20, 11, 32, 2, 4, 64, 32, 2, 32, 5, 54, 2, 16, 11, 32, 1, 32, 0, 32, 4, 32, 3, 65, 4, 116, 106, 65, 2, 116, 106, 40, 2, 96, 70, 4, 64, 32, 0, 32, 4, 32, 3, 65, 4, 116, 106, 65, 2, 116, 106, 32, 2, 54, 2, 96, 32, 2, 69, 4, 64, 32, 0, 32, 3, 65, 2, 116, 106, 32, 0, 32, 3, 65, 2, 116, 106, 40, 2, 4, 65, 1, 32, 4, 116, 65, 127, 115, 113, 34, 1, 54, 2, 4, 32, 1, 69, 4, 64, 32, 0, 32, 0, 40, 2, 0, 65, 1, 32, 3, 116, 65, 127, 115, 113, 54, 2, 0, 11, 11, 11, 11, 226, 2, 1, 6, 127, 32, 1, 40, 2, 0, 33, 3, 32, 1, 65, 16, 106, 32, 1, 40, 2, 0, 65, 124, 113, 106, 34, 4, 40, 2, 0, 34, 5, 65, 1, 113, 4, 64, 32, 3, 65, 124, 113, 65, 16, 106, 32, 5, 65, 124, 113, 106, 34, 2, 65, 240, 255, 255, 255, 3, 73, 4, 64, 32, 0, 32, 4, 16, 1, 32, 1, 32, 2, 32, 3, 65, 3, 113, 114, 34, 3, 54, 2, 0, 32, 1, 65, 16, 106, 32, 1, 40, 2, 0, 65, 124, 113, 106, 34, 4, 40, 2, 0, 33, 5, 11, 11, 32, 3, 65, 2, 113, 4, 64, 32, 1, 65, 4, 107, 40, 2, 0, 34, 2, 40, 2, 0, 34, 6, 65, 124, 113, 65, 16, 106, 32, 3, 65, 124, 113, 106, 34, 7, 65, 240, 255, 255, 255, 3, 73, 4, 64, 32, 0, 32, 2, 16, 1, 32, 2, 32, 7, 32, 6, 65, 3, 113, 114, 34, 3, 54, 2, 0, 32, 2, 33, 1, 11, 11, 32, 4, 32, 5, 65, 2, 114, 54, 2, 0, 32, 4, 65, 4, 107, 32, 1, 54, 2, 0, 32, 0, 32, 3, 65, 124, 113, 34, 2, 65, 128, 2, 73, 4, 127, 32, 2, 65, 4, 118, 33, 4, 65, 0, 5, 32, 2, 65, 31, 32, 2, 103, 107, 34, 2, 65, 4, 107, 118, 65, 16, 115, 33, 4, 32, 2, 65, 7, 107, 11, 34, 3, 65, 4, 116, 32, 4, 106, 65, 2, 116, 106, 40, 2, 96, 33, 2, 32, 1, 65, 0, 54, 2, 16, 32, 1, 32, 2, 54, 2, 20, 32, 2, 4, 64, 32, 2, 32, 1, 54, 2, 16, 11, 32, 0, 32, 4, 32, 3, 65, 4, 116, 106, 65, 2, 116, 106, 32, 1, 54, 2, 96, 32, 0, 32, 0, 40, 2, 0, 65, 1, 32, 3, 116, 114, 54, 2, 0, 32, 0, 32, 3, 65, 2, 116, 106, 32, 0, 32, 3, 65, 2, 116, 106, 40, 2, 4, 65, 1, 32, 4, 116, 114, 54, 2, 4, 11, 119, 1, 1, 127, 32, 2, 2, 127, 32, 0, 40, 2, 160, 12, 34, 2, 4, 64, 32, 2, 32, 1, 65, 16, 107, 70, 4, 64, 32, 2, 40, 2, 0, 33, 3, 32, 1, 65, 16, 107, 33, 1, 11, 11, 32, 1, 11, 107, 34, 2, 65, 48, 73, 4, 64, 15, 11, 32, 1, 32, 3, 65, 2, 113, 32, 2, 65, 32, 107, 65, 1, 114, 114, 54, 2, 0, 32, 1, 65, 0, 54, 2, 16, 32, 1, 65, 0, 54, 2, 20, 32, 1, 32, 2, 106, 65, 16, 107, 34, 2, 65, 2, 54, 2, 0, 32, 0, 32, 2, 54, 2, 160, 12, 32, 0, 32, 1, 16, 2, 11, 155, 1, 1, 3, 127, 35, 0, 34, 0, 69, 4, 64, 65, 1, 63, 0, 34, 0, 74, 4, 127, 65, 1, 32, 0, 107, 64, 0, 65, 0, 72, 5, 65, 0, 11, 4, 64, 0, 11, 65, 176, 3, 34, 0, 65, 0, 54, 2, 0, 65, 208, 15, 65, 0, 54, 2, 0, 3, 64, 32, 1, 65, 23, 73, 4, 64, 32, 1, 65, 2, 116, 65, 176, 3, 106, 65, 0, 54, 2, 4, 65, 0, 33, 2, 3, 64, 32, 2, 65, 16, 73, 4, 64, 32, 1, 65, 4, 116, 32, 2, 106, 65, 2, 116, 65, 176, 3, 106, 65, 0, 54, 2, 96, 32, 2, 65, 1, 106, 33, 2, 12, 1, 11, 11, 32, 1, 65, 1, 106, 33, 1, 12, 1, 11, 11, 65, 176, 3, 65, 224, 15, 63, 0, 65, 16, 116, 16, 3, 65, 176, 3, 36, 0, 11, 32, 0, 11, 45, 0, 32, 0, 65, 240, 255, 255, 255, 3, 79, 4, 64, 65, 32, 65, 224, 0, 65, 201, 3, 65, 29, 16, 0, 0, 11, 32, 0, 65, 15, 106, 65, 112, 113, 34, 0, 65, 16, 32, 0, 65, 16, 75, 27, 11, 169, 1, 1, 1, 127, 32, 0, 32, 1, 65, 128, 2, 73, 4, 127, 32, 1, 65, 4, 118, 33, 1, 65, 0, 5, 32, 1, 65, 248, 255, 255, 255, 1, 73, 4, 64, 32, 1, 65, 1, 65, 27, 32, 1, 103, 107, 116, 106, 65, 1, 107, 33, 1, 11, 32, 1, 65, 31, 32, 1, 103, 107, 34, 2, 65, 4, 107, 118, 65, 16, 115, 33, 1, 32, 2, 65, 7, 107, 11, 34, 2, 65, 2, 116, 106, 40, 2, 4, 65, 127, 32, 1, 116, 113, 34, 1, 4, 127, 32, 0, 32, 1, 104, 32, 2, 65, 4, 116, 106, 65, 2, 116, 106, 40, 2, 96, 5, 32, 0, 40, 2, 0, 65, 127, 32, 2, 65, 1, 106, 116, 113, 34, 1, 4, 127, 32, 0, 32, 0, 32, 1, 104, 34, 0, 65, 2, 116, 106, 40, 2, 4, 104, 32, 0, 65, 4, 116, 106, 65, 2, 116, 106, 40, 2, 96, 5, 65, 0, 11, 11, 11, 111, 1, 1, 127, 63, 0, 34, 2, 32, 1, 65, 248, 255, 255, 255, 1, 73, 4, 127, 32, 1, 65, 1, 65, 27, 32, 1, 103, 107, 116, 65, 1, 107, 106, 5, 32, 1, 11, 65, 16, 32, 0, 40, 2, 160, 12, 32, 2, 65, 16, 116, 65, 16, 107, 71, 116, 106, 65, 255, 255, 3, 106, 65, 128, 128, 124, 113, 65, 16, 118, 34, 1, 32, 2, 32, 1, 74, 27, 64, 0, 65, 0, 72, 4, 64, 32, 1, 64, 0, 65, 0, 72, 4, 64, 0, 11, 11, 32, 0, 32, 2, 65, 16, 116, 63, 0, 65, 16, 116, 16, 3, 11, 113, 1, 2, 127, 32, 1, 40, 2, 0, 34, 3, 65, 124, 113, 32, 2, 107, 34, 4, 65, 32, 79, 4, 64, 32, 1, 32, 2, 32, 3, 65, 2, 113, 114, 54, 2, 0, 32, 2, 32, 1, 65, 16, 106, 106, 34, 1, 32, 4, 65, 16, 107, 65, 1, 114, 54, 2, 0, 32, 0, 32, 1, 16, 2, 5, 32, 1, 32, 3, 65, 126, 113, 54, 2, 0, 32, 1, 65, 16, 106, 32, 1, 40, 2, 0, 65, 124, 113, 106, 32, 1, 65, 16, 106, 32, 1, 40, 2, 0, 65, 124, 113, 106, 40, 2, 0, 65, 125, 113, 54, 2, 0, 11, 11, 91, 1, 2, 127, 32, 0, 32, 1, 16, 5, 34, 4, 16, 6, 34, 3, 69, 4, 64, 65, 1, 36, 1, 65, 0, 36, 1, 32, 0, 32, 4, 16, 6, 34, 3, 69, 4, 64, 32, 0, 32, 4, 16, 7, 32, 0, 32, 4, 16, 6, 33, 3, 11, 11, 32, 3, 65, 0, 54, 2, 4, 32, 3, 32, 2, 54, 2, 8, 32, 3, 32, 1, 54, 2, 12, 32, 0, 32, 3, 16, 1, 32, 0, 32, 3, 32, 4, 16, 8, 32, 3, 11, 13, 0, 16, 4, 32, 0, 32, 1, 16, 9, 65, 16, 106, 11, 33, 1, 1, 127, 32, 0, 65, 172, 3, 75, 4, 64, 32, 0, 65, 16, 107, 34, 1, 32, 1, 40, 2, 4, 65, 1, 106, 54, 2, 4, 11, 32, 0, 11, 18, 0, 32, 0, 65, 172, 3, 75, 4, 64, 32, 0, 65, 16, 107, 16, 52, 11, 11, 140, 3, 1, 1, 127, 2, 64, 32, 1, 69, 13, 0, 32, 0, 65, 0, 58, 0, 0, 32, 0, 32, 1, 106, 65, 1, 107, 65, 0, 58, 0, 0, 32, 1, 65, 2, 77, 13, 0, 32, 0, 65, 1, 106, 65, 0, 58, 0, 0, 32, 0, 65, 2, 106, 65, 0, 58, 0, 0, 32, 0, 32, 1, 106, 34, 2, 65, 2, 107, 65, 0, 58, 0, 0, 32, 2, 65, 3, 107, 65, 0, 58, 0, 0, 32, 1, 65, 6, 77, 13, 0, 32, 0, 65, 3, 106, 65, 0, 58, 0, 0, 32, 0, 32, 1, 106, 65, 4, 107, 65, 0, 58, 0, 0, 32, 1, 65, 8, 77, 13, 0, 32, 1, 65, 0, 32, 0, 107, 65, 3, 113, 34, 1, 107, 33, 2, 32, 0, 32, 1, 106, 34, 0, 65, 0, 54, 2, 0, 32, 0, 32, 2, 65, 124, 113, 34, 1, 106, 65, 4, 107, 65, 0, 54, 2, 0, 32, 1, 65, 8, 77, 13, 0, 32, 0, 65, 4, 106, 65, 0, 54, 2, 0, 32, 0, 65, 8, 106, 65, 0, 54, 2, 0, 32, 0, 32, 1, 106, 34, 2, 65, 12, 107, 65, 0, 54, 2, 0, 32, 2, 65, 8, 107, 65, 0, 54, 2, 0, 32, 1, 65, 24, 77, 13, 0, 32, 0, 65, 12, 106, 65, 0, 54, 2, 0, 32, 0, 65, 16, 106, 65, 0, 54, 2, 0, 32, 0, 65, 20, 106, 65, 0, 54, 2, 0, 32, 0, 65, 24, 106, 65, 0, 54, 2, 0, 32, 0, 32, 1, 106, 34, 2, 65, 28, 107, 65, 0, 54, 2, 0, 32, 2, 65, 24, 107, 65, 0, 54, 2, 0, 32, 2, 65, 20, 107, 65, 0, 54, 2, 0, 32, 2, 65, 16, 107, 65, 0, 54, 2, 0, 32, 0, 32, 0, 65, 4, 113, 65, 24, 106, 34, 2, 106, 33, 0, 32, 1, 32, 2, 107, 33, 1, 3, 64, 32, 1, 65, 32, 79, 4, 64, 32, 0, 66, 0, 55, 3, 0, 32, 0, 65, 8, 106, 66, 0, 55, 3, 0, 32, 0, 65, 16, 106, 66, 0, 55, 3, 0, 32, 0, 65, 24, 106, 66, 0, 55, 3, 0, 32, 1, 65, 32, 107, 33, 1, 32, 0, 65, 32, 106, 33, 0, 12, 1, 11, 11, 11, 11, 178, 1, 1, 3, 127, 32, 1, 65, 240, 255, 255, 255, 3, 32, 2, 118, 75, 4, 64, 65, 144, 1, 65, 192, 1, 65, 23, 65, 56, 16, 0, 0, 11, 32, 1, 32, 2, 116, 34, 3, 65, 0, 16, 10, 34, 2, 32, 3, 16, 13, 32, 0, 69, 4, 64, 65, 12, 65, 2, 16, 10, 34, 0, 65, 172, 3, 75, 4, 64, 32, 0, 65, 16, 107, 34, 1, 32, 1, 40, 2, 4, 65, 1, 106, 54, 2, 4, 11, 11, 32, 0, 65, 0, 54, 2, 0, 32, 0, 65, 0, 54, 2, 4, 32, 0, 65, 0, 54, 2, 8, 32, 2, 34, 1, 32, 0, 40, 2, 0, 34, 4, 71, 4, 64, 32, 1, 65, 172, 3, 75, 4, 64, 32, 1, 65, 16, 107, 34, 5, 32, 5, 40, 2, 4, 65, 1, 106, 54, 2, 4, 11, 32, 4, 16, 12, 11, 32, 0, 32, 1, 54, 2, 0, 32, 0, 32, 2, 54, 2, 4, 32, 0, 32, 3, 54, 2, 8, 32, 0, 11, 46, 1, 2, 127, 65, 12, 65, 5, 16, 10, 34, 0, 65, 172, 3, 75, 4, 64, 32, 0, 65, 16, 107, 34, 1, 32, 1, 40, 2, 4, 65, 1, 106, 54, 2, 4, 11, 32, 0, 65, 128, 2, 65, 3, 16, 14, 11, 66, 2, 1, 127, 1, 126, 66, 128, 128, 128, 128, 128, 128, 128, 128, 128, 127, 33, 2, 3, 64, 32, 1, 65, 192, 0, 72, 4, 64, 32, 0, 32, 2, 131, 66, 0, 86, 4, 64, 65, 63, 32, 1, 107, 15, 11, 32, 2, 66, 1, 136, 33, 2, 32, 1, 65, 1, 106, 33, 1, 12, 1, 11, 11, 65, 127, 11, 165, 1, 2, 2, 127, 1, 126, 2, 127, 66, 128, 128, 128, 128, 128, 128, 128, 128, 128, 127, 33, 4, 3, 64, 32, 3, 65, 192, 0, 72, 4, 64, 65, 63, 32, 3, 107, 32, 1, 32, 4, 131, 66, 0, 86, 13, 2, 26, 32, 4, 66, 1, 136, 33, 4, 32, 3, 65, 1, 106, 33, 3, 12, 1, 11, 11, 65, 127, 11, 33, 3, 3, 64, 2, 127, 66, 128, 128, 128, 128, 128, 128, 128, 128, 128, 127, 33, 4, 65, 0, 33, 2, 3, 64, 32, 2, 65, 192, 0, 72, 4, 64, 65, 63, 32, 2, 107, 32, 0, 32, 4, 131, 66, 0, 86, 13, 2, 26, 32, 4, 66, 1, 136, 33, 4, 32, 2, 65, 1, 106, 33, 2, 12, 1, 11, 11, 65, 127, 11, 32, 3, 107, 34, 2, 65, 0, 78, 4, 64, 32, 0, 32, 1, 32, 2, 172, 134, 133, 33, 0, 12, 1, 11, 11, 32, 0, 11, 40, 0, 32, 1, 32, 0, 40, 2, 8, 79, 4, 64, 65, 128, 2, 65, 192, 2, 65, 163, 1, 65, 44, 16, 0, 0, 11, 32, 1, 32, 0, 40, 2, 4, 106, 32, 2, 58, 0, 0, 11, 38, 0, 32, 1, 32, 0, 40, 2, 8, 79, 4, 64, 65, 128, 2, 65, 192, 2, 65, 152, 1, 65, 44, 16, 0, 0, 11, 32, 1, 32, 0, 40, 2, 4, 106, 45, 0, 0, 11, 164, 9, 2, 1, 127, 6, 126, 32, 0, 69, 4, 64, 65, 232, 0, 65, 6, 16, 10, 34, 0, 65, 172, 3, 75, 4, 64, 32, 0, 65, 16, 107, 34, 5, 32, 5, 40, 2, 4, 65, 1, 106, 54, 2, 4, 11, 11, 32, 0, 65, 0, 54, 2, 0, 32, 0, 65, 0, 54, 2, 4, 32, 0, 65, 0, 54, 2, 8, 32, 0, 66, 0, 55, 3, 16, 32, 0, 66, 0, 55, 3, 24, 32, 0, 66, 0, 55, 3, 32, 32, 0, 66, 0, 55, 3, 40, 32, 0, 66, 0, 55, 3, 48, 32, 0, 66, 0, 55, 3, 56, 32, 0, 66, 0, 55, 3, 64, 32, 0, 66, 0, 55, 3, 72, 32, 0, 66, 0, 55, 3, 80, 32, 0, 66, 0, 55, 3, 88, 32, 0, 66, 0, 55, 3, 96, 32, 0, 32, 2, 173, 55, 3, 80, 32, 0, 32, 3, 173, 55, 3, 88, 65, 12, 65, 4, 16, 10, 34, 2, 65, 172, 3, 75, 4, 64, 32, 2, 65, 16, 107, 34, 3, 32, 3, 40, 2, 4, 65, 1, 106, 54, 2, 4, 11, 32, 2, 32, 4, 65, 0, 16, 14, 33, 2, 32, 0, 40, 2, 0, 16, 12, 32, 0, 32, 2, 54, 2, 0, 32, 0, 32, 4, 54, 2, 4, 32, 0, 66, 1, 32, 1, 173, 134, 66, 1, 125, 55, 3, 96, 32, 0, 66, 243, 130, 183, 218, 216, 230, 232, 30, 55, 3, 72, 35, 4, 69, 4, 64, 65, 0, 33, 2, 3, 64, 32, 2, 65, 128, 2, 72, 4, 64, 32, 2, 65, 255, 1, 113, 173, 33, 7, 32, 0, 41, 3, 72, 34, 8, 33, 9, 2, 127, 66, 128, 128, 128, 128, 128, 128, 128, 128, 128, 127, 33, 6, 65, 0, 33, 3, 3, 64, 32, 3, 65, 192, 0, 72, 4, 64, 65, 63, 32, 3, 107, 32, 6, 32, 8, 131, 66, 0, 86, 13, 2, 26, 32, 6, 66, 1, 136, 33, 6, 32, 3, 65, 1, 106, 33, 3, 12, 1, 11, 11, 65, 127, 11, 33, 1, 3, 64, 2, 127, 66, 128, 128, 128, 128, 128, 128, 128, 128, 128, 127, 33, 6, 65, 0, 33, 3, 3, 64, 32, 3, 65, 192, 0, 72, 4, 64, 65, 63, 32, 3, 107, 32, 6, 32, 7, 131, 66, 0, 86, 13, 2, 26, 32, 6, 66, 1, 136, 33, 6, 32, 3, 65, 1, 106, 33, 3, 12, 1, 11, 11, 65, 127, 11, 32, 1, 107, 34, 3, 65, 0, 78, 4, 64, 32, 7, 32, 9, 32, 3, 172, 134, 133, 33, 7, 12, 1, 11, 11, 65, 0, 33, 5, 3, 64, 32, 5, 32, 0, 40, 2, 4, 65, 1, 107, 72, 4, 64, 65, 0, 33, 3, 32, 7, 66, 8, 134, 33, 7, 32, 0, 41, 3, 72, 34, 8, 33, 9, 2, 127, 66, 128, 128, 128, 128, 128, 128, 128, 128, 128, 127, 33, 6, 3, 64, 32, 3, 65, 192, 0, 72, 4, 64, 65, 63, 32, 3, 107, 32, 6, 32, 8, 131, 66, 0, 86, 13, 2, 26, 32, 6, 66, 1, 136, 33, 6, 32, 3, 65, 1, 106, 33, 3, 12, 1, 11, 11, 65, 127, 11, 33, 1, 3, 64, 2, 127, 66, 128, 128, 128, 128, 128, 128, 128, 128, 128, 127, 33, 6, 65, 0, 33, 4, 3, 64, 32, 4, 65, 192, 0, 72, 4, 64, 65, 63, 32, 4, 107, 32, 6, 32, 7, 131, 66, 0, 86, 13, 2, 26, 32, 6, 66, 1, 136, 33, 6, 32, 4, 65, 1, 106, 33, 4, 12, 1, 11, 11, 65, 127, 11, 32, 1, 107, 34, 3, 65, 0, 78, 4, 64, 32, 7, 32, 9, 32, 3, 172, 134, 133, 33, 7, 12, 1, 11, 11, 32, 5, 65, 1, 106, 33, 5, 12, 1, 11, 11, 35, 6, 40, 2, 4, 32, 2, 65, 3, 116, 106, 32, 7, 55, 3, 0, 32, 2, 65, 1, 106, 33, 2, 12, 1, 11, 11, 2, 127, 32, 0, 41, 3, 72, 33, 6, 66, 128, 128, 128, 128, 128, 128, 128, 128, 128, 127, 33, 7, 65, 0, 33, 2, 3, 64, 32, 2, 65, 192, 0, 72, 4, 64, 65, 63, 32, 2, 107, 32, 6, 32, 7, 131, 66, 0, 86, 13, 2, 26, 32, 7, 66, 1, 136, 33, 7, 32, 2, 65, 1, 106, 33, 2, 12, 1, 11, 11, 65, 127, 11, 172, 33, 8, 65, 0, 33, 2, 3, 64, 32, 2, 65, 128, 2, 72, 4, 64, 35, 5, 33, 4, 32, 2, 172, 32, 8, 134, 34, 9, 33, 7, 2, 127, 32, 0, 41, 3, 72, 34, 10, 33, 11, 66, 128, 128, 128, 128, 128, 128, 128, 128, 128, 127, 33, 6, 65, 0, 33, 3, 3, 64, 32, 3, 65, 192, 0, 72, 4, 64, 65, 63, 32, 3, 107, 32, 6, 32, 11, 131, 66, 0, 86, 13, 2, 26, 32, 6, 66, 1, 136, 33, 6, 32, 3, 65, 1, 106, 33, 3, 12, 1, 11, 11, 65, 127, 11, 33, 1, 3, 64, 2, 127, 66, 128, 128, 128, 128, 128, 128, 128, 128, 128, 127, 33, 6, 65, 0, 33, 5, 3, 64, 32, 5, 65, 192, 0, 72, 4, 64, 65, 63, 32, 5, 107, 32, 6, 32, 7, 131, 66, 0, 86, 13, 2, 26, 32, 6, 66, 1, 136, 33, 6, 32, 5, 65, 1, 106, 33, 5, 12, 1, 11, 11, 65, 127, 11, 32, 1, 107, 34, 3, 65, 0, 78, 4, 64, 32, 7, 32, 10, 32, 3, 172, 134, 133, 33, 7, 12, 1, 11, 11, 32, 4, 40, 2, 4, 32, 2, 65, 3, 116, 106, 32, 7, 32, 9, 132, 55, 3, 0, 32, 2, 65, 1, 106, 33, 2, 12, 1, 11, 11, 65, 1, 36, 4, 11, 32, 0, 66, 0, 55, 3, 24, 32, 0, 66, 0, 55, 3, 32, 65, 0, 33, 2, 3, 64, 32, 2, 32, 0, 40, 2, 4, 72, 4, 64, 32, 0, 40, 2, 0, 32, 2, 65, 0, 16, 18, 32, 2, 65, 1, 106, 33, 2, 12, 1, 11, 11, 32, 0, 66, 0, 55, 3, 40, 32, 0, 65, 0, 54, 2, 8, 32, 0, 66, 0, 55, 3, 16, 32, 0, 66, 0, 55, 3, 40, 32, 0, 40, 2, 0, 32, 0, 40, 2, 8, 16, 19, 33, 1, 32, 0, 40, 2, 0, 32, 0, 40, 2, 8, 65, 1, 16, 18, 32, 0, 32, 0, 41, 3, 40, 35, 6, 40, 2, 4, 32, 1, 65, 3, 116, 106, 41, 3, 0, 133, 55, 3, 40, 32, 0, 32, 0, 40, 2, 8, 65, 1, 106, 32, 0, 40, 2, 4, 111, 54, 2, 8, 32, 0, 35, 5, 40, 2, 4, 32, 0, 41, 3, 40, 34, 6, 66, 45, 136, 167, 65, 255, 1, 113, 65, 3, 116, 106, 41, 3, 0, 32, 6, 66, 8, 134, 66, 1, 132, 133, 55, 3, 40, 32, 0, 11, 38, 1, 1, 127, 32, 0, 40, 2, 0, 34, 0, 65, 172, 3, 75, 4, 64, 32, 0, 65, 16, 107, 34, 1, 32, 1, 40, 2, 4, 65, 1, 106, 54, 2, 4, 11, 32, 0, 11, 55, 1, 2, 127, 32, 1, 32, 0, 40, 2, 0, 34, 2, 71, 4, 64, 32, 1, 65, 172, 3, 75, 4, 64, 32, 1, 65, 16, 107, 34, 3, 32, 3, 40, 2, 4, 65, 1, 106, 54, 2, 4, 11, 32, 2, 16, 12, 11, 32, 0, 32, 1, 54, 2, 0, 11, 7, 0, 32, 0, 40, 2, 4, 11, 9, 0, 32, 0, 32, 1, 54, 2, 4, 11, 7, 0, 32, 0, 40, 2, 8, 11, 9, 0, 32, 0, 32, 1, 54, 2, 8, 11, 7, 0, 32, 0, 41, 3, 16, 11, 9, 0, 32, 0, 32, 1, 55, 3, 16, 11, 7, 0, 32, 0, 41, 3, 24, 11, 9, 0, 32, 0, 32, 1, 55, 3, 24, 11, 7, 0, 32, 0, 41, 3, 32, 11, 9, 0, 32, 0, 32, 1, 55, 3, 32, 11, 7, 0, 32, 0, 41, 3, 40, 11, 9, 0, 32, 0, 32, 1, 55, 3, 40, 11, 7, 0, 32, 0, 41, 3, 48, 11, 9, 0, 32, 0, 32, 1, 55, 3, 48, 11, 7, 0, 32, 0, 41, 3, 56, 11, 9, 0, 32, 0, 32, 1, 55, 3, 56, 11, 7, 0, 32, 0, 41, 3, 64, 11, 9, 0, 32, 0, 32, 1, 55, 3, 64, 11, 7, 0, 32, 0, 41, 3, 72, 11, 9, 0, 32, 0, 32, 1, 55, 3, 72, 11, 7, 0, 32, 0, 41, 3, 80, 11, 9, 0, 32, 0, 32, 1, 55, 3, 80, 11, 7, 0, 32, 0, 41, 3, 88, 11, 9, 0, 32, 0, 32, 1, 55, 3, 88, 11, 7, 0, 32, 0, 41, 3, 96, 11, 9, 0, 32, 0, 32, 1, 55, 3, 96, 11, 172, 4, 2, 5, 127, 1, 126, 32, 2, 65, 172, 3, 75, 4, 64, 32, 2, 65, 16, 107, 34, 4, 32, 4, 40, 2, 4, 65, 1, 106, 54, 2, 4, 11, 32, 2, 33, 4, 65, 0, 33, 2, 32, 1, 40, 2, 8, 33, 5, 32, 1, 40, 2, 4, 33, 6, 3, 64, 2, 127, 65, 0, 33, 3, 3, 64, 32, 3, 32, 5, 72, 4, 64, 32, 3, 32, 6, 106, 45, 0, 0, 33, 1, 32, 0, 40, 2, 0, 32, 0, 40, 2, 8, 16, 19, 33, 7, 32, 0, 40, 2, 0, 32, 0, 40, 2, 8, 32, 1, 16, 18, 32, 0, 32, 0, 41, 3, 40, 35, 6, 40, 2, 4, 32, 7, 65, 3, 116, 106, 41, 3, 0, 133, 55, 3, 40, 32, 0, 32, 0, 40, 2, 8, 65, 1, 106, 32, 0, 40, 2, 4, 111, 54, 2, 8, 32, 0, 35, 5, 40, 2, 4, 32, 0, 41, 3, 40, 34, 8, 66, 45, 136, 167, 65, 255, 1, 113, 65, 3, 116, 106, 41, 3, 0, 32, 1, 173, 32, 8, 66, 8, 134, 132, 133, 55, 3, 40, 32, 0, 32, 0, 41, 3, 16, 66, 1, 124, 55, 3, 16, 32, 0, 32, 0, 41, 3, 24, 66, 1, 124, 55, 3, 24, 32, 0, 41, 3, 16, 32, 0, 41, 3, 80, 90, 4, 127, 32, 0, 41, 3, 40, 32, 0, 41, 3, 96, 131, 80, 5, 65, 0, 11, 4, 127, 65, 1, 5, 32, 0, 41, 3, 16, 32, 0, 41, 3, 88, 90, 11, 4, 64, 32, 0, 32, 0, 41, 3, 32, 55, 3, 48, 32, 0, 32, 0, 41, 3, 16, 55, 3, 56, 32, 0, 32, 0, 41, 3, 40, 55, 3, 64, 65, 0, 33, 1, 3, 64, 32, 1, 32, 0, 40, 2, 4, 72, 4, 64, 32, 0, 40, 2, 0, 32, 1, 65, 0, 16, 18, 32, 1, 65, 1, 106, 33, 1, 12, 1, 11, 11, 32, 0, 66, 0, 55, 3, 40, 32, 0, 65, 0, 54, 2, 8, 32, 0, 66, 0, 55, 3, 16, 32, 0, 66, 0, 55, 3, 40, 32, 0, 40, 2, 0, 32, 0, 40, 2, 8, 16, 19, 33, 1, 32, 0, 40, 2, 0, 32, 0, 40, 2, 8, 65, 1, 16, 18, 32, 0, 32, 0, 41, 3, 40, 35, 6, 40, 2, 4, 32, 1, 65, 3, 116, 106, 41, 3, 0, 133, 55, 3, 40, 32, 0, 32, 0, 40, 2, 8, 65, 1, 106, 32, 0, 40, 2, 4, 111, 54, 2, 8, 32, 0, 35, 5, 40, 2, 4, 32, 0, 41, 3, 40, 34, 8, 66, 45, 136, 167, 65, 255, 1, 113, 65, 3, 116, 106, 41, 3, 0, 32, 8, 66, 8, 134, 66, 1, 132, 133, 55, 3, 40, 32, 3, 65, 1, 106, 12, 3, 11, 32, 3, 65, 1, 106, 33, 3, 12, 1, 11, 11, 65, 127, 11, 34, 1, 65, 0, 78, 4, 64, 32, 5, 32, 1, 107, 33, 5, 32, 1, 32, 6, 106, 33, 6, 32, 2, 34, 1, 65, 1, 106, 33, 2, 32, 4, 40, 2, 4, 32, 1, 65, 2, 116, 106, 32, 0, 41, 3, 56, 62, 2, 0, 12, 1, 11, 11, 32, 4, 11, 10, 0, 16, 15, 36, 5, 16, 15, 36, 6, 11, 3, 0, 1, 11, 73, 1, 2, 127, 32, 0, 40, 2, 4, 34, 1, 65, 255, 255, 255, 255, 0, 113, 34, 2, 65, 1, 70, 4, 64, 32, 0, 65, 16, 106, 16, 53, 32, 0, 32, 0, 40, 2, 0, 65, 1, 114, 54, 2, 0, 35, 0, 32, 0, 16, 2, 5, 32, 0, 32, 2, 65, 1, 107, 32, 1, 65, 128, 128, 128, 128, 127, 113, 114, 54, 2, 4, 11, 11, 58, 0, 2, 64, 2, 64, 2, 64, 32, 0, 65, 8, 107, 40, 2, 0, 14, 7, 0, 0, 1, 1, 1, 1, 1, 2, 11, 15, 11, 32, 0, 40, 2, 0, 34, 0, 4, 64, 32, 0, 65, 172, 3, 79, 4, 64, 32, 0, 65, 16, 107, 16, 52, 11, 11, 15, 11, 0, 11, 11, 137, 3, 7, 0, 65, 16, 11, 55, 40, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 40, 0, 0, 0, 97, 0, 108, 0, 108, 0, 111, 0, 99, 0, 97, 0, 116, 0, 105, 0, 111, 0, 110, 0, 32, 0, 116, 0, 111, 0, 111, 0, 32, 0, 108, 0, 97, 0, 114, 0, 103, 0, 101, 0, 65, 208, 0, 11, 45, 30, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 30, 0, 0, 0, 126, 0, 108, 0, 105, 0, 98, 0, 47, 0, 114, 0, 116, 0, 47, 0, 116, 0, 108, 0, 115, 0, 102, 0, 46, 0, 116, 0, 115, 0, 65, 128, 1, 11, 43, 28, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 28, 0, 0, 0, 73, 0, 110, 0, 118, 0, 97, 0, 108, 0, 105, 0, 100, 0, 32, 0, 108, 0, 101, 0, 110, 0, 103, 0, 116, 0, 104, 0, 65, 176, 1, 11, 53, 38, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 38, 0, 0, 0, 126, 0, 108, 0, 105, 0, 98, 0, 47, 0, 97, 0, 114, 0, 114, 0, 97, 0, 121, 0, 98, 0, 117, 0, 102, 0, 102, 0, 101, 0, 114, 0, 46, 0, 116, 0, 115, 0, 65, 240, 1, 11, 51, 36, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 36, 0, 0, 0, 73, 0, 110, 0, 100, 0, 101, 0, 120, 0, 32, 0, 111, 0, 117, 0, 116, 0, 32, 0, 111, 0, 102, 0, 32, 0, 114, 0, 97, 0, 110, 0, 103, 0, 101, 0, 65, 176, 2, 11, 51, 36, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 36, 0, 0, 0, 126, 0, 108, 0, 105, 0, 98, 0, 47, 0, 116, 0, 121, 0, 112, 0, 101, 0, 100, 0, 97, 0, 114, 0, 114, 0, 97, 0, 121, 0, 46, 0, 116, 0, 115, 0, 65, 240, 2, 11, 53, 7, 0, 0, 0, 16, 0, 0, 0, 0, 0, 0, 0, 16, 0, 0, 0, 0, 0, 0, 0, 16, 0, 0, 0, 0, 0, 0, 0, 145, 4, 0, 0, 2, 0, 0, 0, 49, 0, 0, 0, 2, 0, 0, 0, 17, 1, 0, 0, 2, 0, 0, 0, 16, 0, 34, 16, 115, 111, 117, 114, 99, 101, 77, 97, 112, 112, 105, 110, 103, 85, 82, 76, 16, 46, 47, 114, 97, 98, 105, 110, 46, 119, 97, 115, 109, 46, 109, 97, 112]);
    return instantiate(new Response(new Blob([wasm], {type: "application/wasm"})), imp);
  }
  module2.exports = loadWebAssembly;
});

// node_modules/rabin-wasm/src/index.js
var require_src27 = __commonJS((exports2, module2) => {
  var Rabin = require_rabin();
  var getRabin = require_rabin_wasm();
  var create = async (avg, min, max, windowSize, polynomial) => {
    const compiled = await getRabin();
    return new Rabin(compiled, avg, min, max, windowSize, polynomial);
  };
  module2.exports = {
    Rabin,
    create
  };
});

// node_modules/ipfs-unixfs-importer/src/chunker/rabin.js
var require_rabin2 = __commonJS((exports2, module2) => {
  "use strict";
  var BufferList = require_BufferList();
  var {create} = require_src27();
  var errcode = require_err_code();
  module2.exports = async function* rabinChunker(source, options) {
    const rabin = jsRabin();
    let min, max, avg;
    if (options.minChunkSize && options.maxChunkSize && options.avgChunkSize) {
      avg = options.avgChunkSize;
      min = options.minChunkSize;
      max = options.maxChunkSize;
    } else if (!options.avgChunkSize) {
      throw errcode(new Error("please specify an average chunk size"), "ERR_INVALID_AVG_CHUNK_SIZE");
    } else {
      avg = options.avgChunkSize;
      min = avg / 3;
      max = avg + avg / 2;
    }
    if (min < 16) {
      throw errcode(new Error("rabin min must be greater than 16"), "ERR_INVALID_MIN_CHUNK_SIZE");
    }
    if (max < min) {
      max = min;
    }
    if (avg < min) {
      avg = min;
    }
    const sizepow = Math.floor(Math.log2(avg));
    for await (const chunk of rabin(source, {
      min,
      max,
      bits: sizepow,
      window: options.window,
      polynomial: options.polynomial
    })) {
      yield chunk;
    }
  };
  var jsRabin = () => {
    return async function* (source, options) {
      const r = await create(options.bits, options.min, options.max, options.window);
      const buffers = new BufferList();
      for await (const chunk of source) {
        buffers.append(chunk);
        const sizes = r.fingerprint(chunk);
        for (let i = 0; i < sizes.length; i++) {
          var size = sizes[i];
          var buf = buffers.slice(0, size);
          buffers.consume(size);
          yield buf;
        }
      }
      if (buffers.length) {
        yield buffers.slice(0);
      }
    };
  };
});

// node_modules/ipfs-unixfs-importer/src/chunker/fixed-size.js
var require_fixed_size = __commonJS((exports2, module2) => {
  "use strict";
  var BufferList = require_BufferList();
  module2.exports = async function* fixedSizeChunker(source, options) {
    let bl = new BufferList();
    let currentLength = 0;
    let emitted = false;
    const maxChunkSize = options.maxChunkSize;
    for await (const buffer of source) {
      bl.append(buffer);
      currentLength += buffer.length;
      while (currentLength >= maxChunkSize) {
        yield bl.slice(0, maxChunkSize);
        emitted = true;
        if (maxChunkSize === bl.length) {
          bl = new BufferList();
          currentLength = 0;
        } else {
          const newBl = new BufferList();
          newBl.append(bl.shallowSlice(maxChunkSize));
          bl = newBl;
          currentLength -= maxChunkSize;
        }
      }
    }
    if (!emitted || currentLength) {
      yield bl.slice(0, currentLength);
    }
  };
});

// node_modules/ipfs-unixfs-importer/src/dag-builder/validate-chunks.js
var require_validate_chunks = __commonJS((exports2, module2) => {
  "use strict";
  var errCode = require_err_code();
  var uint8ArrayFromString = require_from_string2();
  async function* validateChunks(source) {
    for await (const content of source) {
      if (content.length === void 0) {
        throw errCode(new Error("Content was invalid"), "ERR_INVALID_CONTENT");
      }
      if (typeof content === "string" || content instanceof String) {
        yield uint8ArrayFromString(content);
      } else if (Array.isArray(content)) {
        yield Uint8Array.from(content);
      } else {
        yield content;
      }
    }
  }
  module2.exports = validateChunks;
});

// node_modules/ipfs-unixfs-importer/src/dag-builder/index.js
var require_dag_builder = __commonJS((exports2, module2) => {
  "use strict";
  var dirBuilder = require_dir();
  var fileBuilder = require_file();
  async function* dagBuilder(source, block, options) {
    for await (const entry of source) {
      if (entry.path) {
        if (entry.path.substring(0, 2) === "./") {
          options.wrapWithDirectory = true;
        }
        entry.path = entry.path.split("/").filter((path) => path && path !== ".").join("/");
      }
      if (entry.content) {
        let source2 = entry.content;
        if (!source2[Symbol.asyncIterator] && !source2[Symbol.iterator] || source2.length !== void 0) {
          source2 = {
            [Symbol.iterator]: function* () {
              yield entry.content;
            }
          };
        }
        let chunker;
        if (typeof options.chunker === "function") {
          chunker = options.chunker;
        } else if (options.chunker === "rabin") {
          chunker = require_rabin2();
        } else {
          chunker = require_fixed_size();
        }
        let chunkValidator;
        if (typeof options.chunkValidator === "function") {
          chunkValidator = options.chunkValidator;
        } else {
          chunkValidator = require_validate_chunks();
        }
        yield () => fileBuilder(entry, chunker(chunkValidator(source2, options), options), block, options);
      } else {
        yield () => dirBuilder(entry, block, options);
      }
    }
  }
  module2.exports = dagBuilder;
});

// node_modules/ipfs-unixfs-importer/src/dir.js
var require_dir2 = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = class Dir {
    constructor(props, options) {
      this.options = options || {};
      Object.assign(this, props);
    }
  };
});

// node_modules/ipfs-unixfs-importer/src/dir-flat.js
var require_dir_flat = __commonJS((exports2, module2) => {
  "use strict";
  var {
    DAGLink,
    DAGNode
  } = require_src16();
  var UnixFS = require_src17();
  var Dir = require_dir2();
  var persist = require_persist();
  var DirFlat = class extends Dir {
    constructor(props, options) {
      super(props, options);
      this._children = {};
    }
    put(name, value) {
      this.cid = void 0;
      this.size = void 0;
      this._children[name] = value;
    }
    get(name) {
      return this._children[name];
    }
    childCount() {
      return Object.keys(this._children).length;
    }
    directChildrenCount() {
      return this.childCount();
    }
    onlyChild() {
      return this._children[Object.keys(this._children)[0]];
    }
    *eachChildSeries() {
      const keys = Object.keys(this._children);
      for (let i = 0; i < keys.length; i++) {
        const key = keys[i];
        yield {
          key,
          child: this._children[key]
        };
      }
    }
    async *flush(path, block) {
      const children = Object.keys(this._children);
      const links = [];
      for (let i = 0; i < children.length; i++) {
        let child = this._children[children[i]];
        if (typeof child.flush === "function") {
          for await (const entry of child.flush(child.path, block)) {
            child = entry;
            yield child;
          }
        }
        links.push(new DAGLink(children[i], child.size, child.cid));
      }
      const unixfs = new UnixFS({
        type: "directory",
        mtime: this.mtime,
        mode: this.mode
      });
      const node = new DAGNode(unixfs.marshal(), links);
      const buffer = node.serialize();
      const cid = await persist(buffer, block, this.options);
      const size = buffer.length + node.Links.reduce((acc, curr) => acc + curr.Tsize, 0);
      this.cid = cid;
      this.size = size;
      yield {
        cid,
        unixfs,
        path,
        size
      };
    }
  };
  module2.exports = DirFlat;
});

// node_modules/sparse-array/index.js
var require_sparse_array = __commonJS((exports2, module2) => {
  "use strict";
  var BITS_PER_BYTE = 7;
  module2.exports = class SparseArray {
    constructor() {
      this._bitArrays = [];
      this._data = [];
      this._length = 0;
      this._changedLength = false;
      this._changedData = false;
    }
    set(index, value) {
      let pos = this._internalPositionFor(index, false);
      if (value === void 0) {
        if (pos !== -1) {
          this._unsetInternalPos(pos);
          this._unsetBit(index);
          this._changedLength = true;
          this._changedData = true;
        }
      } else {
        let needsSort = false;
        if (pos === -1) {
          pos = this._data.length;
          this._setBit(index);
          this._changedData = true;
        } else {
          needsSort = true;
        }
        this._setInternalPos(pos, index, value, needsSort);
        this._changedLength = true;
      }
    }
    unset(index) {
      this.set(index, void 0);
    }
    get(index) {
      this._sortData();
      const pos = this._internalPositionFor(index, true);
      if (pos === -1) {
        return void 0;
      }
      return this._data[pos][1];
    }
    push(value) {
      this.set(this.length, value);
      return this.length;
    }
    get length() {
      this._sortData();
      if (this._changedLength) {
        const last = this._data[this._data.length - 1];
        this._length = last ? last[0] + 1 : 0;
        this._changedLength = false;
      }
      return this._length;
    }
    forEach(iterator) {
      let i = 0;
      while (i < this.length) {
        iterator(this.get(i), i, this);
        i++;
      }
    }
    map(iterator) {
      let i = 0;
      let mapped = new Array(this.length);
      while (i < this.length) {
        mapped[i] = iterator(this.get(i), i, this);
        i++;
      }
      return mapped;
    }
    reduce(reducer, initialValue) {
      let i = 0;
      let acc = initialValue;
      while (i < this.length) {
        const value = this.get(i);
        acc = reducer(acc, value, i);
        i++;
      }
      return acc;
    }
    find(finder) {
      let i = 0, found, last;
      while (i < this.length && !found) {
        last = this.get(i);
        found = finder(last);
        i++;
      }
      return found ? last : void 0;
    }
    _internalPositionFor(index, noCreate) {
      const bytePos = this._bytePosFor(index, noCreate);
      if (bytePos >= this._bitArrays.length) {
        return -1;
      }
      const byte = this._bitArrays[bytePos];
      const bitPos = index - bytePos * BITS_PER_BYTE;
      const exists = (byte & 1 << bitPos) > 0;
      if (!exists) {
        return -1;
      }
      const previousPopCount = this._bitArrays.slice(0, bytePos).reduce(popCountReduce, 0);
      const mask = ~(4294967295 << bitPos + 1);
      const bytePopCount = popCount(byte & mask);
      const arrayPos = previousPopCount + bytePopCount - 1;
      return arrayPos;
    }
    _bytePosFor(index, noCreate) {
      const bytePos = Math.floor(index / BITS_PER_BYTE);
      const targetLength = bytePos + 1;
      while (!noCreate && this._bitArrays.length < targetLength) {
        this._bitArrays.push(0);
      }
      return bytePos;
    }
    _setBit(index) {
      const bytePos = this._bytePosFor(index, false);
      this._bitArrays[bytePos] |= 1 << index - bytePos * BITS_PER_BYTE;
    }
    _unsetBit(index) {
      const bytePos = this._bytePosFor(index, false);
      this._bitArrays[bytePos] &= ~(1 << index - bytePos * BITS_PER_BYTE);
    }
    _setInternalPos(pos, index, value, needsSort) {
      const data = this._data;
      const elem = [index, value];
      if (needsSort) {
        this._sortData();
        data[pos] = elem;
      } else {
        if (data.length) {
          if (data[data.length - 1][0] >= index) {
            data.push(elem);
          } else if (data[0][0] <= index) {
            data.unshift(elem);
          } else {
            const randomIndex = Math.round(data.length / 2);
            this._data = data.slice(0, randomIndex).concat(elem).concat(data.slice(randomIndex));
          }
        } else {
          this._data.push(elem);
        }
        this._changedData = true;
        this._changedLength = true;
      }
    }
    _unsetInternalPos(pos) {
      this._data.splice(pos, 1);
    }
    _sortData() {
      if (this._changedData) {
        this._data.sort(sortInternal);
      }
      this._changedData = false;
    }
    bitField() {
      const bytes = [];
      let pendingBitsForResultingByte = 8;
      let pendingBitsForNewByte = 0;
      let resultingByte = 0;
      let newByte;
      const pending = this._bitArrays.slice();
      while (pending.length || pendingBitsForNewByte) {
        if (pendingBitsForNewByte === 0) {
          newByte = pending.shift();
          pendingBitsForNewByte = 7;
        }
        const usingBits = Math.min(pendingBitsForNewByte, pendingBitsForResultingByte);
        const mask = ~(255 << usingBits);
        const masked = newByte & mask;
        resultingByte |= masked << 8 - pendingBitsForResultingByte;
        newByte = newByte >>> usingBits;
        pendingBitsForNewByte -= usingBits;
        pendingBitsForResultingByte -= usingBits;
        if (!pendingBitsForResultingByte || !pendingBitsForNewByte && !pending.length) {
          bytes.push(resultingByte);
          resultingByte = 0;
          pendingBitsForResultingByte = 8;
        }
      }
      for (var i = bytes.length - 1; i > 0; i--) {
        const value = bytes[i];
        if (value === 0) {
          bytes.pop();
        } else {
          break;
        }
      }
      return bytes;
    }
    compactArray() {
      this._sortData();
      return this._data.map(valueOnly);
    }
  };
  function popCountReduce(count, byte) {
    return count + popCount(byte);
  }
  function popCount(_v) {
    let v = _v;
    v = v - (v >> 1 & 1431655765);
    v = (v & 858993459) + (v >> 2 & 858993459);
    return (v + (v >> 4) & 252645135) * 16843009 >> 24;
  }
  function sortInternal(a, b) {
    return a[0] - b[0];
  }
  function valueOnly(elem) {
    return elem[1];
  }
});

// node_modules/hamt-sharding/src/consumable-buffer.js
var require_consumable_buffer = __commonJS((exports2, module2) => {
  "use strict";
  var START_MASKS = [
    255,
    254,
    252,
    248,
    240,
    224,
    192,
    128
  ];
  var STOP_MASKS = [
    1,
    3,
    7,
    15,
    31,
    63,
    127,
    255
  ];
  module2.exports = class ConsumableBuffer {
    constructor(value) {
      this._value = value;
      this._currentBytePos = value.length - 1;
      this._currentBitPos = 7;
    }
    availableBits() {
      return this._currentBitPos + 1 + this._currentBytePos * 8;
    }
    totalBits() {
      return this._value.length * 8;
    }
    take(bits) {
      let pendingBits = bits;
      let result = 0;
      while (pendingBits && this._haveBits()) {
        const byte = this._value[this._currentBytePos];
        const availableBits = this._currentBitPos + 1;
        const taking = Math.min(availableBits, pendingBits);
        const value = byteBitsToInt(byte, availableBits - taking, taking);
        result = (result << taking) + value;
        pendingBits -= taking;
        this._currentBitPos -= taking;
        if (this._currentBitPos < 0) {
          this._currentBitPos = 7;
          this._currentBytePos--;
        }
      }
      return result;
    }
    untake(bits) {
      this._currentBitPos += bits;
      while (this._currentBitPos > 7) {
        this._currentBitPos -= 8;
        this._currentBytePos += 1;
      }
    }
    _haveBits() {
      return this._currentBytePos >= 0;
    }
  };
  function byteBitsToInt(byte, start, length) {
    const mask = maskFor(start, length);
    return (byte & mask) >>> start;
  }
  function maskFor(start, length) {
    return START_MASKS[start] & STOP_MASKS[Math.min(length + start - 1, 7)];
  }
});

// node_modules/hamt-sharding/src/consumable-hash.js
var require_consumable_hash = __commonJS((exports2, module2) => {
  "use strict";
  var ConsumableBuffer = require_consumable_buffer();
  module2.exports = function wrapHash(hashFn) {
    return function hashing(value) {
      if (value instanceof InfiniteHash) {
        return value;
      } else {
        return new InfiniteHash(value, hashFn);
      }
    };
  };
  var InfiniteHash = class {
    constructor(value, hashFn) {
      if (typeof value !== "string" && !Buffer.isBuffer(value)) {
        throw new Error("can only hash strings or buffers");
      }
      this._value = value;
      this._hashFn = hashFn;
      this._depth = -1;
      this._availableBits = 0;
      this._currentBufferIndex = 0;
      this._buffers = [];
    }
    async take(bits) {
      let pendingBits = bits;
      while (this._availableBits < pendingBits) {
        await this._produceMoreBits();
      }
      let result = 0;
      while (pendingBits > 0) {
        const hash = this._buffers[this._currentBufferIndex];
        const available = Math.min(hash.availableBits(), pendingBits);
        const took = hash.take(available);
        result = (result << available) + took;
        pendingBits -= available;
        this._availableBits -= available;
        if (hash.availableBits() === 0) {
          this._currentBufferIndex++;
        }
      }
      return result;
    }
    untake(bits) {
      let pendingBits = bits;
      while (pendingBits > 0) {
        const hash = this._buffers[this._currentBufferIndex];
        const availableForUntake = Math.min(hash.totalBits() - hash.availableBits(), pendingBits);
        hash.untake(availableForUntake);
        pendingBits -= availableForUntake;
        this._availableBits += availableForUntake;
        if (this._currentBufferIndex > 0 && hash.totalBits() === hash.availableBits()) {
          this._depth--;
          this._currentBufferIndex--;
        }
      }
    }
    async _produceMoreBits() {
      this._depth++;
      const value = this._depth ? this._value + this._depth : this._value;
      const hashValue = await this._hashFn(value);
      const buffer = new ConsumableBuffer(hashValue);
      this._buffers.push(buffer);
      this._availableBits += buffer.availableBits();
    }
  };
});

// node_modules/hamt-sharding/src/bucket.js
var require_bucket = __commonJS((exports2, module2) => {
  "use strict";
  var SparseArray = require_sparse_array();
  var wrapHash = require_consumable_hash();
  var defaultOptions = {
    bits: 8
  };
  var Bucket = class {
    constructor(options, parent, posAtParent) {
      this._options = Object.assign({}, defaultOptions, options);
      this._popCount = 0;
      this._parent = parent;
      this._posAtParent = posAtParent;
      if (!this._options.hashFn) {
        throw new Error("please define an options.hashFn");
      }
      if (!this._options.hash) {
        this._options.hash = wrapHash(this._options.hashFn);
      }
      this._children = new SparseArray();
    }
    static isBucket(o) {
      return o instanceof Bucket;
    }
    async put(key, value) {
      const place = await this._findNewBucketAndPos(key);
      await place.bucket._putAt(place, key, value);
    }
    async get(key) {
      const child = await this._findChild(key);
      if (child) {
        return child.value;
      }
    }
    async del(key) {
      const place = await this._findPlace(key);
      const child = place.bucket._at(place.pos);
      if (child && child.key === key) {
        place.bucket._delAt(place.pos);
      }
    }
    leafCount() {
      return this._children.compactArray().reduce((acc, child) => {
        if (child instanceof Bucket) {
          return acc + child.leafCount();
        }
        return acc + 1;
      }, 0);
    }
    childrenCount() {
      return this._children.length;
    }
    onlyChild() {
      return this._children.get(0);
    }
    *eachLeafSeries() {
      const children = this._children.compactArray();
      for (const child of children) {
        if (child instanceof Bucket) {
          for (const c2 of child.eachLeafSeries()) {
            yield c2;
          }
        } else {
          yield child;
        }
      }
    }
    serialize(map, reduce) {
      return reduce(this._children.reduce((acc, child, index) => {
        if (child) {
          if (child instanceof Bucket) {
            acc.push(child.serialize(map, reduce));
          } else {
            acc.push(map(child, index));
          }
        }
        return acc;
      }, []));
    }
    asyncTransform(asyncMap, asyncReduce) {
      return asyncTransformBucket(this, asyncMap, asyncReduce);
    }
    toJSON() {
      return this.serialize(mapNode, reduceNodes);
    }
    prettyPrint() {
      return JSON.stringify(this.toJSON(), null, "  ");
    }
    tableSize() {
      return Math.pow(2, this._options.bits);
    }
    async _findChild(key) {
      const result = await this._findPlace(key);
      const child = result.bucket._at(result.pos);
      if (child && child.key === key) {
        return child;
      }
    }
    async _findPlace(key) {
      const hashValue = this._options.hash(key);
      const index = await hashValue.take(this._options.bits);
      const child = this._children.get(index);
      if (child instanceof Bucket) {
        return child._findPlace(hashValue);
      }
      return {
        bucket: this,
        pos: index,
        hash: hashValue
      };
    }
    async _findNewBucketAndPos(key) {
      const place = await this._findPlace(key);
      const child = place.bucket._at(place.pos);
      if (child && child.key !== key) {
        const bucket = new Bucket(this._options, place.bucket, place.pos);
        place.bucket._putObjectAt(place.pos, bucket);
        const newPlace = await bucket._findPlace(child.hash);
        newPlace.bucket._putAt(newPlace, child.key, child.value);
        return bucket._findNewBucketAndPos(place.hash);
      }
      return place;
    }
    _putAt(place, key, value) {
      this._putObjectAt(place.pos, {
        key,
        value,
        hash: place.hash
      });
    }
    _putObjectAt(pos, object) {
      if (!this._children.get(pos)) {
        this._popCount++;
      }
      this._children.set(pos, object);
    }
    _delAt(pos) {
      if (this._children.get(pos)) {
        this._popCount--;
      }
      this._children.unset(pos);
      this._level();
    }
    _level() {
      if (this._parent && this._popCount <= 1) {
        if (this._popCount === 1) {
          const onlyChild = this._children.find(exists);
          if (!(onlyChild instanceof Bucket)) {
            const hash = onlyChild.hash;
            hash.untake(this._options.bits);
            const place = {
              pos: this._posAtParent,
              hash
            };
            this._parent._putAt(place, onlyChild.key, onlyChild.value);
          }
        } else {
          this._parent._delAt(this._posAtParent);
        }
      }
    }
    _at(index) {
      return this._children.get(index);
    }
  };
  function exists(o) {
    return Boolean(o);
  }
  function mapNode(node, index) {
    return node.key;
  }
  function reduceNodes(nodes) {
    return nodes;
  }
  async function asyncTransformBucket(bucket, asyncMap, asyncReduce) {
    const output = [];
    for (const child of bucket._children.compactArray()) {
      if (child instanceof Bucket) {
        await asyncTransformBucket(child, asyncMap, asyncReduce);
      } else {
        const mappedChildren = await asyncMap(child);
        output.push({
          bitField: bucket._children.bitField(),
          children: mappedChildren
        });
      }
      return asyncReduce(output);
    }
  }
  module2.exports = Bucket;
});

// node_modules/hamt-sharding/src/index.js
var require_src28 = __commonJS((exports2, module2) => {
  "use strict";
  var Bucket = require_bucket();
  module2.exports = function createHAMT(options) {
    return new Bucket(options);
  };
  module2.exports.isBucket = Bucket.isBucket;
});

// node_modules/ipfs-unixfs-importer/src/dir-sharded.js
var require_dir_sharded = __commonJS((exports2, module2) => {
  "use strict";
  var {
    DAGLink,
    DAGNode
  } = require_src16();
  var UnixFS = require_src17();
  var multihashing = require_src14();
  var Dir = require_dir2();
  var persist = require_persist();
  var Bucket = require_src28();
  var mergeOptions = require_merge_options().bind({ignoreUndefined: true});
  var uint8ArrayFromString = require_from_string2();
  var hashFn = async function(value) {
    const buf = uint8ArrayFromString(value);
    const hash = await multihashing(buf, "murmur3-128");
    const justHash = hash.slice(2, 10);
    const length = justHash.length;
    const result = new Uint8Array(length);
    for (let i = 0; i < length; i++) {
      result[length - i - 1] = justHash[i];
    }
    return result;
  };
  hashFn.code = 34;
  var defaultOptions = {
    hamtHashFn: hashFn,
    hamtBucketBits: 8
  };
  var DirSharded = class extends Dir {
    constructor(props, options) {
      options = mergeOptions(defaultOptions, options);
      super(props, options);
      this._bucket = Bucket({
        hashFn: options.hamtHashFn,
        bits: options.hamtBucketBits
      });
    }
    async put(name, value) {
      await this._bucket.put(name, value);
    }
    get(name) {
      return this._bucket.get(name);
    }
    childCount() {
      return this._bucket.leafCount();
    }
    directChildrenCount() {
      return this._bucket.childrenCount();
    }
    onlyChild() {
      return this._bucket.onlyChild();
    }
    async *eachChildSeries() {
      for await (const {key, value} of this._bucket.eachLeafSeries()) {
        yield {
          key,
          child: value
        };
      }
    }
    async *flush(path, block) {
      for await (const entry of flush(path, this._bucket, block, this, this.options)) {
        yield entry;
      }
    }
  };
  module2.exports = DirSharded;
  module2.exports.hashFn = hashFn;
  async function* flush(path, bucket, block, shardRoot, options) {
    const children = bucket._children;
    const links = [];
    let childrenSize = 0;
    for (let i = 0; i < children.length; i++) {
      const child = children.get(i);
      if (!child) {
        continue;
      }
      const labelPrefix = i.toString(16).toUpperCase().padStart(2, "0");
      if (Bucket.isBucket(child)) {
        let shard;
        for await (const subShard of await flush("", child, block, null, options)) {
          shard = subShard;
        }
        links.push(new DAGLink(labelPrefix, shard.size, shard.cid));
        childrenSize += shard.size;
      } else if (typeof child.value.flush === "function") {
        const dir2 = child.value;
        let flushedDir;
        for await (const entry of dir2.flush(dir2.path, block)) {
          flushedDir = entry;
          yield flushedDir;
        }
        const label = labelPrefix + child.key;
        links.push(new DAGLink(label, flushedDir.size, flushedDir.cid));
        childrenSize += flushedDir.size;
      } else {
        const value = child.value;
        if (!value.cid) {
          continue;
        }
        const label = labelPrefix + child.key;
        const size2 = value.size;
        links.push(new DAGLink(label, size2, value.cid));
        childrenSize += size2;
      }
    }
    const data = Uint8Array.from(children.bitField().reverse());
    const dir = new UnixFS({
      type: "hamt-sharded-directory",
      data,
      fanout: bucket.tableSize(),
      hashType: options.hamtHashFn.code,
      mtime: shardRoot && shardRoot.mtime,
      mode: shardRoot && shardRoot.mode
    });
    const node = new DAGNode(dir.marshal(), links);
    const buffer = node.serialize();
    const cid = await persist(buffer, block, options);
    const size = buffer.length + childrenSize;
    yield {
      cid,
      unixfs: dir,
      path,
      size
    };
  }
});

// node_modules/ipfs-unixfs-importer/src/flat-to-shard.js
var require_flat_to_shard = __commonJS((exports2, module2) => {
  "use strict";
  var DirSharded = require_dir_sharded();
  module2.exports = async function flatToShard(child, dir, threshold, options) {
    let newDir = dir;
    if (dir.flat && dir.directChildrenCount() >= threshold) {
      newDir = await convertToShard(dir, options);
    }
    const parent = newDir.parent;
    if (parent) {
      if (newDir !== dir) {
        if (child) {
          child.parent = newDir;
        }
        await parent.put(newDir.parentKey, newDir);
      }
      return flatToShard(newDir, parent, threshold, options);
    }
    return newDir;
  };
  async function convertToShard(oldDir, options) {
    const newDir = new DirSharded({
      root: oldDir.root,
      dir: true,
      parent: oldDir.parent,
      parentKey: oldDir.parentKey,
      path: oldDir.path,
      dirty: oldDir.dirty,
      flat: false,
      mtime: oldDir.mtime,
      mode: oldDir.mode
    }, options);
    for await (const {key, child} of oldDir.eachChildSeries()) {
      await newDir.put(key, child);
    }
    return newDir;
  }
});

// node_modules/ipfs-unixfs-importer/src/utils/to-path-components.js
var require_to_path_components = __commonJS((exports2, module2) => {
  "use strict";
  var toPathComponents = (path = "") => {
    return (path.trim().match(/([^\\^/]|\\\/)+/g) || []).filter(Boolean);
  };
  module2.exports = toPathComponents;
});

// node_modules/ipfs-unixfs-importer/src/tree-builder.js
var require_tree_builder = __commonJS((exports2, module2) => {
  "use strict";
  var DirFlat = require_dir_flat();
  var flatToShard = require_flat_to_shard();
  var Dir = require_dir2();
  var toPathComponents = require_to_path_components();
  async function addToTree(elem, tree, options) {
    const pathElems = toPathComponents(elem.path || "");
    const lastIndex = pathElems.length - 1;
    let parent = tree;
    let currentPath = "";
    for (let i = 0; i < pathElems.length; i++) {
      const pathElem = pathElems[i];
      currentPath += `${currentPath ? "/" : ""}${pathElem}`;
      const last = i === lastIndex;
      parent.dirty = true;
      parent.cid = null;
      parent.size = null;
      if (last) {
        await parent.put(pathElem, elem);
        tree = await flatToShard(null, parent, options.shardSplitThreshold, options);
      } else {
        let dir = await parent.get(pathElem);
        if (!dir || !(dir instanceof Dir)) {
          dir = new DirFlat({
            dir: true,
            parent,
            parentKey: pathElem,
            path: currentPath,
            dirty: true,
            flat: true,
            mtime: dir && dir.unixfs && dir.unixfs.mtime,
            mode: dir && dir.unixfs && dir.unixfs.mode
          }, options);
        }
        await parent.put(pathElem, dir);
        parent = dir;
      }
    }
    return tree;
  }
  async function* flushAndYield(tree, block) {
    if (!(tree instanceof Dir)) {
      if (tree && tree.unixfs && tree.unixfs.isDirectory()) {
        yield tree;
      }
      return;
    }
    yield* tree.flush(tree.path, block);
  }
  async function* treeBuilder(source, block, options) {
    let tree = new DirFlat({
      root: true,
      dir: true,
      path: "",
      dirty: true,
      flat: true
    }, options);
    for await (const entry of source) {
      if (!entry) {
        continue;
      }
      tree = await addToTree(entry, tree, options);
      if (!entry.unixfs || !entry.unixfs.isDirectory()) {
        yield entry;
      }
    }
    if (options.wrapWithDirectory) {
      yield* flushAndYield(tree, block);
    } else {
      for await (const unwrapped of tree.eachChildSeries()) {
        if (!unwrapped) {
          continue;
        }
        yield* flushAndYield(unwrapped.child, block);
      }
    }
  }
  module2.exports = treeBuilder;
});

// node_modules/ipfs-unixfs-importer/src/index.js
var require_src29 = __commonJS((exports2, module2) => {
  "use strict";
  var parallelBatch = require_it_parallel_batch();
  var mergeOptions = require_merge_options().bind({ignoreUndefined: true});
  var defaultOptions = {
    chunker: "fixed",
    strategy: "balanced",
    rawLeaves: false,
    onlyHash: false,
    reduceSingleLeafToSelf: true,
    codec: "dag-pb",
    hashAlg: "sha2-256",
    leafType: "file",
    cidVersion: 0,
    progress: () => () => {
    },
    shardSplitThreshold: 1e3,
    fileImportConcurrency: 50,
    blockWriteConcurrency: 10,
    minChunkSize: 262144,
    maxChunkSize: 262144,
    avgChunkSize: 262144,
    window: 16,
    polynomial: 17437180132763652,
    maxChildrenPerNode: 174,
    layerRepeat: 4,
    wrapWithDirectory: false,
    pin: false,
    recursive: false,
    hidden: false,
    preload: false,
    chunkValidator: null,
    importBuffer: null
  };
  module2.exports = async function* (source, block, options = {}) {
    const opts = mergeOptions(defaultOptions, options);
    let dagBuilder;
    if (typeof options.dagBuilder === "function") {
      dagBuilder = options.dagBuilder;
    } else {
      dagBuilder = require_dag_builder();
    }
    let treeBuilder;
    if (typeof options.treeBuilder === "function") {
      treeBuilder = options.treeBuilder;
    } else {
      treeBuilder = require_tree_builder();
    }
    for await (const entry of treeBuilder(parallelBatch(dagBuilder(source, block, opts), opts.fileImportConcurrency), block, opts)) {
      yield {
        cid: entry.cid,
        path: entry.path,
        unixfs: entry.unixfs,
        size: entry.size
      };
    }
  };
});

// node_modules/ipfs-core-utils/node_modules/uint8arrays/from-string.js
var require_from_string7 = __commonJS((exports2, module2) => {
  "use strict";
  var {encoding: getCodec} = require_src4();
  var {TextEncoder: TextEncoder2} = require_lib_browser();
  var utf8Encoder = new TextEncoder2();
  function asciiStringToUint8Array(string) {
    const array = new Uint8Array(string.length);
    for (let i = 0; i < string.length; i++) {
      array[i] = string.charCodeAt(i);
    }
    return array;
  }
  function fromString(string, encoding = "utf8") {
    if (encoding === "utf8" || encoding === "utf-8") {
      return utf8Encoder.encode(string);
    }
    if (encoding === "ascii") {
      return asciiStringToUint8Array(string);
    }
    return getCodec(encoding).decode(string);
  }
  module2.exports = fromString;
});

// node_modules/browser-readablestream-to-it/index.js
var require_browser_readablestream_to_it = __commonJS((exports2, module2) => {
  "use strict";
  async function* browserReadableStreamToIt(stream, options = {}) {
    const reader = stream.getReader();
    try {
      while (true) {
        const result = await reader.read();
        if (result.done) {
          return;
        }
        yield result.value;
      }
    } finally {
      if (options.preventCancel !== true) {
        reader.cancel();
      }
      reader.releaseLock();
    }
  }
  module2.exports = browserReadableStreamToIt;
});

// node_modules/blob-to-it/index.js
var require_blob_to_it = __commonJS((exports2, module2) => {
  "use strict";
  var browserReadableStreamToIt = require_browser_readablestream_to_it();
  function blobToIt(blob) {
    if (typeof blob.stream === "function") {
      return browserReadableStreamToIt(blob.stream());
    }
    return browserReadableStreamToIt(new Response(blob).body);
  }
  module2.exports = blobToIt;
});

// node_modules/it-peekable/index.js
var require_it_peekable = __commonJS((exports2, module2) => {
  "use strict";
  function peekableIterator(iterable) {
    const [iterator, symbol] = iterable[Symbol.asyncIterator] ? [iterable[Symbol.asyncIterator](), Symbol.asyncIterator] : [iterable[Symbol.iterator](), Symbol.iterator];
    const queue = [];
    return {
      peek: () => {
        return iterator.next();
      },
      push: (value) => {
        queue.push(value);
      },
      next: () => {
        if (queue.length) {
          return {
            done: false,
            value: queue.shift()
          };
        }
        return iterator.next();
      },
      [symbol]() {
        return this;
      }
    };
  }
  module2.exports = peekableIterator;
});

// node_modules/it-map/index.js
var require_it_map = __commonJS((exports2, module2) => {
  "use strict";
  var map = async function* (source, func) {
    for await (const val of source) {
      yield func(val);
    }
  };
  module2.exports = map;
});

// node_modules/ipfs-core-utils/src/files/normalise-input/utils.js
var require_utils19 = __commonJS((exports2, module2) => {
  "use strict";
  var {Blob: Blob2} = globalThis;
  function isBytes(obj) {
    return ArrayBuffer.isView(obj) || obj instanceof ArrayBuffer;
  }
  function isBlob(obj) {
    return typeof Blob2 !== "undefined" && obj instanceof Blob2;
  }
  function isFileObject(obj) {
    return typeof obj === "object" && (obj.path || obj.content);
  }
  var isReadableStream = (value) => value && typeof value.getReader === "function";
  function mtimeToObject(mtime) {
    if (mtime == null) {
      return void 0;
    }
    if (mtime instanceof Date) {
      const ms = mtime.getTime();
      const secs = Math.floor(ms / 1e3);
      return {
        secs,
        nsecs: (ms - secs * 1e3) * 1e3
      };
    }
    if (Object.prototype.hasOwnProperty.call(mtime, "secs")) {
      return {
        secs: mtime.secs,
        nsecs: mtime.nsecs
      };
    }
    if (Object.prototype.hasOwnProperty.call(mtime, "Seconds")) {
      return {
        secs: mtime.Seconds,
        nsecs: mtime.FractionalNanoseconds
      };
    }
    if (Array.isArray(mtime)) {
      return {
        secs: mtime[0],
        nsecs: mtime[1]
      };
    }
  }
  function modeToNumber(mode) {
    if (mode == null) {
      return void 0;
    }
    if (typeof mode === "number") {
      return mode;
    }
    mode = mode.toString();
    if (mode.substring(0, 1) === "0") {
      return parseInt(mode, 8);
    }
    return parseInt(mode, 10);
  }
  module2.exports = {
    isBytes,
    isBlob,
    isFileObject,
    isReadableStream,
    mtimeToObject,
    modeToNumber
  };
});

// node_modules/ipfs-core-utils/src/files/normalise-input/normalise-content.js
var require_normalise_content = __commonJS((exports2, module2) => {
  "use strict";
  var errCode = require_err_code();
  var uint8ArrayFromString = require_from_string7();
  var browserStreamToIt = require_browser_readablestream_to_it();
  var blobToIt = require_blob_to_it();
  var itPeekable = require_it_peekable();
  var all = require_it_all();
  var map = require_it_map();
  var {
    isBytes,
    isReadableStream,
    isBlob
  } = require_utils19();
  async function* toAsyncIterable(input) {
    if (isBytes(input)) {
      yield toBytes(input);
      return;
    }
    if (typeof input === "string" || input instanceof String) {
      yield toBytes(input.toString());
      return;
    }
    if (isBlob(input)) {
      yield* blobToIt(input);
      return;
    }
    if (isReadableStream(input)) {
      input = browserStreamToIt(input);
    }
    if (input[Symbol.iterator] || input[Symbol.asyncIterator]) {
      const peekable = itPeekable(input);
      const {value, done} = await peekable.peek();
      if (done) {
        yield* [];
        return;
      }
      peekable.push(value);
      if (Number.isInteger(value)) {
        yield Uint8Array.from(await all(peekable));
        return;
      }
      if (isBytes(value) || typeof value === "string" || value instanceof String) {
        yield* map(peekable, toBytes);
        return;
      }
    }
    throw errCode(new Error(`Unexpected input: ${input}`), "ERR_UNEXPECTED_INPUT");
  }
  function toBytes(chunk) {
    if (chunk instanceof Uint8Array) {
      return chunk;
    }
    if (ArrayBuffer.isView(chunk)) {
      return new Uint8Array(chunk.buffer, chunk.byteOffset, chunk.byteLength);
    }
    if (chunk instanceof ArrayBuffer) {
      return new Uint8Array(chunk);
    }
    if (Array.isArray(chunk)) {
      return Uint8Array.from(chunk);
    }
    return uint8ArrayFromString(chunk.toString());
  }
  module2.exports = toAsyncIterable;
});

// node_modules/ipfs-core-utils/src/files/normalise-input/normalise-input.js
var require_normalise_input2 = __commonJS((exports2, module2) => {
  "use strict";
  var errCode = require_err_code();
  var browserStreamToIt = require_browser_readablestream_to_it();
  var itPeekable = require_it_peekable();
  var map = require_it_map();
  var {
    isBytes,
    isBlob,
    isReadableStream,
    isFileObject,
    mtimeToObject,
    modeToNumber
  } = require_utils19();
  module2.exports = async function* normaliseInput(input, normaliseContent) {
    if (input === null || input === void 0) {
      throw errCode(new Error(`Unexpected input: ${input}`), "ERR_UNEXPECTED_INPUT");
    }
    if (typeof input === "string" || input instanceof String) {
      yield toFileObject(input.toString(), normaliseContent);
      return;
    }
    if (isBytes(input) || isBlob(input)) {
      yield toFileObject(input, normaliseContent);
      return;
    }
    if (isReadableStream(input)) {
      input = browserStreamToIt(input);
    }
    if (input[Symbol.iterator] || input[Symbol.asyncIterator]) {
      const peekable = itPeekable(input);
      const {value, done} = await peekable.peek();
      if (done) {
        yield* [];
        return;
      }
      peekable.push(value);
      if (Number.isInteger(value) || isBytes(value)) {
        yield toFileObject(peekable, normaliseContent);
        return;
      }
      if (isFileObject(value) || isBlob(value) || typeof value === "string" || value instanceof String) {
        yield* map(peekable, (value2) => toFileObject(value2, normaliseContent));
        return;
      }
      if (value[Symbol.iterator] || value[Symbol.asyncIterator] || isReadableStream(value)) {
        yield* map(peekable, (value2) => toFileObject(value2, normaliseContent));
        return;
      }
    }
    if (isFileObject(input)) {
      yield toFileObject(input, normaliseContent);
      return;
    }
    throw errCode(new Error("Unexpected input: " + typeof input), "ERR_UNEXPECTED_INPUT");
  };
  async function toFileObject(input, normaliseContent) {
    const {path, mode, mtime, content} = input;
    const file = {path: path || "", mode: modeToNumber(mode), mtime: mtimeToObject(mtime)};
    if (content) {
      file.content = await normaliseContent(content);
    } else if (!path) {
      file.content = await normaliseContent(input);
    }
    return file;
  }
});

// node_modules/ipfs-core-utils/src/files/normalise-input/index.js
var require_normalise_input3 = __commonJS((exports2, module2) => {
  "use strict";
  var normaliseContent = require_normalise_content();
  var normaliseInput = require_normalise_input2();
  module2.exports = (input) => normaliseInput(input, normaliseContent);
});

// node_modules/ipfs-core/src/components/add-all/utils.js
var require_utils20 = __commonJS((exports2, module2) => {
  "use strict";
  var parseChunkerString = (chunker) => {
    if (!chunker) {
      return {
        chunker: "fixed"
      };
    } else if (chunker.startsWith("size-")) {
      const sizeStr = chunker.split("-")[1];
      const size = parseInt(sizeStr);
      if (isNaN(size)) {
        throw new Error("Chunker parameter size must be an integer");
      }
      return {
        chunker: "fixed",
        maxChunkSize: size
      };
    } else if (chunker.startsWith("rabin")) {
      return {
        chunker: "rabin",
        ...parseRabinString(chunker)
      };
    } else {
      throw new Error(`Unrecognized chunker option: ${chunker}`);
    }
  };
  var parseRabinString = (chunker) => {
    const options = {};
    const parts = chunker.split("-");
    switch (parts.length) {
      case 1:
        options.avgChunkSize = 262144;
        break;
      case 2:
        options.avgChunkSize = parseChunkSize(parts[1], "avg");
        break;
      case 4:
        options.minChunkSize = parseChunkSize(parts[1], "min");
        options.avgChunkSize = parseChunkSize(parts[2], "avg");
        options.maxChunkSize = parseChunkSize(parts[3], "max");
        break;
      default:
        throw new Error('Incorrect chunker format (expected "rabin" "rabin-[avg]" or "rabin-[min]-[avg]-[max]"');
    }
    return options;
  };
  var parseChunkSize = (str, name) => {
    const size = parseInt(str);
    if (isNaN(size)) {
      throw new Error(`Chunker parameter ${name} must be an integer`);
    }
    return size;
  };
  module2.exports = {
    parseChunkSize,
    parseRabinString,
    parseChunkerString
  };
});

// node_modules/ipfs-core/src/components/add-all/index.js
var require_add_all2 = __commonJS((exports2, module2) => {
  "use strict";
  var importer = require_src29();
  var normaliseAddInput = require_normalise_input3();
  var {parseChunkerString} = require_utils20();
  var {pipe} = require_it_pipe();
  var withTimeoutOption = require_with_timeout_option();
  var mergeOptions = require_merge_options().bind({ignoreUndefined: true});
  module2.exports = ({block, gcLock, preload, pin, options}) => {
    const isShardingEnabled = options && options.sharding;
    async function* addAll(source, options2 = {}) {
      const opts = mergeOptions({
        shardSplitThreshold: isShardingEnabled ? 1e3 : Infinity,
        strategy: "balanced"
      }, options2, {
        ...parseChunkerString(options2.chunker)
      });
      if (opts.hashAlg && opts.hashAlg !== "sha2-256" && opts.cidVersion !== 1) {
        opts.cidVersion = 1;
      }
      if (opts.trickle) {
        opts.strategy = "trickle";
      }
      if (opts.strategy === "trickle") {
        opts.leafType = "raw";
        opts.reduceSingleLeafToSelf = false;
      }
      if (opts.cidVersion > 0 && opts.rawLeaves === void 0) {
        opts.rawLeaves = true;
      }
      if (opts.hashAlg !== void 0 && opts.rawLeaves === void 0) {
        opts.rawLeaves = true;
      }
      delete opts.trickle;
      const totals = {};
      if (opts.progress) {
        const prog = opts.progress;
        opts.progress = (bytes, path) => {
          if (!totals[path]) {
            totals[path] = 0;
          }
          totals[path] += bytes;
          prog(totals[path], path);
        };
      }
      const iterator = pipe(normaliseAddInput(source), (source2) => importer(source2, block, {
        ...opts,
        pin: false
      }), transformFile(opts), preloadFile(preload, opts), pinFile(pin, opts));
      const releaseLock = await gcLock.readLock();
      try {
        for await (const added of iterator) {
          delete totals[added.path];
          yield added;
        }
      } finally {
        releaseLock();
      }
    }
    return withTimeoutOption(addAll);
  };
  function transformFile(opts) {
    return async function* (source) {
      for await (const file of source) {
        let cid = file.cid;
        if (opts.cidVersion === 1) {
          cid = cid.toV1();
        }
        let path = file.path ? file.path : cid.toString();
        if (opts.wrapWithDirectory && !file.path) {
          path = "";
        }
        yield {
          path,
          cid,
          size: file.size,
          mode: file.unixfs && file.unixfs.mode,
          mtime: file.unixfs && file.unixfs.mtime
        };
      }
    };
  }
  function preloadFile(preload, opts) {
    return async function* (source) {
      for await (const file of source) {
        const isRootFile = !file.path || opts.wrapWithDirectory ? file.path === "" : !file.path.includes("/");
        const shouldPreload = isRootFile && !opts.onlyHash && opts.preload !== false;
        if (shouldPreload) {
          preload(file.cid);
        }
        yield file;
      }
    };
  }
  function pinFile(pin, opts) {
    return async function* (source) {
      for await (const file of source) {
        const isRootDir = !file.path.includes("/");
        const shouldPin = (opts.pin == null ? true : opts.pin) && isRootDir && !opts.onlyHash;
        if (shouldPin) {
          await pin.add(file.cid, {
            preload: false,
            lock: false
          });
        }
        yield file;
      }
    };
  }
});

// node_modules/ipfs-unixfs-exporter/src/utils/find-cid-in-shard.js
var require_find_cid_in_shard = __commonJS((exports2, module2) => {
  "use strict";
  var Bucket = require_bucket();
  var multihashing = require_src14();
  var uint8ArrayFromString = require_from_string2();
  var hashFn = async function(value) {
    const buf = uint8ArrayFromString(value);
    const hash = await multihashing(buf, "murmur3-128");
    const justHash = hash.slice(2, 10);
    const length = justHash.length;
    const result = new Uint8Array(length);
    for (let i = 0; i < length; i++) {
      result[length - i - 1] = justHash[i];
    }
    return result;
  };
  hashFn.code = 34;
  var addLinksToHamtBucket = (links, bucket, rootBucket) => {
    return Promise.all(links.map((link) => {
      if (link.Name.length === 2) {
        const pos = parseInt(link.Name, 16);
        return bucket._putObjectAt(pos, new Bucket({
          hashFn
        }, bucket, pos));
      }
      return rootBucket.put(link.Name.substring(2), true);
    }));
  };
  var toPrefix = (position) => {
    return position.toString("16").toUpperCase().padStart(2, "0").substring(0, 2);
  };
  var toBucketPath = (position) => {
    let bucket = position.bucket;
    const path = [];
    while (bucket._parent) {
      path.push(bucket);
      bucket = bucket._parent;
    }
    path.push(bucket);
    return path.reverse();
  };
  var findShardCid = async (node, name, ipld, context, options) => {
    if (!context) {
      context = {
        rootBucket: new Bucket({
          hashFn
        }),
        hamtDepth: 1
      };
      context.lastBucket = context.rootBucket;
    }
    await addLinksToHamtBucket(node.Links, context.lastBucket, context.rootBucket);
    const position = await context.rootBucket._findNewBucketAndPos(name);
    let prefix = toPrefix(position.pos);
    const bucketPath = toBucketPath(position);
    if (bucketPath.length > context.hamtDepth) {
      context.lastBucket = bucketPath[context.hamtDepth];
      prefix = toPrefix(context.lastBucket._posAtParent);
    }
    const link = node.Links.find((link2) => {
      const entryPrefix = link2.Name.substring(0, 2);
      const entryName = link2.Name.substring(2);
      if (entryPrefix !== prefix) {
        return;
      }
      if (entryName && entryName !== name) {
        return;
      }
      return true;
    });
    if (!link) {
      return null;
    }
    if (link.Name.substring(2) === name) {
      return link.Hash;
    }
    context.hamtDepth++;
    node = await ipld.get(link.Hash, options);
    return findShardCid(node, name, ipld, context, options);
  };
  module2.exports = findShardCid;
});

// node_modules/ipfs-unixfs-exporter/src/utils/extract-data-from-block.js
var require_extract_data_from_block = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = function extractDataFromBlock(block, blockStart, requestedStart, requestedEnd) {
    const blockLength = block.length;
    const blockEnd = blockStart + blockLength;
    if (requestedStart >= blockEnd || requestedEnd < blockStart) {
      return new Uint8Array(0);
    }
    if (requestedEnd >= blockStart && requestedEnd < blockEnd) {
      block = block.slice(0, requestedEnd - blockStart);
    }
    if (requestedStart >= blockStart && requestedStart < blockEnd) {
      block = block.slice(requestedStart - blockStart);
    }
    return block;
  };
});

// node_modules/ipfs-unixfs-exporter/src/utils/validate-offset-and-length.js
var require_validate_offset_and_length = __commonJS((exports2, module2) => {
  "use strict";
  var errCode = require_err_code();
  var validateOffsetAndLength = (size, offset, length) => {
    if (!offset) {
      offset = 0;
    }
    if (offset < 0) {
      throw errCode(new Error("Offset must be greater than or equal to 0"), "ERR_INVALID_PARAMS");
    }
    if (offset > size) {
      throw errCode(new Error("Offset must be less than the file size"), "ERR_INVALID_PARAMS");
    }
    if (!length && length !== 0) {
      length = size - offset;
    }
    if (length < 0) {
      throw errCode(new Error("Length must be greater than or equal to 0"), "ERR_INVALID_PARAMS");
    }
    if (offset + length > size) {
      length = size - offset;
    }
    return {
      offset,
      length
    };
  };
  module2.exports = validateOffsetAndLength;
});

// node_modules/ipfs-unixfs-exporter/src/resolvers/unixfs-v1/content/file.js
var require_file2 = __commonJS((exports2, module2) => {
  "use strict";
  var extractDataFromBlock = require_extract_data_from_block();
  var validateOffsetAndLength = require_validate_offset_and_length();
  var UnixFS = require_src17();
  var errCode = require_err_code();
  async function* emitBytes(ipld, node, start, end, streamPosition = 0, options) {
    if (node instanceof Uint8Array) {
      const buf = extractDataFromBlock(node, streamPosition, start, end);
      if (buf.length) {
        yield buf;
      }
      streamPosition += buf.length;
      return streamPosition;
    }
    let file;
    try {
      file = UnixFS.unmarshal(node.Data);
    } catch (err) {
      throw errCode(err, "ERR_NOT_UNIXFS");
    }
    const nodeHasData = Boolean(file.data && file.data.length);
    if (nodeHasData) {
      const buf = extractDataFromBlock(file.data, streamPosition, start, end);
      if (buf.length) {
        yield buf;
      }
      streamPosition += file.data.length;
    }
    let childStart = streamPosition;
    for (let i = 0; i < node.Links.length; i++) {
      const childLink = node.Links[i];
      const childEnd = streamPosition + file.blockSizes[i];
      if (start >= childStart && start < childEnd || end > childStart && end <= childEnd || start < childStart && end > childEnd) {
        const child = await ipld.get(childLink.Hash, options);
        for await (const buf of emitBytes(ipld, child, start, end, streamPosition, options)) {
          streamPosition += buf.length;
          yield buf;
        }
      }
      streamPosition = childEnd;
      childStart = childEnd + 1;
    }
  }
  var fileContent = (cid, node, unixfs, path, resolve, depth, ipld) => {
    return (options = {}) => {
      const fileSize = unixfs.fileSize();
      const {
        offset,
        length
      } = validateOffsetAndLength(fileSize, options.offset, options.length);
      const start = offset;
      const end = offset + length;
      return emitBytes(ipld, node, start, end, 0, options);
    };
  };
  module2.exports = fileContent;
});

// node_modules/ipfs-unixfs-exporter/src/resolvers/unixfs-v1/content/directory.js
var require_directory = __commonJS((exports2, module2) => {
  "use strict";
  var directoryContent = (cid, node, unixfs, path, resolve, depth, ipld, options) => {
    return async function* (options2 = {}) {
      const offset = options2.offset || 0;
      const length = options2.length || node.Links.length;
      const links = node.Links.slice(offset, length);
      for (const link of links) {
        const result = await resolve(link.Hash, link.Name, `${path}/${link.Name}`, [], depth + 1, ipld, options2);
        yield result.entry;
      }
    };
  };
  module2.exports = directoryContent;
});

// node_modules/ipfs-unixfs-exporter/src/resolvers/unixfs-v1/content/hamt-sharded-directory.js
var require_hamt_sharded_directory = __commonJS((exports2, module2) => {
  "use strict";
  var hamtShardedDirectoryContent = (cid, node, unixfs, path, resolve, depth, ipld) => {
    return (options = {}) => {
      return listDirectory(node, path, resolve, depth, ipld, options);
    };
  };
  async function* listDirectory(node, path, resolve, depth, ipld, options) {
    const links = node.Links;
    for (const link of links) {
      const name = link.Name.substring(2);
      if (name) {
        const result = await resolve(link.Hash, name, `${path}/${name}`, [], depth + 1, ipld);
        yield result.entry;
      } else {
        node = await ipld.get(link.Hash);
        for await (const file of listDirectory(node, path, resolve, depth, ipld, options)) {
          yield file;
        }
      }
    }
  }
  module2.exports = hamtShardedDirectoryContent;
});

// node_modules/ipfs-unixfs-exporter/src/resolvers/unixfs-v1/index.js
var require_unixfs_v1 = __commonJS((exports2, module2) => {
  "use strict";
  var errCode = require_err_code();
  var UnixFS = require_src17();
  var findShardCid = require_find_cid_in_shard();
  var findLinkCid = (node, name) => {
    const link = node.Links.find((link2) => link2.Name === name);
    return link && link.Hash;
  };
  var contentExporters = {
    raw: require_file2(),
    file: require_file2(),
    directory: require_directory(),
    "hamt-sharded-directory": require_hamt_sharded_directory(),
    metadata: (cid, node, unixfs, path, resolve, depth, ipld) => {
    },
    symlink: (cid, node, unixfs, path, resolve, depth, ipld) => {
    }
  };
  var unixFsResolver = async (cid, name, path, toResolve, resolve, depth, ipld, options) => {
    const node = await ipld.get(cid, options);
    let unixfs;
    let next;
    if (!name) {
      name = cid.toBaseEncodedString();
    }
    try {
      unixfs = UnixFS.unmarshal(node.Data);
    } catch (err) {
      throw errCode(err, "ERR_NOT_UNIXFS");
    }
    if (!path) {
      path = name;
    }
    if (toResolve.length) {
      let linkCid;
      if (unixfs && unixfs.type === "hamt-sharded-directory") {
        linkCid = await findShardCid(node, toResolve[0], ipld);
      } else {
        linkCid = findLinkCid(node, toResolve[0]);
      }
      if (!linkCid) {
        throw errCode(new Error("file does not exist"), "ERR_NOT_FOUND");
      }
      const nextName = toResolve.shift();
      const nextPath = `${path}/${nextName}`;
      next = {
        cid: linkCid,
        toResolve,
        name: nextName,
        path: nextPath
      };
    }
    return {
      entry: {
        name,
        path,
        cid,
        node,
        content: contentExporters[unixfs.type](cid, node, unixfs, path, resolve, depth, ipld, options),
        unixfs,
        depth
      },
      next
    };
  };
  module2.exports = unixFsResolver;
});

// node_modules/ipfs-unixfs-exporter/src/resolvers/raw.js
var require_raw = __commonJS((exports2, module2) => {
  "use strict";
  var errCode = require_err_code();
  var extractDataFromBlock = require_extract_data_from_block();
  var validateOffsetAndLength = require_validate_offset_and_length();
  var rawContent = (node) => {
    return function* (options = {}) {
      const {
        offset,
        length
      } = validateOffsetAndLength(node.length, options.offset, options.length);
      yield extractDataFromBlock(node, 0, offset, offset + length);
    };
  };
  var resolve = async (cid, name, path, toResolve, resolve2, depth, ipld, options) => {
    if (toResolve.length) {
      throw errCode(new Error(`No link named ${path} found in raw node ${cid.toBaseEncodedString()}`), "ERR_NOT_FOUND");
    }
    const buf = await ipld.get(cid, options);
    return {
      entry: {
        name,
        path,
        cid,
        node: buf,
        content: rawContent(buf),
        depth
      }
    };
  };
  module2.exports = resolve;
});

// node_modules/ipfs-unixfs-exporter/src/resolvers/dag-cbor.js
var require_dag_cbor = __commonJS((exports2, module2) => {
  "use strict";
  var CID = require_src7();
  var errCode = require_err_code();
  var resolve = async (cid, name, path, toResolve, resolve2, depth, ipld, options) => {
    const node = await ipld.get(cid, options);
    let subObject = node;
    let subPath = path;
    while (toResolve.length) {
      const prop = toResolve[0];
      if (prop in subObject) {
        toResolve.shift();
        subPath = `${subPath}/${prop}`;
        if (CID.isCID(subObject[prop])) {
          return {
            entry: {
              name,
              path,
              cid,
              node,
              depth
            },
            next: {
              cid: subObject[prop],
              name: prop,
              path: subPath,
              toResolve
            }
          };
        }
        subObject = subObject[prop];
      } else {
        throw errCode(new Error(`No property named ${prop} found in cbor node ${cid.toBaseEncodedString()}`), "ERR_NO_PROP");
      }
    }
    return {
      entry: {
        name,
        path,
        cid,
        node,
        depth
      }
    };
  };
  module2.exports = resolve;
});

// node_modules/ipfs-unixfs-exporter/src/resolvers/identity.js
var require_identity = __commonJS((exports2, module2) => {
  "use strict";
  var errCode = require_err_code();
  var extractDataFromBlock = require_extract_data_from_block();
  var validateOffsetAndLength = require_validate_offset_and_length();
  var mh = require_src14().multihash;
  var rawContent = (node) => {
    return function* (options = {}) {
      const {
        offset,
        length
      } = validateOffsetAndLength(node.length, options.offset, options.length);
      yield extractDataFromBlock(node, 0, offset, offset + length);
    };
  };
  var resolve = async (cid, name, path, toResolve, resolve2, depth, ipld, options) => {
    if (toResolve.length) {
      throw errCode(new Error(`No link named ${path} found in raw node ${cid.toBaseEncodedString()}`), "ERR_NOT_FOUND");
    }
    const buf = await mh.decode(cid.multihash);
    return {
      entry: {
        name,
        path,
        cid,
        node: buf,
        content: rawContent(buf.digest),
        depth
      }
    };
  };
  module2.exports = resolve;
});

// node_modules/ipfs-unixfs-exporter/src/resolvers/index.js
var require_resolvers = __commonJS((exports2, module2) => {
  "use strict";
  var errCode = require_err_code();
  var resolvers = {
    "dag-pb": require_unixfs_v1(),
    raw: require_raw(),
    "dag-cbor": require_dag_cbor(),
    identity: require_identity()
  };
  var resolve = (cid, name, path, toResolve, depth, ipld, options) => {
    const resolver = resolvers[cid.codec];
    if (!resolver) {
      throw errCode(new Error(`No resolver for codec ${cid.codec}`), "ERR_NO_RESOLVER");
    }
    return resolver(cid, name, path, toResolve, resolve, depth, ipld, options);
  };
  module2.exports = resolve;
});

// node_modules/ipfs-unixfs-exporter/src/index.js
var require_src30 = __commonJS((exports2, module2) => {
  "use strict";
  var errCode = require_err_code();
  var CID = require_src7();
  var resolve = require_resolvers();
  var last = require_it_last();
  var toPathComponents = (path = "") => {
    return (path.trim().match(/([^\\^/]|\\\/)+/g) || []).filter(Boolean);
  };
  var cidAndRest = (path) => {
    if (path instanceof Uint8Array) {
      return {
        cid: new CID(path),
        toResolve: []
      };
    }
    if (CID.isCID(path)) {
      return {
        cid: path,
        toResolve: []
      };
    }
    if (typeof path === "string") {
      if (path.indexOf("/ipfs/") === 0) {
        path = path.substring(6);
      }
      const output = toPathComponents(path);
      return {
        cid: new CID(output[0]),
        toResolve: output.slice(1)
      };
    }
    throw errCode(new Error(`Unknown path type ${path}`), "ERR_BAD_PATH");
  };
  var walkPath = async function* (path, ipld, options) {
    let {
      cid,
      toResolve
    } = cidAndRest(path);
    let name = cid.toBaseEncodedString();
    let entryPath = name;
    const startingDepth = toResolve.length;
    while (true) {
      const result = await resolve(cid, name, entryPath, toResolve, startingDepth, ipld, options);
      if (!result.entry && !result.next) {
        throw errCode(new Error(`Could not resolve ${path}`), "ERR_NOT_FOUND");
      }
      if (result.entry) {
        yield result.entry;
      }
      if (!result.next) {
        return;
      }
      toResolve = result.next.toResolve;
      cid = result.next.cid;
      name = result.next.name;
      entryPath = result.next.path;
    }
  };
  var exporter = (path, ipld, options) => {
    return last(walkPath(path, ipld, options));
  };
  var recursive = async function* (path, ipld, options) {
    const node = await exporter(path, ipld, options);
    yield node;
    if (node.unixfs && node.unixfs.type.includes("dir")) {
      for await (const child of recurse(node, options)) {
        yield child;
      }
    }
    async function* recurse(node2, options2) {
      for await (const file of node2.content(options2)) {
        yield file;
        if (file.unixfs.type.includes("dir")) {
          for await (const subFile of recurse(file, options2)) {
            yield subFile;
          }
        }
      }
    }
  };
  module2.exports = exporter;
  module2.exports.path = walkPath;
  module2.exports.recursive = recursive;
});

// node_modules/ipfs-core/src/components/cat.js
var require_cat = __commonJS((exports2, module2) => {
  "use strict";
  var exporter = require_src30();
  var {normalizeCidPath} = require_utils7();
  var withTimeoutOption = require_with_timeout_option();
  module2.exports = function({ipld, preload}) {
    async function* cat(ipfsPath, options = {}) {
      ipfsPath = normalizeCidPath(ipfsPath);
      if (options.preload !== false) {
        const pathComponents = ipfsPath.split("/");
        preload(pathComponents[0]);
      }
      const file = await exporter(ipfsPath, ipld, options);
      if (file.unixfs && file.unixfs.type.includes("dir")) {
        throw new Error("this dag node is a directory");
      }
      if (!file.content) {
        throw new Error("this dag node has no content");
      }
      yield* file.content(options);
    }
    return withTimeoutOption(cat);
  };
});

// node_modules/ipfs-core/src/components/get.js
var require_get2 = __commonJS((exports2, module2) => {
  "use strict";
  var exporter = require_src30();
  var errCode = require_err_code();
  var {normalizeCidPath, mapFile} = require_utils7();
  var withTimeoutOption = require_with_timeout_option();
  module2.exports = function({ipld, preload}) {
    async function* get(ipfsPath, options = {}) {
      if (options.preload !== false) {
        let pathComponents;
        try {
          pathComponents = normalizeCidPath(ipfsPath).split("/");
        } catch (err) {
          throw errCode(err, "ERR_INVALID_PATH");
        }
        preload(pathComponents[0]);
      }
      for await (const file of exporter.recursive(ipfsPath, ipld, options)) {
        yield mapFile(file, {
          ...options,
          includeContent: true
        });
      }
    }
    return withTimeoutOption(get);
  };
});

// node_modules/ipfs-core/src/components/ls.js
var require_ls2 = __commonJS((exports2, module2) => {
  "use strict";
  var exporter = require_src30();
  var errCode = require_err_code();
  var {normalizeCidPath, mapFile} = require_utils7();
  var withTimeoutOption = require_with_timeout_option();
  module2.exports = function({ipld, preload}) {
    async function* ls(ipfsPath, options = {}) {
      const path = normalizeCidPath(ipfsPath);
      const recursive = options.recursive;
      const pathComponents = path.split("/");
      if (options.preload !== false) {
        preload(pathComponents[0]);
      }
      const file = await exporter(ipfsPath, ipld, options);
      if (!file.unixfs) {
        throw errCode(new Error("dag node was not a UnixFS node"), "ERR_NOT_UNIXFS");
      }
      if (file.unixfs.type === "file") {
        yield mapFile(file, options);
        return;
      }
      if (file.unixfs.type.includes("dir")) {
        if (recursive) {
          for await (const child of exporter.recursive(file.cid, ipld, options)) {
            if (file.cid.toBaseEncodedString() === child.cid.toBaseEncodedString()) {
              continue;
            }
            yield mapFile(child, options);
          }
          return;
        }
        for await (let child of file.content()) {
          child = mapFile(child, options);
          child.depth--;
          yield child;
        }
        return;
      }
      throw errCode(new Error(`Unknown UnixFS type ${file.unixfs.type}`), "ERR_UNKNOWN_UNIXFS_TYPE");
    }
    return withTimeoutOption(ls);
  };
});

// node_modules/ipfs-core/src/components/root.js
var require_root = __commonJS((exports2, module2) => {
  "use strict";
  var createAddAPI = require_add3();
  var createAddAllAPI = require_add_all2();
  var createCatAPI = require_cat();
  var createGetAPI = require_get2();
  var createLsAPI = require_ls2();
  var Root = class {
    constructor({preload, gcLock, pin, block, ipld, options}) {
      const addAll = createAddAllAPI({
        preload,
        gcLock,
        block,
        pin,
        options
      });
      this.addAll = addAll;
      this.add = createAddAPI({addAll});
      this.cat = createCatAPI({ipld, preload});
      this.get = createGetAPI({ipld, preload});
      this.ls = createLsAPI({ipld, preload});
    }
  };
  module2.exports = Root;
});

// node_modules/ipfs-core/package.json
var require_package3 = __commonJS((exports2, module2) => {
  module2.exports = {
    name: "ipfs-core",
    version: "0.5.0",
    description: "JavaScript implementation of the IPFS specification",
    keywords: [
      "IPFS"
    ],
    homepage: "https://github.com/ipfs/js-ipfs/tree/master/packages/ipfs-core#readme",
    bugs: "https://github.com/ipfs/js-ipfs/issues",
    license: "(Apache-2.0 OR MIT)",
    leadMaintainer: "Alex Potsides <alex@achingbrain.net>",
    main: "src/index.js",
    files: [
      "src",
      "dist"
    ],
    browser: {
      "./src/runtime/init-assets-nodejs.js": "./src/runtime/init-assets-browser.js",
      "./src/runtime/config-nodejs.js": "./src/runtime/config-browser.js",
      "./src/runtime/dns-nodejs.js": "./src/runtime/dns-browser.js",
      "./src/runtime/libp2p-nodejs.js": "./src/runtime/libp2p-browser.js",
      "./src/runtime/libp2p-pubsub-routers-nodejs.js": "./src/runtime/libp2p-pubsub-routers-browser.js",
      "./src/runtime/preload-nodejs.js": "./src/runtime/preload-browser.js",
      "./src/runtime/repo-nodejs.js": "./src/runtime/repo-browser.js",
      "./test/utils/create-repo-nodejs.js": "./test/utils/create-repo-browser.js",
      "ipfs-utils/src/files/glob-source": false
    },
    typesVersions: {
      "*": {
        "*": [
          "dist/*",
          "dist/*/index"
        ]
      }
    },
    repository: {
      type: "git",
      url: "git+https://github.com/ipfs/js-ipfs.git"
    },
    scripts: {
      lint: "aegir lint",
      prepare: "aegir build --no-bundle",
      build: "aegir build",
      test: "aegir test",
      "test:node": "aegir test -t node",
      "test:browser": "aegir test -t browser",
      "test:webworker": "aegir test -t webworker -- --timeout 10000",
      "test:electron-main": "aegir test -t electron-main",
      "test:electron-renderer": "aegir test -t electron-renderer",
      "test:bootstrapers": "IPFS_TEST=bootstrapers aegir test -t browser -f test/bootstrapers.js",
      coverage: "nyc --reporter=text --reporter=lcov npm run test:node",
      clean: "rimraf ./dist",
      "dep-check": "aegir dep-check -i interface-ipfs-core -i ipfs-core-types"
    },
    dependencies: {
      "array-shuffle": "^2.0.0",
      "bignumber.js": "^9.0.0",
      cbor: "^6.0.1",
      cids: "^1.1.5",
      "class-is": "^1.1.0",
      "dag-cbor-links": "^2.0.0",
      "datastore-core": "^3.0.0",
      "datastore-pubsub": "^0.4.1",
      debug: "^4.1.1",
      dlv: "^1.1.3",
      "err-code": "^2.0.3",
      "hamt-sharding": "^1.0.0",
      hashlru: "^2.3.0",
      "interface-datastore": "^3.0.3",
      "ipfs-bitswap": "^4.0.2",
      "ipfs-block-service": "^0.18.0",
      "ipfs-core-types": "^0.3.0",
      "ipfs-core-utils": "^0.7.0",
      "ipfs-repo": "^8.0.0",
      "ipfs-unixfs": "^2.0.3",
      "ipfs-unixfs-exporter": "^3.0.4",
      "ipfs-unixfs-importer": "^5.0.0",
      "ipfs-utils": "^6.0.0",
      ipld: "^0.28.0",
      "ipld-block": "^0.11.0",
      "ipld-dag-cbor": "^0.17.0",
      "ipld-dag-pb": "^0.20.0",
      "ipld-raw": "^6.0.0",
      ipns: "^0.8.0",
      "is-domain-name": "^1.0.1",
      "is-ipfs": "^2.0.0",
      "it-all": "^1.0.4",
      "it-first": "^1.0.4",
      "it-last": "^1.0.4",
      "it-pipe": "^1.1.0",
      libp2p: "^0.30.6",
      "libp2p-bootstrap": "^0.12.1",
      "libp2p-crypto": "^0.19.0",
      "libp2p-floodsub": "^0.24.1",
      "libp2p-gossipsub": "^0.8.0",
      "libp2p-kad-dht": "^0.20.1",
      "libp2p-mdns": "^0.15.0",
      "libp2p-mplex": "^0.10.0",
      "libp2p-noise": "^2.0.1",
      "libp2p-record": "^0.9.0",
      "libp2p-tcp": "^0.15.1",
      "libp2p-webrtc-star": "^0.21.0",
      "libp2p-websockets": "^0.15.0",
      mafmt: "^8.0.0",
      "merge-options": "^3.0.4",
      mortice: "^2.0.0",
      multiaddr: "^8.0.0",
      "multiaddr-to-uri": "^6.0.0",
      multibase: "^3.0.0",
      multicodec: "^2.0.1",
      "multihashing-async": "^2.0.1",
      "native-abort-controller": "~0.0.3",
      "p-queue": "^6.6.1",
      "parse-duration": "^0.4.4",
      "peer-id": "^0.14.1",
      "streaming-iterables": "^5.0.2",
      uint8arrays: "^2.0.5"
    },
    devDependencies: {
      aegir: "^30.3.0",
      delay: "^4.4.0",
      "go-ipfs": "0.8.0-rc2",
      "interface-ipfs-core": "^0.144.0",
      "ipfsd-ctl": "^7.2.0",
      "ipld-git": "^0.6.1",
      "iso-url": "^1.0.0",
      nanoid: "^3.1.12",
      rimraf: "^3.0.2",
      sinon: "^9.0.3"
    },
    gitHead: "91df29245562d5e9ff653e09b54cd2390538e64a"
  };
});

// node_modules/ipfs-core/src/components/version.js
var require_version = __commonJS((exports2, module2) => {
  "use strict";
  var pkg = require_package3();
  var withTimeoutOption = require_with_timeout_option();
  module2.exports = ({repo}) => {
    async function version(options) {
      const repoVersion = await repo.version.get(options);
      return {
        version: pkg.version,
        repo: repoVersion,
        commit: pkg.gitHead || "",
        "interface-ipfs-core": pkg.devDependencies["interface-ipfs-core"]
      };
    }
    return withTimeoutOption(version);
  };
});

// node_modules/ipfs-core/src/components/id.js
var require_id = __commonJS((exports2, module2) => {
  "use strict";
  var pkgversion = require_package3().version;
  var multiaddr = require_src11();
  var withTimeoutOption = require_with_timeout_option();
  var uint8ArrayToString = require_to_string5();
  module2.exports = ({peerId, network}) => {
    async function id(_options) {
      const id2 = peerId.toB58String();
      let addresses = [];
      let protocols = [];
      const net = network.try();
      if (net) {
        const {libp2p} = net;
        addresses = libp2p.multiaddrs;
        protocols = Array.from(libp2p.upgrader.protocols.keys());
      }
      return {
        id: id2,
        publicKey: uint8ArrayToString(peerId.pubKey.bytes, "base64pad"),
        addresses: addresses.map((ma) => {
          const str = ma.toString();
          if (str.endsWith(`/p2p/${id2}`)) {
            return str;
          }
          return `${str}/p2p/${id2}`;
        }).sort().map((ma) => multiaddr(ma)),
        agentVersion: `js-ipfs/${pkgversion}`,
        protocolVersion: "9000",
        protocols: protocols.sort()
      };
    }
    return withTimeoutOption(id);
  };
});

// node_modules/ipfs-core/src/components/config.js
var require_config2 = __commonJS((exports2, module2) => {
  "use strict";
  var getDefaultConfig = require_config_browser();
  var withTimeoutOption = require_with_timeout_option();
  var log = require_browser4()("ipfs:core:config");
  module2.exports = ({repo}) => {
    return {
      getAll: withTimeoutOption(getAll),
      get: withTimeoutOption(get),
      set: withTimeoutOption(set),
      replace: withTimeoutOption(replace),
      profiles: {
        apply: withTimeoutOption(applyProfile),
        list: withTimeoutOption(listProfiles)
      }
    };
    async function getAll(options = {}) {
      return repo.config.getAll(options);
    }
    async function get(key, options) {
      if (!key) {
        return Promise.reject(new Error("key argument is required"));
      }
      return repo.config.get(key, options);
    }
    async function set(key, value, options) {
      return repo.config.set(key, value, options);
    }
    async function replace(value, options) {
      return repo.config.replace(value, options);
    }
    async function applyProfile(profileName, options = {}) {
      const {dryRun} = options;
      const profile = profiles[profileName];
      if (!profile) {
        throw new Error(`No profile with name '${profileName}' exists`);
      }
      try {
        const oldCfg = await repo.config.getAll(options);
        let newCfg = JSON.parse(JSON.stringify(oldCfg));
        newCfg = profile.transform(newCfg);
        if (!dryRun) {
          await repo.config.replace(newCfg, options);
        }
        delete oldCfg.Identity.PrivKey;
        delete newCfg.Identity.PrivKey;
        return {original: oldCfg, updated: newCfg};
      } catch (err) {
        log(err);
        throw new Error(`Could not apply profile '${profileName}' to config: ${err.message}`);
      }
    }
  };
  async function listProfiles(_options) {
    return Object.keys(profiles).map((name) => ({
      name,
      description: profiles[name].description
    }));
  }
  var profiles = {
    server: {
      description: "Recommended for nodes with public IPv4 address (servers, VPSes, etc.), disables host and content discovery and UPnP in local networks.",
      transform: (config) => {
        config.Discovery.MDNS.Enabled = false;
        config.Discovery.webRTCStar.Enabled = false;
        config.Swarm = {
          ...config.Swarm || {},
          DisableNatPortMap: true
        };
        return config;
      }
    },
    "local-discovery": {
      description: "Sets default values to fields affected by `server` profile, enables discovery and UPnP in local networks.",
      transform: (config) => {
        config.Discovery.MDNS.Enabled = true;
        config.Discovery.webRTCStar.Enabled = true;
        config.Swarm = {
          ...config.Swarm || {},
          DisableNatPortMap: false
        };
        return config;
      }
    },
    test: {
      description: "Reduces external interference, useful for running ipfs in test environments. Note that with these settings node won't be able to talk to the rest of the network without manual bootstrap.",
      transform: (config) => {
        const defaultConfig = getDefaultConfig();
        config.Addresses.API = defaultConfig.Addresses.API ? "/ip4/127.0.0.1/tcp/0" : "";
        config.Addresses.Gateway = defaultConfig.Addresses.Gateway ? "/ip4/127.0.0.1/tcp/0" : "";
        config.Addresses.Swarm = defaultConfig.Addresses.Swarm.length ? ["/ip4/127.0.0.1/tcp/0"] : [];
        config.Addresses.Delegates = [];
        config.Bootstrap = [];
        config.Discovery.MDNS.Enabled = false;
        config.Discovery.webRTCStar.Enabled = false;
        config.Swarm = {
          ...config.Swarm || {},
          DisableNatPortMap: true
        };
        return config;
      }
    },
    "default-networking": {
      description: "Restores default network settings. Inverse profile of the `test` profile.",
      transform: (config) => {
        const defaultConfig = getDefaultConfig();
        config.Addresses.API = defaultConfig.Addresses.API;
        config.Addresses.Gateway = defaultConfig.Addresses.Gateway;
        config.Addresses.Swarm = defaultConfig.Addresses.Swarm;
        config.Addresses.Delegates = defaultConfig.Addresses.Delegates;
        config.Bootstrap = defaultConfig.Bootstrap;
        config.Discovery.MDNS.Enabled = defaultConfig.Discovery.MDNS.Enabled;
        config.Discovery.webRTCStar.Enabled = defaultConfig.Discovery.webRTCStar.Enabled;
        config.Swarm = {
          ...config.Swarm || {},
          DisableNatPortMap: false
        };
        return config;
      }
    },
    lowpower: {
      description: "Reduces daemon overhead on the system. May affect node functionality,performance of content discovery and data fetching may be degraded. Recommended for low power systems.",
      transform: (config) => {
        const Swarm = config.Swarm || {};
        const ConnMgr = Swarm.ConnMgr || {};
        ConnMgr.LowWater = 20;
        ConnMgr.HighWater = 40;
        Swarm.ConnMgr = ConnMgr;
        config.Swarm = Swarm;
        return config;
      }
    },
    "default-power": {
      description: 'Inverse of "lowpower" profile.',
      transform: (config) => {
        const defaultConfig = getDefaultConfig();
        config.Swarm = defaultConfig.Swarm;
        return config;
      }
    }
  };
  module2.exports.profiles = profiles;
});

// node_modules/ipfs-core/src/components/dag/get.js
var require_get3 = __commonJS((exports2, module2) => {
  "use strict";
  var withTimeoutOption = require_with_timeout_option();
  var first = require_it_first();
  var last = require_it_last();
  var toCidAndPath = require_to_cid_and_path();
  module2.exports = ({ipld, preload}) => {
    const get = async function get2(ipfsPath, options = {}) {
      const {
        cid,
        path
      } = toCidAndPath(ipfsPath);
      if (path) {
        options.path = path;
      }
      if (options.preload !== false) {
        preload(cid);
      }
      if (options.path) {
        const entry = options.localResolve ? await first(ipld.resolve(cid, options.path)) : await last(ipld.resolve(cid, options.path));
        const result = entry;
        return result;
      }
      return {
        value: await ipld.get(cid, options),
        remainderPath: ""
      };
    };
    return withTimeoutOption(get);
  };
});

// node_modules/ipfs-core/src/components/dag/resolve.js
var require_resolve3 = __commonJS((exports2, module2) => {
  "use strict";
  var CID = require_src7();
  var withTimeoutOption = require_with_timeout_option();
  var toCidAndPath = require_to_cid_and_path();
  module2.exports = ({ipld, preload}) => {
    async function resolve(ipfsPath, options = {}) {
      const {
        cid,
        path
      } = toCidAndPath(ipfsPath);
      if (options.preload !== false) {
        preload(cid);
      }
      if (path) {
        options.path = path;
      }
      let lastCid = cid;
      let lastRemainderPath = options.path || "";
      if (lastRemainderPath.startsWith("/")) {
        lastRemainderPath = lastRemainderPath.substring(1);
      }
      if (options.path) {
        try {
          for await (const {value, remainderPath} of ipld.resolve(cid, options.path, {
            signal: options.signal
          })) {
            if (!CID.isCID(value)) {
              break;
            }
            lastRemainderPath = remainderPath;
            lastCid = value;
          }
        } catch (err) {
          if (err.message.startsWith("Object has no property")) {
            err.message = `no link named "${lastRemainderPath.split("/")[0]}" under ${lastCid}`;
            err.code = "ERR_NO_LINK";
          }
          throw err;
        }
      }
      return {
        cid: lastCid,
        remainderPath: lastRemainderPath || ""
      };
    }
    return withTimeoutOption(resolve);
  };
});

// node_modules/ipfs-core/src/components/dag/tree.js
var require_tree = __commonJS((exports2, module2) => {
  "use strict";
  var withTimeoutOption = require_with_timeout_option();
  var toCidAndPath = require_to_cid_and_path();
  module2.exports = ({ipld, preload}) => {
    async function* tree(ipfsPath, options = {}) {
      const {
        cid,
        path
      } = toCidAndPath(ipfsPath);
      if (path) {
        options.path = path;
      }
      if (options.preload !== false) {
        preload(cid);
      }
      yield* ipld.tree(cid, options.path, options);
    }
    return withTimeoutOption(tree);
  };
});

// node_modules/ipfs-core/src/components/dag/put.js
var require_put2 = __commonJS((exports2, module2) => {
  "use strict";
  var multicodec = require_src6();
  var nameToCodec = (name) => multicodec[name.toUpperCase().replace(/-/g, "_")];
  var withTimeoutOption = require_with_timeout_option();
  module2.exports = ({ipld, pin, gcLock, preload}) => {
    async function put(dagNode, options = {}) {
      const {cidVersion, format, hashAlg} = readEncodingOptions(options);
      const release = options.pin ? await gcLock.readLock() : null;
      try {
        const cid = await ipld.put(dagNode, format, {
          hashAlg,
          cidVersion,
          signal: options.signal
        });
        if (options.pin) {
          await pin.add(cid, {
            lock: false
          });
        }
        if (options.preload !== false) {
          preload(cid);
        }
        return cid;
      } finally {
        if (release) {
          release();
        }
      }
    }
    return withTimeoutOption(put);
  };
  var readEncodingOptions = (options) => {
    if (options.cid && (options.format || options.hashAlg)) {
      throw new Error("Can't put dag node. Please provide either `cid` OR `format` and `hashAlg` options.");
    } else if (options.format && !options.hashAlg || !options.format && options.hashAlg) {
      throw new Error("Can't put dag node. Please provide `format` AND `hashAlg` options.");
    }
    const {hashAlg, format} = options.cid != null ? {format: options.cid.code, hashAlg: void 0} : encodingCodes({...defaultCIDOptions, ...options});
    const cidVersion = readVersion({...options, format, hashAlg});
    return {
      cidVersion,
      format,
      hashAlg
    };
  };
  var encodingCodes = ({format, hashAlg}) => ({
    format: typeof format === "string" ? nameToCodec(format) : format,
    hashAlg: typeof hashAlg === "string" ? nameToCodec(hashAlg) : hashAlg
  });
  var readVersion = ({version, cid, format, hashAlg}) => {
    if (typeof version === "number") {
      return version;
    } else if (cid) {
      return cid.version;
    } else if (format === multicodec.DAG_PB && hashAlg === multicodec.SHA2_256) {
      return 0;
    } else {
      return 1;
    }
  };
  var defaultCIDOptions = {
    format: multicodec.DAG_CBOR,
    hashAlg: multicodec.SHA2_256
  };
});

// node_modules/ipfs-core/src/components/dag/index.js
var require_dag = __commonJS((exports2, module2) => {
  "use strict";
  var createGet = require_get3();
  var createResolve = require_resolve3();
  var createTree = require_tree();
  var createPut = require_put2();
  var Reader = class {
    constructor(config) {
      this.get = createGet(config);
      this.resolve = createResolve(config);
      this.tree = createTree(config);
    }
  };
  var DagAPI = class {
    constructor({ipld, pin, preload, gcLock, dagReader}) {
      const {get, resolve, tree} = dagReader;
      const put = createPut({ipld, preload, pin, gcLock});
      this.get = get;
      this.resolve = resolve;
      this.tree = tree;
      this.put = put;
    }
    static reader(config) {
      return new Reader(config);
    }
  };
  module2.exports = DagAPI;
});

// node_modules/multiaddr-to-uri/index.js
var require_multiaddr_to_uri = __commonJS((exports2, module2) => {
  var Multiaddr = require_src11();
  var reduceValue = (_, v) => v;
  var tcpUri = (str, port, parts, opts) => {
    if (opts && opts.assumeHttp === false)
      return `tcp://${str}:${port}`;
    let protocol = "tcp";
    let explicitPort = `:${port}`;
    const last = parts[parts.length - 1];
    if (last.protocol === "tcp") {
      protocol = port === "443" ? "https" : "http";
      explicitPort = port === "443" || port === "80" ? "" : explicitPort;
    }
    return `${protocol}://${str}${explicitPort}`;
  };
  var Reducers = {
    ip4: reduceValue,
    ip6: (str, content, i, parts) => parts.length === 1 && parts[0].protocol === "ip6" ? content : `[${content}]`,
    tcp: (str, content, i, parts, opts) => parts.some((p) => ["http", "https", "ws", "wss"].includes(p.protocol)) ? `${str}:${content}` : tcpUri(str, content, parts, opts),
    udp: (str, content) => `udp://${str}:${content}`,
    dnsaddr: reduceValue,
    dns4: reduceValue,
    dns6: reduceValue,
    ipfs: (str, content) => `${str}/ipfs/${content}`,
    p2p: (str, content) => `${str}/p2p/${content}`,
    http: (str) => `http://${str}`,
    https: (str) => `https://${str}`,
    ws: (str) => `ws://${str}`,
    wss: (str) => `wss://${str}`,
    "p2p-websocket-star": (str) => `${str}/p2p-websocket-star`,
    "p2p-webrtc-star": (str) => `${str}/p2p-webrtc-star`,
    "p2p-webrtc-direct": (str) => `${str}/p2p-webrtc-direct`
  };
  module2.exports = (multiaddr, opts) => {
    const ma = Multiaddr(multiaddr);
    const parts = multiaddr.toString().split("/").slice(1);
    return ma.tuples().map((tuple) => ({
      protocol: parts.shift(),
      content: tuple[1] ? parts.shift() : null
    })).reduce((str, part, i, parts2) => {
      const reduce = Reducers[part.protocol];
      if (!reduce)
        throw new Error(`Unsupported protocol ${part.protocol}`);
      return reduce(str, part.content, i, parts2, opts);
    }, "");
  };
});

// node_modules/array-shuffle/index.js
var require_array_shuffle = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = (array) => {
    if (!Array.isArray(array)) {
      throw new TypeError(`Expected an array, got ${typeof array}`);
    }
    array = [...array];
    for (let index = array.length - 1; index > 0; index--) {
      const newIndex = Math.floor(Math.random() * (index + 1));
      [array[index], array[newIndex]] = [array[newIndex], array[index]];
    }
    return array;
  };
});

// node_modules/ipfs-core/src/runtime/preload-browser.js
var require_preload_browser = __commonJS((exports2, module2) => {
  "use strict";
  var {default: PQueue} = require_dist();
  var HTTP = require_http();
  var debug = require_browser4();
  var log = Object.assign(debug("ipfs:preload"), {
    error: debug("ipfs:preload:error")
  });
  var httpQueue = new PQueue({concurrency: 4});
  module2.exports = function preload(url, options = {}) {
    log(url);
    return httpQueue.add(async () => {
      const res = await HTTP.post(url, {signal: options.signal});
      const reader = res.body.getReader();
      try {
        while (true) {
          const {done} = await reader.read();
          if (done)
            return;
        }
      } finally {
        reader.releaseLock();
      }
    });
  };
});

// node_modules/ipfs-core/src/preload.js
var require_preload = __commonJS((exports2, module2) => {
  "use strict";
  var toUri = require_multiaddr_to_uri();
  var debug = require_browser4();
  var CID = require_src7();
  var shuffle = require_array_shuffle();
  var AbortController = require_src2();
  var preload = require_preload_browser();
  var hashlru = require_hashlru();
  var log = Object.assign(debug("ipfs:preload"), {error: debug("ipfs:preload:error")});
  var createPreloader = (options = {}) => {
    options.enabled = Boolean(options.enabled);
    options.addresses = options.addresses || [];
    options.cache = options.cache || 1e3;
    if (!options.enabled || !options.addresses.length) {
      log("preload disabled");
      const api2 = () => {
      };
      return Object.assign(api2, {
        start: () => {
        },
        stop: () => {
        }
      });
    }
    let stopped = true;
    let requests = [];
    const apiUris = options.addresses.map(toUri);
    const cache = hashlru(options.cache);
    const api = async (path) => {
      try {
        if (stopped)
          throw new Error(`preload ${path} but preloader is not started`);
        if (typeof path !== "string") {
          path = new CID(path).toString();
        }
        if (cache.has(path)) {
          return;
        }
        cache.set(path, true);
        const fallbackApiUris = shuffle(apiUris);
        let success = false;
        const now = Date.now();
        for (const uri of fallbackApiUris) {
          if (stopped)
            throw new Error(`preload aborted for ${path}`);
          let controller;
          try {
            controller = new AbortController();
            requests = requests.concat(controller);
            await preload(`${uri}/api/v0/refs?r=true&arg=${encodeURIComponent(path)}`, {signal: controller.signal});
            success = true;
          } catch (err) {
            if (err.type !== "aborted")
              log.error(err);
          } finally {
            requests = requests.filter((r) => r !== controller);
          }
          if (success)
            break;
        }
        log(`${success ? "" : "un"}successfully preloaded ${path} in ${Date.now() - now}ms`);
      } catch (err) {
        log.error(err);
      }
    };
    api.start = () => {
      stopped = false;
    };
    api.stop = () => {
      stopped = true;
      log(`aborting ${requests.length} pending preload request(s)`);
      requests.forEach((r) => r.abort());
      requests = [];
    };
    return api;
  };
  module2.exports = createPreloader;
});

// node_modules/ipfs-core/src/mfs-preload.js
var require_mfs_preload = __commonJS((exports2, module2) => {
  "use strict";
  var debug = require_browser4();
  var {cidToString} = require_cid();
  var log = Object.assign(debug("ipfs:mfs-preload"), {
    error: debug("ipfs:mfs-preload:error")
  });
  module2.exports = ({preload, files, options = {}}) => {
    options.interval = options.interval || 30 * 1e3;
    if (!options.enabled) {
      log("MFS preload disabled");
      const noop = async () => {
      };
      return {start: noop, stop: noop};
    }
    let rootCid, timeoutId;
    const preloadMfs = async () => {
      try {
        const stats = await files.stat("/");
        const nextRootCid = cidToString(stats.cid, {base: "base32"});
        if (rootCid !== nextRootCid) {
          log(`preloading updated MFS root ${rootCid} -> ${stats.cid}`);
          await preload(stats.cid);
          rootCid = nextRootCid;
        }
      } catch (err) {
        log.error("failed to preload MFS root", err);
      } finally {
        timeoutId = setTimeout(preloadMfs, options.interval);
      }
    };
    return {
      async start() {
        const stats = await files.stat("/");
        rootCid = cidToString(stats.cid, {base: "base32"});
        log(`monitoring MFS root ${stats.cid}`);
        timeoutId = setTimeout(preloadMfs, options.interval);
      },
      stop() {
        clearTimeout(timeoutId);
      }
    };
  };
});

// node_modules/shortid/lib/random/random-from-seed.js
var require_random_from_seed = __commonJS((exports2, module2) => {
  "use strict";
  var seed = 1;
  function getNextValue() {
    seed = (seed * 9301 + 49297) % 233280;
    return seed / 233280;
  }
  function setSeed(_seed_) {
    seed = _seed_;
  }
  module2.exports = {
    nextValue: getNextValue,
    seed: setSeed
  };
});

// node_modules/shortid/lib/alphabet.js
var require_alphabet = __commonJS((exports2, module2) => {
  "use strict";
  var randomFromSeed = require_random_from_seed();
  var ORIGINAL = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_-";
  var alphabet;
  var previousSeed;
  var shuffled;
  function reset() {
    shuffled = false;
  }
  function setCharacters(_alphabet_) {
    if (!_alphabet_) {
      if (alphabet !== ORIGINAL) {
        alphabet = ORIGINAL;
        reset();
      }
      return;
    }
    if (_alphabet_ === alphabet) {
      return;
    }
    if (_alphabet_.length !== ORIGINAL.length) {
      throw new Error("Custom alphabet for shortid must be " + ORIGINAL.length + " unique characters. You submitted " + _alphabet_.length + " characters: " + _alphabet_);
    }
    var unique = _alphabet_.split("").filter(function(item, ind, arr) {
      return ind !== arr.lastIndexOf(item);
    });
    if (unique.length) {
      throw new Error("Custom alphabet for shortid must be " + ORIGINAL.length + " unique characters. These characters were not unique: " + unique.join(", "));
    }
    alphabet = _alphabet_;
    reset();
  }
  function characters(_alphabet_) {
    setCharacters(_alphabet_);
    return alphabet;
  }
  function setSeed(seed) {
    randomFromSeed.seed(seed);
    if (previousSeed !== seed) {
      reset();
      previousSeed = seed;
    }
  }
  function shuffle() {
    if (!alphabet) {
      setCharacters(ORIGINAL);
    }
    var sourceArray = alphabet.split("");
    var targetArray = [];
    var r = randomFromSeed.nextValue();
    var characterIndex;
    while (sourceArray.length > 0) {
      r = randomFromSeed.nextValue();
      characterIndex = Math.floor(r * sourceArray.length);
      targetArray.push(sourceArray.splice(characterIndex, 1)[0]);
    }
    return targetArray.join("");
  }
  function getShuffled() {
    if (shuffled) {
      return shuffled;
    }
    shuffled = shuffle();
    return shuffled;
  }
  function lookup(index) {
    var alphabetShuffled = getShuffled();
    return alphabetShuffled[index];
  }
  function get() {
    return alphabet || ORIGINAL;
  }
  module2.exports = {
    get,
    characters,
    seed: setSeed,
    lookup,
    shuffled: getShuffled
  };
});

// node_modules/shortid/lib/random/random-byte-browser.js
var require_random_byte_browser = __commonJS((exports2, module2) => {
  "use strict";
  var crypto2 = typeof window === "object" && (window.crypto || window.msCrypto);
  var randomByte;
  if (!crypto2 || !crypto2.getRandomValues) {
    randomByte = function(size) {
      var bytes = [];
      for (var i = 0; i < size; i++) {
        bytes.push(Math.floor(Math.random() * 256));
      }
      return bytes;
    };
  } else {
    randomByte = function(size) {
      return crypto2.getRandomValues(new Uint8Array(size));
    };
  }
  module2.exports = randomByte;
});

// node_modules/shortid/node_modules/nanoid/format.browser.js
var require_format_browser = __commonJS((exports2, module2) => {
  module2.exports = function(random, alphabet, size) {
    var mask = (2 << Math.log(alphabet.length - 1) / Math.LN2) - 1;
    var step = -~(1.6 * mask * size / alphabet.length);
    var id = "";
    while (true) {
      var bytes = random(step);
      var i = step;
      while (i--) {
        id += alphabet[bytes[i] & mask] || "";
        if (id.length === +size)
          return id;
      }
    }
  };
});

// node_modules/shortid/lib/generate.js
var require_generate = __commonJS((exports2, module2) => {
  "use strict";
  var alphabet = require_alphabet();
  var random = require_random_byte_browser();
  var format = require_format_browser();
  function generate(number) {
    var loopCounter = 0;
    var done;
    var str = "";
    while (!done) {
      str = str + format(random, alphabet.get(), 1);
      done = number < Math.pow(16, loopCounter + 1);
      loopCounter++;
    }
    return str;
  }
  module2.exports = generate;
});

// node_modules/shortid/lib/build.js
var require_build = __commonJS((exports2, module2) => {
  "use strict";
  var generate = require_generate();
  var alphabet = require_alphabet();
  var REDUCE_TIME = 1567752802062;
  var version = 7;
  var counter;
  var previousSeconds;
  function build(clusterWorkerId) {
    var str = "";
    var seconds = Math.floor((Date.now() - REDUCE_TIME) * 1e-3);
    if (seconds === previousSeconds) {
      counter++;
    } else {
      counter = 0;
      previousSeconds = seconds;
    }
    str = str + generate(version);
    str = str + generate(clusterWorkerId);
    if (counter > 0) {
      str = str + generate(counter);
    }
    str = str + generate(seconds);
    return str;
  }
  module2.exports = build;
});

// node_modules/shortid/lib/is-valid.js
var require_is_valid = __commonJS((exports2, module2) => {
  "use strict";
  var alphabet = require_alphabet();
  function isShortId(id) {
    if (!id || typeof id !== "string" || id.length < 6) {
      return false;
    }
    var nonAlphabetic = new RegExp("[^" + alphabet.get().replace(/[|\\{}()[\]^$+*?.-]/g, "\\$&") + "]");
    return !nonAlphabetic.test(id);
  }
  module2.exports = isShortId;
});

// node_modules/shortid/lib/util/cluster-worker-id-browser.js
var require_cluster_worker_id_browser = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = 0;
});

// node_modules/shortid/lib/index.js
var require_lib3 = __commonJS((exports2, module2) => {
  "use strict";
  var alphabet = require_alphabet();
  var build = require_build();
  var isValid = require_is_valid();
  var clusterWorkerId = require_cluster_worker_id_browser() || 0;
  function seed(seedValue) {
    alphabet.seed(seedValue);
    return module2.exports;
  }
  function worker(workerId) {
    clusterWorkerId = workerId;
    return module2.exports;
  }
  function characters(newCharacters) {
    if (newCharacters !== void 0) {
      alphabet.characters(newCharacters);
    }
    return alphabet.shuffled();
  }
  function generate() {
    return build(clusterWorkerId);
  }
  module2.exports = generate;
  module2.exports.generate = generate;
  module2.exports.seed = seed;
  module2.exports.worker = worker;
  module2.exports.characters = characters;
  module2.exports.isValid = isValid;
});

// node_modules/shortid/index.js
var require_shortid = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = require_lib3();
});

// node_modules/mortice/lib/constants.js
var require_constants6 = __commonJS((exports2, module2) => {
  module2.exports = {
    WORKER_REQUEST_READ_LOCK: "lock:worker:request-read",
    WORKER_RELEASE_READ_LOCK: "lock:worker:release-read",
    MASTER_GRANT_READ_LOCK: "lock:master:grant-read",
    WORKER_REQUEST_WRITE_LOCK: "lock:worker:request-write",
    WORKER_RELEASE_WRITE_LOCK: "lock:worker:release-write",
    MASTER_GRANT_WRITE_LOCK: "lock:master:grant-write"
  };
});

// empty:cluster
var require_cluster = __commonJS(() => {
});

// node_modules/mortice/lib/node.js
var require_node2 = __commonJS((exports2, module2) => {
  var EventEmitter = require_events().EventEmitter;
  var shortid = require_shortid();
  var {
    WORKER_REQUEST_READ_LOCK,
    WORKER_RELEASE_READ_LOCK,
    MASTER_GRANT_READ_LOCK,
    WORKER_REQUEST_WRITE_LOCK,
    WORKER_RELEASE_WRITE_LOCK,
    MASTER_GRANT_WRITE_LOCK
  } = require_constants6();
  var cluster;
  var handleWorkerLockRequest = (emitter, masterEvent, requestType, releaseType, grantType) => {
    return (worker, requestEvent) => {
      if (requestEvent && requestEvent.type === requestType) {
        emitter.emit(masterEvent, requestEvent.name, () => {
          worker.send({
            type: grantType,
            name: requestEvent.name,
            identifier: requestEvent.identifier
          });
          return new Promise((resolve) => {
            const releaseEventListener = (releaseEvent) => {
              if (releaseEvent && releaseEvent.type === releaseType && releaseEvent.identifier === requestEvent.identifier) {
                worker.removeListener("message", releaseEventListener);
                resolve();
              }
            };
            worker.on("message", releaseEventListener);
          });
        });
      }
    };
  };
  var makeWorkerLockRequest = (name, requestType, grantType, releaseType) => {
    return () => {
      const id = shortid.generate();
      process.send({
        type: requestType,
        identifier: id,
        name
      });
      return new Promise((resolve) => {
        const listener = (event) => {
          if (event && event.type === grantType && event.identifier === id) {
            process.removeListener("message", listener);
            resolve(() => {
              process.send({
                type: releaseType,
                identifier: id,
                name
              });
            });
          }
        };
        process.on("message", listener);
      });
    };
  };
  module2.exports = (options) => {
    try {
      cluster = require_cluster();
      if (!Object.keys(cluster).length) {
        return;
      }
    } catch (_) {
      return;
    }
    if (cluster.isMaster || options.singleProcess) {
      const emitter = new EventEmitter();
      cluster.on("message", handleWorkerLockRequest(emitter, "requestReadLock", WORKER_REQUEST_READ_LOCK, WORKER_RELEASE_READ_LOCK, MASTER_GRANT_READ_LOCK));
      cluster.on("message", handleWorkerLockRequest(emitter, "requestWriteLock", WORKER_REQUEST_WRITE_LOCK, WORKER_RELEASE_WRITE_LOCK, MASTER_GRANT_WRITE_LOCK));
      return emitter;
    }
    return {
      isWorker: true,
      readLock: (name) => makeWorkerLockRequest(name, WORKER_REQUEST_READ_LOCK, MASTER_GRANT_READ_LOCK, WORKER_RELEASE_READ_LOCK),
      writeLock: (name) => makeWorkerLockRequest(name, WORKER_REQUEST_WRITE_LOCK, MASTER_GRANT_WRITE_LOCK, WORKER_RELEASE_WRITE_LOCK)
    };
  };
});

// node_modules/observable-webworkers/lib/index.js
var require_lib4 = __commonJS((exports2, module2) => {
  var events = {};
  var observable = (worker) => {
    worker.addEventListener("message", (event) => {
      observable.dispatchEvent("message", worker, event);
    });
    if (worker.port) {
      worker.port.addEventListener("message", (event) => {
        observable.dispatchEvent("message", worker, event);
      });
    }
  };
  observable.addEventListener = (type, fn) => {
    if (!events[type]) {
      events[type] = [];
    }
    events[type].push(fn);
  };
  observable.removeEventListener = (type, fn) => {
    if (!events[type]) {
      return;
    }
    events[type] = events[type].filter((listener) => listener === fn);
  };
  observable.dispatchEvent = function() {
    const args = Array.prototype.slice.call(arguments);
    const type = args.shift();
    if (!events[type]) {
      return;
    }
    events[type].forEach((fn) => fn.apply(null, args));
  };
  module2.exports = observable;
});

// node_modules/mortice/lib/browser.js
var require_browser6 = __commonJS((exports2, module2) => {
  var EventEmitter = require_events().EventEmitter;
  var shortid = require_shortid();
  var {
    WORKER_REQUEST_READ_LOCK,
    WORKER_RELEASE_READ_LOCK,
    MASTER_GRANT_READ_LOCK,
    WORKER_REQUEST_WRITE_LOCK,
    WORKER_RELEASE_WRITE_LOCK,
    MASTER_GRANT_WRITE_LOCK
  } = require_constants6();
  var observer = require_lib4();
  var globalThis2 = require_globalthis()();
  var handleWorkerLockRequest = (emitter, masterEvent, requestType, releaseType, grantType) => {
    return (worker, event) => {
      if (!event || !event.data || event.data.type !== requestType) {
        return;
      }
      const requestEvent = {
        type: event.data.type,
        name: event.data.name,
        identifier: event.data.identifier
      };
      emitter.emit(masterEvent, requestEvent.name, () => {
        worker.postMessage({
          type: grantType,
          name: requestEvent.name,
          identifier: requestEvent.identifier
        });
        return new Promise((resolve) => {
          const releaseEventListener = (event2) => {
            if (!event2 || !event2.data) {
              return;
            }
            const releaseEvent = {
              type: event2.data.type,
              name: event2.data.name,
              identifier: event2.data.identifier
            };
            if (releaseEvent && releaseEvent.type === releaseType && releaseEvent.identifier === requestEvent.identifier) {
              worker.removeEventListener("message", releaseEventListener);
              resolve();
            }
          };
          worker.addEventListener("message", releaseEventListener);
        });
      });
    };
  };
  var makeWorkerLockRequest = (name, requestType, grantType, releaseType) => {
    return () => {
      const id = shortid.generate();
      globalThis2.postMessage({
        type: requestType,
        identifier: id,
        name
      });
      return new Promise((resolve) => {
        const listener = (event) => {
          if (!event || !event.data) {
            return;
          }
          const responseEvent = {
            type: event.data.type,
            identifier: event.data.identifier
          };
          if (responseEvent && responseEvent.type === grantType && responseEvent.identifier === id) {
            globalThis2.removeEventListener("message", listener);
            resolve(() => {
              globalThis2.postMessage({
                type: releaseType,
                identifier: id,
                name
              });
            });
          }
        };
        globalThis2.addEventListener("message", listener);
      });
    };
  };
  var defaultOptions = {
    singleProcess: false
  };
  module2.exports = (options) => {
    options = Object.assign({}, defaultOptions, options);
    const isMaster = !!globalThis2.document || options.singleProcess;
    if (isMaster) {
      const emitter = new EventEmitter();
      observer.addEventListener("message", handleWorkerLockRequest(emitter, "requestReadLock", WORKER_REQUEST_READ_LOCK, WORKER_RELEASE_READ_LOCK, MASTER_GRANT_READ_LOCK));
      observer.addEventListener("message", handleWorkerLockRequest(emitter, "requestWriteLock", WORKER_REQUEST_WRITE_LOCK, WORKER_RELEASE_WRITE_LOCK, MASTER_GRANT_WRITE_LOCK));
      return emitter;
    }
    return {
      isWorker: true,
      readLock: (name) => makeWorkerLockRequest(name, WORKER_REQUEST_READ_LOCK, MASTER_GRANT_READ_LOCK, WORKER_RELEASE_READ_LOCK),
      writeLock: (name) => makeWorkerLockRequest(name, WORKER_REQUEST_WRITE_LOCK, MASTER_GRANT_WRITE_LOCK, WORKER_RELEASE_WRITE_LOCK)
    };
  };
});

// node_modules/promise-timeout/index.js
var require_promise_timeout = __commonJS((exports2, module2) => {
  "use strict";
  var TimeoutError;
  var timeout = module2.exports.timeout = function(promise, timeoutMillis) {
    var error = new TimeoutError(), timeout2;
    return Promise.race([
      promise,
      new Promise(function(resolve, reject) {
        timeout2 = setTimeout(function() {
          reject(error);
        }, timeoutMillis);
      })
    ]).then(function(v) {
      clearTimeout(timeout2);
      return v;
    }, function(err) {
      clearTimeout(timeout2);
      throw err;
    });
  };
  TimeoutError = module2.exports.TimeoutError = function() {
    Error.call(this);
    this.stack = Error().stack;
    this.message = "Timeout";
  };
  TimeoutError.prototype = Object.create(Error.prototype);
  TimeoutError.prototype.name = "TimeoutError";
});

// node_modules/mortice/lib/index.js
var require_lib5 = __commonJS((exports2, module2) => {
  var node = require_node2();
  var browser = require_browser6();
  var {default: Queue} = require_dist();
  var {timeout} = require_promise_timeout();
  var observe = require_lib4();
  var mutexes = {};
  var implementation;
  function createReleaseable(queue, options) {
    let res;
    const p = new Promise((resolve) => {
      res = resolve;
    });
    queue.add(() => timeout((() => {
      return new Promise((resolve) => {
        res(() => {
          resolve();
        });
      });
    })(), options.timeout));
    return p;
  }
  var createMutex = (name, options) => {
    if (implementation.isWorker) {
      return {
        readLock: implementation.readLock(name, options),
        writeLock: implementation.writeLock(name, options)
      };
    }
    const masterQueue = new Queue({concurrency: 1});
    let readQueue = null;
    return {
      readLock: () => {
        if (readQueue) {
          return createReleaseable(readQueue, options);
        }
        readQueue = new Queue({
          concurrency: options.concurrency,
          autoStart: false
        });
        const localReadQueue = readQueue;
        const readPromise = createReleaseable(readQueue, options);
        masterQueue.add(() => {
          localReadQueue.start();
          return localReadQueue.onIdle().then(() => {
            if (readQueue === localReadQueue) {
              readQueue = null;
            }
          });
        });
        return readPromise;
      },
      writeLock: () => {
        readQueue = null;
        return createReleaseable(masterQueue, options);
      }
    };
  };
  var defaultOptions = {
    concurrency: Infinity,
    timeout: 846e5,
    global,
    singleProcess: false
  };
  module2.exports = (name, options) => {
    if (!options) {
      options = {};
    }
    if (typeof name === "object") {
      options = name;
      name = "lock";
    }
    if (!name) {
      name = "lock";
    }
    options = Object.assign({}, defaultOptions, options);
    if (!implementation) {
      implementation = node(options) || browser(options);
      if (!implementation.isWorker) {
        implementation.on("requestReadLock", (name2, fn) => {
          if (!mutexes[name2]) {
            return;
          }
          mutexes[name2].readLock().then((release) => fn().finally(() => release()));
        });
        implementation.on("requestWriteLock", async (name2, fn) => {
          if (!mutexes[name2]) {
            return;
          }
          mutexes[name2].writeLock().then((release) => fn().finally(() => release()));
        });
      }
    }
    if (!mutexes[name]) {
      mutexes[name] = createMutex(name, options);
    }
    return mutexes[name];
  };
  module2.exports.Worker = function(script, Impl) {
    Impl = Impl || global.Worker;
    let worker;
    try {
      worker = new Impl(script);
    } catch (error) {
      if (error.message.includes("not a constructor")) {
        worker = Impl(script);
      }
    }
    if (!worker) {
      throw new Error("Could not create Worker from", Impl);
    }
    observe(worker);
    return worker;
  };
});

// node_modules/ipfs-core/src/components/files/utils/create-lock.js
var require_create_lock = __commonJS((exports2, module2) => {
  "use strict";
  var mortice = require_lib5();
  var lock;
  module2.exports = (repoOwner) => {
    if (lock) {
      return lock;
    }
    const mutex = mortice({
      singleProcess: repoOwner
    });
    lock = {
      readLock: (func) => {
        return async (...args) => {
          const releaseLock = await mutex.readLock();
          try {
            return await func.apply(null, args);
          } finally {
            releaseLock();
          }
        };
      },
      writeLock: (func) => {
        return async (...args) => {
          const releaseLock = await mutex.writeLock();
          try {
            return await func.apply(null, args);
          } finally {
            releaseLock();
          }
        };
      }
    };
    return lock;
  };
});

// node_modules/ipfs-core/src/components/files/utils/with-mfs-root.js
var require_with_mfs_root = __commonJS((exports2, module2) => {
  "use strict";
  var CID = require_src7();
  var UnixFs = require_src17();
  var {
    DAGNode
  } = require_src16();
  var log = require_browser4()("ipfs:mfs:utils:with-mfs-root");
  var mc = require_src6();
  var mh = require_src14().multihash;
  var errCode = require_err_code();
  var {
    MFS_ROOT_KEY
  } = require_utils7();
  var loadMfsRoot = async (context, options) => {
    if (options && options.signal && options.signal.aborted) {
      throw errCode(new Error("Request aborted"), "ERR_ABORTED", {name: "Aborted"});
    }
    await context.repo.datastore.open();
    let cid;
    try {
      const buf = await context.repo.datastore.get(MFS_ROOT_KEY);
      cid = new CID(buf);
    } catch (err) {
      if (err.code !== "ERR_NOT_FOUND") {
        throw err;
      }
      log("Creating new MFS root");
      const node = new DAGNode(new UnixFs({type: "directory"}).marshal());
      cid = await context.ipld.put(node, mc.DAG_PB, {
        cidVersion: 0,
        hashAlg: mh.names["sha2-256"]
      });
      if (options && options.signal && options.signal.aborted) {
        throw errCode(new Error("Request aborted"), "ERR_ABORTED", {name: "Aborted"});
      }
      await context.repo.datastore.put(MFS_ROOT_KEY, cid.bytes);
    }
    log(`Loaded MFS root /ipfs/${cid}`);
    return cid;
  };
  module2.exports = loadMfsRoot;
});

// node_modules/ipfs-core/src/components/files/utils/to-path-components.js
var require_to_path_components2 = __commonJS((exports2, module2) => {
  "use strict";
  var toPathComponents = (path = "") => {
    return (path.trim().match(/([^\\^/]|\\\/)+/g) || []).filter(Boolean);
  };
  module2.exports = toPathComponents;
});

// node_modules/ipfs-core/src/components/files/utils/to-mfs-path.js
var require_to_mfs_path = __commonJS((exports2, module2) => {
  "use strict";
  var loadMfsRoot = require_with_mfs_root();
  var toPathComponents = require_to_path_components2();
  var exporter = require_src30();
  var errCode = require_err_code();
  var CID = require_src7();
  var IPFS_PREFIX = "ipfs";
  var toMfsPath = async (context, path, options) => {
    const outputArray = Array.isArray(path);
    let paths = Array.isArray(path) ? path : [path];
    const root = await loadMfsRoot(context, options);
    paths = paths.map((path2) => {
      if (CID.isCID(path2)) {
        path2 = `/ipfs/${path2}`;
      }
      path2 = (path2 || "").trim();
      path2 = path2.replace(/(\/\/+)/g, "/");
      if (path2.endsWith("/") && path2.length > 1) {
        path2 = path2.substring(0, path2.length - 1);
      }
      if (!path2) {
        throw errCode(new Error("paths must not be empty"), "ERR_NO_PATH");
      }
      if (path2.substring(0, 1) !== "/") {
        throw errCode(new Error("paths must start with a leading slash"), "ERR_INVALID_PATH");
      }
      if (path2.substring(path2.length - 1) === "/") {
        path2 = path2.substring(0, path2.length - 1);
      }
      const pathComponents = toPathComponents(path2);
      if (pathComponents[0] === IPFS_PREFIX) {
        let mfsDirectory2;
        if (pathComponents.length === 2) {
          mfsDirectory2 = `/${pathComponents.join("/")}`;
        } else {
          mfsDirectory2 = `/${pathComponents.slice(0, pathComponents.length - 1).join("/")}`;
        }
        return {
          type: "ipfs",
          depth: pathComponents.length - 2,
          mfsPath: `/${pathComponents.join("/")}`,
          mfsDirectory: mfsDirectory2,
          parts: pathComponents,
          path: `/${pathComponents.join("/")}`,
          name: pathComponents[pathComponents.length - 1]
        };
      }
      const mfsPath = `/${IPFS_PREFIX}/${root}${pathComponents.length ? "/" + pathComponents.join("/") : ""}`;
      const mfsDirectory = `/${IPFS_PREFIX}/${root}/${pathComponents.slice(0, pathComponents.length - 1).join("/")}`;
      return {
        type: "mfs",
        depth: pathComponents.length,
        mfsDirectory,
        mfsPath,
        parts: pathComponents,
        path: `/${pathComponents.join("/")}`,
        name: pathComponents[pathComponents.length - 1]
      };
    });
    await Promise.all(paths.map(async (path2) => {
      const cidPath = path2.type === "mfs" ? path2.mfsPath : path2.path;
      try {
        const res = await exporter(cidPath, context.ipld);
        path2.cid = res.cid;
        path2.mfsPath = `/ipfs/${res.path}`;
        path2.unixfs = res.unixfs;
        path2.content = res.content;
      } catch (err) {
        if (err.code !== "ERR_NOT_FOUND") {
          throw err;
        }
      }
      path2.exists = Boolean(path2.cid);
    }));
    if (outputArray) {
      return paths;
    }
    return paths[0];
  };
  module2.exports = toMfsPath;
});

// node_modules/ipfs-core/src/components/files/stat.js
var require_stat3 = __commonJS((exports2, module2) => {
  "use strict";
  var mergeOptions = require_merge_options().bind({ignoreUndefined: true});
  var toMfsPath = require_to_mfs_path();
  var exporter = require_src30();
  var log = require_browser4()("ipfs:mfs:stat");
  var errCode = require_err_code();
  var withTimeoutOption = require_with_timeout_option();
  var defaultOptions = {
    withLocal: false,
    signal: void 0
  };
  module2.exports = (context) => {
    async function mfsStat(path, options) {
      options = mergeOptions(defaultOptions, options);
      log(`Fetching stats for ${path}`);
      const {
        type,
        cid,
        mfsPath
      } = await toMfsPath(context, path, options);
      const exportPath = type === "ipfs" && cid ? cid : mfsPath;
      let file;
      try {
        file = await exporter(exportPath, context.ipld);
      } catch (err) {
        if (err.code === "ERR_NOT_FOUND") {
          throw errCode(new Error(`${path} does not exist`), "ERR_NOT_FOUND");
        }
        throw err;
      }
      if (!statters[file.cid.codec]) {
        throw new Error(`Cannot stat codec ${file.cid.codec}`);
      }
      return statters[file.cid.codec](file);
    }
    return withTimeoutOption(mfsStat);
  };
  var statters = {
    raw: (file) => {
      return {
        cid: file.cid,
        size: file.node.length,
        cumulativeSize: file.node.length,
        blocks: 0,
        type: "file",
        local: void 0,
        sizeLocal: void 0,
        withLocality: false
      };
    },
    "dag-pb": (file) => {
      const blocks = file.node.Links.length;
      const size = file.node.size;
      const cumulativeSize = file.node.size;
      const output = {
        cid: file.cid,
        type: "file",
        size,
        cumulativeSize,
        blocks,
        local: void 0,
        sizeLocal: void 0,
        withLocality: false
      };
      if (file.unixfs) {
        output.size = file.unixfs.fileSize();
        if (file.unixfs.type === "hamt-sharded-directory") {
          output.type = "directory";
        } else {
          output.type = file.unixfs.type;
        }
        output.mode = file.unixfs.mode;
        if (file.unixfs.isDirectory()) {
          output.size = 0;
          output.cumulativeSize = file.node.size;
        }
        if (output.type === "file") {
          output.blocks = file.unixfs.blockSizes.length;
        }
        if (file.unixfs.mtime) {
          output.mtime = file.unixfs.mtime;
        }
      }
      return output;
    },
    "dag-cbor": (file) => {
      return {
        cid: file.cid,
        local: void 0,
        sizeLocal: void 0,
        withLocality: false
      };
    },
    identity: (file) => {
      return {
        cid: file.cid,
        size: file.node.digest.length,
        cumulativeSize: file.node.digest.length,
        blocks: 0,
        type: "file",
        local: void 0,
        sizeLocal: void 0,
        withLocality: false
      };
    }
  };
});

// node_modules/ipfs-core/src/components/files/utils/to-trail.js
var require_to_trail = __commonJS((exports2, module2) => {
  "use strict";
  var exporter = require_src30();
  var log = require_browser4()("ipfs:mfs:utils:to-trail");
  var toTrail = async (context, path) => {
    log(`Creating trail for path ${path}`);
    const output = [];
    for await (const fsEntry of exporter.path(path, context.ipld)) {
      output.push({
        name: fsEntry.name,
        cid: fsEntry.cid,
        size: fsEntry.node.size,
        type: fsEntry.unixfs ? fsEntry.unixfs.type : void 0
      });
    }
    return output;
  };
  module2.exports = toTrail;
});

// node_modules/ipfs-core/src/components/files/utils/hamt-utils.js
var require_hamt_utils = __commonJS((exports2, module2) => {
  "use strict";
  var {
    DAGNode
  } = require_src16();
  var Bucket = require_bucket();
  var DirSharded = require_dir_sharded();
  var log = require_browser4()("ipfs:mfs:core:utils:hamt-utils");
  var UnixFS = require_src17();
  var mc = require_src6();
  var mh = require_src14().multihash;
  var last = require_it_last();
  var updateHamtDirectory = async (context, links, bucket, options) => {
    const data = Uint8Array.from(bucket._children.bitField().reverse());
    const node = UnixFS.unmarshal(options.parent.Data);
    const dir = new UnixFS({
      type: "hamt-sharded-directory",
      data,
      fanout: bucket.tableSize(),
      hashType: DirSharded.hashFn.code,
      mode: node.mode,
      mtime: node.mtime
    });
    const hashAlg = mh.names[options.hashAlg];
    const parent = new DAGNode(dir.marshal(), links);
    const cid = await context.ipld.put(parent, mc.DAG_PB, {
      cidVersion: options.cidVersion,
      hashAlg,
      onlyHash: !options.flush
    });
    return {
      node: parent,
      cid,
      size: parent.size
    };
  };
  var recreateHamtLevel = async (links, rootBucket, parentBucket, positionAtParent) => {
    const bucket = new Bucket({
      hashFn: DirSharded.hashFn,
      hash: parentBucket ? parentBucket._options.hash : void 0
    }, parentBucket, positionAtParent);
    if (parentBucket) {
      parentBucket._putObjectAt(positionAtParent, bucket);
    }
    await addLinksToHamtBucket(links, bucket, rootBucket);
    return bucket;
  };
  var addLinksToHamtBucket = async (links, bucket, rootBucket) => {
    await Promise.all(links.map((link) => {
      if (link.Name.length === 2) {
        const pos = parseInt(link.Name, 16);
        bucket._putObjectAt(pos, new Bucket({
          hashFn: DirSharded.hashFn
        }, bucket, pos));
        return Promise.resolve();
      }
      return (rootBucket || bucket).put(link.Name.substring(2), {
        size: link.Tsize,
        cid: link.Hash
      });
    }));
  };
  var toPrefix = (position) => {
    return position.toString("16").toUpperCase().padStart(2, "0").substring(0, 2);
  };
  var generatePath = async (context, fileName, rootNode) => {
    const rootBucket = await recreateHamtLevel(rootNode.Links, null, null, null);
    const position = await rootBucket._findNewBucketAndPos(fileName);
    const path = [{
      bucket: position.bucket,
      prefix: toPrefix(position.pos)
    }];
    let currentBucket = position.bucket;
    while (currentBucket !== rootBucket) {
      path.push({
        bucket: currentBucket,
        prefix: toPrefix(currentBucket._posAtParent)
      });
      currentBucket = currentBucket._parent;
    }
    path.reverse();
    path[0].node = rootNode;
    for (let i = 0; i < path.length; i++) {
      const segment = path[i];
      const link = segment.node.Links.filter((link2) => link2.Name.substring(0, 2) === segment.prefix).pop();
      if (!link) {
        log(`Link ${segment.prefix}${fileName} will be added`);
        continue;
      }
      if (link.Name === `${segment.prefix}${fileName}`) {
        log(`Link ${segment.prefix}${fileName} will be replaced`);
        continue;
      }
      log(`Found subshard ${segment.prefix}`);
      const node = await context.ipld.get(link.Hash);
      if (!path[i + 1]) {
        log(`Loaded new subshard ${segment.prefix}`);
        await recreateHamtLevel(node.Links, rootBucket, segment.bucket, parseInt(segment.prefix, 16));
        const position2 = await rootBucket._findNewBucketAndPos(fileName);
        path.push({
          bucket: position2.bucket,
          prefix: toPrefix(position2.pos),
          node
        });
        continue;
      }
      const nextSegment = path[i + 1];
      await addLinksToHamtBucket(node.Links, nextSegment.bucket, rootBucket);
      nextSegment.node = node;
    }
    await rootBucket.put(fileName, true);
    path.reverse();
    return {
      rootBucket,
      path
    };
  };
  var createShard = async (context, contents, options) => {
    const shard = new DirSharded({
      root: true,
      dir: true,
      parent: null,
      parentKey: null,
      path: "",
      dirty: true,
      flat: false,
      mtime: options.mtime,
      mode: options.mode
    }, {
      ...options,
      codec: "dag-pb"
    });
    for (let i = 0; i < contents.length; i++) {
      await shard._bucket.put(contents[i].name, {
        size: contents[i].size,
        cid: contents[i].cid
      });
    }
    return last(shard.flush("", context.block, null));
  };
  module2.exports = {
    generatePath,
    updateHamtDirectory,
    recreateHamtLevel,
    addLinksToHamtBucket,
    toPrefix,
    createShard
  };
});

// node_modules/ipfs-core/src/components/files/utils/add-link.js
var require_add_link = __commonJS((exports2, module2) => {
  "use strict";
  var {
    DAGLink,
    DAGNode
  } = require_src16();
  var CID = require_src7();
  var log = require_browser4()("ipfs:mfs:core:utils:add-link");
  var UnixFS = require_src17();
  var DirSharded = require_dir_sharded();
  var {
    updateHamtDirectory,
    recreateHamtLevel,
    createShard,
    toPrefix,
    addLinksToHamtBucket
  } = require_hamt_utils();
  var errCode = require_err_code();
  var mc = require_src6();
  var mh = require_src14().multihash;
  var last = require_it_last();
  var addLink = async (context, options) => {
    if (!options.parentCid && !options.parent) {
      throw errCode(new Error("No parent node or CID passed to addLink"), "EINVALIDPARENT");
    }
    if (options.parentCid && !CID.isCID(options.parentCid)) {
      throw errCode(new Error("Invalid CID passed to addLink"), "EINVALIDPARENTCID");
    }
    if (!options.parent) {
      log(`Loading parent node ${options.parentCid}`);
      options.parent = await context.ipld.get(options.parentCid);
    }
    if (!options.cid) {
      throw errCode(new Error("No child cid passed to addLink"), "EINVALIDCHILDCID");
    }
    if (!options.name) {
      throw errCode(new Error("No child name passed to addLink"), "EINVALIDCHILDNAME");
    }
    if (!CID.isCID(options.cid)) {
      options.cid = new CID(options.cid);
    }
    if (!options.size && options.size !== 0) {
      throw errCode(new Error("No child size passed to addLink"), "EINVALIDCHILDSIZE");
    }
    const meta = UnixFS.unmarshal(options.parent.Data);
    if (meta.type === "hamt-sharded-directory") {
      log("Adding link to sharded directory");
      return addToShardedDirectory(context, options);
    }
    if (options.parent.Links.length >= options.shardSplitThreshold) {
      log("Converting directory to sharded directory");
      return convertToShardedDirectory(context, {
        ...options,
        mtime: meta.mtime,
        mode: meta.mode
      });
    }
    log(`Adding ${options.name} (${options.cid}) to regular directory`);
    return addToDirectory(context, options);
  };
  var convertToShardedDirectory = async (context, options) => {
    const result = await createShard(context, options.parent.Links.map((link) => ({
      name: link.Name,
      size: link.Tsize,
      cid: link.Hash
    })).concat({
      name: options.name,
      size: options.size,
      cid: options.cid
    }), options);
    log(`Converted directory to sharded directory ${result.cid}`);
    return result;
  };
  var addToDirectory = async (context, options) => {
    options.parent.rmLink(options.name);
    options.parent.addLink(new DAGLink(options.name, options.size, options.cid));
    const node = UnixFS.unmarshal(options.parent.Data);
    if (node.mtime) {
      node.mtime = new Date();
      options.parent = new DAGNode(node.marshal(), options.parent.Links);
    }
    const hashAlg = mh.names[options.hashAlg];
    const cid = await context.ipld.put(options.parent, mc.DAG_PB, {
      cidVersion: options.cidVersion,
      hashAlg,
      onlyHash: !options.flush
    });
    return {
      node: options.parent,
      cid,
      size: options.parent.size
    };
  };
  var addToShardedDirectory = async (context, options) => {
    const {
      shard,
      path
    } = await addFileToShardedDirectory(context, options);
    const result = await last(shard.flush("", context.block));
    const node = await context.ipld.get(result.cid);
    const oldLink = options.parent.Links.find((link) => link.Name.substring(0, 2) === path[0].prefix);
    const newLink = node.Links.find((link) => link.Name.substring(0, 2) === path[0].prefix);
    if (oldLink) {
      options.parent.rmLink(oldLink.Name);
    }
    options.parent.addLink(newLink);
    return updateHamtDirectory(context, options.parent.Links, path[0].bucket, options);
  };
  var addFileToShardedDirectory = async (context, options) => {
    const file = {
      name: options.name,
      cid: options.cid,
      size: options.size
    };
    const rootBucket = await recreateHamtLevel(options.parent.Links);
    const node = UnixFS.unmarshal(options.parent.Data);
    const shard = new DirSharded({
      root: true,
      dir: true,
      parent: null,
      parentKey: null,
      path: "",
      dirty: true,
      flat: false,
      mode: node.mode
    }, options);
    shard._bucket = rootBucket;
    if (node.mtime) {
      shard.mtime = new Date();
    }
    const position = await rootBucket._findNewBucketAndPos(file.name);
    const path = toBucketPath(position);
    path[0].node = options.parent;
    let index = 0;
    while (index < path.length) {
      const segment = path[index];
      index++;
      const node2 = segment.node;
      const link = node2.Links.find((link2) => link2.Name.substring(0, 2) === segment.prefix);
      if (!link) {
        log(`Link ${segment.prefix}${file.name} will be added`);
        index = path.length;
        break;
      }
      if (link.Name === `${segment.prefix}${file.name}`) {
        log(`Link ${segment.prefix}${file.name} will be replaced`);
        index = path.length;
        break;
      }
      if (link.Name.length > 2) {
        log(`Link ${link.Name} ${link.Hash} will be replaced with a subshard`);
        index = path.length;
        break;
      }
      log(`Found subshard ${segment.prefix}`);
      const subShard = await context.ipld.get(link.Hash);
      if (!path[index]) {
        log(`Loaded new subshard ${segment.prefix}`);
        await recreateHamtLevel(subShard.Links, rootBucket, segment.bucket, parseInt(segment.prefix, 16));
        const position2 = await rootBucket._findNewBucketAndPos(file.name);
        path.push({
          bucket: position2.bucket,
          prefix: toPrefix(position2.pos),
          node: subShard
        });
        break;
      }
      const nextSegment = path[index];
      await addLinksToHamtBucket(subShard.Links, nextSegment.bucket, rootBucket);
      nextSegment.node = subShard;
    }
    await shard._bucket.put(file.name, {
      size: file.size,
      cid: file.cid
    });
    return {
      shard,
      path
    };
  };
  var toBucketPath = (position) => {
    let bucket = position.bucket;
    let positionInBucket = position.pos;
    const path = [{
      bucket,
      prefix: toPrefix(positionInBucket)
    }];
    bucket = position.bucket._parent;
    positionInBucket = position.bucket._posAtParent;
    while (bucket) {
      path.push({
        bucket,
        prefix: toPrefix(positionInBucket)
      });
      positionInBucket = bucket._posAtParent;
      bucket = bucket._parent;
    }
    path.reverse();
    return path;
  };
  module2.exports = addLink;
});

// node_modules/ipfs-core/src/components/files/utils/update-tree.js
var require_update_tree = __commonJS((exports2, module2) => {
  "use strict";
  var log = require_browser4()("ipfs:mfs:utils:update-tree");
  var addLink = require_add_link();
  var defaultOptions = {
    shardSplitThreshold: 1e3
  };
  var updateTree = async (context, trail, options) => {
    options = Object.assign({}, defaultOptions, options);
    log("Trail", trail);
    trail = trail.slice().reverse();
    let index = 0;
    let child;
    for await (const node of context.ipld.getMany(trail.map((node2) => node2.cid))) {
      const cid2 = trail[index].cid;
      const name = trail[index].name;
      index++;
      if (!child) {
        child = {
          cid: cid2,
          name,
          size: node.size
        };
        continue;
      }
      const result = await addLink(context, {
        parent: node,
        name: child.name,
        cid: child.cid,
        size: child.size,
        flush: options.flush,
        shardSplitThreshold: options.shardSplitThreshold,
        hashAlg: options.hashAlg,
        cidVersion: options.cidVersion
      });
      child = {
        cid: result.cid,
        name,
        size: result.size
      };
    }
    const {cid} = child;
    log(`Final CID ${cid}`);
    return cid;
  };
  module2.exports = updateTree;
});

// node_modules/ipfs-core/src/components/files/utils/update-mfs-root.js
var require_update_mfs_root = __commonJS((exports2, module2) => {
  "use strict";
  var log = require_browser4()("ipfs:mfs:utils:update-mfs-root");
  var {
    MFS_ROOT_KEY
  } = require_utils7();
  var errCode = require_err_code();
  var updateMfsRoot = async (context, cid, options) => {
    if (options && options.signal && options.signal.aborted) {
      throw errCode(new Error("Request aborted"), "ERR_ABORTED", {name: "Aborted"});
    }
    log(`New MFS root will be ${cid}`);
    await context.repo.datastore.put(MFS_ROOT_KEY, cid.bytes);
    return cid;
  };
  module2.exports = updateMfsRoot;
});

// node_modules/ipfs-core/src/components/files/utils/create-node.js
var require_create_node = __commonJS((exports2, module2) => {
  "use strict";
  var UnixFS = require_src17();
  var {
    DAGNode
  } = require_src16();
  var mc = require_src6();
  var mh = require_src14().multihash;
  var createNode = async (context, type, options) => {
    const hashAlg = mh.names[options.hashAlg];
    const metadata = new UnixFS({
      type,
      mode: options.mode,
      mtime: options.mtime
    });
    const node = new DAGNode(metadata.marshal());
    const cid = await context.ipld.put(node, mc.DAG_PB, {
      cidVersion: options.cidVersion,
      hashAlg,
      onlyHash: !options.flush
    });
    return {
      cid,
      node
    };
  };
  module2.exports = createNode;
});

// node_modules/ipfs-core/src/components/files/mkdir.js
var require_mkdir = __commonJS((exports2, module2) => {
  "use strict";
  var errCode = require_err_code();
  var log = require_browser4()("ipfs:mfs:mkdir");
  var exporter = require_src30();
  var createNode = require_create_node();
  var toPathComponents = require_to_path_components2();
  var updateMfsRoot = require_update_mfs_root();
  var updateTree = require_update_tree();
  var addLink = require_add_link();
  var withMfsRoot = require_with_mfs_root();
  var mergeOptions = require_merge_options().bind({ignoreUndefined: true});
  var withTimeoutOption = require_with_timeout_option();
  var defaultOptions = {
    parents: false,
    hashAlg: "sha2-256",
    cidVersion: 0,
    shardSplitThreshold: 1e3,
    flush: true,
    mode: null,
    mtime: null,
    signal: void 0
  };
  module2.exports = (context) => {
    async function mfsMkdir(path, options = {}) {
      const opts = mergeOptions(defaultOptions, options);
      if (!path) {
        throw new Error("no path given to Mkdir");
      }
      path = path.trim();
      if (path === "/") {
        if (opts.parents) {
          return;
        }
        throw errCode(new Error("cannot create directory '/': Already exists"), "ERR_INVALID_PATH");
      }
      if (path.substring(0, 1) !== "/") {
        throw errCode(new Error("paths must start with a leading slash"), "ERR_INVALID_PATH");
      }
      log(`Creating ${path}`);
      const pathComponents = toPathComponents(path);
      if (pathComponents[0] === "ipfs") {
        throw errCode(new Error("path cannot have the prefix 'ipfs'"), "ERR_INVALID_PATH");
      }
      const root = await withMfsRoot(context, opts);
      let parent;
      const trail = [];
      const emptyDir = await createNode(context, "directory", opts);
      for (let i = 0; i <= pathComponents.length; i++) {
        const subPathComponents = pathComponents.slice(0, i);
        const subPath = `/ipfs/${root}/${subPathComponents.join("/")}`;
        try {
          parent = await exporter(subPath, context.ipld);
          log(`${subPath} existed`);
          log(`${subPath} had children ${parent.node.Links.map((link) => link.Name)}`);
          if (i === pathComponents.length) {
            if (opts.parents) {
              return;
            }
            throw errCode(new Error("file already exists"), "ERR_ALREADY_EXISTS");
          }
          trail.push({
            name: parent.name,
            cid: parent.cid
          });
        } catch (err) {
          if (err.code === "ERR_NOT_FOUND") {
            if (i < pathComponents.length && !opts.parents) {
              throw errCode(new Error(`Intermediate directory path ${subPath} does not exist, use the -p flag to create it`), "ERR_NOT_FOUND");
            }
            await addEmptyDir(context, subPathComponents[subPathComponents.length - 1], emptyDir, trail[trail.length - 1], trail, opts);
          } else {
            throw err;
          }
        }
      }
      const newRootCid = await updateTree(context, trail, opts);
      await updateMfsRoot(context, newRootCid, opts);
    }
    return withTimeoutOption(mfsMkdir);
  };
  var addEmptyDir = async (context, childName, emptyDir, parent, trail, options) => {
    log(`Adding empty dir called ${childName} to ${parent.cid}`);
    const result = await addLink(context, {
      parent: parent.node,
      parentCid: parent.cid,
      size: emptyDir.node.size,
      cid: emptyDir.cid,
      name: childName,
      hashAlg: options.hashAlg,
      cidVersion: options.cidVersion,
      flush: options.flush
    });
    trail[trail.length - 1].cid = result.cid;
    trail.push({
      name: childName,
      cid: emptyDir.cid
    });
  };
});

// node_modules/ipfs-core/src/components/files/utils/to-sources.js
var require_to_sources = __commonJS((exports2, module2) => {
  "use strict";
  var toMfsPath = require_to_mfs_path();
  var mergeOptions = require_merge_options().bind({ignoreUndefined: true});
  async function toSources(context, args, defaultOptions) {
    const sources = [];
    let options;
    for (let i = 0; i < args.length; i++) {
      if (typeof args[i] === "string" || args[i] instanceof String) {
        sources.push(args[i].trim());
      } else if (i === args.length - 1) {
        options = args[i];
      }
    }
    options = mergeOptions(defaultOptions, options);
    return {
      sources: await toMfsPath(context, sources, options),
      options
    };
  }
  module2.exports = toSources;
});

// node_modules/ipfs-core/src/components/files/utils/to-sources-and-destination.js
var require_to_sources_and_destination = __commonJS((exports2, module2) => {
  "use strict";
  var toSources = require_to_sources();
  async function toSourcesAndDestination(context, args, defaultOptions) {
    const {
      sources,
      options
    } = await toSources(context, args, defaultOptions);
    const destination = sources.pop();
    return {
      destination,
      sources,
      options
    };
  }
  module2.exports = toSourcesAndDestination;
});

// node_modules/ipfs-core/src/components/files/cp.js
var require_cp = __commonJS((exports2, module2) => {
  "use strict";
  var mkdir = require_mkdir();
  var stat = require_stat3();
  var log = require_browser4()("ipfs:mfs:cp");
  var errCode = require_err_code();
  var updateTree = require_update_tree();
  var updateMfsRoot = require_update_mfs_root();
  var addLink = require_add_link();
  var toMfsPath = require_to_mfs_path();
  var toSourcesAndDestination = require_to_sources_and_destination();
  var toTrail = require_to_trail();
  var withTimeoutOption = require_with_timeout_option();
  var defaultOptions = {
    parents: false,
    flush: true,
    hashAlg: "sha2-256",
    cidVersion: 0,
    shardSplitThreshold: 1e3,
    signal: void 0
  };
  module2.exports = function derp(context) {
    async function mfsCp(...args) {
      let {
        sources,
        destination,
        options
      } = await toSourcesAndDestination(context, args, defaultOptions);
      if (!sources.length) {
        throw errCode(new Error("Please supply at least one source"), "ERR_INVALID_PARAMS");
      }
      options.parents = options.p || options.parents;
      const missing = sources.find((source) => !source.exists);
      if (missing) {
        throw errCode(new Error(`${missing.path} does not exist`), "ERR_INVALID_PARAMS");
      }
      const destinationIsDirectory = isDirectory(destination);
      if (destination.exists) {
        log("Destination exists");
        if (sources.length === 1 && !destinationIsDirectory) {
          throw errCode(new Error("directory already has entry by that name"), "ERR_ALREADY_EXISTS");
        }
      } else {
        log("Destination does not exist");
        if (sources.length > 1) {
          if (!options.parents) {
            throw errCode(new Error("destination did not exist, pass -p to create intermediate directories"), "ERR_INVALID_PARAMS");
          }
          await mkdir(context)(destination.path, options);
          destination = await toMfsPath(context, destination.path, options);
        } else if (destination.parts.length > 1) {
          const parentFolder = `/${destination.parts.slice(0, -1).join("/")}`;
          try {
            await stat(context)(parentFolder, options);
          } catch (err) {
            if (err.code !== "ERR_NOT_FOUND") {
              throw err;
            }
            if (!options.parents) {
              throw errCode(new Error("destination did not exist, pass -p to create intermediate directories"), "ERR_INVALID_PARAMS");
            }
            await mkdir(context)(parentFolder, options);
            destination = await toMfsPath(context, destination.path, options);
          }
        }
      }
      const destinationPath = isDirectory(destination) ? destination.mfsPath : destination.mfsDirectory;
      const trail = await toTrail(context, destinationPath);
      if (sources.length === 1) {
        const source = sources.pop();
        const destinationName = destinationIsDirectory ? source.name : destination.name;
        log(`Only one source, copying to destination ${destinationIsDirectory ? "directory" : "file"} ${destinationName}`);
        return copyToFile(context, source, destinationName, trail, options);
      }
      log("Multiple sources, wrapping in a directory");
      return copyToDirectory(context, sources, destination, trail, options);
    }
    return withTimeoutOption(mfsCp);
  };
  var isDirectory = (destination) => {
    return destination.unixfs && destination.unixfs.type && destination.unixfs.type.includes("directory");
  };
  var copyToFile = async (context, source, destination, destinationTrail, options) => {
    let parent = destinationTrail.pop();
    parent = await addSourceToParent(context, source, destination, parent, options);
    destinationTrail.push(parent);
    const newRootCid = await updateTree(context, destinationTrail, options);
    await updateMfsRoot(context, newRootCid, options);
  };
  var copyToDirectory = async (context, sources, destination, destinationTrail, options) => {
    for (let i = 0; i < sources.length; i++) {
      const source = sources[i];
      destination = await addSourceToParent(context, source, source.name, destination, options);
    }
    destinationTrail[destinationTrail.length - 1] = destination;
    const newRootCid = await updateTree(context, destinationTrail, options);
    await updateMfsRoot(context, newRootCid, options);
  };
  var addSourceToParent = async (context, source, childName, parent, options) => {
    const sourceBlock = await context.repo.blocks.get(source.cid);
    const {
      node,
      cid
    } = await addLink(context, {
      parentCid: parent.cid,
      size: sourceBlock.data.length,
      cid: source.cid,
      name: childName,
      hashAlg: options.hashAlg,
      cidVersion: options.cidVersion,
      flush: options.flush
    });
    parent.node = node;
    parent.cid = cid;
    parent.size = node.size;
    return parent;
  };
});

// node_modules/ipfs-core/src/components/files/utils/remove-link.js
var require_remove_link = __commonJS((exports2, module2) => {
  "use strict";
  var {
    DAGNode,
    DAGLink
  } = require_src16();
  var CID = require_src7();
  var log = require_browser4()("ipfs:mfs:core:utils:remove-link");
  var UnixFS = require_src17();
  var {
    generatePath,
    updateHamtDirectory
  } = require_hamt_utils();
  var errCode = require_err_code();
  var mc = require_src6();
  var mh = require_src14().multihash;
  var removeLink = async (context, options) => {
    if (!options.parentCid && !options.parent) {
      throw errCode(new Error("No parent node or CID passed to removeLink"), "EINVALIDPARENT");
    }
    if (options.parentCid && !CID.isCID(options.parentCid)) {
      throw errCode(new Error("Invalid CID passed to removeLink"), "EINVALIDPARENTCID");
    }
    if (!options.parent) {
      log(`Loading parent node ${options.parentCid}`);
      options.parent = await context.ipld.get(options.parentCid);
    }
    if (!options.name) {
      throw errCode(new Error("No child name passed to removeLink"), "EINVALIDCHILDNAME");
    }
    const meta = UnixFS.unmarshal(options.parent.Data);
    if (meta.type === "hamt-sharded-directory") {
      log(`Removing ${options.name} from sharded directory`);
      return removeFromShardedDirectory(context, options);
    }
    log(`Removing link ${options.name} regular directory`);
    return removeFromDirectory(context, options);
  };
  var removeFromDirectory = async (context, options) => {
    const hashAlg = mh.names[options.hashAlg];
    options.parent.rmLink(options.name);
    const cid = await context.ipld.put(options.parent, mc.DAG_PB, {
      cidVersion: options.cidVersion,
      hashAlg
    });
    log(`Updated regular directory ${cid}`);
    return {
      node: options.parent,
      cid
    };
  };
  var removeFromShardedDirectory = async (context, options) => {
    const {
      rootBucket,
      path
    } = await generatePath(context, options.name, options.parent);
    await rootBucket.del(options.name);
    const {
      node
    } = await updateShard(context, path, {
      name: options.name,
      cid: options.cid,
      size: options.size,
      hashAlg: options.hashAlg,
      cidVersion: options.cidVersion,
      flush: options.flush
    }, options);
    return updateHamtDirectory(context, node.Links, rootBucket, options);
  };
  var updateShard = async (context, positions, child, options) => {
    const {
      bucket,
      prefix,
      node
    } = positions.pop();
    const link = node.Links.find((link2) => link2.Name.substring(0, 2) === prefix);
    if (!link) {
      throw errCode(new Error(`No link found with prefix ${prefix} for file ${child.name}`), "ERR_NOT_FOUND");
    }
    if (link.Name === `${prefix}${child.name}`) {
      log(`Removing existing link ${link.Name}`);
      node.rmLink(link.Name);
      await bucket.del(child.name);
      return updateHamtDirectory(context, node.Links, bucket, options);
    }
    log(`Descending into sub-shard ${link.Name} for ${prefix}${child.name}`);
    const result = await updateShard(context, positions, child, options);
    let newName = prefix;
    if (result.node.Links.length === 1) {
      log(`Removing subshard for ${prefix}`);
      result.cid = result.node.Links[0].Hash;
      result.node = result.node.Links[0];
      newName = `${prefix}${result.node.Name.substring(2)}`;
    }
    log(`Updating shard ${prefix} with name ${newName}`);
    const size = DAGNode.isDAGNode(result.node) ? result.node.size : result.node.Tsize;
    return updateShardParent(context, bucket, node, prefix, newName, size, result.cid, options);
  };
  var updateShardParent = (context, bucket, parent, oldName, newName, size, cid, options) => {
    parent.rmLink(oldName);
    parent.addLink(new DAGLink(newName, size, cid));
    return updateHamtDirectory(context, parent.Links, bucket, options);
  };
  module2.exports = removeLink;
});

// node_modules/ipfs-core/src/components/files/rm.js
var require_rm4 = __commonJS((exports2, module2) => {
  "use strict";
  var errCode = require_err_code();
  var updateTree = require_update_tree();
  var updateMfsRoot = require_update_mfs_root();
  var toSources = require_to_sources();
  var removeLink = require_remove_link();
  var toMfsPath = require_to_mfs_path();
  var toTrail = require_to_trail();
  var withTimeoutOption = require_with_timeout_option();
  var defaultOptions = {
    recursive: false,
    cidVersion: 0,
    hashAlg: "sha2-256",
    flush: true,
    signal: void 0
  };
  module2.exports = (context) => {
    async function mfsRm(...args) {
      const {
        sources,
        options
      } = await toSources(context, args, defaultOptions);
      if (!sources.length) {
        throw errCode(new Error("Please supply at least one path to remove"), "ERR_INVALID_PARAMS");
      }
      sources.forEach((source) => {
        if (source.path === "/") {
          throw errCode(new Error("Cannot delete root"), "ERR_INVALID_PARAMS");
        }
      });
      for (const source of sources) {
        await removePath(context, source.path, options);
      }
    }
    return withTimeoutOption(mfsRm);
  };
  var removePath = async (context, path, options) => {
    const mfsPath = await toMfsPath(context, path, options);
    const trail = await toTrail(context, mfsPath.mfsPath);
    const child = trail[trail.length - 1];
    trail.pop();
    const parent = trail[trail.length - 1];
    if (!parent) {
      throw errCode(new Error(`${path} does not exist`), "ERR_NOT_FOUND");
    }
    if (child.type === "directory" && !options.recursive) {
      throw errCode(new Error(`${path} is a directory, use -r to remove directories`), "ERR_WAS_DIR");
    }
    const {
      cid
    } = await removeLink(context, {
      parentCid: parent.cid,
      name: child.name,
      hashAlg: options.hashAlg,
      cidVersion: options.cidVersion,
      flush: options.flush
    });
    parent.cid = cid;
    const newRootCid = await updateTree(context, trail, options);
    await updateMfsRoot(context, newRootCid, options);
  };
});

// node_modules/ipfs-core/src/components/files/chmod.js
var require_chmod = __commonJS((exports2, module2) => {
  "use strict";
  var mergeOptions = require_merge_options().bind({ignoreUndefined: true});
  var toMfsPath = require_to_mfs_path();
  var log = require_browser4()("ipfs:mfs:touch");
  var errCode = require_err_code();
  var UnixFS = require_src17();
  var toTrail = require_to_trail();
  var addLink = require_add_link();
  var updateTree = require_update_tree();
  var updateMfsRoot = require_update_mfs_root();
  var {DAGNode} = require_src16();
  var mc = require_src6();
  var mh = require_src14().multihash;
  var {pipe} = require_it_pipe();
  var importer = require_src29();
  var exporter = require_src30();
  var last = require_it_last();
  var cp = require_cp();
  var rm = require_rm4();
  var persist = require_persist();
  var withTimeoutOption = require_with_timeout_option();
  var defaultOptions = {
    flush: true,
    shardSplitThreshold: 1e3,
    hashAlg: "sha2-256",
    cidVersion: 0,
    recursive: false,
    signal: void 0
  };
  function calculateModification(mode, originalMode, isDirectory) {
    let modification = 0;
    if (mode.includes("x") || mode.includes("X") && (isDirectory || (originalMode & 1 || originalMode & 8 || originalMode & 64))) {
      modification += 1;
    }
    if (mode.includes("w")) {
      modification += 2;
    }
    if (mode.includes("r")) {
      modification += 4;
    }
    return modification;
  }
  function calculateUGO(references, modification) {
    let ugo = 0;
    if (references.includes("u")) {
      ugo += modification << 6;
    }
    if (references.includes("g")) {
      ugo += modification << 3;
    }
    if (references.includes("o")) {
      ugo += modification;
    }
    return ugo;
  }
  function calculateSpecial(references, mode, modification) {
    if (mode.includes("t")) {
      modification += parseInt("1000", 8);
    }
    if (mode.includes("s")) {
      if (references.includes("u")) {
        modification += parseInt("4000", 8);
      }
      if (references.includes("g")) {
        modification += parseInt("2000", 8);
      }
    }
    return modification;
  }
  function parseSymbolicMode(input, originalMode, isDirectory) {
    if (!originalMode) {
      originalMode = 0;
    }
    const match = input.match(/^(u?g?o?a?)(-?\+?=?)?(r?w?x?X?s?t?)$/);
    if (!match) {
      throw new Error(`Invalid file mode: ${input}`);
    }
    let [
      ,
      references,
      operator,
      mode
    ] = match;
    if (references === "a" || !references) {
      references = "ugo";
    }
    let modification = calculateModification(mode, originalMode, isDirectory);
    modification = calculateUGO(references, modification);
    modification = calculateSpecial(references, mode, modification);
    if (operator === "=") {
      if (references.includes("u")) {
        originalMode = originalMode & parseInt("7077", 8);
        originalMode = originalMode | modification;
      }
      if (references.includes("g")) {
        originalMode = originalMode & parseInt("7707", 8);
        originalMode = originalMode | modification;
      }
      if (references.includes("o")) {
        originalMode = originalMode & parseInt("7770", 8);
        originalMode = originalMode | modification;
      }
      return originalMode;
    }
    if (operator === "+") {
      return modification | originalMode;
    }
    if (operator === "-") {
      return modification ^ originalMode;
    }
  }
  function calculateMode(mode, metadata) {
    if (mode instanceof String) {
      mode = mode.toString();
    }
    if (typeof mode === "string") {
      if (mode.match(/^\d+$/g)) {
        mode = parseInt(mode, 8);
      } else {
        mode = mode.split(",").reduce((curr, acc) => {
          return parseSymbolicMode(acc, curr, metadata.isDirectory());
        }, metadata.mode);
      }
    }
    return mode;
  }
  module2.exports = (context) => {
    async function mfsChmod(path, mode, options = {}) {
      const opts = mergeOptions(defaultOptions, options);
      log(`Fetching stats for ${path}`);
      const {
        cid,
        mfsDirectory,
        name
      } = await toMfsPath(context, path, opts);
      if (cid.codec !== "dag-pb") {
        throw errCode(new Error(`${path} was not a UnixFS node`), "ERR_NOT_UNIXFS");
      }
      if (opts.recursive) {
        const root = await pipe(async function* () {
          for await (const entry of exporter.recursive(cid, context.ipld)) {
            let node2 = await context.ipld.get(entry.cid);
            entry.unixfs.mode = calculateMode(mode, entry.unixfs);
            node2 = new DAGNode(entry.unixfs.marshal(), node2.Links);
            yield {
              path: entry.path,
              content: node2
            };
          }
        }, (source) => importer(source, context.block, {
          ...opts,
          pin: false,
          dagBuilder: async function* (source2, block, opts2) {
            for await (const entry of source2) {
              yield async function() {
                const cid2 = await persist(entry.content.serialize(), block, opts2);
                return {
                  cid: cid2,
                  path: entry.path,
                  unixfs: UnixFS.unmarshal(entry.content.Data),
                  node: entry.content
                };
              };
            }
          }
        }), (nodes) => last(nodes));
        await rm(context)(path, opts);
        await cp(context)(`/ipfs/${root.cid}`, path, opts);
        return;
      }
      let node = await context.ipld.get(cid);
      const metadata = UnixFS.unmarshal(node.Data);
      metadata.mode = calculateMode(mode, metadata);
      node = new DAGNode(metadata.marshal(), node.Links);
      const updatedCid = await context.ipld.put(node, mc.DAG_PB, {
        cidVersion: cid.version,
        hashAlg: mh.names[opts.hashAlg || defaultOptions.hashAlg],
        onlyHash: !opts.flush
      });
      const trail = await toTrail(context, mfsDirectory);
      const parent = trail[trail.length - 1];
      const parentNode = await context.ipld.get(parent.cid);
      const result = await addLink(context, {
        parent: parentNode,
        name,
        cid: updatedCid,
        size: node.serialize().length,
        flush: opts.flush,
        hashAlg: opts.hashAlg,
        cidVersion: cid.version
      });
      parent.cid = result.cid;
      const newRootCid = await updateTree(context, trail, opts);
      await updateMfsRoot(context, newRootCid, opts);
    }
    return withTimeoutOption(mfsChmod);
  };
});

// node_modules/ipfs-core/src/components/files/flush.js
var require_flush = __commonJS((exports2, module2) => {
  "use strict";
  var stat = require_stat3();
  var withTimeoutOption = require_with_timeout_option();
  var mergeOptions = require_merge_options().bind({ignoreUndefined: true});
  var defaultOptions = {
    timeout: void 0,
    signal: void 0
  };
  module2.exports = (context) => {
    async function mfsFlush(path, options = {}) {
      options = mergeOptions(defaultOptions, options);
      const {cid} = await stat(context)(path, options);
      return cid;
    }
    return withTimeoutOption(mfsFlush);
  };
});

// node_modules/ipfs-core/src/components/files/mv.js
var require_mv = __commonJS((exports2, module2) => {
  "use strict";
  var toSources = require_to_sources();
  var cp = require_cp();
  var rm = require_rm4();
  var withTimeoutOption = require_with_timeout_option();
  var defaultOptions = {
    parents: false,
    recursive: false,
    flush: true,
    cidVersion: 0,
    hashAlg: "sha2-256",
    shardSplitThreshold: 1e3,
    signal: void 0
  };
  module2.exports = (context) => {
    async function mfsMv(...args) {
      const {
        sources,
        options
      } = await toSources(context, args, defaultOptions);
      const cpArgs = sources.map((source) => source.path).concat(options);
      const rmArgs = sources.slice(0, -1).map((source) => source.path).concat(Object.assign(options, {
        recursive: true
      }));
      await cp(context).apply(null, cpArgs);
      await rm(context).apply(null, rmArgs);
    }
    return withTimeoutOption(mfsMv);
  };
});

// node_modules/ipfs-core/src/components/files/touch.js
var require_touch = __commonJS((exports2, module2) => {
  "use strict";
  var mergeOptions = require_merge_options().bind({ignoreUndefined: true});
  var toMfsPath = require_to_mfs_path();
  var log = require_browser4()("ipfs:mfs:touch");
  var errCode = require_err_code();
  var UnixFS = require_src17();
  var toTrail = require_to_trail();
  var addLink = require_add_link();
  var updateTree = require_update_tree();
  var updateMfsRoot = require_update_mfs_root();
  var {DAGNode} = require_src16();
  var mc = require_src6();
  var mh = require_src14().multihash;
  var withTimeoutOption = require_with_timeout_option();
  var defaultOptions = {
    mtime: void 0,
    flush: true,
    shardSplitThreshold: 1e3,
    cidVersion: 0,
    hashAlg: "sha2-256",
    signal: void 0
  };
  module2.exports = (context) => {
    async function mfsTouch(path, options = {}) {
      const settings = mergeOptions(defaultOptions, options);
      settings.mtime = settings.mtime || new Date();
      log(`Touching ${path} mtime: ${settings.mtime}`);
      const {
        cid,
        mfsDirectory,
        name,
        exists
      } = await toMfsPath(context, path, settings);
      let node;
      let updatedCid;
      let cidVersion = settings.cidVersion;
      if (!exists) {
        const metadata = new UnixFS({
          type: "file",
          mtime: settings.mtime
        });
        node = new DAGNode(metadata.marshal());
        updatedCid = await context.ipld.put(node, mc.DAG_PB, {
          cidVersion: settings.cidVersion,
          hashAlg: mh.names["sha2-256"],
          onlyHash: !settings.flush
        });
      } else {
        if (cid.codec !== "dag-pb") {
          throw errCode(new Error(`${path} was not a UnixFS node`), "ERR_NOT_UNIXFS");
        }
        cidVersion = cid.version;
        node = await context.ipld.get(cid);
        const metadata = UnixFS.unmarshal(node.Data);
        metadata.mtime = settings.mtime;
        node = new DAGNode(metadata.marshal(), node.Links);
        updatedCid = await context.ipld.put(node, mc.DAG_PB, {
          cidVersion: cid.version,
          hashAlg: mh.names["sha2-256"],
          onlyHash: !settings.flush
        });
      }
      const trail = await toTrail(context, mfsDirectory);
      const parent = trail[trail.length - 1];
      const parentNode = await context.ipld.get(parent.cid);
      const result = await addLink(context, {
        parent: parentNode,
        name,
        cid: updatedCid,
        size: node.serialize().length,
        flush: settings.flush,
        shardSplitThreshold: settings.shardSplitThreshold,
        hashAlg: "sha2-256",
        cidVersion
      });
      parent.cid = result.cid;
      const newRootCid = await updateTree(context, trail, settings);
      await updateMfsRoot(context, newRootCid, settings);
    }
    return withTimeoutOption(mfsTouch);
  };
});

// node_modules/ipfs-core/src/components/files/utils/to-async-iterator.js
var require_to_async_iterator = __commonJS((exports2, module2) => {
  "use strict";
  var errCode = require_err_code();
  var log = require_browser4()("ipfs:mfs:utils:to-async-iterator");
  var {
    MFS_MAX_CHUNK_SIZE
  } = require_utils7();
  var uint8ArrayFromString = require_from_string6();
  var toAsyncIterator = (content) => {
    if (!content) {
      throw errCode(new Error("paths must start with a leading slash"), "ERR_INVALID_PATH");
    }
    if (typeof content === "string" || content instanceof String) {
      log("Content was a string");
      content = uint8ArrayFromString(content.toString());
    }
    if (content.length) {
      log("Content was array-like");
      return {
        [Symbol.asyncIterator]: function* bufferContent() {
          yield content;
        }
      };
    }
    if (content[Symbol.asyncIterator]) {
      log("Content was an async iterator");
      return content;
    }
    if (content[Symbol.iterator]) {
      log("Content was an iterator");
      return content;
    }
    if (global.Blob && content instanceof global.Blob) {
      log("Content was an HTML5 Blob");
      let index = 0;
      const iterator = {
        next: () => {
          if (index > content.size) {
            return {
              done: true
            };
          }
          return new Promise((resolve, reject) => {
            const chunk = content.slice(index, MFS_MAX_CHUNK_SIZE);
            index += MFS_MAX_CHUNK_SIZE;
            const reader = new global.FileReader();
            const handleLoad = (ev) => {
              reader.removeEventListener("loadend", handleLoad, false);
              if (ev.error) {
                return reject(ev.error);
              }
              resolve({
                done: false,
                value: new Uint8Array(reader.result)
              });
            };
            reader.addEventListener("loadend", handleLoad);
            reader.readAsArrayBuffer(chunk);
          });
        }
      };
      return {
        [Symbol.asyncIterator]: () => {
          return iterator;
        }
      };
    }
    throw errCode(new Error(`Don't know how to convert ${content} into an async iterator`), "ERR_INVALID_PARAMS");
  };
  module2.exports = toAsyncIterator;
});

// node_modules/ipfs-core/src/components/files/write.js
var require_write = __commonJS((exports2, module2) => {
  "use strict";
  var log = require_browser4()("ipfs:mfs:write");
  var importer = require_src29();
  var stat = require_stat3();
  var mkdir = require_mkdir();
  var addLink = require_add_link();
  var mergeOptions = require_merge_options().bind({ignoreUndefined: true});
  var createLock = require_create_lock();
  var toAsyncIterator = require_to_async_iterator();
  var toMfsPath = require_to_mfs_path();
  var toPathComponents = require_to_path_components2();
  var toTrail = require_to_trail();
  var updateTree = require_update_tree();
  var updateMfsRoot = require_update_mfs_root();
  var errCode = require_err_code();
  var {
    MFS_MAX_CHUNK_SIZE
  } = require_utils7();
  var last = require_it_last();
  var withTimeoutOption = require_with_timeout_option();
  var defaultOptions = {
    offset: 0,
    length: void 0,
    create: false,
    truncate: false,
    rawLeaves: false,
    reduceSingleLeafToSelf: false,
    cidVersion: 0,
    hashAlg: "sha2-256",
    parents: false,
    progress: () => {
    },
    strategy: "trickle",
    flush: true,
    leafType: "raw",
    shardSplitThreshold: 1e3,
    mode: void 0,
    mtime: void 0,
    signal: void 0
  };
  module2.exports = (context) => {
    async function mfsWrite(path, content, options = {}) {
      options = mergeOptions(defaultOptions, options);
      let source, destination, parent;
      log("Reading source, destination and parent");
      await createLock().readLock(async () => {
        source = await toAsyncIterator(content);
        destination = await toMfsPath(context, path, options);
        parent = await toMfsPath(context, destination.mfsDirectory, options);
      })();
      log("Read source, destination and parent");
      if (!options.parents && !parent.exists) {
        throw errCode(new Error("directory does not exist"), "ERR_NO_EXIST");
      }
      if (!options.create && !destination.exists) {
        throw errCode(new Error("file does not exist"), "ERR_NO_EXIST");
      }
      return updateOrImport(context, path, source, destination, options);
    }
    return withTimeoutOption(mfsWrite);
  };
  var updateOrImport = async (context, path, source, destination, options) => {
    const child = await write(context, source, destination, options);
    await createLock().writeLock(async () => {
      const pathComponents = toPathComponents(path);
      const fileName = pathComponents.pop();
      let parentExists = false;
      try {
        await stat(context)(`/${pathComponents.join("/")}`, options);
        parentExists = true;
      } catch (err) {
        if (err.code !== "ERR_NOT_FOUND") {
          throw err;
        }
      }
      if (!parentExists) {
        await mkdir(context)(`/${pathComponents.join("/")}`, options);
      }
      const updatedPath = await toMfsPath(context, path, options);
      const trail = await toTrail(context, updatedPath.mfsDirectory);
      const parent = trail[trail.length - 1];
      if (!parent.type.includes("directory")) {
        throw errCode(new Error(`cannot write to ${parent.name}: Not a directory`), "ERR_NOT_A_DIRECTORY");
      }
      const parentNode = await context.ipld.get(parent.cid);
      const result = await addLink(context, {
        parent: parentNode,
        name: fileName,
        cid: child.cid,
        size: child.size,
        flush: options.flush,
        shardSplitThreshold: options.shardSplitThreshold,
        hashAlg: options.hashAlg,
        cidVersion: options.cidVersion
      });
      parent.cid = result.cid;
      const newRootCid = await updateTree(context, trail, options);
      await updateMfsRoot(context, newRootCid, options);
    })();
  };
  var write = async (context, source, destination, options) => {
    if (destination.exists) {
      log(`Overwriting file ${destination.cid} offset ${options.offset} length ${options.length}`);
    } else {
      log(`Writing file offset ${options.offset} length ${options.length}`);
    }
    const sources = [];
    if (options.offset > 0) {
      if (destination.unixfs) {
        log(`Writing first ${options.offset} bytes of original file`);
        sources.push(() => {
          return destination.content({
            offset: 0,
            length: options.offset
          });
        });
        if (destination.unixfs.fileSize() < options.offset) {
          const extra = options.offset - destination.unixfs.fileSize();
          log(`Writing zeros for extra ${extra} bytes`);
          sources.push(asyncZeroes(extra));
        }
      } else {
        log(`Writing zeros for first ${options.offset} bytes`);
        sources.push(asyncZeroes(options.offset));
      }
    }
    sources.push(limitAsyncStreamBytes(source, options.length));
    const content = countBytesStreamed(catAsyncIterators(sources), (bytesWritten) => {
      if (destination.unixfs && !options.truncate) {
        const fileSize = destination.unixfs.fileSize();
        if (fileSize > bytesWritten) {
          log(`Writing last ${fileSize - bytesWritten} of ${fileSize} bytes from original file starting at offset ${bytesWritten}`);
          return destination.content({
            offset: bytesWritten
          });
        } else {
          log("Not writing last bytes from original file");
        }
      }
      return {
        [Symbol.asyncIterator]: async function* () {
        }
      };
    });
    let mode;
    if (options.mode !== void 0 && options.mode !== null) {
      mode = options.mode;
    } else if (destination && destination.unixfs) {
      mode = destination.unixfs.mode;
    }
    let mtime;
    if (options.mtime !== void 0 && options.mtine !== null) {
      mtime = options.mtime;
    } else if (destination && destination.unixfs) {
      mtime = destination.unixfs.mtime;
    }
    const result = await last(importer([{
      content,
      mode,
      mtime
    }], context.block, {
      progress: options.progress,
      hashAlg: options.hashAlg,
      cidVersion: options.cidVersion,
      strategy: options.strategy,
      rawLeaves: options.rawLeaves,
      reduceSingleLeafToSelf: options.reduceSingleLeafToSelf,
      leafType: options.leafType,
      pin: false
    }));
    log(`Wrote ${result.cid}`);
    return {
      cid: result.cid,
      size: result.size
    };
  };
  var limitAsyncStreamBytes = (stream, limit) => {
    return async function* _limitAsyncStreamBytes() {
      let emitted = 0;
      for await (const buf of stream) {
        emitted += buf.length;
        if (emitted > limit) {
          yield buf.slice(0, limit - emitted);
          return;
        }
        yield buf;
      }
    };
  };
  var asyncZeroes = (count, chunkSize = MFS_MAX_CHUNK_SIZE) => {
    const buf = new Uint8Array(chunkSize);
    const stream = {
      [Symbol.asyncIterator]: function* _asyncZeroes() {
        while (true) {
          yield buf.slice();
        }
      }
    };
    return limitAsyncStreamBytes(stream, count);
  };
  var catAsyncIterators = async function* (sources) {
    for (let i = 0; i < sources.length; i++) {
      yield* sources[i]();
    }
  };
  var countBytesStreamed = async function* (source, notify) {
    let wrote = 0;
    for await (const buf of source) {
      wrote += buf.length;
      yield buf;
    }
    for await (const buf of notify(wrote)) {
      wrote += buf.length;
      yield buf;
    }
  };
});

// node_modules/ipfs-core/src/components/files/read.js
var require_read = __commonJS((exports2, module2) => {
  "use strict";
  var exporter = require_src30();
  var mergeOptions = require_merge_options().bind({ignoreUndefined: true});
  var toMfsPath = require_to_mfs_path();
  var errCode = require_err_code();
  var withTimeoutOption = require_with_timeout_option();
  var defaultOptions = {
    offset: 0,
    length: Infinity,
    signal: void 0
  };
  module2.exports = (context) => {
    function mfsRead(path, options = {}) {
      options = mergeOptions(defaultOptions, options);
      return {
        [Symbol.asyncIterator]: async function* read() {
          const mfsPath = await toMfsPath(context, path, options);
          const result = await exporter(mfsPath.mfsPath, context.ipld);
          if (result.unixfs.type !== "file") {
            throw errCode(new Error(`${path} was not a file`), "ERR_NOT_FILE");
          }
          if (!result.content) {
            throw errCode(new Error(`Could not load content stream from ${path}`), "ERR_NO_CONTENT");
          }
          for await (const buf of result.content({
            offset: options.offset,
            length: options.length
          })) {
            yield buf;
          }
        }
      };
    }
    return withTimeoutOption(mfsRead);
  };
});

// node_modules/ipfs-core/src/components/files/ls.js
var require_ls3 = __commonJS((exports2, module2) => {
  "use strict";
  var exporter = require_src30();
  var toMfsPath = require_to_mfs_path();
  var withTimeoutOption = require_with_timeout_option();
  var toOutput = (fsEntry) => {
    let type = "file";
    let size = fsEntry.node.size || fsEntry.node.length;
    let mode;
    let mtime;
    if (fsEntry.unixfs) {
      size = fsEntry.unixfs.fileSize();
      type = fsEntry.unixfs.type;
      if (fsEntry.unixfs.type === "hamt-sharded-directory") {
        type = "directory";
      }
      mode = fsEntry.unixfs.mode;
      mtime = fsEntry.unixfs.mtime;
    }
    const output = {
      cid: fsEntry.cid,
      name: fsEntry.name,
      type,
      size
    };
    if (mtime !== void 0) {
      output.mtime = mtime;
    }
    if (mode !== void 0) {
      output.mode = mode;
    }
    return output;
  };
  module2.exports = (context) => {
    async function* mfsLs(path, options = {}) {
      const mfsPath = await toMfsPath(context, path, options);
      const fsDir = await exporter(mfsPath.mfsPath, context.ipld);
      if (!fsDir.unixfs || !fsDir.unixfs.type.includes("directory")) {
        yield toOutput(fsDir);
        return;
      }
      for await (const fsEntry of fsDir.content(options)) {
        yield toOutput(fsEntry);
      }
    }
    return withTimeoutOption(mfsLs);
  };
});

// node_modules/ipfs-core/src/components/files/index.js
var require_files = __commonJS((exports2, module2) => {
  "use strict";
  var createLock = require_create_lock();
  var isIpfs = require_src13();
  var readOperations = {
    stat: require_stat3()
  };
  var writeOperations = {
    chmod: require_chmod(),
    cp: require_cp(),
    flush: require_flush(),
    mkdir: require_mkdir(),
    mv: require_mv(),
    rm: require_rm4(),
    touch: require_touch()
  };
  var unwrappedOperations = {
    write: require_write(),
    read: require_read(),
    ls: require_ls3()
  };
  var wrap = ({
    options,
    mfs,
    operations,
    lock
  }) => {
    Object.keys(operations).forEach((key) => {
      mfs[key] = lock(operations[key](options));
    });
  };
  var defaultOptions = {
    repoOwner: true,
    ipld: null,
    repo: null
  };
  function createMfs(options) {
    const {
      repoOwner
    } = Object.assign({}, defaultOptions || {}, options);
    options.repo = {
      blocks: options.blocks,
      datastore: options.datastore
    };
    const lock = createLock(repoOwner);
    const readLock = (operation) => {
      return lock.readLock(operation);
    };
    const writeLock = (operation) => {
      return lock.writeLock(operation);
    };
    const mfs = {};
    wrap({
      options,
      mfs,
      operations: readOperations,
      lock: readLock
    });
    wrap({
      options,
      mfs,
      operations: writeOperations,
      lock: writeLock
    });
    Object.keys(unwrappedOperations).forEach((key) => {
      mfs[key] = unwrappedOperations[key](options);
    });
    return mfs;
  }
  module2.exports = ({ipld, block, blockService, repo, preload, options: constructorOptions}) => {
    const methods = createMfs({
      ipld,
      block,
      blocks: blockService,
      datastore: repo.root,
      repoOwner: constructorOptions.repoOwner
    });
    const withPreload = (fn) => (...args) => {
      const paths = args.filter((arg) => isIpfs.ipfsPath(arg) || isIpfs.cid(arg));
      if (paths.length) {
        const options = args[args.length - 1];
        if (options && options.preload !== false) {
          paths.forEach((path) => preload(path));
        }
      }
      return fn(...args);
    };
    return {
      ...methods,
      chmod: methods.chmod,
      cp: withPreload(methods.cp),
      mkdir: methods.mkdir,
      stat: withPreload(methods.stat),
      rm: methods.rm,
      read: withPreload(methods.read),
      touch: methods.touch,
      write: methods.write,
      mv: withPreload(methods.mv),
      flush: methods.flush,
      ls: withPreload(async function* (...args) {
        for await (const file of methods.ls(...args)) {
          yield {...file, size: file.size || 0};
        }
      })
    };
  };
});

// node_modules/ipfs-core/src/components/key/export.js
var require_export = __commonJS((exports2, module2) => {
  "use strict";
  var withTimeoutOption = require_with_timeout_option();
  module2.exports = ({keychain}) => {
    const exportKey = (name, password) => keychain.exportKey(name, password);
    return withTimeoutOption(exportKey);
  };
});

// node_modules/ipfs-core/src/components/key/gen.js
var require_gen = __commonJS((exports2, module2) => {
  "use strict";
  var withTimeoutOption = require_with_timeout_option();
  module2.exports = ({keychain}) => {
    const gen = (name, options = {}) => {
      return keychain.createKey(name, options.type || "rsa", options.size || 2048);
    };
    return withTimeoutOption(gen);
  };
});

// node_modules/ipfs-core/src/components/key/import.js
var require_import = __commonJS((exports2, module2) => {
  "use strict";
  var withTimeoutOption = require_with_timeout_option();
  module2.exports = ({keychain}) => {
    const importKey = (name, pem, password) => {
      return keychain.importKey(name, pem, password);
    };
    return withTimeoutOption(importKey);
  };
});

// node_modules/ipfs-core/src/components/key/info.js
var require_info = __commonJS((exports2, module2) => {
  "use strict";
  var withTimeoutOption = require_with_timeout_option();
  module2.exports = ({keychain}) => {
    const info = (name) => keychain.findKeyByName(name);
    return withTimeoutOption(info);
  };
});

// node_modules/ipfs-core/src/components/key/list.js
var require_list2 = __commonJS((exports2, module2) => {
  "use strict";
  var withTimeoutOption = require_with_timeout_option();
  module2.exports = ({keychain}) => {
    const list = () => keychain.listKeys();
    return withTimeoutOption(list);
  };
});

// node_modules/ipfs-core/src/components/key/rename.js
var require_rename = __commonJS((exports2, module2) => {
  "use strict";
  var withTimeoutOption = require_with_timeout_option();
  module2.exports = ({keychain}) => {
    const rename = async (oldName, newName) => {
      const key = await keychain.renameKey(oldName, newName);
      return {
        was: oldName,
        now: key.name,
        id: key.id,
        overwrite: false
      };
    };
    return withTimeoutOption(rename);
  };
});

// node_modules/ipfs-core/src/components/key/rm.js
var require_rm5 = __commonJS((exports2, module2) => {
  "use strict";
  var withTimeoutOption = require_with_timeout_option();
  module2.exports = ({keychain}) => {
    const rm = (name) => keychain.removeKey(name);
    return withTimeoutOption(rm);
  };
});

// node_modules/ipfs-core/src/components/key/index.js
var require_key5 = __commonJS((exports2, module2) => {
  "use strict";
  var createExport = require_export();
  var createGen = require_gen();
  var createImport = require_import();
  var createInfo = require_info();
  var createList = require_list2();
  var createRename = require_rename();
  var createRm = require_rm5();
  var KeyAPI = class {
    constructor({keychain}) {
      this.gen = createGen({keychain});
      this.list = createList({keychain});
      this.rm = createRm({keychain});
      this.rename = createRename({keychain});
      this.export = createExport({keychain});
      this.import = createImport({keychain});
      this.info = createInfo({keychain});
    }
  };
  module2.exports = KeyAPI;
});

// node_modules/ipfs-core/src/components/object/get.js
var require_get4 = __commonJS((exports2, module2) => {
  "use strict";
  var CID = require_src7();
  var errCode = require_err_code();
  var withTimeoutOption = require_with_timeout_option();
  var uint8ArrayFromString = require_from_string6();
  function normalizeMultihash(multihash, enc) {
    if (typeof multihash === "string") {
      if (enc === "base58" || !enc) {
        return multihash;
      }
      return uint8ArrayFromString(multihash, enc);
    } else if (multihash instanceof Uint8Array) {
      return multihash;
    } else if (CID.isCID(multihash)) {
      return multihash.bytes;
    }
    throw new Error("unsupported multihash");
  }
  module2.exports = ({ipld, preload}) => {
    async function get(multihash, options = {}) {
      let mh, cid;
      try {
        mh = normalizeMultihash(multihash, options.enc);
      } catch (err) {
        throw errCode(err, "ERR_INVALID_MULTIHASH");
      }
      try {
        cid = new CID(mh);
      } catch (err) {
        throw errCode(err, "ERR_INVALID_CID");
      }
      if (options.cidVersion === 1) {
        cid = cid.toV1();
      }
      if (options.preload !== false) {
        preload(cid);
      }
      return ipld.get(cid, {signal: options.signal});
    }
    return withTimeoutOption(get);
  };
});

// node_modules/ipfs-core/src/components/object/data.js
var require_data = __commonJS((exports2, module2) => {
  "use strict";
  var withTimeoutOption = require_with_timeout_option();
  module2.exports = ({ipld, preload}) => {
    const get = require_get4()({ipld, preload});
    async function data(multihash, options) {
      const node = await get(multihash, options);
      return node.Data;
    }
    return withTimeoutOption(data);
  };
});

// node_modules/ipfs-core/src/components/object/links.js
var require_links = __commonJS((exports2, module2) => {
  "use strict";
  var dagPB = require_src16();
  var DAGLink = dagPB.DAGLink;
  var CID = require_src7();
  var withTimeoutOption = require_with_timeout_option();
  function findLinks(node, links = []) {
    for (const key in node) {
      const val = node[key];
      if (key === "/" && Object.keys(node).length === 1) {
        try {
          links.push(new DAGLink("", 0, new CID(val)));
          continue;
        } catch (_) {
        }
      }
      if (CID.isCID(val)) {
        links.push(new DAGLink("", 0, val));
        continue;
      }
      if (Array.isArray(val)) {
        findLinks(val, links);
      }
      if (val && typeof val === "object") {
        findLinks(val, links);
      }
    }
    return links;
  }
  module2.exports = ({dag}) => {
    async function links(multihash, options = {}) {
      const cid = new CID(multihash);
      const result = await dag.get(cid, options);
      if (cid.codec === "raw") {
        return [];
      }
      if (cid.codec === "dag-pb") {
        return result.value.Links;
      }
      if (cid.codec === "dag-cbor") {
        return findLinks(result);
      }
      throw new Error(`Cannot resolve links from codec ${cid.codec}`);
    }
    return withTimeoutOption(links);
  };
});

// node_modules/ipfs-core/src/components/object/new.js
var require_new = __commonJS((exports2, module2) => {
  "use strict";
  var dagPB = require_src16();
  var DAGNode = dagPB.DAGNode;
  var multicodec = require_src6();
  var Unixfs = require_src17();
  var withTimeoutOption = require_with_timeout_option();
  module2.exports = ({ipld, preload}) => {
    async function _new(options = {}) {
      let data;
      if (options.template) {
        if (options.template === "unixfs-dir") {
          data = new Unixfs("directory").marshal();
        } else {
          throw new Error("unknown template");
        }
      } else {
        data = new Uint8Array(0);
      }
      const node = new DAGNode(data);
      const cid = await ipld.put(node, multicodec.DAG_PB, {
        cidVersion: 0,
        hashAlg: multicodec.SHA2_256,
        signal: options.signal
      });
      if (options.preload !== false) {
        preload(cid);
      }
      return cid;
    }
    return withTimeoutOption(_new);
  };
});

// node_modules/ipfs-core/src/components/object/put.js
var require_put3 = __commonJS((exports2, module2) => {
  "use strict";
  var dagPB = require_src16();
  var DAGNode = dagPB.DAGNode;
  var DAGLink = dagPB.DAGLink;
  var mh = require_src14().multihash;
  var multicodec = require_src6();
  var withTimeoutOption = require_with_timeout_option();
  var uint8ArrayToString = require_to_string5();
  var uint8ArrayFromString = require_from_string6();
  function parseBuffer(buf, encoding) {
    switch (encoding) {
      case "json":
        return parseJSONBuffer(buf);
      case "protobuf":
        return parseProtoBuffer(buf);
      default:
        throw new Error(`unkown encoding: ${encoding}`);
    }
  }
  function parseJSONBuffer(buf) {
    let data;
    let links;
    try {
      const parsed = JSON.parse(uint8ArrayToString(buf));
      links = (parsed.Links || []).map((link) => {
        return new DAGLink(link.Name || link.name, link.Size || link.size, mh.fromB58String(link.Hash || link.hash || link.multihash));
      });
      data = uint8ArrayFromString(parsed.Data);
    } catch (err) {
      throw new Error("failed to parse JSON: " + err);
    }
    return new DAGNode(data, links);
  }
  function parseProtoBuffer(buf) {
    return dagPB.util.deserialize(buf);
  }
  module2.exports = ({ipld, gcLock, preload}) => {
    async function put(obj, options = {}) {
      const encoding = options.enc;
      let node;
      if (obj instanceof Uint8Array) {
        if (encoding) {
          node = await parseBuffer(obj, encoding);
        } else {
          node = new DAGNode(obj);
        }
      } else if (DAGNode.isDAGNode(obj)) {
        node = obj;
      } else if (typeof obj === "object") {
        node = new DAGNode(obj.Data, obj.Links);
      } else {
        throw new Error("obj not recognized");
      }
      const release = await gcLock.readLock();
      try {
        const cid = await ipld.put(node, multicodec.DAG_PB, {
          cidVersion: 0,
          hashAlg: multicodec.SHA2_256
        });
        if (options.preload !== false) {
          preload(cid);
        }
        return cid;
      } finally {
        release();
      }
    }
    return withTimeoutOption(put);
  };
});

// node_modules/ipfs-core/src/components/object/stat.js
var require_stat4 = __commonJS((exports2, module2) => {
  "use strict";
  var dagPB = require_src16();
  var withTimeoutOption = require_with_timeout_option();
  module2.exports = ({ipld, preload}) => {
    const get = require_get4()({ipld, preload});
    async function stat(multihash, options = {}) {
      const node = await get(multihash, options);
      const serialized = dagPB.util.serialize(node);
      const cid = await dagPB.util.cid(serialized, {
        cidVersion: 0
      });
      const blockSize = serialized.length;
      const linkLength = node.Links.reduce((a, l) => a + l.Tsize, 0);
      return {
        Hash: cid.toBaseEncodedString(),
        NumLinks: node.Links.length,
        BlockSize: blockSize,
        LinksSize: blockSize - node.Data.length,
        DataSize: node.Data.length,
        CumulativeSize: blockSize + linkLength
      };
    }
    return withTimeoutOption(stat);
  };
});

// node_modules/ipfs-core/src/components/object/patch/add-link.js
var require_add_link2 = __commonJS((exports2, module2) => {
  "use strict";
  var withTimeoutOption = require_with_timeout_option();
  module2.exports = ({ipld, gcLock, preload}) => {
    const get = require_get4()({ipld, preload});
    const put = require_put3()({ipld, gcLock, preload});
    async function addLink(multihash, link, options) {
      const node = await get(multihash, options);
      node.addLink(link);
      return put(node, options);
    }
    return withTimeoutOption(addLink);
  };
});

// node_modules/ipfs-core/node_modules/uint8arrays/concat.js
var require_concat5 = __commonJS((exports2, module2) => {
  "use strict";
  function concat(arrays, length) {
    if (!length) {
      length = arrays.reduce((acc, curr) => acc + curr.length, 0);
    }
    const output = new Uint8Array(length);
    let offset = 0;
    for (const arr of arrays) {
      output.set(arr, offset);
      offset += arr.length;
    }
    return output;
  }
  module2.exports = concat;
});

// node_modules/ipfs-core/src/components/object/patch/append-data.js
var require_append_data = __commonJS((exports2, module2) => {
  "use strict";
  var {DAGNode} = require_src16();
  var withTimeoutOption = require_with_timeout_option();
  var uint8ArrayConcat = require_concat5();
  module2.exports = ({ipld, gcLock, preload}) => {
    const get = require_get4()({ipld, preload});
    const put = require_put3()({ipld, gcLock, preload});
    async function appendData(multihash, data, options) {
      const node = await get(multihash, options);
      const newData = uint8ArrayConcat([node.Data, data]);
      return put(new DAGNode(newData, node.Links), options);
    }
    return withTimeoutOption(appendData);
  };
});

// node_modules/ipfs-core/src/components/object/patch/rm-link.js
var require_rm_link = __commonJS((exports2, module2) => {
  "use strict";
  var withTimeoutOption = require_with_timeout_option();
  module2.exports = ({ipld, gcLock, preload}) => {
    const get = require_get4()({ipld, preload});
    const put = require_put3()({ipld, gcLock, preload});
    async function rmLink(multihash, linkRef, options) {
      const node = await get(multihash, options);
      node.rmLink(linkRef.Name || linkRef.name);
      return put(node, options);
    }
    return withTimeoutOption(rmLink);
  };
});

// node_modules/ipfs-core/src/components/object/patch/set-data.js
var require_set_data = __commonJS((exports2, module2) => {
  "use strict";
  var {DAGNode} = require_src16();
  var withTimeoutOption = require_with_timeout_option();
  module2.exports = ({ipld, gcLock, preload}) => {
    const get = require_get4()({ipld, preload});
    const put = require_put3()({ipld, gcLock, preload});
    async function setData(multihash, data, options) {
      const node = await get(multihash, options);
      return put(new DAGNode(data, node.Links), options);
    }
    return withTimeoutOption(setData);
  };
});

// node_modules/ipfs-core/src/components/object/patch/index.js
var require_patch = __commonJS((exports2, module2) => {
  "use strict";
  var createAddLink = require_add_link2();
  var createAppendData = require_append_data();
  var createRmLink = require_rm_link();
  var createSetData = require_set_data();
  var ObjectPatchAPI = class {
    constructor({ipld, preload, gcLock}) {
      this.addLink = createAddLink({ipld, preload, gcLock});
      this.appendData = createAppendData({ipld, preload, gcLock});
      this.rmLink = createRmLink({ipld, preload, gcLock});
      this.setData = createSetData({ipld, preload, gcLock});
    }
  };
  module2.exports = ObjectPatchAPI;
});

// node_modules/ipfs-core/src/components/object/index.js
var require_object = __commonJS((exports2, module2) => {
  "use strict";
  var createData = require_data();
  var createGet = require_get4();
  var createLinks = require_links();
  var createNew = require_new();
  var createPut = require_put3();
  var createStat = require_stat4();
  var ObjectPatchAPI = require_patch();
  var ObjectAPI = class {
    constructor({ipld, preload, dag, gcLock}) {
      this.data = createData({ipld, preload});
      this.get = createGet({ipld, preload});
      this.links = createLinks({dag});
      this.new = createNew({ipld, preload});
      this.put = createPut({ipld, preload, gcLock});
      this.stat = createStat({ipld, preload});
      this.patch = new ObjectPatchAPI({ipld, preload, gcLock});
    }
  };
  module2.exports = ObjectAPI;
});

// node_modules/ipfs-core/src/components/repo/gc.js
var require_gc = __commonJS((exports2, module2) => {
  "use strict";
  var CID = require_src7();
  var log = require_browser4()("ipfs:repo:gc");
  var {MFS_ROOT_KEY} = require_utils7();
  var withTimeoutOption = require_with_timeout_option();
  var {Errors} = require_src15();
  var ERR_NOT_FOUND = Errors.notFoundError().code;
  var {parallelMerge, transform, map} = require_dist2();
  var multibase = require_src4();
  var BLOCK_RM_CONCURRENCY = 256;
  module2.exports = ({gcLock, pin, refs, repo}) => {
    async function* gc(_options = {}) {
      const start = Date.now();
      log("Creating set of marked blocks");
      const release = await gcLock.writeLock();
      try {
        const markedSet = await createMarkedSet({pin, refs, repo});
        const blockKeys = repo.blocks.query({keysOnly: true});
        yield* deleteUnmarkedBlocks({repo}, markedSet, blockKeys);
        log(`Complete (${Date.now() - start}ms)`);
      } finally {
        release();
      }
    }
    return withTimeoutOption(gc);
  };
  async function createMarkedSet({pin, refs, repo}) {
    const pinsSource = map(({cid}) => cid, pin.ls());
    const mfsSource = async function* () {
      let mh;
      try {
        mh = await repo.root.get(MFS_ROOT_KEY);
      } catch (err) {
        if (err.code === ERR_NOT_FOUND) {
          log("No blocks in MFS");
          return;
        }
        throw err;
      }
      const rootCid = new CID(mh);
      yield rootCid;
      for await (const {ref} of refs(rootCid, {recursive: true})) {
        yield new CID(ref);
      }
    }();
    const output = new Set();
    for await (const cid of parallelMerge(pinsSource, mfsSource)) {
      output.add(multibase.encode("base32", cid.multihash).toString());
    }
    return output;
  }
  async function* deleteUnmarkedBlocks({repo}, markedSet, blockKeys) {
    let blocksCount = 0;
    let removedBlocksCount = 0;
    const removeBlock = async (cid) => {
      blocksCount++;
      try {
        const b32 = multibase.encode("base32", cid.multihash).toString();
        if (markedSet.has(b32))
          return null;
        const res = {cid};
        try {
          await repo.blocks.delete(cid);
          removedBlocksCount++;
        } catch (err) {
          res.err = new Error(`Could not delete block with CID ${cid}: ${err.message}`);
        }
        return res;
      } catch (err) {
        const msg = `Could delete block with CID ${cid}`;
        log(msg, err);
        return {err: new Error(msg + `: ${err.message}`)};
      }
    };
    for await (const res of transform(BLOCK_RM_CONCURRENCY, removeBlock, blockKeys)) {
      if (res)
        yield res;
    }
    log(`Marked set has ${markedSet.size} unique blocks. Blockstore has ${blocksCount} blocks. Deleted ${removedBlocksCount} blocks.`);
  }
});

// node_modules/ipfs-core/src/components/repo/stat.js
var require_stat5 = __commonJS((exports2, module2) => {
  "use strict";
  var withTimeoutOption = require_with_timeout_option();
  module2.exports = ({repo}) => {
    async function stat(options) {
      const stats = await repo.stat(options);
      return {
        numObjects: stats.numObjects,
        repoSize: stats.repoSize,
        repoPath: stats.repoPath,
        version: stats.version.toString(),
        storageMax: stats.storageMax
      };
    }
    return withTimeoutOption(stat);
  };
});

// node_modules/just-safe-get/index.js
var require_just_safe_get = __commonJS((exports2, module2) => {
  module2.exports = get;
  function get(obj, propsArg, defaultValue) {
    if (!obj) {
      return defaultValue;
    }
    var props, prop;
    if (Array.isArray(propsArg)) {
      props = propsArg.slice(0);
    }
    if (typeof propsArg == "string") {
      props = propsArg.split(".");
    }
    if (typeof propsArg == "symbol") {
      props = [propsArg];
    }
    if (!Array.isArray(props)) {
      throw new Error("props arg must be an array, a string or a symbol");
    }
    while (props.length) {
      prop = props.shift();
      if (!obj) {
        return defaultValue;
      }
      obj = obj[prop];
      if (obj === void 0) {
        return defaultValue;
      }
    }
    return obj;
  }
});

// node_modules/ipfs-repo-migrations/node_modules/uint8arrays/to-string.js
var require_to_string8 = __commonJS((exports2, module2) => {
  "use strict";
  var {encoding: getCodec} = require_src4();
  var {TextDecoder: TextDecoder2} = require_lib_browser();
  var utf8Decoder = new TextDecoder2("utf8");
  function uint8ArrayToAsciiString(array) {
    let string = "";
    for (let i = 0; i < array.length; i++) {
      string += String.fromCharCode(array[i]);
    }
    return string;
  }
  function toString(array, encoding = "utf8") {
    if (encoding === "utf8" || encoding === "utf-8") {
      return utf8Decoder.decode(array);
    }
    if (encoding === "ascii") {
      return uint8ArrayToAsciiString(array);
    }
    return getCodec(encoding).encode(array);
  }
  module2.exports = toString;
});

// node_modules/ipfs-repo-migrations/src/utils.js
var require_utils21 = __commonJS((exports2, module2) => {
  "use strict";
  var {
    Key,
    Errors
  } = require_src15();
  var core = require_src22();
  var ShardingStore = core.ShardingDatastore;
  var CONFIG_KEY = new Key("/config");
  var VERSION_KEY = new Key("/version");
  function getDatastoreAndOptions(name, options) {
    if (!options || !options.storageBackends) {
      throw new Error("Please pass storage backend definitions");
    }
    if (!options.storageBackends[name]) {
      throw new Error(`Storage backend '${name}' not defined in config`);
    }
    const StorageBackend = options.storageBackends[name];
    let storageBackendOptions = {};
    if (options.storageBackendOptions !== void 0 && options.storageBackendOptions[name] !== void 0) {
      storageBackendOptions = options.storageBackendOptions[name];
    }
    return {
      StorageBackend,
      storageOptions: storageBackendOptions
    };
  }
  function findLevelJs(store) {
    let db = store;
    while (db.db || db.child) {
      db = db.db || db.child;
      if (db.type === "level-js" || db.constructor.name === "Level") {
        return db;
      }
    }
  }
  async function hasWithFallback(key, has, store) {
    const result = await has(key);
    if (result) {
      return result;
    }
    const levelJs = findLevelJs(store);
    if (!levelJs) {
      return false;
    }
    return new Promise((resolve, reject) => {
      const req = levelJs.store("readonly").get(key.toString());
      req.transaction.onabort = () => {
        reject(req.transaction.error);
      };
      req.transaction.oncomplete = () => {
        resolve(Boolean(req.result));
      };
    });
  }
  async function getWithFallback(key, get, has, store) {
    if (await has(key)) {
      return get(key);
    }
    const levelJs = findLevelJs(store);
    if (!levelJs) {
      throw Errors.notFoundError();
    }
    return new Promise((resolve, reject) => {
      const req = levelJs.store("readonly").get(key.toString());
      req.transaction.onabort = () => {
        reject(req.transaction.error);
      };
      req.transaction.oncomplete = () => {
        if (req.result) {
          return resolve(req.result);
        }
        reject(Errors.notFoundError());
      };
    });
  }
  function createStore(location2, name, options) {
    const {StorageBackend, storageOptions} = getDatastoreAndOptions(name, options);
    if (name !== "root") {
      location2 = `${location2}/${name}`;
    }
    let store = new StorageBackend(location2, storageOptions);
    if (storageOptions.sharding) {
      store = new ShardingStore(store, new core.shard.NextToLast(2));
    }
    const originalGet = store.get.bind(store);
    const originalHas = store.has.bind(store);
    store.get = (key) => getWithFallback(key, originalGet, originalHas, store);
    store.has = (key) => hasWithFallback(key, originalHas, store);
    return store;
  }
  module2.exports = {
    createStore,
    hasWithFallback,
    getWithFallback,
    findLevelJs,
    CONFIG_KEY,
    VERSION_KEY
  };
});

// node_modules/it-length/index.js
var require_it_length = __commonJS((exports2, module2) => {
  "use strict";
  var length = async (iterator) => {
    let count = 0;
    for await (const _ of iterator) {
      count++;
    }
    return count;
  };
  module2.exports = length;
});

// node_modules/ipfs-repo-migrations/migrations/migration-8/index.js
var require_migration_8 = __commonJS((exports2, module2) => {
  "use strict";
  var CID = require_src7();
  var Key = require_src15().Key;
  var mb = require_src4();
  var log = require_browser4()("ipfs:repo:migrator:migration-8");
  var uint8ArrayToString = require_to_string8();
  var {createStore} = require_utils21();
  var length = require_it_length();
  function keyToMultihash(key) {
    const buf = mb.decode(`b${key.toString().slice(1)}`);
    let multihash = new CID(buf).multihash;
    multihash = mb.encode("base32", multihash).slice(1);
    multihash = uint8ArrayToString(multihash).toUpperCase();
    return new Key(`/${multihash}`, false);
  }
  function keyToCid(key) {
    const buf = mb.decode(`b${key.toString().slice(1)}`);
    const multihash = mb.encode("base32", new CID(1, "raw", buf).bytes).slice(1);
    return new Key(`/${uint8ArrayToString(multihash)}`.toUpperCase(), false);
  }
  async function process2(repoPath, repoOptions, onProgress, keyFunction) {
    const blockstore = createStore(repoPath, "blocks", repoOptions);
    await blockstore.open();
    let blockCount;
    if (onProgress) {
      blockCount = await length(blockstore.query({
        keysOnly: true,
        filters: [({key}) => {
          const newKey = keyFunction(key);
          return newKey.toString() !== key.toString();
        }]
      }));
    }
    try {
      let counter = 0;
      for await (const block of blockstore.query({})) {
        const newKey = keyFunction(block.key);
        if (newKey.toString() !== block.key.toString()) {
          counter += 1;
          log(`Migrating Block from ${block.key} to ${newKey}`);
          await blockstore.delete(block.key);
          await blockstore.put(newKey, block.value);
          if (onProgress) {
            onProgress(counter / blockCount * 100, `Migrated Block from ${block.key} to ${newKey}`);
          }
        }
      }
    } finally {
      await blockstore.close();
    }
  }
  module2.exports = {
    version: 8,
    description: "Transforms key names into base32 encoding and converts Block store to use bare multihashes encoded as base32",
    migrate: (repoPath, repoOptions, onProgress = () => {
    }) => {
      return process2(repoPath, repoOptions, onProgress, keyToMultihash);
    },
    revert: (repoPath, repoOptions, onProgress = () => {
    }) => {
      return process2(repoPath, repoOptions, onProgress, keyToCid);
    }
  };
});

// node_modules/fnv1a/index.js
var require_fnv1a = __commonJS((exports2, module2) => {
  hash.BASE = 2166136261;
  function hash(s) {
    var h = hash.BASE;
    for (var i = 0, l = s.length; i < l; i++) {
      h ^= s.charCodeAt(i);
      h += (h << 1) + (h << 4) + (h << 7) + (h << 8) + (h << 24);
    }
    return h >>> 0;
  }
  module2.exports = hash;
});

// node_modules/ipfs-repo-migrations/node_modules/varint/encode.js
var require_encode6 = __commonJS((exports2, module2) => {
  module2.exports = encode;
  var MSB = 128;
  var REST = 127;
  var MSBALL = ~REST;
  var INT = Math.pow(2, 31);
  function encode(num, out, offset) {
    if (Number.MAX_SAFE_INTEGER && num > Number.MAX_SAFE_INTEGER) {
      encode.bytes = 0;
      throw new RangeError("Could not encode varint");
    }
    out = out || [];
    offset = offset || 0;
    var oldOffset = offset;
    while (num >= INT) {
      out[offset++] = num & 255 | MSB;
      num /= 128;
    }
    while (num & MSBALL) {
      out[offset++] = num & 255 | MSB;
      num >>>= 7;
    }
    out[offset] = num | 0;
    encode.bytes = offset - oldOffset + 1;
    return out;
  }
});

// node_modules/ipfs-repo-migrations/node_modules/varint/decode.js
var require_decode6 = __commonJS((exports2, module2) => {
  module2.exports = read;
  var MSB = 128;
  var REST = 127;
  function read(buf, offset) {
    var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf.length;
    do {
      if (counter >= l || shift > 49) {
        read.bytes = 0;
        throw new RangeError("Could not decode varint");
      }
      b = buf[counter++];
      res += shift < 28 ? (b & REST) << shift : (b & REST) * Math.pow(2, shift);
      shift += 7;
    } while (b >= MSB);
    read.bytes = counter - offset;
    return res;
  }
});

// node_modules/ipfs-repo-migrations/node_modules/varint/length.js
var require_length4 = __commonJS((exports2, module2) => {
  var N1 = Math.pow(2, 7);
  var N2 = Math.pow(2, 14);
  var N3 = Math.pow(2, 21);
  var N4 = Math.pow(2, 28);
  var N5 = Math.pow(2, 35);
  var N6 = Math.pow(2, 42);
  var N7 = Math.pow(2, 49);
  var N8 = Math.pow(2, 56);
  var N9 = Math.pow(2, 63);
  module2.exports = function(value) {
    return value < N1 ? 1 : value < N2 ? 2 : value < N3 ? 3 : value < N4 ? 4 : value < N5 ? 5 : value < N6 ? 6 : value < N7 ? 7 : value < N8 ? 8 : value < N9 ? 9 : 10;
  };
});

// node_modules/ipfs-repo-migrations/node_modules/varint/index.js
var require_varint5 = __commonJS((exports2, module2) => {
  module2.exports = {
    encode: require_encode6(),
    decode: require_decode6(),
    encodingLength: require_length4()
  };
});

// node_modules/ipfs-repo-migrations/migrations/migration-9/pin.proto.js
var require_pin_proto = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = `
  syntax = "proto2";

  package ipfs.pin;

  option go_package = "pb";

  message Set {
    optional uint32 version = 1;
    optional uint32 fanout = 2;
    optional fixed32 seed = 3;
  }
`;
});

// node_modules/ipfs-repo-migrations/migrations/migration-9/utils.js
var require_utils22 = __commonJS((exports2, module2) => {
  "use strict";
  var multibase = require_src4();
  var {Key} = require_src15();
  var multihashes = require_src14().multihash;
  var PIN_DS_KEY = new Key("/local/pins");
  var DEFAULT_FANOUT = 256;
  var MAX_ITEMS = 8192;
  var EMPTY_KEY = multihashes.fromB58String("QmdfTbBqBPQ7VNxZEYEj14VmRuZBkqFbiwReogJgS1zR1n");
  var PinTypes = {
    direct: "direct",
    recursive: "recursive"
  };
  function cidToKey(cid) {
    return new Key(`/${multibase.encoding("base32upper").encode(cid.multihash)}`);
  }
  module2.exports = {
    PIN_DS_KEY,
    DEFAULT_FANOUT,
    MAX_ITEMS,
    EMPTY_KEY,
    PinTypes,
    cidToKey
  };
});

// node_modules/ipfs-repo-migrations/node_modules/uint8arrays/concat.js
var require_concat6 = __commonJS((exports2, module2) => {
  "use strict";
  function concat(arrays, length) {
    if (!length) {
      length = arrays.reduce((acc, curr) => acc + curr.length, 0);
    }
    const output = new Uint8Array(length);
    let offset = 0;
    for (const arr of arrays) {
      output.set(arr, offset);
      offset += arr.length;
    }
    return output;
  }
  module2.exports = concat;
});

// node_modules/ipfs-repo-migrations/node_modules/uint8arrays/compare.js
var require_compare2 = __commonJS((exports2, module2) => {
  "use strict";
  function compare(a, b) {
    for (let i = 0; i < a.byteLength; i++) {
      if (a[i] < b[i]) {
        return -1;
      }
      if (a[i] > b[i]) {
        return 1;
      }
    }
    if (a.byteLength > b.byteLength) {
      return 1;
    }
    if (a.byteLength < b.byteLength) {
      return -1;
    }
    return 0;
  }
  module2.exports = compare;
});

// node_modules/ipfs-repo-migrations/node_modules/uint8arrays/from-string.js
var require_from_string8 = __commonJS((exports2, module2) => {
  "use strict";
  var {encoding: getCodec} = require_src4();
  var {TextEncoder: TextEncoder2} = require_lib_browser();
  var utf8Encoder = new TextEncoder2();
  function asciiStringToUint8Array(string) {
    const array = new Uint8Array(string.length);
    for (let i = 0; i < string.length; i++) {
      array[i] = string.charCodeAt(i);
    }
    return array;
  }
  function fromString(string, encoding = "utf8") {
    if (encoding === "utf8" || encoding === "utf-8") {
      return utf8Encoder.encode(string);
    }
    if (encoding === "ascii") {
      return asciiStringToUint8Array(string);
    }
    return getCodec(encoding).decode(string);
  }
  module2.exports = fromString;
});

// node_modules/ipfs-repo-migrations/node_modules/uint8arrays/equals.js
var require_equals4 = __commonJS((exports2, module2) => {
  "use strict";
  function equals(a, b) {
    if (a === b) {
      return true;
    }
    if (a.byteLength !== b.byteLength) {
      return false;
    }
    for (let i = 0; i < a.byteLength; i++) {
      if (a[i] !== b[i]) {
        return false;
      }
    }
    return true;
  }
  module2.exports = equals;
});

// node_modules/ipfs-repo-migrations/migrations/migration-9/pin-set.js
var require_pin_set = __commonJS((exports2, module2) => {
  "use strict";
  var CID = require_src7();
  var protobuf = require_src8();
  var fnv1a = require_fnv1a();
  var varint = require_varint5();
  var dagpb = require_src16();
  var {DAGNode, DAGLink} = dagpb;
  var multicodec = require_src6();
  var pbSchema = require_pin_proto();
  var {cidToKey, DEFAULT_FANOUT, MAX_ITEMS, EMPTY_KEY} = require_utils22();
  var uint8ArrayConcat = require_concat6();
  var uint8ArrayCompare = require_compare2();
  var uint8ArrayToString = require_to_string8();
  var uint8ArrayFromString = require_from_string8();
  var uint8ArrayEquals = require_equals4();
  var pb = protobuf(pbSchema);
  function toB58String(hash2) {
    return new CID(hash2).toBaseEncodedString();
  }
  function readHeader(rootNode) {
    const rootData = rootNode.Data;
    const hdrLength = varint.decode(rootData);
    const vBytes = varint.decode.bytes;
    if (vBytes <= 0) {
      throw new Error("Invalid Set header length");
    }
    if (vBytes + hdrLength > rootData.length) {
      throw new Error("Impossibly large set header length");
    }
    const hdrSlice = rootData.slice(vBytes, hdrLength + vBytes);
    const header = pb.Set.decode(hdrSlice);
    if (header.version !== 1) {
      throw new Error(`Unsupported Set version: ${header.version}`);
    }
    if (header.fanout > rootNode.Links.length) {
      throw new Error("Impossibly large fanout");
    }
    return {
      header,
      data: rootData.slice(hdrLength + vBytes)
    };
  }
  function hash(seed, key) {
    const buffer = new Uint8Array(4);
    const dataView = new DataView(buffer.buffer);
    dataView.setUint32(0, seed, true);
    const encodedKey = uint8ArrayFromString(toB58String(key));
    const data = uint8ArrayConcat([buffer, encodedKey], buffer.byteLength + encodedKey.byteLength);
    return fnv1a(uint8ArrayToString(data));
  }
  async function* walkItems(blockstore, node) {
    const pbh = readHeader(node);
    let idx = 0;
    for (const link of node.Links) {
      if (idx < pbh.header.fanout) {
        const linkHash = link.Hash;
        if (!uint8ArrayEquals(EMPTY_KEY, linkHash.bytes)) {
          const buf = await blockstore.get(cidToKey(linkHash));
          const node2 = dagpb.util.deserialize(buf);
          yield* walkItems(blockstore, node2);
        }
      } else {
        yield link.Hash;
      }
      idx++;
    }
  }
  async function* loadSet(blockstore, rootNode, name) {
    const link = rootNode.Links.find((l) => l.Name === name);
    if (!link) {
      throw new Error("No link found with name " + name);
    }
    const buf = await blockstore.get(cidToKey(link.Hash));
    const node = dagpb.util.deserialize(buf);
    yield* walkItems(blockstore, node);
  }
  function storeItems(blockstore, items) {
    return storePins(items, 0);
    async function storePins(pins, depth) {
      const pbHeader = pb.Set.encode({
        version: 1,
        fanout: DEFAULT_FANOUT,
        seed: depth
      });
      const header = varint.encode(pbHeader.length);
      const headerBuf = uint8ArrayConcat([header, pbHeader]);
      const fanoutLinks = [];
      for (let i = 0; i < DEFAULT_FANOUT; i++) {
        fanoutLinks.push(new DAGLink("", 1, EMPTY_KEY));
      }
      if (pins.length <= MAX_ITEMS) {
        const nodes = pins.map((item) => {
          return {
            link: new DAGLink("", 1, item.key),
            data: item.data || new Uint8Array()
          };
        }).sort((a, b) => {
          return uint8ArrayCompare(a.link.Hash.bytes, b.link.Hash.bytes);
        });
        const rootLinks = fanoutLinks.concat(nodes.map((item) => item.link));
        const rootData = uint8ArrayConcat([headerBuf, ...nodes.map((item) => item.data)]);
        return new DAGNode(rootData, rootLinks);
      } else {
        const bins = pins.reduce((bins2, pin) => {
          const n = hash(depth, pin.key) % DEFAULT_FANOUT;
          bins2[n] = n in bins2 ? bins2[n].concat([pin]) : [pin];
          return bins2;
        }, []);
        let idx = 0;
        for (const bin of bins) {
          const child = await storePins(bin, depth + 1);
          await storeChild(child, idx);
          idx++;
        }
        return new DAGNode(headerBuf, fanoutLinks);
      }
      async function storeChild(child, binIdx) {
        const buf = dagpb.util.serialize(child);
        const cid = await dagpb.util.cid(buf, {
          cidVersion: 0,
          hashAlg: multicodec.SHA2_256
        });
        await blockstore.put(cidToKey(cid), buf);
        fanoutLinks[binIdx] = new DAGLink("", child.size, cid);
      }
    }
  }
  async function storeSet(blockstore, type, cids) {
    const rootNode = await storeItems(blockstore, cids.map((cid2) => {
      return {
        key: cid2,
        data: null
      };
    }));
    const buf = rootNode.serialize(rootNode);
    const cid = await dagpb.util.cid(buf, {
      cidVersion: 0,
      hashAlg: multicodec.SHA2_256
    });
    await blockstore.put(cidToKey(cid), buf);
    return new DAGLink(type, rootNode.size, cid);
  }
  module2.exports = {
    loadSet,
    storeSet
  };
});

// node_modules/ipfs-repo-migrations/migrations/migration-9/index.js
var require_migration_9 = __commonJS((exports2, module2) => {
  "use strict";
  var CID = require_src7();
  var dagpb = require_src16();
  var cbor = require_cbor();
  var multicodec = require_src6();
  var multibase = require_src4();
  var pinset = require_pin_set();
  var {createStore} = require_utils21();
  var {cidToKey, PIN_DS_KEY, PinTypes} = require_utils22();
  var length = require_it_length();
  async function pinsToDatastore(blockstore, datastore, pinstore, onProgress) {
    if (!await datastore.has(PIN_DS_KEY)) {
      return;
    }
    const mh = await datastore.get(PIN_DS_KEY);
    const cid = new CID(mh);
    const pinRootBuf = await blockstore.get(cidToKey(cid));
    const pinRoot = dagpb.util.deserialize(pinRootBuf);
    let counter = 0;
    let pinCount;
    if (onProgress) {
      pinCount = await length(pinset.loadSet(blockstore, pinRoot, PinTypes.recursive)) + await length(pinset.loadSet(blockstore, pinRoot, PinTypes.direct));
    }
    for await (const cid2 of pinset.loadSet(blockstore, pinRoot, PinTypes.recursive)) {
      counter++;
      const pin = {
        depth: Infinity
      };
      if (cid2.version !== 0) {
        pin.version = cid2.version;
      }
      if (cid2.codec !== "dag-pb") {
        pin.codec = multicodec.getNumber(cid2.codec);
      }
      await pinstore.put(cidToKey(cid2), cbor.encode(pin));
      if (onProgress) {
        onProgress(counter / pinCount * 100, `Migrated recursive pin ${cid2}`);
      }
    }
    for await (const cid2 of pinset.loadSet(blockstore, pinRoot, PinTypes.direct)) {
      counter++;
      const pin = {
        depth: 0
      };
      if (cid2.version !== 0) {
        pin.version = cid2.version;
      }
      if (cid2.codec !== "dag-pb") {
        pin.codec = multicodec.getNumber(cid2.codec);
      }
      await pinstore.put(cidToKey(cid2), cbor.encode(pin));
      onProgress(counter / pinCount * 100, `Migrated direct pin ${cid2}`);
    }
    await blockstore.delete(cidToKey(cid));
    await datastore.delete(PIN_DS_KEY);
  }
  async function pinsToDAG(blockstore, datastore, pinstore, onProgress) {
    let recursivePins = [];
    let directPins = [];
    let counter = 0;
    let pinCount;
    if (onProgress) {
      pinCount = await length(pinstore.query({keysOnly: true}));
    }
    for await (const {key, value} of pinstore.query({})) {
      counter++;
      const pin = cbor.decode(value);
      const cid2 = new CID(pin.version || 0, pin.codec && multicodec.getName(pin.codec) || "dag-pb", multibase.decode("b" + key.toString().split("/").pop()));
      if (pin.depth === 0) {
        if (onProgress) {
          onProgress(counter / pinCount * 100, `Reverted direct pin ${cid2}`);
        }
        directPins.push(cid2);
      } else {
        if (onProgress) {
          onProgress(counter / pinCount * 100, `Reverted recursive pin ${cid2}`);
        }
        recursivePins.push(cid2);
      }
    }
    onProgress(100, "Updating pin root");
    const pinRoot = new dagpb.DAGNode(new Uint8Array(), [
      await pinset.storeSet(blockstore, PinTypes.recursive, recursivePins),
      await pinset.storeSet(blockstore, PinTypes.direct, directPins)
    ]);
    const buf = pinRoot.serialize();
    const cid = await dagpb.util.cid(buf, {
      cidVersion: 0,
      hashAlg: multicodec.SHA2_256
    });
    await blockstore.put(cidToKey(cid), buf);
    await datastore.put(PIN_DS_KEY, cid.multihash);
  }
  async function process2(repoPath, repoOptions, onProgress, fn) {
    const blockstore = createStore(repoPath, "blocks", repoOptions);
    const datastore = createStore(repoPath, "datastore", repoOptions);
    const pinstore = createStore(repoPath, "pins", repoOptions);
    await blockstore.open();
    await datastore.open();
    await pinstore.open();
    try {
      await fn(blockstore, datastore, pinstore, onProgress);
    } finally {
      await pinstore.close();
      await datastore.close();
      await blockstore.close();
    }
  }
  module2.exports = {
    version: 9,
    description: "Migrates pins to datastore",
    migrate: (repoPath, repoOptions, onProgress = () => {
    }) => {
      return process2(repoPath, repoOptions, onProgress, pinsToDatastore);
    },
    revert: (repoPath, repoOptions, onProgress = () => {
    }) => {
      return process2(repoPath, repoOptions, onProgress, pinsToDAG);
    }
  };
});

// node_modules/ipfs-repo-migrations/migrations/migration-10/index.js
var require_migration_10 = __commonJS((exports2, module2) => {
  "use strict";
  var {
    createStore,
    findLevelJs
  } = require_utils21();
  var {Key} = require_src15();
  var fromString = require_from_string8();
  var toString = require_to_string8();
  async function keysToBinary(name, store, onProgress = () => {
  }) {
    let db = findLevelJs(store);
    if (!db) {
      onProgress(`${name} did not need an upgrade`);
      return;
    }
    onProgress(`Upgrading ${name}`);
    await withEach(db, (key, value) => {
      return [
        {type: "del", key},
        {type: "put", key: fromString(key), value}
      ];
    });
  }
  async function keysToStrings(name, store, onProgress = () => {
  }) {
    let db = findLevelJs(store);
    if (!db) {
      onProgress(`${name} did not need a downgrade`);
      return;
    }
    onProgress(`Downgrading ${name}`);
    await withEach(db, (key, value) => {
      return [
        {type: "del", key},
        {type: "put", key: toString(key), value}
      ];
    });
  }
  async function process2(repoPath, repoOptions, onProgress, fn) {
    const datastores = Object.keys(repoOptions.storageBackends).filter((key) => repoOptions.storageBackends[key].name === "LevelDatastore").map((name) => ({
      name,
      store: createStore(repoPath, name, repoOptions)
    }));
    onProgress(0, `Migrating ${datastores.length} dbs`);
    let migrated = 0;
    for (const {name, store} of datastores) {
      await store.open();
      try {
        await fn(name, store, (message) => {
          onProgress(parseInt(migrated / datastores.length * 100), message);
        });
      } finally {
        migrated++;
        store.close();
      }
    }
    onProgress(100, `Migrated ${datastores.length} dbs`);
  }
  module2.exports = {
    version: 10,
    description: "Migrates datastore-level keys to binary",
    migrate: (repoPath, repoOptions, onProgress = () => {
    }) => {
      return process2(repoPath, repoOptions, onProgress, keysToBinary);
    },
    revert: (repoPath, repoOptions, onProgress = () => {
    }) => {
      return process2(repoPath, repoOptions, onProgress, keysToStrings);
    }
  };
  function withEach(db, fn) {
    function batch(operations, next) {
      const store = db.store("readwrite");
      const transaction = store.transaction;
      let index = 0;
      let error;
      transaction.onabort = () => next(error || transaction.error || new Error("aborted by user"));
      transaction.oncomplete = () => next();
      function loop() {
        var op = operations[index++];
        var key = op.key;
        try {
          var req = op.type === "del" ? store.delete(key) : store.put(op.value, key);
        } catch (err) {
          error = err;
          transaction.abort();
          return;
        }
        if (index < operations.length) {
          req.onsuccess = loop;
        }
      }
      loop();
    }
    return new Promise((resolve, reject) => {
      const it = db.iterator();
      it._deserializeKey = it._deserializeValue = (data) => data;
      next();
      function next() {
        it.next((err, key, value) => {
          if (err || key === void 0) {
            it.end((err2) => {
              if (err2) {
                reject(err2);
                return;
              }
              resolve();
            });
            return;
          }
          batch(fn(key, value), next);
        });
      }
    });
  }
});

// node_modules/ipfs-repo-migrations/migrations/index.js
var require_migrations = __commonJS((exports2, module2) => {
  "use strict";
  var emptyMigration = {
    description: "Empty migration.",
    migrate: () => {
    },
    revert: () => {
    },
    empty: true
  };
  module2.exports = [
    Object.assign({version: 1}, emptyMigration),
    Object.assign({version: 2}, emptyMigration),
    Object.assign({version: 3}, emptyMigration),
    Object.assign({version: 4}, emptyMigration),
    Object.assign({version: 5}, emptyMigration),
    Object.assign({version: 6}, emptyMigration),
    Object.assign({version: 7}, emptyMigration),
    require_migration_8(),
    require_migration_9(),
    require_migration_10()
  ];
});

// node_modules/ipfs-repo-migrations/src/errors.js
var require_errors7 = __commonJS((exports2) => {
  "use strict";
  var NonReversibleMigrationError = class extends Error {
    constructor(message) {
      super(message);
      this.name = "NonReversibleMigrationError";
      this.code = "ERR_NON_REVERSIBLE_MIGRATION";
      this.message = message;
    }
  };
  NonReversibleMigrationError.code = "ERR_NON_REVERSIBLE_MIGRATION";
  exports2.NonReversibleMigrationError = NonReversibleMigrationError;
  var NotInitializedRepoError = class extends Error {
    constructor(message) {
      super(message);
      this.name = "NotInitializedRepoError";
      this.code = "ERR_NOT_INITIALIZED_REPO";
      this.message = message;
    }
  };
  NotInitializedRepoError.code = "ERR_NOT_INITIALIZED_REPO";
  exports2.NotInitializedRepoError = NotInitializedRepoError;
  var RequiredParameterError = class extends Error {
    constructor(message) {
      super(message);
      this.name = "RequiredParameterError";
      this.code = "ERR_REQUIRED_PARAMETER";
      this.message = message;
    }
  };
  RequiredParameterError.code = "ERR_REQUIRED_PARAMETER";
  exports2.RequiredParameterError = RequiredParameterError;
  var InvalidValueError = class extends Error {
    constructor(message) {
      super(message);
      this.name = "InvalidValueError";
      this.code = "ERR_INVALID_VALUE";
      this.message = message;
    }
  };
  InvalidValueError.code = "ERR_INVALID_VALUE";
  exports2.InvalidValueError = InvalidValueError;
  var MissingRepoOptionsError = class extends Error {
    constructor(message) {
      super(message);
      this.name = "MissingRepoOptionsError";
      this.code = "ERR_MISSING_REPO_OPTIONS";
      this.message = message;
    }
  };
  MissingRepoOptionsError.code = "ERR_MISSING_REPO_OPTIONS";
  exports2.MissingRepoOptionsError = MissingRepoOptionsError;
});

// node_modules/ipfs-repo-migrations/src/repo/init.js
var require_init = __commonJS((exports2) => {
  "use strict";
  var log = require_browser4()("ipfs:repo:migrator:repo:init");
  var {CONFIG_KEY, VERSION_KEY, createStore} = require_utils21();
  var {MissingRepoOptionsError} = require_errors7();
  exports2.isRepoInitialized = async function isRepoInitialized(path, repoOptions) {
    if (!repoOptions) {
      throw new MissingRepoOptionsError("Please pass repo options when trying to open a repo");
    }
    let root;
    try {
      root = createStore(path, "root", repoOptions);
      await root.open();
      const versionCheck = await root.has(VERSION_KEY);
      const configCheck = await root.has(CONFIG_KEY);
      if (!versionCheck || !configCheck) {
        log(`Version entry present: ${versionCheck}`);
        log(`Config entry present: ${configCheck}`);
        return false;
      }
      return true;
    } catch (e) {
      log("While checking if repo is initialized error was thrown: " + e.message);
      return false;
    } finally {
      if (root !== void 0) {
        await root.close();
      }
    }
  };
});

// node_modules/ipfs-repo-migrations/src/repo/version.js
var require_version2 = __commonJS((exports2) => {
  "use strict";
  var repoInit = require_init();
  var {MissingRepoOptionsError, NotInitializedRepoError} = require_errors7();
  var {VERSION_KEY, createStore} = require_utils21();
  var uint8ArrayFromString = require_from_string8();
  var uint8ArrayToString = require_to_string8();
  exports2.getVersion = getVersion;
  async function getVersion(path, repoOptions) {
    if (!await repoInit.isRepoInitialized(path, repoOptions)) {
      throw new NotInitializedRepoError(`Repo in path ${path} is not initialized!`);
    }
    if (!repoOptions) {
      throw new MissingRepoOptionsError("Please pass repo options when trying to open a repo");
    }
    const store = createStore(path, "root", repoOptions);
    await store.open();
    let version = await store.get(VERSION_KEY);
    if (version instanceof Uint8Array) {
      version = uint8ArrayToString(version);
    }
    version = parseInt(version);
    await store.close();
    return version;
  }
  async function setVersion(path, version, repoOptions) {
    if (!repoOptions) {
      throw new MissingRepoOptionsError("Please pass repo options when trying to open a repo");
    }
    const store = createStore(path, "root", repoOptions);
    await store.open();
    await store.put(VERSION_KEY, uint8ArrayFromString(String(version)));
    await store.close();
  }
  exports2.setVersion = setVersion;
});

// node_modules/ipfs-repo-migrations/src/repo/lock-memory.js
var require_lock_memory = __commonJS((exports2) => {
  "use strict";
  var debug = require_browser4();
  var log = debug("ipfs:repo:migrator:repo_mem_lock");
  var lockFile = "repo.lock";
  var LOCKS = {};
  exports2.lock = async function lock(version, dir) {
    const file = dir + "/" + lockFile;
    log("locking %s", file);
    if (LOCKS[file] === true) {
      throw Error(`There is already present lock for: ${file}`);
    }
    LOCKS[file] = true;
    return {
      close() {
        if (LOCKS[file]) {
          log("releasing lock %s", file);
          delete LOCKS[file];
        }
      }
    };
  };
});

// node_modules/ipfs-repo-migrations/src/index.js
var require_src31 = __commonJS((exports2) => {
  "use strict";
  var defaultMigrations = require_migrations();
  var repoVersion = require_version2();
  var repoLock = require_lock_memory();
  var errors = require_errors7();
  var log = require_browser4()("ipfs:repo:migrator");
  exports2.getCurrentRepoVersion = repoVersion.getVersion;
  exports2.errors = errors;
  function getLatestMigrationVersion(migrations) {
    migrations = migrations || defaultMigrations;
    if (!Array.isArray(migrations) || migrations.length === 0) {
      return 0;
    }
    return migrations[migrations.length - 1].version;
  }
  exports2.getLatestMigrationVersion = getLatestMigrationVersion;
  async function migrate(path, repoOptions, toVersion, {ignoreLock = false, onProgress, isDryRun = false, migrations}) {
    migrations = migrations || defaultMigrations;
    if (!path) {
      throw new errors.RequiredParameterError("Path argument is required!");
    }
    if (!repoOptions) {
      throw new errors.RequiredParameterError("repoOptions argument is required!");
    }
    if (!toVersion) {
      throw new errors.RequiredParameterError("toVersion argument is required!");
    }
    if (!Number.isInteger(toVersion) || toVersion <= 0) {
      throw new errors.InvalidValueError("Version has to be positive integer!");
    }
    const currentVersion = await repoVersion.getVersion(path, repoOptions);
    if (currentVersion === toVersion) {
      log("Nothing to migrate.");
      return;
    }
    if (currentVersion > toVersion) {
      throw new errors.InvalidValueError(`Current repo's version (${currentVersion}) is higher then toVersion (${toVersion}), you probably wanted to revert it?`);
    }
    verifyAvailableMigrations(migrations, currentVersion, toVersion);
    let lock;
    if (!isDryRun && !ignoreLock) {
      lock = await repoLock.lock(currentVersion, path);
    }
    try {
      for (const migration of migrations) {
        if (toVersion !== void 0 && migration.version > toVersion) {
          break;
        }
        if (migration.version <= currentVersion) {
          continue;
        }
        log(`Migrating version ${migration.version}`);
        try {
          if (!isDryRun) {
            let progressCallback;
            if (onProgress) {
              progressCallback = (percent, message) => onProgress(migration.version, percent.toFixed(2), message);
            }
            await migration.migrate(path, repoOptions, progressCallback);
          }
        } catch (e) {
          const lastSuccessfullyMigratedVersion = migration.version - 1;
          log(`An exception was raised during execution of migration. Setting the repo's version to last successfully migrated version: ${lastSuccessfullyMigratedVersion}`);
          await repoVersion.setVersion(path, lastSuccessfullyMigratedVersion, repoOptions);
          throw new Error(`During migration to version ${migration.version} exception was raised: ${e.stack || e.message || e}`);
        }
        log(`Migrating to version ${migration.version} finished`);
      }
      if (!isDryRun) {
        await repoVersion.setVersion(path, toVersion || getLatestMigrationVersion(migrations), repoOptions);
      }
      log("Repo successfully migrated", toVersion !== void 0 ? `to version ${toVersion}!` : "to latest version!");
    } finally {
      if (!isDryRun && !ignoreLock) {
        await lock.close();
      }
    }
  }
  exports2.migrate = migrate;
  async function revert(path, repoOptions, toVersion, {ignoreLock = false, onProgress, isDryRun = false, migrations}) {
    migrations = migrations || defaultMigrations;
    if (!path) {
      throw new errors.RequiredParameterError("Path argument is required!");
    }
    if (!repoOptions) {
      throw new errors.RequiredParameterError("repoOptions argument is required!");
    }
    if (!toVersion) {
      throw new errors.RequiredParameterError("When reverting migrations, you have to specify to which version to revert!");
    }
    if (!Number.isInteger(toVersion) || toVersion <= 0) {
      throw new errors.InvalidValueError("Version has to be positive integer!");
    }
    const currentVersion = await repoVersion.getVersion(path, repoOptions);
    if (currentVersion === toVersion) {
      log("Nothing to revert.");
      return;
    }
    if (currentVersion < toVersion) {
      throw new errors.InvalidValueError(`Current repo's version (${currentVersion}) is lower then toVersion (${toVersion}), you probably wanted to migrate it?`);
    }
    verifyAvailableMigrations(migrations, toVersion, currentVersion, true);
    let lock;
    if (!isDryRun && !ignoreLock)
      lock = await repoLock.lock(currentVersion, path);
    log(`Reverting from version ${currentVersion} to ${toVersion}`);
    try {
      const reversedMigrationArray = migrations.slice().reverse();
      for (const migration of reversedMigrationArray) {
        if (migration.version <= toVersion) {
          break;
        }
        if (migration.version > currentVersion) {
          continue;
        }
        log(`Reverting migration version ${migration.version}`);
        try {
          if (!isDryRun) {
            let progressCallback;
            if (onProgress) {
              progressCallback = (percent, message) => onProgress(migration.version, percent.toFixed(2), message);
            }
            await migration.revert(path, repoOptions, progressCallback);
          }
        } catch (e) {
          const lastSuccessfullyRevertedVersion = migration.version;
          log(`An exception was raised during execution of migration. Setting the repo's version to last successfully reverted version: ${lastSuccessfullyRevertedVersion}`);
          await repoVersion.setVersion(path, lastSuccessfullyRevertedVersion, repoOptions);
          e.message = `During reversion to version ${migration.version} exception was raised: ${e.message}`;
          throw e;
        }
        log(`Reverting to version ${migration.version} finished`);
      }
      if (!isDryRun) {
        await repoVersion.setVersion(path, toVersion, repoOptions);
      }
      log(`All migrations successfully reverted to version ${toVersion}!`);
    } finally {
      if (!isDryRun && !ignoreLock) {
        await lock.close();
      }
    }
  }
  exports2.revert = revert;
  function verifyAvailableMigrations(migrations, fromVersion, toVersion, checkReversibility = false) {
    let migrationCounter = 0;
    for (const migration of migrations) {
      if (migration.version > toVersion) {
        break;
      }
      if (migration.version > fromVersion) {
        if (checkReversibility && !migration.revert) {
          throw new errors.NonReversibleMigrationError(`It is not possible to revert to version ${fromVersion} because migration version ${migration.version} is not reversible. Cancelling reversion.`);
        }
        migrationCounter++;
      }
    }
    if (migrationCounter !== toVersion - fromVersion) {
      throw new errors.InvalidValueError(`The ipfs-repo-migrations package does not have all migration to migrate from version ${fromVersion} to ${toVersion}`);
    }
  }
});

// node_modules/bytes/index.js
var require_bytes2 = __commonJS((exports2, module2) => {
  /*!
   * bytes
   * Copyright(c) 2012-2014 TJ Holowaychuk
   * Copyright(c) 2015 Jed Watson
   * MIT Licensed
   */
  "use strict";
  module2.exports = bytes;
  module2.exports.format = format;
  module2.exports.parse = parse;
  var formatThousandsRegExp = /\B(?=(\d{3})+(?!\d))/g;
  var formatDecimalsRegExp = /(?:\.0*|(\.[^0]+)0+)$/;
  var map = {
    b: 1,
    kb: 1 << 10,
    mb: 1 << 20,
    gb: 1 << 30,
    tb: Math.pow(1024, 4),
    pb: Math.pow(1024, 5)
  };
  var parseRegExp = /^((-|\+)?(\d+(?:\.\d+)?)) *(kb|mb|gb|tb|pb)$/i;
  function bytes(value, options) {
    if (typeof value === "string") {
      return parse(value);
    }
    if (typeof value === "number") {
      return format(value, options);
    }
    return null;
  }
  function format(value, options) {
    if (!Number.isFinite(value)) {
      return null;
    }
    var mag = Math.abs(value);
    var thousandsSeparator = options && options.thousandsSeparator || "";
    var unitSeparator = options && options.unitSeparator || "";
    var decimalPlaces = options && options.decimalPlaces !== void 0 ? options.decimalPlaces : 2;
    var fixedDecimals = Boolean(options && options.fixedDecimals);
    var unit = options && options.unit || "";
    if (!unit || !map[unit.toLowerCase()]) {
      if (mag >= map.pb) {
        unit = "PB";
      } else if (mag >= map.tb) {
        unit = "TB";
      } else if (mag >= map.gb) {
        unit = "GB";
      } else if (mag >= map.mb) {
        unit = "MB";
      } else if (mag >= map.kb) {
        unit = "KB";
      } else {
        unit = "B";
      }
    }
    var val = value / map[unit.toLowerCase()];
    var str = val.toFixed(decimalPlaces);
    if (!fixedDecimals) {
      str = str.replace(formatDecimalsRegExp, "$1");
    }
    if (thousandsSeparator) {
      str = str.replace(formatThousandsRegExp, thousandsSeparator);
    }
    return str + unitSeparator + unit;
  }
  function parse(val) {
    if (typeof val === "number" && !isNaN(val)) {
      return val;
    }
    if (typeof val !== "string") {
      return null;
    }
    var results = parseRegExp.exec(val);
    var floatValue;
    var unit = "b";
    if (!results) {
      floatValue = parseInt(val, 10);
      unit = "b";
    } else {
      floatValue = parseFloat(results[1]);
      unit = results[4].toLowerCase();
    }
    return Math.floor(map[unit] * floatValue);
  }
});

// node_modules/ipfs-utils/src/path-join.browser.js
var require_path_join_browser = __commonJS((exports2, module2) => {
  "use strict";
  function join(...args) {
    if (args.length === 0) {
      return ".";
    }
    return args.join("/");
  }
  module2.exports = join;
});

// node_modules/ipfs-repo/src/constants.js
var require_constants7 = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = {
    repoVersion: 10
  };
});

// node_modules/ipfs-repo/src/backends.js
var require_backends = __commonJS((exports2) => {
  "use strict";
  exports2.create = function createBackend(name, path, options) {
    const Ctor = options.storageBackends[name];
    const backendOptions = Object.assign({}, options.storageBackendOptions[name] || {});
    return new Ctor(path, backendOptions);
  };
});

// node_modules/ipfs-repo/node_modules/uint8arrays/to-string.js
var require_to_string9 = __commonJS((exports2, module2) => {
  "use strict";
  var {encoding: getCodec} = require_src4();
  var {TextDecoder: TextDecoder2} = require_lib_browser();
  var utf8Decoder = new TextDecoder2("utf8");
  function uint8ArrayToAsciiString(array) {
    let string = "";
    for (let i = 0; i < array.length; i++) {
      string += String.fromCharCode(array[i]);
    }
    return string;
  }
  function toString(array, encoding = "utf8") {
    if (encoding === "utf8" || encoding === "utf-8") {
      return utf8Decoder.decode(array);
    }
    if (encoding === "ascii") {
      return uint8ArrayToAsciiString(array);
    }
    return getCodec(encoding).encode(array);
  }
  module2.exports = toString;
});

// node_modules/ipfs-repo/node_modules/uint8arrays/from-string.js
var require_from_string9 = __commonJS((exports2, module2) => {
  "use strict";
  var {encoding: getCodec} = require_src4();
  var {TextEncoder: TextEncoder2} = require_lib_browser();
  var utf8Encoder = new TextEncoder2();
  function asciiStringToUint8Array(string) {
    const array = new Uint8Array(string.length);
    for (let i = 0; i < string.length; i++) {
      array[i] = string.charCodeAt(i);
    }
    return array;
  }
  function fromString(string, encoding = "utf8") {
    if (encoding === "utf8" || encoding === "utf-8") {
      return utf8Encoder.encode(string);
    }
    if (encoding === "ascii") {
      return asciiStringToUint8Array(string);
    }
    return getCodec(encoding).decode(string);
  }
  module2.exports = fromString;
});

// node_modules/ipfs-repo/src/version.js
var require_version3 = __commonJS((exports2, module2) => {
  "use strict";
  var Key = require_src15().Key;
  var debug = require_browser4();
  var log = debug("ipfs:repo:version");
  var uint8ArrayToString = require_to_string9();
  var uint8ArrayFromString = require_from_string9();
  var {
    hasWithFallback,
    getWithFallback
  } = require_utils21();
  var versionKey = new Key("version");
  module2.exports = (store) => {
    return {
      async exists() {
        return hasWithFallback(versionKey, store.has.bind(store), store);
      },
      async get() {
        const buf = await getWithFallback(versionKey, store.get.bind(store), store.has.bind(store), store);
        return parseInt(uint8ArrayToString(buf), 10);
      },
      async set(version) {
        return store.put(versionKey, uint8ArrayFromString(String(version)));
      },
      async check(expected) {
        const version = await this.get();
        log("comparing version: %s and %s", version, expected);
        const compatibleVersion = version === 6 && expected === 7 || expected === 6 && version === 7;
        return version === expected || compatibleVersion;
      }
    };
  };
});

// node_modules/just-safe-set/index.js
var require_just_safe_set = __commonJS((exports2, module2) => {
  module2.exports = set;
  function set(obj, props, value) {
    if (typeof props == "string") {
      props = props.split(".");
    }
    if (typeof props == "symbol") {
      props = [props];
    }
    var lastProp = props.pop();
    if (!lastProp) {
      return false;
    }
    var thisProp;
    while (thisProp = props.shift()) {
      if (typeof obj[thisProp] == "undefined") {
        obj[thisProp] = {};
      }
      obj = obj[thisProp];
      if (!obj || typeof obj != "object") {
        return false;
      }
    }
    obj[lastProp] = value;
    return true;
  }
});

// node_modules/ipfs-repo/src/errors/index.js
var require_errors8 = __commonJS((exports2) => {
  "use strict";
  var LockExistsError = class extends Error {
    constructor(message) {
      super(message);
      this.name = "LockExistsError";
      this.code = LockExistsError.code;
    }
  };
  LockExistsError.code = "ERR_LOCK_EXISTS";
  exports2.LockExistsError = LockExistsError;
  var NotFoundError = class extends Error {
    constructor(message) {
      super(message);
      this.name = "NotFoundError";
      this.code = NotFoundError.code;
    }
  };
  NotFoundError.code = "ERR_NOT_FOUND";
  exports2.NotFoundError = NotFoundError;
  var InvalidRepoVersionError = class extends Error {
    constructor(message) {
      super(message);
      this.name = "InvalidRepoVersionError";
      this.code = InvalidRepoVersionError.code;
    }
  };
  InvalidRepoVersionError.code = "ERR_INVALID_REPO_VERSION";
  exports2.InvalidRepoVersionError = InvalidRepoVersionError;
  exports2.ERR_REPO_NOT_INITIALIZED = "ERR_REPO_NOT_INITIALIZED";
  exports2.ERR_REPO_ALREADY_OPEN = "ERR_REPO_ALREADY_OPEN";
  exports2.ERR_REPO_ALREADY_CLOSED = "ERR_REPO_ALREADY_CLOSED";
});

// node_modules/ipfs-repo/src/config.js
var require_config3 = __commonJS((exports2, module2) => {
  "use strict";
  var Key = require_src15().Key;
  var {default: Queue} = require_dist();
  var _get = require_just_safe_get();
  var _set = require_just_safe_set();
  var errcode = require_err_code();
  var errors = require_errors8();
  var uint8ArrayToString = require_to_string9();
  var uint8ArrayFromString = require_from_string9();
  var {
    hasWithFallback,
    getWithFallback
  } = require_utils21();
  var configKey = new Key("config");
  module2.exports = (store) => {
    const setQueue = new Queue({concurrency: 1});
    const configStore = {
      async getAll(options = {}) {
        return configStore.get(void 0, options);
      },
      async get(key, options = {}) {
        if (!key) {
          key = void 0;
        }
        const encodedValue = await getWithFallback(configKey, store.get.bind(store), store.has.bind(store), store);
        if (options.signal && options.signal.aborted) {
          return;
        }
        const config = JSON.parse(uint8ArrayToString(encodedValue));
        if (key !== void 0 && _get(config, key) === void 0) {
          throw new errors.NotFoundError(`Key ${key} does not exist in config`);
        }
        const value = key !== void 0 ? _get(config, key) : config;
        return value;
      },
      async set(key, value, options = {}) {
        if (arguments.length === 1) {
          value = key;
          key = void 0;
        } else if (!key || typeof key !== "string") {
          throw errcode(new Error("Invalid key type: " + typeof key), "ERR_INVALID_KEY");
        }
        if (value === void 0 || value instanceof Uint8Array) {
          throw errcode(new Error("Invalid value type: " + typeof value), "ERR_INVALID_VALUE");
        }
        return setQueue.add(() => _maybeDoSet({
          key,
          value
        }, options.signal));
      },
      async replace(value, options = {}) {
        if (!value || value instanceof Uint8Array) {
          throw errcode(new Error("Invalid value type: " + typeof value), "ERR_INVALID_VALUE");
        }
        return setQueue.add(() => _maybeDoSet({
          key: void 0,
          value
        }, options.signal));
      },
      async exists() {
        return hasWithFallback(configKey, store.has.bind(store), store);
      }
    };
    return configStore;
    async function _maybeDoSet(m, signal) {
      if (signal && signal.aborted) {
        return;
      }
      const key = m.key;
      const value = m.value;
      if (key) {
        const config = await configStore.get();
        _set(config, key, value);
        return _saveAll(config);
      }
      return _saveAll(value);
    }
    function _saveAll(config) {
      const buf = uint8ArrayFromString(JSON.stringify(config, null, 2));
      return store.put(configKey, buf);
    }
  };
});

// node_modules/sort-keys/index.js
var require_sort_keys = __commonJS((exports2, module2) => {
  "use strict";
  var isPlainObject = require_is_plain_obj();
  module2.exports = (object, options = {}) => {
    if (!isPlainObject(object) && !Array.isArray(object)) {
      throw new TypeError("Expected a plain object or array");
    }
    const {deep} = options;
    const seenInput = [];
    const seenOutput = [];
    const deepSortArray = (array) => {
      const seenIndex = seenInput.indexOf(array);
      if (seenIndex !== -1) {
        return seenOutput[seenIndex];
      }
      const result = [];
      seenInput.push(array);
      seenOutput.push(result);
      result.push(...array.map((item) => {
        if (Array.isArray(item)) {
          return deepSortArray(item);
        }
        if (isPlainObject(item)) {
          return sortKeys(item);
        }
        return item;
      }));
      return result;
    };
    const sortKeys = (object2) => {
      const seenIndex = seenInput.indexOf(object2);
      if (seenIndex !== -1) {
        return seenOutput[seenIndex];
      }
      const result = {};
      const keys = Object.keys(object2).sort(options.compare);
      seenInput.push(object2);
      seenOutput.push(result);
      for (const key of keys) {
        const value = object2[key];
        let newValue;
        if (deep && Array.isArray(value)) {
          newValue = deepSortArray(value);
        } else {
          newValue = deep && isPlainObject(value) ? sortKeys(value) : value;
        }
        Object.defineProperty(result, key, {
          ...Object.getOwnPropertyDescriptor(object2, key),
          value: newValue
        });
      }
      return result;
    };
    if (Array.isArray(object)) {
      return deep ? deepSortArray(object) : object.slice();
    }
    return sortKeys(object);
  };
});

// node_modules/ipfs-repo/src/spec.js
var require_spec = __commonJS((exports2, module2) => {
  "use strict";
  var Key = require_src15().Key;
  var sortKeys = require_sort_keys();
  var uint8ArrayToString = require_to_string9();
  var uint8ArrayFromString = require_from_string9();
  var specKey = new Key("datastore_spec");
  module2.exports = (store) => {
    return {
      async exists() {
        return store.has(specKey);
      },
      async get() {
        const buf = await store.get(specKey);
        return JSON.parse(uint8ArrayToString(buf));
      },
      async set(spec) {
        return store.put(specKey, uint8ArrayFromString(JSON.stringify(sortKeys(spec, {deep: true}))));
      }
    };
  };
});

// node_modules/ipfs-repo/src/api-addr.js
var require_api_addr = __commonJS((exports2, module2) => {
  "use strict";
  var Key = require_src15().Key;
  var uint8ArrayFromString = require_from_string9();
  var apiFile = new Key("api");
  module2.exports = (store) => {
    return {
      async get() {
        const value = await store.get(apiFile);
        return value && value.toString();
      },
      async set(value) {
        return store.put(apiFile, uint8ArrayFromString(value.toString()));
      },
      async delete() {
        return store.delete(apiFile);
      }
    };
  };
});

// node_modules/ipfs-repo/src/blockstore-utils.js
var require_blockstore_utils = __commonJS((exports2) => {
  "use strict";
  var {Key} = require_src15();
  var CID = require_src7();
  var multibase = require_src4();
  var errcode = require_err_code();
  var uint8ArrayToString = require_to_string9();
  exports2.cidToKey = (cid) => {
    if (!CID.isCID(cid)) {
      throw errcode(new Error("Not a valid cid"), "ERR_INVALID_CID");
    }
    return new Key("/" + uint8ArrayToString(multibase.encode("base32", cid.multihash)).slice(1).toUpperCase(), false);
  };
  exports2.keyToCid = (key) => {
    return new CID(1, "raw", multibase.decode("b" + key.toString().slice(1).toLowerCase()));
  };
});

// node_modules/fast-fifo/fixed-size.js
var require_fixed_size2 = __commonJS((exports2, module2) => {
  module2.exports = class FixedFIFO {
    constructor(hwm) {
      if (!(hwm > 0) || (hwm - 1 & hwm) !== 0)
        throw new Error("Max size for a FixedFIFO should be a power of two");
      this.buffer = new Array(hwm);
      this.mask = hwm - 1;
      this.top = 0;
      this.btm = 0;
      this.next = null;
    }
    push(data) {
      if (this.buffer[this.top] !== void 0)
        return false;
      this.buffer[this.top] = data;
      this.top = this.top + 1 & this.mask;
      return true;
    }
    shift() {
      const last = this.buffer[this.btm];
      if (last === void 0)
        return void 0;
      this.buffer[this.btm] = void 0;
      this.btm = this.btm + 1 & this.mask;
      return last;
    }
    isEmpty() {
      return this.buffer[this.btm] === void 0;
    }
  };
});

// node_modules/fast-fifo/index.js
var require_fast_fifo = __commonJS((exports2, module2) => {
  var FixedFIFO = require_fixed_size2();
  module2.exports = class FastFIFO {
    constructor(hwm) {
      this.hwm = hwm || 16;
      this.head = new FixedFIFO(this.hwm);
      this.tail = this.head;
    }
    push(val) {
      if (!this.head.push(val)) {
        const prev = this.head;
        this.head = prev.next = new FixedFIFO(2 * this.head.buffer.length);
        this.head.push(val);
      }
    }
    shift() {
      const val = this.tail.shift();
      if (val === void 0 && this.tail.next) {
        const next = this.tail.next;
        this.tail.next = null;
        this.tail = next;
        return this.tail.shift();
      }
      return val;
    }
    isEmpty() {
      return this.head.isEmpty();
    }
  };
});

// node_modules/it-pushable/index.js
var require_it_pushable = __commonJS((exports2, module2) => {
  var FIFO = require_fast_fifo();
  module2.exports = (options) => {
    options = options || {};
    let onEnd;
    if (typeof options === "function") {
      onEnd = options;
      options = {};
    } else {
      onEnd = options.onEnd;
    }
    let buffer = new FIFO();
    let pushable, onNext, ended;
    const waitNext = () => {
      if (!buffer.isEmpty()) {
        if (options.writev) {
          let next2;
          const values = [];
          while (!buffer.isEmpty()) {
            next2 = buffer.shift();
            if (next2.error)
              throw next2.error;
            values.push(next2.value);
          }
          return {done: next2.done, value: values};
        }
        const next = buffer.shift();
        if (next.error)
          throw next.error;
        return next;
      }
      if (ended)
        return {done: true};
      return new Promise((resolve, reject) => {
        onNext = (next) => {
          onNext = null;
          if (next.error) {
            reject(next.error);
          } else {
            if (options.writev && !next.done) {
              resolve({done: next.done, value: [next.value]});
            } else {
              resolve(next);
            }
          }
          return pushable;
        };
      });
    };
    const bufferNext = (next) => {
      if (onNext)
        return onNext(next);
      buffer.push(next);
      return pushable;
    };
    const bufferError = (err) => {
      buffer = new FIFO();
      if (onNext)
        return onNext({error: err});
      buffer.push({error: err});
      return pushable;
    };
    const push = (value) => {
      if (ended)
        return pushable;
      return bufferNext({done: false, value});
    };
    const end = (err) => {
      if (ended)
        return pushable;
      ended = true;
      return err ? bufferError(err) : bufferNext({done: true});
    };
    const _return = () => {
      buffer = new FIFO();
      end();
      return {done: true};
    };
    const _throw = (err) => {
      end(err);
      return {done: true};
    };
    pushable = {
      [Symbol.asyncIterator]() {
        return this;
      },
      next: waitNext,
      return: _return,
      throw: _throw,
      push,
      end
    };
    if (!onEnd)
      return pushable;
    const _pushable = pushable;
    pushable = {
      [Symbol.asyncIterator]() {
        return this;
      },
      next() {
        return _pushable.next();
      },
      throw(err) {
        _pushable.throw(err);
        if (onEnd) {
          onEnd(err);
          onEnd = null;
        }
        return {done: true};
      },
      return() {
        _pushable.return();
        if (onEnd) {
          onEnd();
          onEnd = null;
        }
        return {done: true};
      },
      push,
      end(err) {
        _pushable.end(err);
        if (onEnd) {
          onEnd(err);
          onEnd = null;
        }
        return pushable;
      }
    };
    return pushable;
  };
});

// node_modules/ipfs-repo/src/blockstore.js
var require_blockstore = __commonJS((exports2, module2) => {
  "use strict";
  var core = require_src22();
  var ShardingStore = core.ShardingDatastore;
  var Block = require_src26();
  var {cidToKey, keyToCid} = require_blockstore_utils();
  var map = require_it_map();
  var drain = require_it_drain();
  var pushable = require_it_pushable();
  module2.exports = async (filestore, options) => {
    const store = await maybeWithSharding(filestore, options);
    return createBaseStore(store);
  };
  function maybeWithSharding(filestore, options) {
    if (options.sharding) {
      const shard = new core.shard.NextToLast(2);
      return ShardingStore.createOrOpen(filestore, shard);
    }
    return filestore;
  }
  function createBaseStore(store) {
    return {
      async *query(query, options) {
        for await (const {key, value} of store.query(query, options)) {
          if (query.keysOnly) {
            yield keyToCid(key);
            continue;
          }
          yield new Block(value, keyToCid(key));
        }
      },
      async get(cid, options) {
        const key = cidToKey(cid);
        const blockData = await store.get(key, options);
        return new Block(blockData, cid);
      },
      async *getMany(cids, options) {
        for await (const cid of cids) {
          yield this.get(cid, options);
        }
      },
      async put(block, options) {
        if (!Block.isBlock(block)) {
          throw new Error("invalid block");
        }
        const key = cidToKey(block.cid);
        const exists = await store.has(key, options);
        if (!exists) {
          await store.put(key, block.data, options);
        }
        return block;
      },
      async *putMany(blocks, options) {
        const output = pushable();
        const runner = process && process.nextTick ? process.nextTick : setImmediate;
        runner(async () => {
          try {
            await drain(store.putMany(async function* () {
              for await (const block of blocks) {
                const key = cidToKey(block.cid);
                const exists = await store.has(key, options);
                if (!exists) {
                  yield {key, value: block.data};
                }
                output.push(block);
              }
            }()));
            output.end();
          } catch (err) {
            output.end(err);
          }
        });
        yield* output;
      },
      async has(cid, options) {
        return store.has(cidToKey(cid), options);
      },
      async delete(cid, options) {
        return store.delete(cidToKey(cid), options);
      },
      async *deleteMany(cids, options) {
        yield* store.deleteMany(map(cids, (cid) => cidToKey(cid)), options);
      },
      async close() {
        return store.close();
      }
    };
  }
});

// node_modules/xtend/immutable.js
var require_immutable = __commonJS((exports2, module2) => {
  module2.exports = extend;
  var hasOwnProperty = Object.prototype.hasOwnProperty;
  function extend() {
    var target = {};
    for (var i = 0; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  }
});

// node_modules/xtend/mutable.js
var require_mutable = __commonJS((exports2, module2) => {
  module2.exports = extend;
  var hasOwnProperty = Object.prototype.hasOwnProperty;
  function extend(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      for (var key in source) {
        if (hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  }
});

// node_modules/level-supports/index.js
var require_level_supports = __commonJS((exports2, module2) => {
  "use strict";
  var xtend = require_immutable();
  var assign = require_mutable();
  module2.exports = function supports() {
    var manifest = xtend.apply(null, arguments);
    return assign(manifest, {
      bufferKeys: manifest.bufferKeys || false,
      snapshots: manifest.snapshots || false,
      permanence: manifest.permanence || false,
      seek: manifest.seek || false,
      clear: manifest.clear || false,
      status: manifest.status || false,
      createIfMissing: manifest.createIfMissing || false,
      errorIfExists: manifest.errorIfExists || false,
      deferredOpen: manifest.deferredOpen || false,
      openCallback: manifest.openCallback || false,
      promises: manifest.promises || false,
      streams: manifest.streams || false,
      encodings: manifest.encodings || false,
      additionalMethods: xtend(manifest.additionalMethods)
    });
  };
});

// node_modules/immediate/lib/nextTick.js
var require_nextTick = __commonJS((exports2) => {
  "use strict";
  exports2.test = function() {
    return typeof process !== "undefined" && !process.browser;
  };
  exports2.install = function(func) {
    return function() {
      process.nextTick(func);
    };
  };
});

// node_modules/immediate/lib/queueMicrotask.js
var require_queueMicrotask = __commonJS((exports2) => {
  "use strict";
  exports2.test = function() {
    return typeof global.queueMicrotask === "function";
  };
  exports2.install = function(func) {
    return function() {
      global.queueMicrotask(func);
    };
  };
});

// node_modules/immediate/lib/mutation.js
var require_mutation = __commonJS((exports2) => {
  "use strict";
  var Mutation = global.MutationObserver || global.WebKitMutationObserver;
  exports2.test = function() {
    return Mutation;
  };
  exports2.install = function(handle) {
    var called = 0;
    var observer = new Mutation(handle);
    var element = global.document.createTextNode("");
    observer.observe(element, {
      characterData: true
    });
    return function() {
      element.data = called = ++called % 2;
    };
  };
});

// node_modules/immediate/lib/messageChannel.js
var require_messageChannel = __commonJS((exports2) => {
  "use strict";
  exports2.test = function() {
    if (global.setImmediate) {
      return false;
    }
    return typeof global.MessageChannel !== "undefined";
  };
  exports2.install = function(func) {
    var channel = new global.MessageChannel();
    channel.port1.onmessage = func;
    return function() {
      channel.port2.postMessage(0);
    };
  };
});

// node_modules/immediate/lib/stateChange.js
var require_stateChange = __commonJS((exports2) => {
  "use strict";
  exports2.test = function() {
    return "document" in global && "onreadystatechange" in global.document.createElement("script");
  };
  exports2.install = function(handle) {
    return function() {
      var scriptEl = global.document.createElement("script");
      scriptEl.onreadystatechange = function() {
        handle();
        scriptEl.onreadystatechange = null;
        scriptEl.parentNode.removeChild(scriptEl);
        scriptEl = null;
      };
      global.document.documentElement.appendChild(scriptEl);
      return handle;
    };
  };
});

// node_modules/immediate/lib/timeout.js
var require_timeout = __commonJS((exports2) => {
  "use strict";
  exports2.test = function() {
    return true;
  };
  exports2.install = function(t) {
    return function() {
      setTimeout(t, 0);
    };
  };
});

// node_modules/immediate/lib/index.js
var require_lib6 = __commonJS((exports2, module2) => {
  "use strict";
  var types = [
    require_nextTick(),
    require_queueMicrotask(),
    require_mutation(),
    require_messageChannel(),
    require_stateChange(),
    require_timeout()
  ];
  var draining;
  var currentQueue;
  var queueIndex = -1;
  var queue = [];
  var scheduled = false;
  function cleanUpNextTick() {
    if (!draining || !currentQueue) {
      return;
    }
    draining = false;
    if (currentQueue.length) {
      queue = currentQueue.concat(queue);
    } else {
      queueIndex = -1;
    }
    if (queue.length) {
      nextTick();
    }
  }
  function nextTick() {
    if (draining) {
      return;
    }
    scheduled = false;
    draining = true;
    var len2 = queue.length;
    var timeout = setTimeout(cleanUpNextTick);
    while (len2) {
      currentQueue = queue;
      queue = [];
      while (currentQueue && ++queueIndex < len2) {
        currentQueue[queueIndex].run();
      }
      queueIndex = -1;
      len2 = queue.length;
    }
    currentQueue = null;
    queueIndex = -1;
    draining = false;
    clearTimeout(timeout);
  }
  var scheduleDrain;
  var i = -1;
  var len = types.length;
  while (++i < len) {
    if (types[i] && types[i].test && types[i].test()) {
      scheduleDrain = types[i].install(nextTick);
      break;
    }
  }
  function Item(fun, array) {
    this.fun = fun;
    this.array = array;
  }
  Item.prototype.run = function() {
    var fun = this.fun;
    var array = this.array;
    switch (array.length) {
      case 0:
        return fun();
      case 1:
        return fun(array[0]);
      case 2:
        return fun(array[0], array[1]);
      case 3:
        return fun(array[0], array[1], array[2]);
      default:
        return fun.apply(null, array);
    }
  };
  module2.exports = immediate;
  function immediate(task) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
      for (var i2 = 1; i2 < arguments.length; i2++) {
        args[i2 - 1] = arguments[i2];
      }
    }
    queue.push(new Item(task, args));
    if (!scheduled && !draining) {
      scheduled = true;
      scheduleDrain();
    }
  }
});

// node_modules/abstract-leveldown/next-tick-browser.js
var require_next_tick_browser = __commonJS((exports2, module2) => {
  module2.exports = require_lib6();
});

// node_modules/abstract-leveldown/abstract-iterator.js
var require_abstract_iterator = __commonJS((exports2, module2) => {
  var nextTick = require_next_tick_browser();
  function AbstractIterator(db) {
    if (typeof db !== "object" || db === null) {
      throw new TypeError("First argument must be an abstract-leveldown compliant store");
    }
    this.db = db;
    this._ended = false;
    this._nexting = false;
  }
  AbstractIterator.prototype.next = function(callback) {
    var self2 = this;
    if (typeof callback !== "function") {
      throw new Error("next() requires a callback argument");
    }
    if (self2._ended) {
      nextTick(callback, new Error("cannot call next() after end()"));
      return self2;
    }
    if (self2._nexting) {
      nextTick(callback, new Error("cannot call next() before previous next() has completed"));
      return self2;
    }
    self2._nexting = true;
    self2._next(function() {
      self2._nexting = false;
      callback.apply(null, arguments);
    });
    return self2;
  };
  AbstractIterator.prototype._next = function(callback) {
    nextTick(callback);
  };
  AbstractIterator.prototype.seek = function(target) {
    if (this._ended) {
      throw new Error("cannot call seek() after end()");
    }
    if (this._nexting) {
      throw new Error("cannot call seek() before next() has completed");
    }
    target = this.db._serializeKey(target);
    this._seek(target);
  };
  AbstractIterator.prototype._seek = function(target) {
  };
  AbstractIterator.prototype.end = function(callback) {
    if (typeof callback !== "function") {
      throw new Error("end() requires a callback argument");
    }
    if (this._ended) {
      return nextTick(callback, new Error("end() already called on iterator"));
    }
    this._ended = true;
    this._end(callback);
  };
  AbstractIterator.prototype._end = function(callback) {
    nextTick(callback);
  };
  AbstractIterator.prototype._nextTick = nextTick;
  module2.exports = AbstractIterator;
});

// node_modules/abstract-leveldown/abstract-chained-batch.js
var require_abstract_chained_batch = __commonJS((exports2, module2) => {
  var nextTick = require_next_tick_browser();
  function AbstractChainedBatch(db) {
    if (typeof db !== "object" || db === null) {
      throw new TypeError("First argument must be an abstract-leveldown compliant store");
    }
    this.db = db;
    this._operations = [];
    this._written = false;
  }
  AbstractChainedBatch.prototype._checkWritten = function() {
    if (this._written) {
      throw new Error("write() already called on this batch");
    }
  };
  AbstractChainedBatch.prototype.put = function(key, value) {
    this._checkWritten();
    var err = this.db._checkKey(key) || this.db._checkValue(value);
    if (err)
      throw err;
    key = this.db._serializeKey(key);
    value = this.db._serializeValue(value);
    this._put(key, value);
    return this;
  };
  AbstractChainedBatch.prototype._put = function(key, value) {
    this._operations.push({type: "put", key, value});
  };
  AbstractChainedBatch.prototype.del = function(key) {
    this._checkWritten();
    var err = this.db._checkKey(key);
    if (err)
      throw err;
    key = this.db._serializeKey(key);
    this._del(key);
    return this;
  };
  AbstractChainedBatch.prototype._del = function(key) {
    this._operations.push({type: "del", key});
  };
  AbstractChainedBatch.prototype.clear = function() {
    this._checkWritten();
    this._clear();
    return this;
  };
  AbstractChainedBatch.prototype._clear = function() {
    this._operations = [];
  };
  AbstractChainedBatch.prototype.write = function(options, callback) {
    this._checkWritten();
    if (typeof options === "function") {
      callback = options;
    }
    if (typeof callback !== "function") {
      throw new Error("write() requires a callback argument");
    }
    if (typeof options !== "object" || options === null) {
      options = {};
    }
    this._written = true;
    this._write(options, callback);
  };
  AbstractChainedBatch.prototype._write = function(options, callback) {
    this.db._batch(this._operations, options, callback);
  };
  AbstractChainedBatch.prototype._nextTick = nextTick;
  module2.exports = AbstractChainedBatch;
});

// node_modules/abstract-leveldown/abstract-leveldown.js
var require_abstract_leveldown = __commonJS((exports2, module2) => {
  var xtend = require_immutable();
  var supports = require_level_supports();
  var Buffer2 = require_buffer().Buffer;
  var AbstractIterator = require_abstract_iterator();
  var AbstractChainedBatch = require_abstract_chained_batch();
  var nextTick = require_next_tick_browser();
  var hasOwnProperty = Object.prototype.hasOwnProperty;
  var rangeOptions = "start end gt gte lt lte".split(" ");
  function AbstractLevelDOWN(manifest) {
    this.status = "new";
    this.supports = supports(manifest, {
      status: true
    });
  }
  AbstractLevelDOWN.prototype.open = function(options, callback) {
    var self2 = this;
    var oldStatus = this.status;
    if (typeof options === "function")
      callback = options;
    if (typeof callback !== "function") {
      throw new Error("open() requires a callback argument");
    }
    if (typeof options !== "object" || options === null)
      options = {};
    options.createIfMissing = options.createIfMissing !== false;
    options.errorIfExists = !!options.errorIfExists;
    this.status = "opening";
    this._open(options, function(err) {
      if (err) {
        self2.status = oldStatus;
        return callback(err);
      }
      self2.status = "open";
      callback();
    });
  };
  AbstractLevelDOWN.prototype._open = function(options, callback) {
    nextTick(callback);
  };
  AbstractLevelDOWN.prototype.close = function(callback) {
    var self2 = this;
    var oldStatus = this.status;
    if (typeof callback !== "function") {
      throw new Error("close() requires a callback argument");
    }
    this.status = "closing";
    this._close(function(err) {
      if (err) {
        self2.status = oldStatus;
        return callback(err);
      }
      self2.status = "closed";
      callback();
    });
  };
  AbstractLevelDOWN.prototype._close = function(callback) {
    nextTick(callback);
  };
  AbstractLevelDOWN.prototype.get = function(key, options, callback) {
    if (typeof options === "function")
      callback = options;
    if (typeof callback !== "function") {
      throw new Error("get() requires a callback argument");
    }
    var err = this._checkKey(key);
    if (err)
      return nextTick(callback, err);
    key = this._serializeKey(key);
    if (typeof options !== "object" || options === null)
      options = {};
    options.asBuffer = options.asBuffer !== false;
    this._get(key, options, callback);
  };
  AbstractLevelDOWN.prototype._get = function(key, options, callback) {
    nextTick(function() {
      callback(new Error("NotFound"));
    });
  };
  AbstractLevelDOWN.prototype.put = function(key, value, options, callback) {
    if (typeof options === "function")
      callback = options;
    if (typeof callback !== "function") {
      throw new Error("put() requires a callback argument");
    }
    var err = this._checkKey(key) || this._checkValue(value);
    if (err)
      return nextTick(callback, err);
    key = this._serializeKey(key);
    value = this._serializeValue(value);
    if (typeof options !== "object" || options === null)
      options = {};
    this._put(key, value, options, callback);
  };
  AbstractLevelDOWN.prototype._put = function(key, value, options, callback) {
    nextTick(callback);
  };
  AbstractLevelDOWN.prototype.del = function(key, options, callback) {
    if (typeof options === "function")
      callback = options;
    if (typeof callback !== "function") {
      throw new Error("del() requires a callback argument");
    }
    var err = this._checkKey(key);
    if (err)
      return nextTick(callback, err);
    key = this._serializeKey(key);
    if (typeof options !== "object" || options === null)
      options = {};
    this._del(key, options, callback);
  };
  AbstractLevelDOWN.prototype._del = function(key, options, callback) {
    nextTick(callback);
  };
  AbstractLevelDOWN.prototype.batch = function(array, options, callback) {
    if (!arguments.length)
      return this._chainedBatch();
    if (typeof options === "function")
      callback = options;
    if (typeof array === "function")
      callback = array;
    if (typeof callback !== "function") {
      throw new Error("batch(array) requires a callback argument");
    }
    if (!Array.isArray(array)) {
      return nextTick(callback, new Error("batch(array) requires an array argument"));
    }
    if (array.length === 0) {
      return nextTick(callback);
    }
    if (typeof options !== "object" || options === null)
      options = {};
    var serialized = new Array(array.length);
    for (var i = 0; i < array.length; i++) {
      if (typeof array[i] !== "object" || array[i] === null) {
        return nextTick(callback, new Error("batch(array) element must be an object and not `null`"));
      }
      var e = xtend(array[i]);
      if (e.type !== "put" && e.type !== "del") {
        return nextTick(callback, new Error("`type` must be 'put' or 'del'"));
      }
      var err = this._checkKey(e.key);
      if (err)
        return nextTick(callback, err);
      e.key = this._serializeKey(e.key);
      if (e.type === "put") {
        var valueErr = this._checkValue(e.value);
        if (valueErr)
          return nextTick(callback, valueErr);
        e.value = this._serializeValue(e.value);
      }
      serialized[i] = e;
    }
    this._batch(serialized, options, callback);
  };
  AbstractLevelDOWN.prototype._batch = function(array, options, callback) {
    nextTick(callback);
  };
  AbstractLevelDOWN.prototype.clear = function(options, callback) {
    if (typeof options === "function") {
      callback = options;
    } else if (typeof callback !== "function") {
      throw new Error("clear() requires a callback argument");
    }
    options = cleanRangeOptions(this, options);
    options.reverse = !!options.reverse;
    options.limit = "limit" in options ? options.limit : -1;
    this._clear(options, callback);
  };
  AbstractLevelDOWN.prototype._clear = function(options, callback) {
    options.keys = true;
    options.values = false;
    options.keyAsBuffer = true;
    options.valueAsBuffer = true;
    var iterator = this._iterator(options);
    var emptyOptions = {};
    var self2 = this;
    var next = function(err) {
      if (err) {
        return iterator.end(function() {
          callback(err);
        });
      }
      iterator.next(function(err2, key) {
        if (err2)
          return next(err2);
        if (key === void 0)
          return iterator.end(callback);
        self2._del(key, emptyOptions, next);
      });
    };
    next();
  };
  AbstractLevelDOWN.prototype._setupIteratorOptions = function(options) {
    options = cleanRangeOptions(this, options);
    options.reverse = !!options.reverse;
    options.keys = options.keys !== false;
    options.values = options.values !== false;
    options.limit = "limit" in options ? options.limit : -1;
    options.keyAsBuffer = options.keyAsBuffer !== false;
    options.valueAsBuffer = options.valueAsBuffer !== false;
    return options;
  };
  function cleanRangeOptions(db, options) {
    var result = {};
    for (var k in options) {
      if (!hasOwnProperty.call(options, k))
        continue;
      var opt = options[k];
      if (isRangeOption(k)) {
        opt = db._serializeKey(opt);
      }
      result[k] = opt;
    }
    return result;
  }
  function isRangeOption(k) {
    return rangeOptions.indexOf(k) !== -1;
  }
  AbstractLevelDOWN.prototype.iterator = function(options) {
    if (typeof options !== "object" || options === null)
      options = {};
    options = this._setupIteratorOptions(options);
    return this._iterator(options);
  };
  AbstractLevelDOWN.prototype._iterator = function(options) {
    return new AbstractIterator(this);
  };
  AbstractLevelDOWN.prototype._chainedBatch = function() {
    return new AbstractChainedBatch(this);
  };
  AbstractLevelDOWN.prototype._serializeKey = function(key) {
    return key;
  };
  AbstractLevelDOWN.prototype._serializeValue = function(value) {
    return value;
  };
  AbstractLevelDOWN.prototype._checkKey = function(key) {
    if (key === null || key === void 0) {
      return new Error("key cannot be `null` or `undefined`");
    } else if (Buffer2.isBuffer(key) && key.length === 0) {
      return new Error("key cannot be an empty Buffer");
    } else if (key === "") {
      return new Error("key cannot be an empty String");
    } else if (Array.isArray(key) && key.length === 0) {
      return new Error("key cannot be an empty Array");
    }
  };
  AbstractLevelDOWN.prototype._checkValue = function(value) {
    if (value === null || value === void 0) {
      return new Error("value cannot be `null` or `undefined`");
    }
  };
  AbstractLevelDOWN.prototype._nextTick = nextTick;
  module2.exports = AbstractLevelDOWN;
});

// node_modules/abstract-leveldown/index.js
var require_abstract_leveldown2 = __commonJS((exports2) => {
  exports2.AbstractLevelDOWN = require_abstract_leveldown();
  exports2.AbstractIterator = require_abstract_iterator();
  exports2.AbstractChainedBatch = require_abstract_chained_batch();
});

// node_modules/deferred-leveldown/deferred-iterator.js
var require_deferred_iterator = __commonJS((exports2, module2) => {
  var AbstractIterator = require_abstract_leveldown2().AbstractIterator;
  var inherits = require_inherits_browser();
  function DeferredIterator(db, options) {
    AbstractIterator.call(this, db);
    this._options = options;
    this._iterator = null;
    this._operations = [];
  }
  inherits(DeferredIterator, AbstractIterator);
  DeferredIterator.prototype.setDb = function(db) {
    var it = this._iterator = db.iterator(this._options);
    this._operations.forEach(function(op) {
      it[op.method].apply(it, op.args);
    });
  };
  DeferredIterator.prototype._operation = function(method, args) {
    if (this._iterator)
      return this._iterator[method].apply(this._iterator, args);
    this._operations.push({method, args});
  };
  "next end".split(" ").forEach(function(m) {
    DeferredIterator.prototype["_" + m] = function() {
      this._operation(m, arguments);
    };
  });
  DeferredIterator.prototype.seek = function() {
    this._operation("seek", arguments);
  };
  module2.exports = DeferredIterator;
});

// node_modules/deferred-leveldown/deferred-leveldown.js
var require_deferred_leveldown = __commonJS((exports2, module2) => {
  var AbstractLevelDOWN = require_abstract_leveldown2().AbstractLevelDOWN;
  var inherits = require_inherits_browser();
  var DeferredIterator = require_deferred_iterator();
  var deferrables = "put get del batch clear".split(" ");
  var optionalDeferrables = "approximateSize compactRange".split(" ");
  function DeferredLevelDOWN(db) {
    AbstractLevelDOWN.call(this, db.supports || {});
    optionalDeferrables.forEach(function(m) {
      if (typeof db[m] === "function" && !this.supports.additionalMethods[m]) {
        this.supports.additionalMethods[m] = true;
      }
    }, this);
    this._db = db;
    this._operations = [];
    closed(this);
  }
  inherits(DeferredLevelDOWN, AbstractLevelDOWN);
  DeferredLevelDOWN.prototype.type = "deferred-leveldown";
  DeferredLevelDOWN.prototype._open = function(options, callback) {
    var self2 = this;
    this._db.open(options, function(err) {
      if (err)
        return callback(err);
      self2._operations.forEach(function(op) {
        if (op.iterator) {
          op.iterator.setDb(self2._db);
        } else {
          self2._db[op.method].apply(self2._db, op.args);
        }
      });
      self2._operations = [];
      open(self2);
      callback();
    });
  };
  DeferredLevelDOWN.prototype._close = function(callback) {
    var self2 = this;
    this._db.close(function(err) {
      if (err)
        return callback(err);
      closed(self2);
      callback();
    });
  };
  function open(self2) {
    deferrables.concat("iterator").forEach(function(m) {
      self2["_" + m] = function() {
        return this._db[m].apply(this._db, arguments);
      };
    });
    Object.keys(self2.supports.additionalMethods).forEach(function(m) {
      self2[m] = function() {
        return this._db[m].apply(this._db, arguments);
      };
    });
  }
  function closed(self2) {
    deferrables.forEach(function(m) {
      self2["_" + m] = function() {
        this._operations.push({method: m, args: arguments});
      };
    });
    Object.keys(self2.supports.additionalMethods).forEach(function(m) {
      self2[m] = function() {
        this._operations.push({method: m, args: arguments});
      };
    });
    self2._iterator = function(options) {
      var it = new DeferredIterator(self2, options);
      this._operations.push({iterator: it});
      return it;
    };
  }
  DeferredLevelDOWN.prototype._serializeKey = function(key) {
    return key;
  };
  DeferredLevelDOWN.prototype._serializeValue = function(value) {
    return value;
  };
  module2.exports = DeferredLevelDOWN;
  module2.exports.DeferredIterator = DeferredIterator;
});

// node_modules/readable-stream/readable-browser.js
var require_readable_browser = __commonJS((exports2, module2) => {
  exports2 = module2.exports = require_stream_readable();
  exports2.Stream = exports2;
  exports2.Readable = exports2;
  exports2.Writable = require_stream_writable();
  exports2.Duplex = require_stream_duplex();
  exports2.Transform = require_stream_transform();
  exports2.PassThrough = require_stream_passthrough();
  exports2.finished = require_end_of_stream();
  exports2.pipeline = require_pipeline();
});

// node_modules/level-iterator-stream/index.js
var require_level_iterator_stream = __commonJS((exports2, module2) => {
  var inherits = require_inherits_browser();
  var Readable = require_readable_browser().Readable;
  var extend = require_immutable();
  module2.exports = ReadStream;
  inherits(ReadStream, Readable);
  function ReadStream(iterator, options) {
    if (!(this instanceof ReadStream))
      return new ReadStream(iterator, options);
    options = options || {};
    Readable.call(this, extend(options, {
      objectMode: true
    }));
    this._iterator = iterator;
    this._options = options;
    this.on("end", this.destroy.bind(this, null, null));
  }
  ReadStream.prototype._read = function() {
    var self2 = this;
    var options = this._options;
    if (this.destroyed)
      return;
    this._iterator.next(function(err, key, value) {
      if (self2.destroyed)
        return;
      if (err)
        return self2.destroy(err);
      if (key === void 0 && value === void 0) {
        self2.push(null);
      } else if (options.keys !== false && options.values === false) {
        self2.push(key);
      } else if (options.keys === false && options.values !== false) {
        self2.push(value);
      } else {
        self2.push({key, value});
      }
    });
  };
  ReadStream.prototype._destroy = function(err, callback) {
    this._iterator.end(function(err2) {
      callback(err || err2);
    });
  };
});

// node_modules/prr/prr.js
var require_prr = __commonJS((exports2, module2) => {
  /*!
    * prr
    * (c) 2013 Rod Vagg <rod@vagg.org>
    * https://github.com/rvagg/prr
    * License: MIT
    */
  (function(name, context, definition) {
    if (typeof module2 != "undefined" && module2.exports)
      module2.exports = definition();
    else
      context[name] = definition();
  })("prr", exports2, function() {
    var setProperty = typeof Object.defineProperty == "function" ? function(obj, key, options) {
      Object.defineProperty(obj, key, options);
      return obj;
    } : function(obj, key, options) {
      obj[key] = options.value;
      return obj;
    }, makeOptions = function(value, options) {
      var oo = typeof options == "object", os = !oo && typeof options == "string", op = function(p) {
        return oo ? !!options[p] : os ? options.indexOf(p[0]) > -1 : false;
      };
      return {
        enumerable: op("enumerable"),
        configurable: op("configurable"),
        writable: op("writable"),
        value
      };
    }, prr = function(obj, key, value, options) {
      var k;
      options = makeOptions(value, options);
      if (typeof key == "object") {
        for (k in key) {
          if (Object.hasOwnProperty.call(key, k)) {
            options.value = key[k];
            setProperty(obj, k, options);
          }
        }
        return obj;
      }
      return setProperty(obj, key, options);
    };
    return prr;
  });
});

// node_modules/errno/custom.js
var require_custom = __commonJS((exports2, module2) => {
  var prr = require_prr();
  function init(type, message, cause) {
    if (!!message && typeof message != "string") {
      message = message.message || message.name;
    }
    prr(this, {
      type,
      name: type,
      cause: typeof message != "string" ? message : cause,
      message
    }, "ewr");
  }
  function CustomError(message, cause) {
    Error.call(this);
    if (Error.captureStackTrace)
      Error.captureStackTrace(this, this.constructor);
    init.call(this, "CustomError", message, cause);
  }
  CustomError.prototype = new Error();
  function createError(errno, type, proto) {
    var err = function(message, cause) {
      init.call(this, type, message, cause);
      if (type == "FilesystemError") {
        this.code = this.cause.code;
        this.path = this.cause.path;
        this.errno = this.cause.errno;
        this.message = (errno.errno[this.cause.errno] ? errno.errno[this.cause.errno].description : this.cause.message) + (this.cause.path ? " [" + this.cause.path + "]" : "");
      }
      Error.call(this);
      if (Error.captureStackTrace)
        Error.captureStackTrace(this, err);
    };
    err.prototype = !!proto ? new proto() : new CustomError();
    return err;
  }
  module2.exports = function(errno) {
    var ce = function(type, proto) {
      return createError(errno, type, proto);
    };
    return {
      CustomError,
      FilesystemError: ce("FilesystemError"),
      createError: ce
    };
  };
});

// node_modules/errno/errno.js
var require_errno = __commonJS((exports2, module2) => {
  var all = module2.exports.all = [
    {
      errno: -2,
      code: "ENOENT",
      description: "no such file or directory"
    },
    {
      errno: -1,
      code: "UNKNOWN",
      description: "unknown error"
    },
    {
      errno: 0,
      code: "OK",
      description: "success"
    },
    {
      errno: 1,
      code: "EOF",
      description: "end of file"
    },
    {
      errno: 2,
      code: "EADDRINFO",
      description: "getaddrinfo error"
    },
    {
      errno: 3,
      code: "EACCES",
      description: "permission denied"
    },
    {
      errno: 4,
      code: "EAGAIN",
      description: "resource temporarily unavailable"
    },
    {
      errno: 5,
      code: "EADDRINUSE",
      description: "address already in use"
    },
    {
      errno: 6,
      code: "EADDRNOTAVAIL",
      description: "address not available"
    },
    {
      errno: 7,
      code: "EAFNOSUPPORT",
      description: "address family not supported"
    },
    {
      errno: 8,
      code: "EALREADY",
      description: "connection already in progress"
    },
    {
      errno: 9,
      code: "EBADF",
      description: "bad file descriptor"
    },
    {
      errno: 10,
      code: "EBUSY",
      description: "resource busy or locked"
    },
    {
      errno: 11,
      code: "ECONNABORTED",
      description: "software caused connection abort"
    },
    {
      errno: 12,
      code: "ECONNREFUSED",
      description: "connection refused"
    },
    {
      errno: 13,
      code: "ECONNRESET",
      description: "connection reset by peer"
    },
    {
      errno: 14,
      code: "EDESTADDRREQ",
      description: "destination address required"
    },
    {
      errno: 15,
      code: "EFAULT",
      description: "bad address in system call argument"
    },
    {
      errno: 16,
      code: "EHOSTUNREACH",
      description: "host is unreachable"
    },
    {
      errno: 17,
      code: "EINTR",
      description: "interrupted system call"
    },
    {
      errno: 18,
      code: "EINVAL",
      description: "invalid argument"
    },
    {
      errno: 19,
      code: "EISCONN",
      description: "socket is already connected"
    },
    {
      errno: 20,
      code: "EMFILE",
      description: "too many open files"
    },
    {
      errno: 21,
      code: "EMSGSIZE",
      description: "message too long"
    },
    {
      errno: 22,
      code: "ENETDOWN",
      description: "network is down"
    },
    {
      errno: 23,
      code: "ENETUNREACH",
      description: "network is unreachable"
    },
    {
      errno: 24,
      code: "ENFILE",
      description: "file table overflow"
    },
    {
      errno: 25,
      code: "ENOBUFS",
      description: "no buffer space available"
    },
    {
      errno: 26,
      code: "ENOMEM",
      description: "not enough memory"
    },
    {
      errno: 27,
      code: "ENOTDIR",
      description: "not a directory"
    },
    {
      errno: 28,
      code: "EISDIR",
      description: "illegal operation on a directory"
    },
    {
      errno: 29,
      code: "ENONET",
      description: "machine is not on the network"
    },
    {
      errno: 31,
      code: "ENOTCONN",
      description: "socket is not connected"
    },
    {
      errno: 32,
      code: "ENOTSOCK",
      description: "socket operation on non-socket"
    },
    {
      errno: 33,
      code: "ENOTSUP",
      description: "operation not supported on socket"
    },
    {
      errno: 34,
      code: "ENOENT",
      description: "no such file or directory"
    },
    {
      errno: 35,
      code: "ENOSYS",
      description: "function not implemented"
    },
    {
      errno: 36,
      code: "EPIPE",
      description: "broken pipe"
    },
    {
      errno: 37,
      code: "EPROTO",
      description: "protocol error"
    },
    {
      errno: 38,
      code: "EPROTONOSUPPORT",
      description: "protocol not supported"
    },
    {
      errno: 39,
      code: "EPROTOTYPE",
      description: "protocol wrong type for socket"
    },
    {
      errno: 40,
      code: "ETIMEDOUT",
      description: "connection timed out"
    },
    {
      errno: 41,
      code: "ECHARSET",
      description: "invalid Unicode character"
    },
    {
      errno: 42,
      code: "EAIFAMNOSUPPORT",
      description: "address family for hostname not supported"
    },
    {
      errno: 44,
      code: "EAISERVICE",
      description: "servname not supported for ai_socktype"
    },
    {
      errno: 45,
      code: "EAISOCKTYPE",
      description: "ai_socktype not supported"
    },
    {
      errno: 46,
      code: "ESHUTDOWN",
      description: "cannot send after transport endpoint shutdown"
    },
    {
      errno: 47,
      code: "EEXIST",
      description: "file already exists"
    },
    {
      errno: 48,
      code: "ESRCH",
      description: "no such process"
    },
    {
      errno: 49,
      code: "ENAMETOOLONG",
      description: "name too long"
    },
    {
      errno: 50,
      code: "EPERM",
      description: "operation not permitted"
    },
    {
      errno: 51,
      code: "ELOOP",
      description: "too many symbolic links encountered"
    },
    {
      errno: 52,
      code: "EXDEV",
      description: "cross-device link not permitted"
    },
    {
      errno: 53,
      code: "ENOTEMPTY",
      description: "directory not empty"
    },
    {
      errno: 54,
      code: "ENOSPC",
      description: "no space left on device"
    },
    {
      errno: 55,
      code: "EIO",
      description: "i/o error"
    },
    {
      errno: 56,
      code: "EROFS",
      description: "read-only file system"
    },
    {
      errno: 57,
      code: "ENODEV",
      description: "no such device"
    },
    {
      errno: 58,
      code: "ESPIPE",
      description: "invalid seek"
    },
    {
      errno: 59,
      code: "ECANCELED",
      description: "operation canceled"
    }
  ];
  module2.exports.errno = {};
  module2.exports.code = {};
  all.forEach(function(error) {
    module2.exports.errno[error.errno] = error;
    module2.exports.code[error.code] = error;
  });
  module2.exports.custom = require_custom()(module2.exports);
  module2.exports.create = module2.exports.custom.createError;
});

// node_modules/level-errors/errors.js
var require_errors9 = __commonJS((exports2, module2) => {
  var createError = require_errno().create;
  var LevelUPError = createError("LevelUPError");
  var NotFoundError = createError("NotFoundError", LevelUPError);
  NotFoundError.prototype.notFound = true;
  NotFoundError.prototype.status = 404;
  module2.exports = {
    LevelUPError,
    InitializationError: createError("InitializationError", LevelUPError),
    OpenError: createError("OpenError", LevelUPError),
    ReadError: createError("ReadError", LevelUPError),
    WriteError: createError("WriteError", LevelUPError),
    NotFoundError,
    EncodingError: createError("EncodingError", LevelUPError)
  };
});

// node_modules/levelup/lib/promisify.js
var require_promisify = __commonJS((exports2, module2) => {
  function promisify() {
    var callback;
    var promise = new Promise(function(resolve, reject) {
      callback = function callback2(err, value) {
        if (err)
          reject(err);
        else
          resolve(value);
      };
    });
    callback.promise = promise;
    return callback;
  }
  module2.exports = promisify;
});

// node_modules/levelup/lib/common.js
var require_common4 = __commonJS((exports2) => {
  exports2.getCallback = function(options, callback) {
    return typeof options === "function" ? options : callback;
  };
  exports2.getOptions = function(options) {
    return typeof options === "object" && options !== null ? options : {};
  };
});

// node_modules/levelup/lib/batch.js
var require_batch = __commonJS((exports2, module2) => {
  var WriteError = require_errors9().WriteError;
  var promisify = require_promisify();
  var getCallback = require_common4().getCallback;
  var getOptions = require_common4().getOptions;
  function Batch(levelup) {
    this.db = this._levelup = levelup;
    this.batch = levelup.db.batch();
    this.ops = [];
    this.length = 0;
  }
  Batch.prototype.put = function(key, value) {
    try {
      this.batch.put(key, value);
    } catch (e) {
      throw new WriteError(e);
    }
    this.ops.push({type: "put", key, value});
    this.length++;
    return this;
  };
  Batch.prototype.del = function(key) {
    try {
      this.batch.del(key);
    } catch (err) {
      throw new WriteError(err);
    }
    this.ops.push({type: "del", key});
    this.length++;
    return this;
  };
  Batch.prototype.clear = function() {
    try {
      this.batch.clear();
    } catch (err) {
      throw new WriteError(err);
    }
    this.ops = [];
    this.length = 0;
    return this;
  };
  Batch.prototype.write = function(options, callback) {
    var levelup = this._levelup;
    var ops = this.ops;
    var promise;
    callback = getCallback(options, callback);
    if (!callback) {
      callback = promisify();
      promise = callback.promise;
    }
    options = getOptions(options);
    try {
      this.batch.write(options, function(err) {
        if (err) {
          return callback(new WriteError(err));
        }
        levelup.emit("batch", ops);
        callback();
      });
    } catch (err) {
      throw new WriteError(err);
    }
    return promise;
  };
  module2.exports = Batch;
});

// node_modules/assert/build/internal/errors.js
var require_errors10 = __commonJS((exports2, module2) => {
  "use strict";
  function _typeof(obj) {
    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      _typeof = function _typeof2(obj2) {
        return typeof obj2;
      };
    } else {
      _typeof = function _typeof2(obj2) {
        return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
      };
    }
    return _typeof(obj);
  }
  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
  function _possibleConstructorReturn(self2, call) {
    if (call && (_typeof(call) === "object" || typeof call === "function")) {
      return call;
    }
    return _assertThisInitialized(self2);
  }
  function _assertThisInitialized(self2) {
    if (self2 === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return self2;
  }
  function _getPrototypeOf(o) {
    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
      return o2.__proto__ || Object.getPrototypeOf(o2);
    };
    return _getPrototypeOf(o);
  }
  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }
    subClass.prototype = Object.create(superClass && superClass.prototype, {constructor: {value: subClass, writable: true, configurable: true}});
    if (superClass)
      _setPrototypeOf(subClass, superClass);
  }
  function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
      o2.__proto__ = p2;
      return o2;
    };
    return _setPrototypeOf(o, p);
  }
  var codes = {};
  var assert;
  var util;
  function createErrorType(code, message, Base) {
    if (!Base) {
      Base = Error;
    }
    function getMessage(arg1, arg2, arg3) {
      if (typeof message === "string") {
        return message;
      } else {
        return message(arg1, arg2, arg3);
      }
    }
    var NodeError = /* @__PURE__ */ function(_Base) {
      _inherits(NodeError2, _Base);
      function NodeError2(arg1, arg2, arg3) {
        var _this;
        _classCallCheck(this, NodeError2);
        _this = _possibleConstructorReturn(this, _getPrototypeOf(NodeError2).call(this, getMessage(arg1, arg2, arg3)));
        _this.code = code;
        return _this;
      }
      return NodeError2;
    }(Base);
    codes[code] = NodeError;
  }
  function oneOf(expected, thing) {
    if (Array.isArray(expected)) {
      var len = expected.length;
      expected = expected.map(function(i) {
        return String(i);
      });
      if (len > 2) {
        return "one of ".concat(thing, " ").concat(expected.slice(0, len - 1).join(", "), ", or ") + expected[len - 1];
      } else if (len === 2) {
        return "one of ".concat(thing, " ").concat(expected[0], " or ").concat(expected[1]);
      } else {
        return "of ".concat(thing, " ").concat(expected[0]);
      }
    } else {
      return "of ".concat(thing, " ").concat(String(expected));
    }
  }
  function startsWith(str, search, pos) {
    return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
  }
  function endsWith(str, search, this_len) {
    if (this_len === void 0 || this_len > str.length) {
      this_len = str.length;
    }
    return str.substring(this_len - search.length, this_len) === search;
  }
  function includes(str, search, start) {
    if (typeof start !== "number") {
      start = 0;
    }
    if (start + search.length > str.length) {
      return false;
    } else {
      return str.indexOf(search, start) !== -1;
    }
  }
  createErrorType("ERR_AMBIGUOUS_ARGUMENT", 'The "%s" argument is ambiguous. %s', TypeError);
  createErrorType("ERR_INVALID_ARG_TYPE", function(name, expected, actual) {
    if (assert === void 0)
      assert = require_assert();
    assert(typeof name === "string", "'name' must be a string");
    var determiner;
    if (typeof expected === "string" && startsWith(expected, "not ")) {
      determiner = "must not be";
      expected = expected.replace(/^not /, "");
    } else {
      determiner = "must be";
    }
    var msg;
    if (endsWith(name, " argument")) {
      msg = "The ".concat(name, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
    } else {
      var type = includes(name, ".") ? "property" : "argument";
      msg = 'The "'.concat(name, '" ').concat(type, " ").concat(determiner, " ").concat(oneOf(expected, "type"));
    }
    msg += ". Received type ".concat(_typeof(actual));
    return msg;
  }, TypeError);
  createErrorType("ERR_INVALID_ARG_VALUE", function(name, value) {
    var reason = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : "is invalid";
    if (util === void 0)
      util = require_util10();
    var inspected = util.inspect(value);
    if (inspected.length > 128) {
      inspected = "".concat(inspected.slice(0, 128), "...");
    }
    return "The argument '".concat(name, "' ").concat(reason, ". Received ").concat(inspected);
  }, TypeError, RangeError);
  createErrorType("ERR_INVALID_RETURN_VALUE", function(input, name, value) {
    var type;
    if (value && value.constructor && value.constructor.name) {
      type = "instance of ".concat(value.constructor.name);
    } else {
      type = "type ".concat(_typeof(value));
    }
    return "Expected ".concat(input, ' to be returned from the "').concat(name, '"') + " function but got ".concat(type, ".");
  }, TypeError);
  createErrorType("ERR_MISSING_ARGS", function() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    if (assert === void 0)
      assert = require_assert();
    assert(args.length > 0, "At least one arg needs to be specified");
    var msg = "The ";
    var len = args.length;
    args = args.map(function(a) {
      return '"'.concat(a, '"');
    });
    switch (len) {
      case 1:
        msg += "".concat(args[0], " argument");
        break;
      case 2:
        msg += "".concat(args[0], " and ").concat(args[1], " arguments");
        break;
      default:
        msg += args.slice(0, len - 1).join(", ");
        msg += ", and ".concat(args[len - 1], " arguments");
        break;
    }
    return "".concat(msg, " must be specified");
  }, TypeError);
  module2.exports.codes = codes;
});

// node_modules/assert/build/internal/assert/assertion_error.js
var require_assertion_error = __commonJS((exports2, module2) => {
  "use strict";
  function _objectSpread(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i] != null ? arguments[i] : {};
      var ownKeys = Object.keys(source);
      if (typeof Object.getOwnPropertySymbols === "function") {
        ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function(sym) {
          return Object.getOwnPropertyDescriptor(source, sym).enumerable;
        }));
      }
      ownKeys.forEach(function(key) {
        _defineProperty(target, key, source[key]);
      });
    }
    return target;
  }
  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {value, enumerable: true, configurable: true, writable: true});
    } else {
      obj[key] = value;
    }
    return obj;
  }
  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor)
        descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }
  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps)
      _defineProperties(Constructor.prototype, protoProps);
    if (staticProps)
      _defineProperties(Constructor, staticProps);
    return Constructor;
  }
  function _possibleConstructorReturn(self2, call) {
    if (call && (_typeof(call) === "object" || typeof call === "function")) {
      return call;
    }
    return _assertThisInitialized(self2);
  }
  function _assertThisInitialized(self2) {
    if (self2 === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return self2;
  }
  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }
    subClass.prototype = Object.create(superClass && superClass.prototype, {constructor: {value: subClass, writable: true, configurable: true}});
    if (superClass)
      _setPrototypeOf(subClass, superClass);
  }
  function _wrapNativeSuper(Class) {
    var _cache = typeof Map === "function" ? new Map() : void 0;
    _wrapNativeSuper = function _wrapNativeSuper2(Class2) {
      if (Class2 === null || !_isNativeFunction(Class2))
        return Class2;
      if (typeof Class2 !== "function") {
        throw new TypeError("Super expression must either be null or a function");
      }
      if (typeof _cache !== "undefined") {
        if (_cache.has(Class2))
          return _cache.get(Class2);
        _cache.set(Class2, Wrapper);
      }
      function Wrapper() {
        return _construct(Class2, arguments, _getPrototypeOf(this).constructor);
      }
      Wrapper.prototype = Object.create(Class2.prototype, {constructor: {value: Wrapper, enumerable: false, writable: true, configurable: true}});
      return _setPrototypeOf(Wrapper, Class2);
    };
    return _wrapNativeSuper(Class);
  }
  function isNativeReflectConstruct() {
    if (typeof Reflect === "undefined" || !Reflect.construct)
      return false;
    if (Reflect.construct.sham)
      return false;
    if (typeof Proxy === "function")
      return true;
    try {
      Date.prototype.toString.call(Reflect.construct(Date, [], function() {
      }));
      return true;
    } catch (e) {
      return false;
    }
  }
  function _construct(Parent, args, Class) {
    if (isNativeReflectConstruct()) {
      _construct = Reflect.construct;
    } else {
      _construct = function _construct2(Parent2, args2, Class2) {
        var a = [null];
        a.push.apply(a, args2);
        var Constructor = Function.bind.apply(Parent2, a);
        var instance = new Constructor();
        if (Class2)
          _setPrototypeOf(instance, Class2.prototype);
        return instance;
      };
    }
    return _construct.apply(null, arguments);
  }
  function _isNativeFunction(fn) {
    return Function.toString.call(fn).indexOf("[native code]") !== -1;
  }
  function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf2(o2, p2) {
      o2.__proto__ = p2;
      return o2;
    };
    return _setPrototypeOf(o, p);
  }
  function _getPrototypeOf(o) {
    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf2(o2) {
      return o2.__proto__ || Object.getPrototypeOf(o2);
    };
    return _getPrototypeOf(o);
  }
  function _typeof(obj) {
    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      _typeof = function _typeof2(obj2) {
        return typeof obj2;
      };
    } else {
      _typeof = function _typeof2(obj2) {
        return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
      };
    }
    return _typeof(obj);
  }
  var _require = require_util10();
  var inspect = _require.inspect;
  var _require2 = require_errors10();
  var ERR_INVALID_ARG_TYPE = _require2.codes.ERR_INVALID_ARG_TYPE;
  function endsWith(str, search, this_len) {
    if (this_len === void 0 || this_len > str.length) {
      this_len = str.length;
    }
    return str.substring(this_len - search.length, this_len) === search;
  }
  function repeat(str, count) {
    count = Math.floor(count);
    if (str.length == 0 || count == 0)
      return "";
    var maxCount = str.length * count;
    count = Math.floor(Math.log(count) / Math.log(2));
    while (count) {
      str += str;
      count--;
    }
    str += str.substring(0, maxCount - str.length);
    return str;
  }
  var blue = "";
  var green = "";
  var red = "";
  var white = "";
  var kReadableOperator = {
    deepStrictEqual: "Expected values to be strictly deep-equal:",
    strictEqual: "Expected values to be strictly equal:",
    strictEqualObject: 'Expected "actual" to be reference-equal to "expected":',
    deepEqual: "Expected values to be loosely deep-equal:",
    equal: "Expected values to be loosely equal:",
    notDeepStrictEqual: 'Expected "actual" not to be strictly deep-equal to:',
    notStrictEqual: 'Expected "actual" to be strictly unequal to:',
    notStrictEqualObject: 'Expected "actual" not to be reference-equal to "expected":',
    notDeepEqual: 'Expected "actual" not to be loosely deep-equal to:',
    notEqual: 'Expected "actual" to be loosely unequal to:',
    notIdentical: "Values identical but not reference-equal:"
  };
  var kMaxShortLength = 10;
  function copyError(source) {
    var keys = Object.keys(source);
    var target = Object.create(Object.getPrototypeOf(source));
    keys.forEach(function(key) {
      target[key] = source[key];
    });
    Object.defineProperty(target, "message", {
      value: source.message
    });
    return target;
  }
  function inspectValue(val) {
    return inspect(val, {
      compact: false,
      customInspect: false,
      depth: 1e3,
      maxArrayLength: Infinity,
      showHidden: false,
      breakLength: Infinity,
      showProxy: false,
      sorted: true,
      getters: true
    });
  }
  function createErrDiff(actual, expected, operator) {
    var other = "";
    var res = "";
    var lastPos = 0;
    var end = "";
    var skipped = false;
    var actualInspected = inspectValue(actual);
    var actualLines = actualInspected.split("\n");
    var expectedLines = inspectValue(expected).split("\n");
    var i = 0;
    var indicator = "";
    if (operator === "strictEqual" && _typeof(actual) === "object" && _typeof(expected) === "object" && actual !== null && expected !== null) {
      operator = "strictEqualObject";
    }
    if (actualLines.length === 1 && expectedLines.length === 1 && actualLines[0] !== expectedLines[0]) {
      var inputLength = actualLines[0].length + expectedLines[0].length;
      if (inputLength <= kMaxShortLength) {
        if ((_typeof(actual) !== "object" || actual === null) && (_typeof(expected) !== "object" || expected === null) && (actual !== 0 || expected !== 0)) {
          return "".concat(kReadableOperator[operator], "\n\n") + "".concat(actualLines[0], " !== ").concat(expectedLines[0], "\n");
        }
      } else if (operator !== "strictEqualObject") {
        var maxLength = process.stderr && process.stderr.isTTY ? process.stderr.columns : 80;
        if (inputLength < maxLength) {
          while (actualLines[0][i] === expectedLines[0][i]) {
            i++;
          }
          if (i > 2) {
            indicator = "\n  ".concat(repeat(" ", i), "^");
            i = 0;
          }
        }
      }
    }
    var a = actualLines[actualLines.length - 1];
    var b = expectedLines[expectedLines.length - 1];
    while (a === b) {
      if (i++ < 2) {
        end = "\n  ".concat(a).concat(end);
      } else {
        other = a;
      }
      actualLines.pop();
      expectedLines.pop();
      if (actualLines.length === 0 || expectedLines.length === 0)
        break;
      a = actualLines[actualLines.length - 1];
      b = expectedLines[expectedLines.length - 1];
    }
    var maxLines = Math.max(actualLines.length, expectedLines.length);
    if (maxLines === 0) {
      var _actualLines = actualInspected.split("\n");
      if (_actualLines.length > 30) {
        _actualLines[26] = "".concat(blue, "...").concat(white);
        while (_actualLines.length > 27) {
          _actualLines.pop();
        }
      }
      return "".concat(kReadableOperator.notIdentical, "\n\n").concat(_actualLines.join("\n"), "\n");
    }
    if (i > 3) {
      end = "\n".concat(blue, "...").concat(white).concat(end);
      skipped = true;
    }
    if (other !== "") {
      end = "\n  ".concat(other).concat(end);
      other = "";
    }
    var printedLines = 0;
    var msg = kReadableOperator[operator] + "\n".concat(green, "+ actual").concat(white, " ").concat(red, "- expected").concat(white);
    var skippedMsg = " ".concat(blue, "...").concat(white, " Lines skipped");
    for (i = 0; i < maxLines; i++) {
      var cur = i - lastPos;
      if (actualLines.length < i + 1) {
        if (cur > 1 && i > 2) {
          if (cur > 4) {
            res += "\n".concat(blue, "...").concat(white);
            skipped = true;
          } else if (cur > 3) {
            res += "\n  ".concat(expectedLines[i - 2]);
            printedLines++;
          }
          res += "\n  ".concat(expectedLines[i - 1]);
          printedLines++;
        }
        lastPos = i;
        other += "\n".concat(red, "-").concat(white, " ").concat(expectedLines[i]);
        printedLines++;
      } else if (expectedLines.length < i + 1) {
        if (cur > 1 && i > 2) {
          if (cur > 4) {
            res += "\n".concat(blue, "...").concat(white);
            skipped = true;
          } else if (cur > 3) {
            res += "\n  ".concat(actualLines[i - 2]);
            printedLines++;
          }
          res += "\n  ".concat(actualLines[i - 1]);
          printedLines++;
        }
        lastPos = i;
        res += "\n".concat(green, "+").concat(white, " ").concat(actualLines[i]);
        printedLines++;
      } else {
        var expectedLine = expectedLines[i];
        var actualLine = actualLines[i];
        var divergingLines = actualLine !== expectedLine && (!endsWith(actualLine, ",") || actualLine.slice(0, -1) !== expectedLine);
        if (divergingLines && endsWith(expectedLine, ",") && expectedLine.slice(0, -1) === actualLine) {
          divergingLines = false;
          actualLine += ",";
        }
        if (divergingLines) {
          if (cur > 1 && i > 2) {
            if (cur > 4) {
              res += "\n".concat(blue, "...").concat(white);
              skipped = true;
            } else if (cur > 3) {
              res += "\n  ".concat(actualLines[i - 2]);
              printedLines++;
            }
            res += "\n  ".concat(actualLines[i - 1]);
            printedLines++;
          }
          lastPos = i;
          res += "\n".concat(green, "+").concat(white, " ").concat(actualLine);
          other += "\n".concat(red, "-").concat(white, " ").concat(expectedLine);
          printedLines += 2;
        } else {
          res += other;
          other = "";
          if (cur === 1 || i === 0) {
            res += "\n  ".concat(actualLine);
            printedLines++;
          }
        }
      }
      if (printedLines > 20 && i < maxLines - 2) {
        return "".concat(msg).concat(skippedMsg, "\n").concat(res, "\n").concat(blue, "...").concat(white).concat(other, "\n") + "".concat(blue, "...").concat(white);
      }
    }
    return "".concat(msg).concat(skipped ? skippedMsg : "", "\n").concat(res).concat(other).concat(end).concat(indicator);
  }
  var AssertionError = /* @__PURE__ */ function(_Error) {
    _inherits(AssertionError2, _Error);
    function AssertionError2(options) {
      var _this;
      _classCallCheck(this, AssertionError2);
      if (_typeof(options) !== "object" || options === null) {
        throw new ERR_INVALID_ARG_TYPE("options", "Object", options);
      }
      var message = options.message, operator = options.operator, stackStartFn = options.stackStartFn;
      var actual = options.actual, expected = options.expected;
      var limit = Error.stackTraceLimit;
      Error.stackTraceLimit = 0;
      if (message != null) {
        _this = _possibleConstructorReturn(this, _getPrototypeOf(AssertionError2).call(this, String(message)));
      } else {
        if (process.stderr && process.stderr.isTTY) {
          if (process.stderr && process.stderr.getColorDepth && process.stderr.getColorDepth() !== 1) {
            blue = "[34m";
            green = "[32m";
            white = "[39m";
            red = "[31m";
          } else {
            blue = "";
            green = "";
            white = "";
            red = "";
          }
        }
        if (_typeof(actual) === "object" && actual !== null && _typeof(expected) === "object" && expected !== null && "stack" in actual && actual instanceof Error && "stack" in expected && expected instanceof Error) {
          actual = copyError(actual);
          expected = copyError(expected);
        }
        if (operator === "deepStrictEqual" || operator === "strictEqual") {
          _this = _possibleConstructorReturn(this, _getPrototypeOf(AssertionError2).call(this, createErrDiff(actual, expected, operator)));
        } else if (operator === "notDeepStrictEqual" || operator === "notStrictEqual") {
          var base = kReadableOperator[operator];
          var res = inspectValue(actual).split("\n");
          if (operator === "notStrictEqual" && _typeof(actual) === "object" && actual !== null) {
            base = kReadableOperator.notStrictEqualObject;
          }
          if (res.length > 30) {
            res[26] = "".concat(blue, "...").concat(white);
            while (res.length > 27) {
              res.pop();
            }
          }
          if (res.length === 1) {
            _this = _possibleConstructorReturn(this, _getPrototypeOf(AssertionError2).call(this, "".concat(base, " ").concat(res[0])));
          } else {
            _this = _possibleConstructorReturn(this, _getPrototypeOf(AssertionError2).call(this, "".concat(base, "\n\n").concat(res.join("\n"), "\n")));
          }
        } else {
          var _res = inspectValue(actual);
          var other = "";
          var knownOperators = kReadableOperator[operator];
          if (operator === "notDeepEqual" || operator === "notEqual") {
            _res = "".concat(kReadableOperator[operator], "\n\n").concat(_res);
            if (_res.length > 1024) {
              _res = "".concat(_res.slice(0, 1021), "...");
            }
          } else {
            other = "".concat(inspectValue(expected));
            if (_res.length > 512) {
              _res = "".concat(_res.slice(0, 509), "...");
            }
            if (other.length > 512) {
              other = "".concat(other.slice(0, 509), "...");
            }
            if (operator === "deepEqual" || operator === "equal") {
              _res = "".concat(knownOperators, "\n\n").concat(_res, "\n\nshould equal\n\n");
            } else {
              other = " ".concat(operator, " ").concat(other);
            }
          }
          _this = _possibleConstructorReturn(this, _getPrototypeOf(AssertionError2).call(this, "".concat(_res).concat(other)));
        }
      }
      Error.stackTraceLimit = limit;
      _this.generatedMessage = !message;
      Object.defineProperty(_assertThisInitialized(_this), "name", {
        value: "AssertionError [ERR_ASSERTION]",
        enumerable: false,
        writable: true,
        configurable: true
      });
      _this.code = "ERR_ASSERTION";
      _this.actual = actual;
      _this.expected = expected;
      _this.operator = operator;
      if (Error.captureStackTrace) {
        Error.captureStackTrace(_assertThisInitialized(_this), stackStartFn);
      }
      _this.stack;
      _this.name = "AssertionError";
      return _possibleConstructorReturn(_this);
    }
    _createClass(AssertionError2, [{
      key: "toString",
      value: function toString() {
        return "".concat(this.name, " [").concat(this.code, "]: ").concat(this.message);
      }
    }, {
      key: inspect.custom,
      value: function value(recurseTimes, ctx) {
        return inspect(this, _objectSpread({}, ctx, {
          customInspect: false,
          depth: 0
        }));
      }
    }]);
    return AssertionError2;
  }(_wrapNativeSuper(Error));
  module2.exports = AssertionError;
});

// node_modules/es6-object-assign/index.js
var require_es6_object_assign = __commonJS((exports2, module2) => {
  "use strict";
  function assign(target, firstSource) {
    if (target === void 0 || target === null) {
      throw new TypeError("Cannot convert first argument to object");
    }
    var to = Object(target);
    for (var i = 1; i < arguments.length; i++) {
      var nextSource = arguments[i];
      if (nextSource === void 0 || nextSource === null) {
        continue;
      }
      var keysArray = Object.keys(Object(nextSource));
      for (var nextIndex = 0, len = keysArray.length; nextIndex < len; nextIndex++) {
        var nextKey = keysArray[nextIndex];
        var desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);
        if (desc !== void 0 && desc.enumerable) {
          to[nextKey] = nextSource[nextKey];
        }
      }
    }
    return to;
  }
  function polyfill() {
    if (!Object.assign) {
      Object.defineProperty(Object, "assign", {
        enumerable: false,
        configurable: true,
        writable: true,
        value: assign
      });
    }
  }
  module2.exports = {
    assign,
    polyfill
  };
});

// node_modules/object-is/implementation.js
var require_implementation3 = __commonJS((exports2, module2) => {
  "use strict";
  var numberIsNaN = function(value) {
    return value !== value;
  };
  module2.exports = function is(a, b) {
    if (a === 0 && b === 0) {
      return 1 / a === 1 / b;
    }
    if (a === b) {
      return true;
    }
    if (numberIsNaN(a) && numberIsNaN(b)) {
      return true;
    }
    return false;
  };
});

// node_modules/object-is/polyfill.js
var require_polyfill2 = __commonJS((exports2, module2) => {
  "use strict";
  var implementation = require_implementation3();
  module2.exports = function getPolyfill() {
    return typeof Object.is === "function" ? Object.is : implementation;
  };
});

// node_modules/object-is/shim.js
var require_shim2 = __commonJS((exports2, module2) => {
  "use strict";
  var getPolyfill = require_polyfill2();
  var define2 = require_define_properties();
  module2.exports = function shimObjectIs() {
    var polyfill = getPolyfill();
    define2(Object, {is: polyfill}, {
      is: function testObjectIs() {
        return Object.is !== polyfill;
      }
    });
    return polyfill;
  };
});

// node_modules/object-is/index.js
var require_object_is = __commonJS((exports2, module2) => {
  "use strict";
  var define2 = require_define_properties();
  var callBind = require_call_bind();
  var implementation = require_implementation3();
  var getPolyfill = require_polyfill2();
  var shim = require_shim2();
  var polyfill = callBind(getPolyfill(), Object);
  define2(polyfill, {
    getPolyfill,
    implementation,
    shim
  });
  module2.exports = polyfill;
});

// node_modules/is-nan/implementation.js
var require_implementation4 = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = function isNaN2(value) {
    return value !== value;
  };
});

// node_modules/is-nan/polyfill.js
var require_polyfill3 = __commonJS((exports2, module2) => {
  "use strict";
  var implementation = require_implementation4();
  module2.exports = function getPolyfill() {
    if (Number.isNaN && Number.isNaN(NaN) && !Number.isNaN("a")) {
      return Number.isNaN;
    }
    return implementation;
  };
});

// node_modules/is-nan/shim.js
var require_shim3 = __commonJS((exports2, module2) => {
  "use strict";
  var define2 = require_define_properties();
  var getPolyfill = require_polyfill3();
  module2.exports = function shimNumberIsNaN() {
    var polyfill = getPolyfill();
    define2(Number, {isNaN: polyfill}, {
      isNaN: function testIsNaN() {
        return Number.isNaN !== polyfill;
      }
    });
    return polyfill;
  };
});

// node_modules/is-nan/index.js
var require_is_nan = __commonJS((exports2, module2) => {
  "use strict";
  var callBind = require_call_bind();
  var define2 = require_define_properties();
  var implementation = require_implementation4();
  var getPolyfill = require_polyfill3();
  var shim = require_shim3();
  var polyfill = callBind(getPolyfill(), Number);
  define2(polyfill, {
    getPolyfill,
    implementation,
    shim
  });
  module2.exports = polyfill;
});

// node_modules/assert/build/internal/util/comparisons.js
var require_comparisons = __commonJS((exports2, module2) => {
  "use strict";
  function _slicedToArray(arr, i) {
    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();
  }
  function _nonIterableRest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance");
  }
  function _iterableToArrayLimit(arr, i) {
    var _arr = [];
    var _n = true;
    var _d = false;
    var _e = void 0;
    try {
      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);
        if (i && _arr.length === i)
          break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"] != null)
          _i["return"]();
      } finally {
        if (_d)
          throw _e;
      }
    }
    return _arr;
  }
  function _arrayWithHoles(arr) {
    if (Array.isArray(arr))
      return arr;
  }
  function _typeof(obj) {
    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      _typeof = function _typeof2(obj2) {
        return typeof obj2;
      };
    } else {
      _typeof = function _typeof2(obj2) {
        return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
      };
    }
    return _typeof(obj);
  }
  var regexFlagsSupported = /a/g.flags !== void 0;
  var arrayFromSet = function arrayFromSet2(set) {
    var array = [];
    set.forEach(function(value) {
      return array.push(value);
    });
    return array;
  };
  var arrayFromMap = function arrayFromMap2(map) {
    var array = [];
    map.forEach(function(value, key) {
      return array.push([key, value]);
    });
    return array;
  };
  var objectIs = Object.is ? Object.is : require_object_is();
  var objectGetOwnPropertySymbols = Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols : function() {
    return [];
  };
  var numberIsNaN = Number.isNaN ? Number.isNaN : require_is_nan();
  function uncurryThis(f) {
    return f.call.bind(f);
  }
  var hasOwnProperty = uncurryThis(Object.prototype.hasOwnProperty);
  var propertyIsEnumerable = uncurryThis(Object.prototype.propertyIsEnumerable);
  var objectToString = uncurryThis(Object.prototype.toString);
  var _require$types = require_util10().types;
  var isAnyArrayBuffer = _require$types.isAnyArrayBuffer;
  var isArrayBufferView = _require$types.isArrayBufferView;
  var isDate = _require$types.isDate;
  var isMap = _require$types.isMap;
  var isRegExp = _require$types.isRegExp;
  var isSet = _require$types.isSet;
  var isNativeError = _require$types.isNativeError;
  var isBoxedPrimitive = _require$types.isBoxedPrimitive;
  var isNumberObject = _require$types.isNumberObject;
  var isStringObject = _require$types.isStringObject;
  var isBooleanObject = _require$types.isBooleanObject;
  var isBigIntObject = _require$types.isBigIntObject;
  var isSymbolObject = _require$types.isSymbolObject;
  var isFloat32Array = _require$types.isFloat32Array;
  var isFloat64Array = _require$types.isFloat64Array;
  function isNonIndex(key) {
    if (key.length === 0 || key.length > 10)
      return true;
    for (var i = 0; i < key.length; i++) {
      var code = key.charCodeAt(i);
      if (code < 48 || code > 57)
        return true;
    }
    return key.length === 10 && key >= Math.pow(2, 32);
  }
  function getOwnNonIndexProperties(value) {
    return Object.keys(value).filter(isNonIndex).concat(objectGetOwnPropertySymbols(value).filter(Object.prototype.propertyIsEnumerable.bind(value)));
  }
  /*!
   * The buffer module from node.js, for the browser.
   *
   * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
   * @license  MIT
   */
  function compare(a, b) {
    if (a === b) {
      return 0;
    }
    var x = a.length;
    var y = b.length;
    for (var i = 0, len = Math.min(x, y); i < len; ++i) {
      if (a[i] !== b[i]) {
        x = a[i];
        y = b[i];
        break;
      }
    }
    if (x < y) {
      return -1;
    }
    if (y < x) {
      return 1;
    }
    return 0;
  }
  var ONLY_ENUMERABLE = void 0;
  var kStrict = true;
  var kLoose = false;
  var kNoIterator = 0;
  var kIsArray = 1;
  var kIsSet = 2;
  var kIsMap = 3;
  function areSimilarRegExps(a, b) {
    return regexFlagsSupported ? a.source === b.source && a.flags === b.flags : RegExp.prototype.toString.call(a) === RegExp.prototype.toString.call(b);
  }
  function areSimilarFloatArrays(a, b) {
    if (a.byteLength !== b.byteLength) {
      return false;
    }
    for (var offset = 0; offset < a.byteLength; offset++) {
      if (a[offset] !== b[offset]) {
        return false;
      }
    }
    return true;
  }
  function areSimilarTypedArrays(a, b) {
    if (a.byteLength !== b.byteLength) {
      return false;
    }
    return compare(new Uint8Array(a.buffer, a.byteOffset, a.byteLength), new Uint8Array(b.buffer, b.byteOffset, b.byteLength)) === 0;
  }
  function areEqualArrayBuffers(buf1, buf2) {
    return buf1.byteLength === buf2.byteLength && compare(new Uint8Array(buf1), new Uint8Array(buf2)) === 0;
  }
  function isEqualBoxedPrimitive(val1, val2) {
    if (isNumberObject(val1)) {
      return isNumberObject(val2) && objectIs(Number.prototype.valueOf.call(val1), Number.prototype.valueOf.call(val2));
    }
    if (isStringObject(val1)) {
      return isStringObject(val2) && String.prototype.valueOf.call(val1) === String.prototype.valueOf.call(val2);
    }
    if (isBooleanObject(val1)) {
      return isBooleanObject(val2) && Boolean.prototype.valueOf.call(val1) === Boolean.prototype.valueOf.call(val2);
    }
    if (isBigIntObject(val1)) {
      return isBigIntObject(val2) && BigInt.prototype.valueOf.call(val1) === BigInt.prototype.valueOf.call(val2);
    }
    return isSymbolObject(val2) && Symbol.prototype.valueOf.call(val1) === Symbol.prototype.valueOf.call(val2);
  }
  function innerDeepEqual(val1, val2, strict, memos) {
    if (val1 === val2) {
      if (val1 !== 0)
        return true;
      return strict ? objectIs(val1, val2) : true;
    }
    if (strict) {
      if (_typeof(val1) !== "object") {
        return typeof val1 === "number" && numberIsNaN(val1) && numberIsNaN(val2);
      }
      if (_typeof(val2) !== "object" || val1 === null || val2 === null) {
        return false;
      }
      if (Object.getPrototypeOf(val1) !== Object.getPrototypeOf(val2)) {
        return false;
      }
    } else {
      if (val1 === null || _typeof(val1) !== "object") {
        if (val2 === null || _typeof(val2) !== "object") {
          return val1 == val2;
        }
        return false;
      }
      if (val2 === null || _typeof(val2) !== "object") {
        return false;
      }
    }
    var val1Tag = objectToString(val1);
    var val2Tag = objectToString(val2);
    if (val1Tag !== val2Tag) {
      return false;
    }
    if (Array.isArray(val1)) {
      if (val1.length !== val2.length) {
        return false;
      }
      var keys1 = getOwnNonIndexProperties(val1, ONLY_ENUMERABLE);
      var keys2 = getOwnNonIndexProperties(val2, ONLY_ENUMERABLE);
      if (keys1.length !== keys2.length) {
        return false;
      }
      return keyCheck(val1, val2, strict, memos, kIsArray, keys1);
    }
    if (val1Tag === "[object Object]") {
      if (!isMap(val1) && isMap(val2) || !isSet(val1) && isSet(val2)) {
        return false;
      }
    }
    if (isDate(val1)) {
      if (!isDate(val2) || Date.prototype.getTime.call(val1) !== Date.prototype.getTime.call(val2)) {
        return false;
      }
    } else if (isRegExp(val1)) {
      if (!isRegExp(val2) || !areSimilarRegExps(val1, val2)) {
        return false;
      }
    } else if (isNativeError(val1) || val1 instanceof Error) {
      if (val1.message !== val2.message || val1.name !== val2.name) {
        return false;
      }
    } else if (isArrayBufferView(val1)) {
      if (!strict && (isFloat32Array(val1) || isFloat64Array(val1))) {
        if (!areSimilarFloatArrays(val1, val2)) {
          return false;
        }
      } else if (!areSimilarTypedArrays(val1, val2)) {
        return false;
      }
      var _keys = getOwnNonIndexProperties(val1, ONLY_ENUMERABLE);
      var _keys2 = getOwnNonIndexProperties(val2, ONLY_ENUMERABLE);
      if (_keys.length !== _keys2.length) {
        return false;
      }
      return keyCheck(val1, val2, strict, memos, kNoIterator, _keys);
    } else if (isSet(val1)) {
      if (!isSet(val2) || val1.size !== val2.size) {
        return false;
      }
      return keyCheck(val1, val2, strict, memos, kIsSet);
    } else if (isMap(val1)) {
      if (!isMap(val2) || val1.size !== val2.size) {
        return false;
      }
      return keyCheck(val1, val2, strict, memos, kIsMap);
    } else if (isAnyArrayBuffer(val1)) {
      if (!areEqualArrayBuffers(val1, val2)) {
        return false;
      }
    } else if (isBoxedPrimitive(val1) && !isEqualBoxedPrimitive(val1, val2)) {
      return false;
    }
    return keyCheck(val1, val2, strict, memos, kNoIterator);
  }
  function getEnumerables(val, keys) {
    return keys.filter(function(k) {
      return propertyIsEnumerable(val, k);
    });
  }
  function keyCheck(val1, val2, strict, memos, iterationType, aKeys) {
    if (arguments.length === 5) {
      aKeys = Object.keys(val1);
      var bKeys = Object.keys(val2);
      if (aKeys.length !== bKeys.length) {
        return false;
      }
    }
    var i = 0;
    for (; i < aKeys.length; i++) {
      if (!hasOwnProperty(val2, aKeys[i])) {
        return false;
      }
    }
    if (strict && arguments.length === 5) {
      var symbolKeysA = objectGetOwnPropertySymbols(val1);
      if (symbolKeysA.length !== 0) {
        var count = 0;
        for (i = 0; i < symbolKeysA.length; i++) {
          var key = symbolKeysA[i];
          if (propertyIsEnumerable(val1, key)) {
            if (!propertyIsEnumerable(val2, key)) {
              return false;
            }
            aKeys.push(key);
            count++;
          } else if (propertyIsEnumerable(val2, key)) {
            return false;
          }
        }
        var symbolKeysB = objectGetOwnPropertySymbols(val2);
        if (symbolKeysA.length !== symbolKeysB.length && getEnumerables(val2, symbolKeysB).length !== count) {
          return false;
        }
      } else {
        var _symbolKeysB = objectGetOwnPropertySymbols(val2);
        if (_symbolKeysB.length !== 0 && getEnumerables(val2, _symbolKeysB).length !== 0) {
          return false;
        }
      }
    }
    if (aKeys.length === 0 && (iterationType === kNoIterator || iterationType === kIsArray && val1.length === 0 || val1.size === 0)) {
      return true;
    }
    if (memos === void 0) {
      memos = {
        val1: new Map(),
        val2: new Map(),
        position: 0
      };
    } else {
      var val2MemoA = memos.val1.get(val1);
      if (val2MemoA !== void 0) {
        var val2MemoB = memos.val2.get(val2);
        if (val2MemoB !== void 0) {
          return val2MemoA === val2MemoB;
        }
      }
      memos.position++;
    }
    memos.val1.set(val1, memos.position);
    memos.val2.set(val2, memos.position);
    var areEq = objEquiv(val1, val2, strict, aKeys, memos, iterationType);
    memos.val1.delete(val1);
    memos.val2.delete(val2);
    return areEq;
  }
  function setHasEqualElement(set, val1, strict, memo) {
    var setValues = arrayFromSet(set);
    for (var i = 0; i < setValues.length; i++) {
      var val2 = setValues[i];
      if (innerDeepEqual(val1, val2, strict, memo)) {
        set.delete(val2);
        return true;
      }
    }
    return false;
  }
  function findLooseMatchingPrimitives(prim) {
    switch (_typeof(prim)) {
      case "undefined":
        return null;
      case "object":
        return void 0;
      case "symbol":
        return false;
      case "string":
        prim = +prim;
      case "number":
        if (numberIsNaN(prim)) {
          return false;
        }
    }
    return true;
  }
  function setMightHaveLoosePrim(a, b, prim) {
    var altValue = findLooseMatchingPrimitives(prim);
    if (altValue != null)
      return altValue;
    return b.has(altValue) && !a.has(altValue);
  }
  function mapMightHaveLoosePrim(a, b, prim, item, memo) {
    var altValue = findLooseMatchingPrimitives(prim);
    if (altValue != null) {
      return altValue;
    }
    var curB = b.get(altValue);
    if (curB === void 0 && !b.has(altValue) || !innerDeepEqual(item, curB, false, memo)) {
      return false;
    }
    return !a.has(altValue) && innerDeepEqual(item, curB, false, memo);
  }
  function setEquiv(a, b, strict, memo) {
    var set = null;
    var aValues = arrayFromSet(a);
    for (var i = 0; i < aValues.length; i++) {
      var val = aValues[i];
      if (_typeof(val) === "object" && val !== null) {
        if (set === null) {
          set = new Set();
        }
        set.add(val);
      } else if (!b.has(val)) {
        if (strict)
          return false;
        if (!setMightHaveLoosePrim(a, b, val)) {
          return false;
        }
        if (set === null) {
          set = new Set();
        }
        set.add(val);
      }
    }
    if (set !== null) {
      var bValues = arrayFromSet(b);
      for (var _i = 0; _i < bValues.length; _i++) {
        var _val = bValues[_i];
        if (_typeof(_val) === "object" && _val !== null) {
          if (!setHasEqualElement(set, _val, strict, memo))
            return false;
        } else if (!strict && !a.has(_val) && !setHasEqualElement(set, _val, strict, memo)) {
          return false;
        }
      }
      return set.size === 0;
    }
    return true;
  }
  function mapHasEqualEntry(set, map, key1, item1, strict, memo) {
    var setValues = arrayFromSet(set);
    for (var i = 0; i < setValues.length; i++) {
      var key2 = setValues[i];
      if (innerDeepEqual(key1, key2, strict, memo) && innerDeepEqual(item1, map.get(key2), strict, memo)) {
        set.delete(key2);
        return true;
      }
    }
    return false;
  }
  function mapEquiv(a, b, strict, memo) {
    var set = null;
    var aEntries = arrayFromMap(a);
    for (var i = 0; i < aEntries.length; i++) {
      var _aEntries$i = _slicedToArray(aEntries[i], 2), key = _aEntries$i[0], item1 = _aEntries$i[1];
      if (_typeof(key) === "object" && key !== null) {
        if (set === null) {
          set = new Set();
        }
        set.add(key);
      } else {
        var item2 = b.get(key);
        if (item2 === void 0 && !b.has(key) || !innerDeepEqual(item1, item2, strict, memo)) {
          if (strict)
            return false;
          if (!mapMightHaveLoosePrim(a, b, key, item1, memo))
            return false;
          if (set === null) {
            set = new Set();
          }
          set.add(key);
        }
      }
    }
    if (set !== null) {
      var bEntries = arrayFromMap(b);
      for (var _i2 = 0; _i2 < bEntries.length; _i2++) {
        var _bEntries$_i = _slicedToArray(bEntries[_i2], 2), key = _bEntries$_i[0], item = _bEntries$_i[1];
        if (_typeof(key) === "object" && key !== null) {
          if (!mapHasEqualEntry(set, a, key, item, strict, memo))
            return false;
        } else if (!strict && (!a.has(key) || !innerDeepEqual(a.get(key), item, false, memo)) && !mapHasEqualEntry(set, a, key, item, false, memo)) {
          return false;
        }
      }
      return set.size === 0;
    }
    return true;
  }
  function objEquiv(a, b, strict, keys, memos, iterationType) {
    var i = 0;
    if (iterationType === kIsSet) {
      if (!setEquiv(a, b, strict, memos)) {
        return false;
      }
    } else if (iterationType === kIsMap) {
      if (!mapEquiv(a, b, strict, memos)) {
        return false;
      }
    } else if (iterationType === kIsArray) {
      for (; i < a.length; i++) {
        if (hasOwnProperty(a, i)) {
          if (!hasOwnProperty(b, i) || !innerDeepEqual(a[i], b[i], strict, memos)) {
            return false;
          }
        } else if (hasOwnProperty(b, i)) {
          return false;
        } else {
          var keysA = Object.keys(a);
          for (; i < keysA.length; i++) {
            var key = keysA[i];
            if (!hasOwnProperty(b, key) || !innerDeepEqual(a[key], b[key], strict, memos)) {
              return false;
            }
          }
          if (keysA.length !== Object.keys(b).length) {
            return false;
          }
          return true;
        }
      }
    }
    for (i = 0; i < keys.length; i++) {
      var _key = keys[i];
      if (!innerDeepEqual(a[_key], b[_key], strict, memos)) {
        return false;
      }
    }
    return true;
  }
  function isDeepEqual(val1, val2) {
    return innerDeepEqual(val1, val2, kLoose);
  }
  function isDeepStrictEqual(val1, val2) {
    return innerDeepEqual(val1, val2, kStrict);
  }
  module2.exports = {
    isDeepEqual,
    isDeepStrictEqual
  };
});

// node_modules/assert/build/assert.js
var require_assert = __commonJS((exports2, module2) => {
  "use strict";
  function _typeof(obj) {
    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      _typeof = function _typeof2(obj2) {
        return typeof obj2;
      };
    } else {
      _typeof = function _typeof2(obj2) {
        return obj2 && typeof Symbol === "function" && obj2.constructor === Symbol && obj2 !== Symbol.prototype ? "symbol" : typeof obj2;
      };
    }
    return _typeof(obj);
  }
  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
  var _require = require_errors10();
  var _require$codes = _require.codes;
  var ERR_AMBIGUOUS_ARGUMENT = _require$codes.ERR_AMBIGUOUS_ARGUMENT;
  var ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE;
  var ERR_INVALID_ARG_VALUE = _require$codes.ERR_INVALID_ARG_VALUE;
  var ERR_INVALID_RETURN_VALUE = _require$codes.ERR_INVALID_RETURN_VALUE;
  var ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS;
  var AssertionError = require_assertion_error();
  var _require2 = require_util10();
  var inspect = _require2.inspect;
  var _require$types = require_util10().types;
  var isPromise = _require$types.isPromise;
  var isRegExp = _require$types.isRegExp;
  var objectAssign = Object.assign ? Object.assign : require_es6_object_assign().assign;
  var objectIs = Object.is ? Object.is : require_object_is();
  var errorCache = new Map();
  var isDeepEqual;
  var isDeepStrictEqual;
  function lazyLoadComparison() {
    var comparison = require_comparisons();
    isDeepEqual = comparison.isDeepEqual;
    isDeepStrictEqual = comparison.isDeepStrictEqual;
  }
  var warned = false;
  var assert = module2.exports = ok;
  var NO_EXCEPTION_SENTINEL = {};
  function innerFail(obj) {
    if (obj.message instanceof Error)
      throw obj.message;
    throw new AssertionError(obj);
  }
  function fail(actual, expected, message, operator, stackStartFn) {
    var argsLen = arguments.length;
    var internalMessage;
    if (argsLen === 0) {
      internalMessage = "Failed";
    } else if (argsLen === 1) {
      message = actual;
      actual = void 0;
    } else {
      if (warned === false) {
        warned = true;
        var warn = process.emitWarning ? process.emitWarning : console.warn.bind(console);
        warn("assert.fail() with more than one argument is deprecated. Please use assert.strictEqual() instead or only pass a message.", "DeprecationWarning", "DEP0094");
      }
      if (argsLen === 2)
        operator = "!=";
    }
    if (message instanceof Error)
      throw message;
    var errArgs = {
      actual,
      expected,
      operator: operator === void 0 ? "fail" : operator,
      stackStartFn: stackStartFn || fail
    };
    if (message !== void 0) {
      errArgs.message = message;
    }
    var err = new AssertionError(errArgs);
    if (internalMessage) {
      err.message = internalMessage;
      err.generatedMessage = true;
    }
    throw err;
  }
  assert.fail = fail;
  assert.AssertionError = AssertionError;
  function innerOk(fn, argLen, value, message) {
    if (!value) {
      var generatedMessage = false;
      if (argLen === 0) {
        generatedMessage = true;
        message = "No value argument passed to `assert.ok()`";
      } else if (message instanceof Error) {
        throw message;
      }
      var err = new AssertionError({
        actual: value,
        expected: true,
        message,
        operator: "==",
        stackStartFn: fn
      });
      err.generatedMessage = generatedMessage;
      throw err;
    }
  }
  function ok() {
    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }
    innerOk.apply(void 0, [ok, args.length].concat(args));
  }
  assert.ok = ok;
  assert.equal = function equal(actual, expected, message) {
    if (arguments.length < 2) {
      throw new ERR_MISSING_ARGS("actual", "expected");
    }
    if (actual != expected) {
      innerFail({
        actual,
        expected,
        message,
        operator: "==",
        stackStartFn: equal
      });
    }
  };
  assert.notEqual = function notEqual(actual, expected, message) {
    if (arguments.length < 2) {
      throw new ERR_MISSING_ARGS("actual", "expected");
    }
    if (actual == expected) {
      innerFail({
        actual,
        expected,
        message,
        operator: "!=",
        stackStartFn: notEqual
      });
    }
  };
  assert.deepEqual = function deepEqual(actual, expected, message) {
    if (arguments.length < 2) {
      throw new ERR_MISSING_ARGS("actual", "expected");
    }
    if (isDeepEqual === void 0)
      lazyLoadComparison();
    if (!isDeepEqual(actual, expected)) {
      innerFail({
        actual,
        expected,
        message,
        operator: "deepEqual",
        stackStartFn: deepEqual
      });
    }
  };
  assert.notDeepEqual = function notDeepEqual(actual, expected, message) {
    if (arguments.length < 2) {
      throw new ERR_MISSING_ARGS("actual", "expected");
    }
    if (isDeepEqual === void 0)
      lazyLoadComparison();
    if (isDeepEqual(actual, expected)) {
      innerFail({
        actual,
        expected,
        message,
        operator: "notDeepEqual",
        stackStartFn: notDeepEqual
      });
    }
  };
  assert.deepStrictEqual = function deepStrictEqual(actual, expected, message) {
    if (arguments.length < 2) {
      throw new ERR_MISSING_ARGS("actual", "expected");
    }
    if (isDeepEqual === void 0)
      lazyLoadComparison();
    if (!isDeepStrictEqual(actual, expected)) {
      innerFail({
        actual,
        expected,
        message,
        operator: "deepStrictEqual",
        stackStartFn: deepStrictEqual
      });
    }
  };
  assert.notDeepStrictEqual = notDeepStrictEqual;
  function notDeepStrictEqual(actual, expected, message) {
    if (arguments.length < 2) {
      throw new ERR_MISSING_ARGS("actual", "expected");
    }
    if (isDeepEqual === void 0)
      lazyLoadComparison();
    if (isDeepStrictEqual(actual, expected)) {
      innerFail({
        actual,
        expected,
        message,
        operator: "notDeepStrictEqual",
        stackStartFn: notDeepStrictEqual
      });
    }
  }
  assert.strictEqual = function strictEqual(actual, expected, message) {
    if (arguments.length < 2) {
      throw new ERR_MISSING_ARGS("actual", "expected");
    }
    if (!objectIs(actual, expected)) {
      innerFail({
        actual,
        expected,
        message,
        operator: "strictEqual",
        stackStartFn: strictEqual
      });
    }
  };
  assert.notStrictEqual = function notStrictEqual(actual, expected, message) {
    if (arguments.length < 2) {
      throw new ERR_MISSING_ARGS("actual", "expected");
    }
    if (objectIs(actual, expected)) {
      innerFail({
        actual,
        expected,
        message,
        operator: "notStrictEqual",
        stackStartFn: notStrictEqual
      });
    }
  };
  var Comparison = function Comparison2(obj, keys, actual) {
    var _this = this;
    _classCallCheck(this, Comparison2);
    keys.forEach(function(key) {
      if (key in obj) {
        if (actual !== void 0 && typeof actual[key] === "string" && isRegExp(obj[key]) && obj[key].test(actual[key])) {
          _this[key] = actual[key];
        } else {
          _this[key] = obj[key];
        }
      }
    });
  };
  function compareExceptionKey(actual, expected, key, message, keys, fn) {
    if (!(key in actual) || !isDeepStrictEqual(actual[key], expected[key])) {
      if (!message) {
        var a = new Comparison(actual, keys);
        var b = new Comparison(expected, keys, actual);
        var err = new AssertionError({
          actual: a,
          expected: b,
          operator: "deepStrictEqual",
          stackStartFn: fn
        });
        err.actual = actual;
        err.expected = expected;
        err.operator = fn.name;
        throw err;
      }
      innerFail({
        actual,
        expected,
        message,
        operator: fn.name,
        stackStartFn: fn
      });
    }
  }
  function expectedException(actual, expected, msg, fn) {
    if (typeof expected !== "function") {
      if (isRegExp(expected))
        return expected.test(actual);
      if (arguments.length === 2) {
        throw new ERR_INVALID_ARG_TYPE("expected", ["Function", "RegExp"], expected);
      }
      if (_typeof(actual) !== "object" || actual === null) {
        var err = new AssertionError({
          actual,
          expected,
          message: msg,
          operator: "deepStrictEqual",
          stackStartFn: fn
        });
        err.operator = fn.name;
        throw err;
      }
      var keys = Object.keys(expected);
      if (expected instanceof Error) {
        keys.push("name", "message");
      } else if (keys.length === 0) {
        throw new ERR_INVALID_ARG_VALUE("error", expected, "may not be an empty object");
      }
      if (isDeepEqual === void 0)
        lazyLoadComparison();
      keys.forEach(function(key) {
        if (typeof actual[key] === "string" && isRegExp(expected[key]) && expected[key].test(actual[key])) {
          return;
        }
        compareExceptionKey(actual, expected, key, msg, keys, fn);
      });
      return true;
    }
    if (expected.prototype !== void 0 && actual instanceof expected) {
      return true;
    }
    if (Error.isPrototypeOf(expected)) {
      return false;
    }
    return expected.call({}, actual) === true;
  }
  function getActual(fn) {
    if (typeof fn !== "function") {
      throw new ERR_INVALID_ARG_TYPE("fn", "Function", fn);
    }
    try {
      fn();
    } catch (e) {
      return e;
    }
    return NO_EXCEPTION_SENTINEL;
  }
  function checkIsPromise(obj) {
    return isPromise(obj) || obj !== null && _typeof(obj) === "object" && typeof obj.then === "function" && typeof obj.catch === "function";
  }
  function waitForActual(promiseFn) {
    return Promise.resolve().then(function() {
      var resultPromise;
      if (typeof promiseFn === "function") {
        resultPromise = promiseFn();
        if (!checkIsPromise(resultPromise)) {
          throw new ERR_INVALID_RETURN_VALUE("instance of Promise", "promiseFn", resultPromise);
        }
      } else if (checkIsPromise(promiseFn)) {
        resultPromise = promiseFn;
      } else {
        throw new ERR_INVALID_ARG_TYPE("promiseFn", ["Function", "Promise"], promiseFn);
      }
      return Promise.resolve().then(function() {
        return resultPromise;
      }).then(function() {
        return NO_EXCEPTION_SENTINEL;
      }).catch(function(e) {
        return e;
      });
    });
  }
  function expectsError(stackStartFn, actual, error, message) {
    if (typeof error === "string") {
      if (arguments.length === 4) {
        throw new ERR_INVALID_ARG_TYPE("error", ["Object", "Error", "Function", "RegExp"], error);
      }
      if (_typeof(actual) === "object" && actual !== null) {
        if (actual.message === error) {
          throw new ERR_AMBIGUOUS_ARGUMENT("error/message", 'The error message "'.concat(actual.message, '" is identical to the message.'));
        }
      } else if (actual === error) {
        throw new ERR_AMBIGUOUS_ARGUMENT("error/message", 'The error "'.concat(actual, '" is identical to the message.'));
      }
      message = error;
      error = void 0;
    } else if (error != null && _typeof(error) !== "object" && typeof error !== "function") {
      throw new ERR_INVALID_ARG_TYPE("error", ["Object", "Error", "Function", "RegExp"], error);
    }
    if (actual === NO_EXCEPTION_SENTINEL) {
      var details = "";
      if (error && error.name) {
        details += " (".concat(error.name, ")");
      }
      details += message ? ": ".concat(message) : ".";
      var fnType = stackStartFn.name === "rejects" ? "rejection" : "exception";
      innerFail({
        actual: void 0,
        expected: error,
        operator: stackStartFn.name,
        message: "Missing expected ".concat(fnType).concat(details),
        stackStartFn
      });
    }
    if (error && !expectedException(actual, error, message, stackStartFn)) {
      throw actual;
    }
  }
  function expectsNoError(stackStartFn, actual, error, message) {
    if (actual === NO_EXCEPTION_SENTINEL)
      return;
    if (typeof error === "string") {
      message = error;
      error = void 0;
    }
    if (!error || expectedException(actual, error)) {
      var details = message ? ": ".concat(message) : ".";
      var fnType = stackStartFn.name === "doesNotReject" ? "rejection" : "exception";
      innerFail({
        actual,
        expected: error,
        operator: stackStartFn.name,
        message: "Got unwanted ".concat(fnType).concat(details, "\n") + 'Actual message: "'.concat(actual && actual.message, '"'),
        stackStartFn
      });
    }
    throw actual;
  }
  assert.throws = function throws(promiseFn) {
    for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
      args[_key2 - 1] = arguments[_key2];
    }
    expectsError.apply(void 0, [throws, getActual(promiseFn)].concat(args));
  };
  assert.rejects = function rejects(promiseFn) {
    for (var _len3 = arguments.length, args = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
      args[_key3 - 1] = arguments[_key3];
    }
    return waitForActual(promiseFn).then(function(result) {
      return expectsError.apply(void 0, [rejects, result].concat(args));
    });
  };
  assert.doesNotThrow = function doesNotThrow(fn) {
    for (var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
      args[_key4 - 1] = arguments[_key4];
    }
    expectsNoError.apply(void 0, [doesNotThrow, getActual(fn)].concat(args));
  };
  assert.doesNotReject = function doesNotReject(fn) {
    for (var _len5 = arguments.length, args = new Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) {
      args[_key5 - 1] = arguments[_key5];
    }
    return waitForActual(fn).then(function(result) {
      return expectsNoError.apply(void 0, [doesNotReject, result].concat(args));
    });
  };
  assert.ifError = function ifError(err) {
    if (err !== null && err !== void 0) {
      var message = "ifError got unwanted exception: ";
      if (_typeof(err) === "object" && typeof err.message === "string") {
        if (err.message.length === 0 && err.constructor) {
          message += err.constructor.name;
        } else {
          message += err.message;
        }
      } else {
        message += inspect(err);
      }
      var newErr = new AssertionError({
        actual: err,
        expected: null,
        operator: "ifError",
        message,
        stackStartFn: ifError
      });
      var origStack = err.stack;
      if (typeof origStack === "string") {
        var tmp2 = origStack.split("\n");
        tmp2.shift();
        var tmp1 = newErr.stack.split("\n");
        for (var i = 0; i < tmp2.length; i++) {
          var pos = tmp1.indexOf(tmp2[i]);
          if (pos !== -1) {
            tmp1 = tmp1.slice(0, pos);
            break;
          }
        }
        newErr.stack = "".concat(tmp1.join("\n"), "\n").concat(tmp2.join("\n"));
      }
      throw newErr;
    }
  };
  function strict() {
    for (var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
      args[_key6] = arguments[_key6];
    }
    innerOk.apply(void 0, [strict, args.length].concat(args));
  }
  assert.strict = objectAssign(strict, assert, {
    equal: assert.strictEqual,
    deepEqual: assert.deepStrictEqual,
    notEqual: assert.notStrictEqual,
    notDeepEqual: assert.notDeepStrictEqual
  });
  assert.strict.strict = assert.strict;
});

// node_modules/levelup/lib/levelup.js
var require_levelup = __commonJS((exports2, module2) => {
  var EventEmitter = require_events().EventEmitter;
  var inherits = require_util10().inherits;
  var extend = require_immutable();
  var DeferredLevelDOWN = require_deferred_leveldown();
  var IteratorStream = require_level_iterator_stream();
  var Batch = require_batch();
  var errors = require_errors9();
  var supports = require_level_supports();
  var assert = require_assert();
  var promisify = require_promisify();
  var getCallback = require_common4().getCallback;
  var getOptions = require_common4().getOptions;
  var WriteError = errors.WriteError;
  var ReadError = errors.ReadError;
  var NotFoundError = errors.NotFoundError;
  var OpenError = errors.OpenError;
  var InitializationError = errors.InitializationError;
  function LevelUP(db, options, callback) {
    if (!(this instanceof LevelUP)) {
      return new LevelUP(db, options, callback);
    }
    var error;
    var self2 = this;
    EventEmitter.call(this);
    this.setMaxListeners(Infinity);
    if (typeof options === "function") {
      callback = options;
      options = {};
    }
    options = options || {};
    if (!db || typeof db !== "object") {
      error = new InitializationError("First argument must be an abstract-leveldown compliant store");
      if (typeof callback === "function") {
        return process.nextTick(callback, error);
      }
      throw error;
    }
    assert.strictEqual(typeof db.status, "string", ".status required, old abstract-leveldown");
    this.options = getOptions(options);
    this._db = db;
    this.db = new DeferredLevelDOWN(db);
    this.open(callback || function(err) {
      if (err)
        self2.emit("error", err);
    });
    this.supports = supports(this.db.supports, {
      status: false,
      deferredOpen: true,
      openCallback: true,
      promises: true,
      streams: true
    });
    Object.keys(this.supports.additionalMethods).forEach(function(method) {
      if (this[method] != null)
        return;
      this[method] = function() {
        return this.db[method].apply(this.db, arguments);
      };
    }, this);
  }
  LevelUP.prototype.emit = EventEmitter.prototype.emit;
  LevelUP.prototype.once = EventEmitter.prototype.once;
  inherits(LevelUP, EventEmitter);
  LevelUP.prototype.open = function(opts, callback) {
    var self2 = this;
    var promise;
    if (typeof opts === "function") {
      callback = opts;
      opts = null;
    }
    if (!callback) {
      callback = promisify();
      promise = callback.promise;
    }
    if (!opts) {
      opts = this.options;
    }
    if (this.isOpen()) {
      process.nextTick(callback, null, self2);
      return promise;
    }
    if (this._isOpening()) {
      this.once("open", function() {
        callback(null, self2);
      });
      return promise;
    }
    this.emit("opening");
    this.db.open(opts, function(err) {
      if (err) {
        return callback(new OpenError(err));
      }
      self2.db = self2._db;
      callback(null, self2);
      self2.emit("open");
      self2.emit("ready");
    });
    return promise;
  };
  LevelUP.prototype.close = function(callback) {
    var self2 = this;
    var promise;
    if (!callback) {
      callback = promisify();
      promise = callback.promise;
    }
    if (this.isOpen()) {
      this.db.close(function() {
        self2.emit("closed");
        callback.apply(null, arguments);
      });
      this.emit("closing");
      this.db = new DeferredLevelDOWN(this._db);
    } else if (this.isClosed()) {
      process.nextTick(callback);
    } else if (this.db.status === "closing") {
      this.once("closed", callback);
    } else if (this._isOpening()) {
      this.once("open", function() {
        self2.close(callback);
      });
    }
    return promise;
  };
  LevelUP.prototype.isOpen = function() {
    return this.db.status === "open";
  };
  LevelUP.prototype._isOpening = function() {
    return this.db.status === "opening";
  };
  LevelUP.prototype.isClosed = function() {
    return /^clos|new/.test(this.db.status);
  };
  LevelUP.prototype.get = function(key, options, callback) {
    var promise;
    callback = getCallback(options, callback);
    if (!callback) {
      callback = promisify();
      promise = callback.promise;
    }
    if (maybeError(this, callback)) {
      return promise;
    }
    options = getOptions(options);
    this.db.get(key, options, function(err, value) {
      if (err) {
        if (/notfound/i.test(err) || err.notFound) {
          err = new NotFoundError("Key not found in database [" + key + "]", err);
        } else {
          err = new ReadError(err);
        }
        return callback(err);
      }
      callback(null, value);
    });
    return promise;
  };
  LevelUP.prototype.put = function(key, value, options, callback) {
    var self2 = this;
    var promise;
    callback = getCallback(options, callback);
    if (!callback) {
      callback = promisify();
      promise = callback.promise;
    }
    if (maybeError(this, callback)) {
      return promise;
    }
    options = getOptions(options);
    this.db.put(key, value, options, function(err) {
      if (err) {
        return callback(new WriteError(err));
      }
      self2.emit("put", key, value);
      callback();
    });
    return promise;
  };
  LevelUP.prototype.del = function(key, options, callback) {
    var self2 = this;
    var promise;
    callback = getCallback(options, callback);
    if (!callback) {
      callback = promisify();
      promise = callback.promise;
    }
    if (maybeError(this, callback)) {
      return promise;
    }
    options = getOptions(options);
    this.db.del(key, options, function(err) {
      if (err) {
        return callback(new WriteError(err));
      }
      self2.emit("del", key);
      callback();
    });
    return promise;
  };
  LevelUP.prototype.batch = function(arr, options, callback) {
    if (!arguments.length) {
      return new Batch(this);
    }
    var self2 = this;
    var promise;
    if (typeof arr === "function")
      callback = arr;
    else
      callback = getCallback(options, callback);
    if (!callback) {
      callback = promisify();
      promise = callback.promise;
    }
    if (maybeError(this, callback)) {
      return promise;
    }
    options = getOptions(options);
    this.db.batch(arr, options, function(err) {
      if (err) {
        return callback(new WriteError(err));
      }
      self2.emit("batch", arr);
      callback();
    });
    return promise;
  };
  LevelUP.prototype.iterator = function(options) {
    return this.db.iterator(options);
  };
  LevelUP.prototype.clear = function(options, callback) {
    var self2 = this;
    var promise;
    callback = getCallback(options, callback);
    options = getOptions(options);
    if (!callback) {
      callback = promisify();
      promise = callback.promise;
    }
    if (maybeError(this, callback)) {
      return promise;
    }
    this.db.clear(options, function(err) {
      if (err) {
        return callback(new WriteError(err));
      }
      self2.emit("clear", options);
      callback();
    });
    return promise;
  };
  LevelUP.prototype.readStream = LevelUP.prototype.createReadStream = function(options) {
    options = extend({keys: true, values: true}, options);
    if (typeof options.limit !== "number") {
      options.limit = -1;
    }
    return new IteratorStream(this.db.iterator(options), options);
  };
  LevelUP.prototype.keyStream = LevelUP.prototype.createKeyStream = function(options) {
    return this.createReadStream(extend(options, {keys: true, values: false}));
  };
  LevelUP.prototype.valueStream = LevelUP.prototype.createValueStream = function(options) {
    return this.createReadStream(extend(options, {keys: false, values: true}));
  };
  LevelUP.prototype.toString = function() {
    return "LevelUP";
  };
  LevelUP.prototype.type = "levelup";
  function maybeError(db, callback) {
    if (!db._isOpening() && !db.isOpen()) {
      process.nextTick(callback, new ReadError("Database is not open"));
      return true;
    }
  }
  LevelUP.errors = errors;
  module2.exports = LevelUP.default = LevelUP;
});

// node_modules/encoding-down/node_modules/abstract-leveldown/next-tick-browser.js
var require_next_tick_browser2 = __commonJS((exports2, module2) => {
  module2.exports = require_lib6();
});

// node_modules/encoding-down/node_modules/abstract-leveldown/abstract-iterator.js
var require_abstract_iterator2 = __commonJS((exports2, module2) => {
  var nextTick = require_next_tick_browser2();
  function AbstractIterator(db) {
    if (typeof db !== "object" || db === null) {
      throw new TypeError("First argument must be an abstract-leveldown compliant store");
    }
    this.db = db;
    this._ended = false;
    this._nexting = false;
  }
  AbstractIterator.prototype.next = function(callback) {
    var self2 = this;
    if (typeof callback !== "function") {
      throw new Error("next() requires a callback argument");
    }
    if (self2._ended) {
      nextTick(callback, new Error("cannot call next() after end()"));
      return self2;
    }
    if (self2._nexting) {
      nextTick(callback, new Error("cannot call next() before previous next() has completed"));
      return self2;
    }
    self2._nexting = true;
    self2._next(function() {
      self2._nexting = false;
      callback.apply(null, arguments);
    });
    return self2;
  };
  AbstractIterator.prototype._next = function(callback) {
    nextTick(callback);
  };
  AbstractIterator.prototype.seek = function(target) {
    if (this._ended) {
      throw new Error("cannot call seek() after end()");
    }
    if (this._nexting) {
      throw new Error("cannot call seek() before next() has completed");
    }
    target = this.db._serializeKey(target);
    this._seek(target);
  };
  AbstractIterator.prototype._seek = function(target) {
  };
  AbstractIterator.prototype.end = function(callback) {
    if (typeof callback !== "function") {
      throw new Error("end() requires a callback argument");
    }
    if (this._ended) {
      return nextTick(callback, new Error("end() already called on iterator"));
    }
    this._ended = true;
    this._end(callback);
  };
  AbstractIterator.prototype._end = function(callback) {
    nextTick(callback);
  };
  AbstractIterator.prototype._nextTick = nextTick;
  module2.exports = AbstractIterator;
});

// node_modules/encoding-down/node_modules/abstract-leveldown/abstract-chained-batch.js
var require_abstract_chained_batch2 = __commonJS((exports2, module2) => {
  var nextTick = require_next_tick_browser2();
  function AbstractChainedBatch(db) {
    if (typeof db !== "object" || db === null) {
      throw new TypeError("First argument must be an abstract-leveldown compliant store");
    }
    this.db = db;
    this._operations = [];
    this._written = false;
  }
  AbstractChainedBatch.prototype._checkWritten = function() {
    if (this._written) {
      throw new Error("write() already called on this batch");
    }
  };
  AbstractChainedBatch.prototype.put = function(key, value) {
    this._checkWritten();
    var err = this.db._checkKey(key) || this.db._checkValue(value);
    if (err)
      throw err;
    key = this.db._serializeKey(key);
    value = this.db._serializeValue(value);
    this._put(key, value);
    return this;
  };
  AbstractChainedBatch.prototype._put = function(key, value) {
    this._operations.push({type: "put", key, value});
  };
  AbstractChainedBatch.prototype.del = function(key) {
    this._checkWritten();
    var err = this.db._checkKey(key);
    if (err)
      throw err;
    key = this.db._serializeKey(key);
    this._del(key);
    return this;
  };
  AbstractChainedBatch.prototype._del = function(key) {
    this._operations.push({type: "del", key});
  };
  AbstractChainedBatch.prototype.clear = function() {
    this._checkWritten();
    this._clear();
    return this;
  };
  AbstractChainedBatch.prototype._clear = function() {
    this._operations = [];
  };
  AbstractChainedBatch.prototype.write = function(options, callback) {
    this._checkWritten();
    if (typeof options === "function") {
      callback = options;
    }
    if (typeof callback !== "function") {
      throw new Error("write() requires a callback argument");
    }
    if (typeof options !== "object" || options === null) {
      options = {};
    }
    this._written = true;
    this._write(options, callback);
  };
  AbstractChainedBatch.prototype._write = function(options, callback) {
    this.db._batch(this._operations, options, callback);
  };
  AbstractChainedBatch.prototype._nextTick = nextTick;
  module2.exports = AbstractChainedBatch;
});

// node_modules/encoding-down/node_modules/abstract-leveldown/abstract-leveldown.js
var require_abstract_leveldown3 = __commonJS((exports2, module2) => {
  var xtend = require_immutable();
  var supports = require_level_supports();
  var Buffer2 = require_buffer().Buffer;
  var AbstractIterator = require_abstract_iterator2();
  var AbstractChainedBatch = require_abstract_chained_batch2();
  var nextTick = require_next_tick_browser2();
  var hasOwnProperty = Object.prototype.hasOwnProperty;
  var rangeOptions = "start end gt gte lt lte".split(" ");
  function AbstractLevelDOWN(manifest) {
    this.status = "new";
    this.supports = supports(manifest, {
      status: true
    });
  }
  AbstractLevelDOWN.prototype.open = function(options, callback) {
    var self2 = this;
    var oldStatus = this.status;
    if (typeof options === "function")
      callback = options;
    if (typeof callback !== "function") {
      throw new Error("open() requires a callback argument");
    }
    if (typeof options !== "object" || options === null)
      options = {};
    options.createIfMissing = options.createIfMissing !== false;
    options.errorIfExists = !!options.errorIfExists;
    this.status = "opening";
    this._open(options, function(err) {
      if (err) {
        self2.status = oldStatus;
        return callback(err);
      }
      self2.status = "open";
      callback();
    });
  };
  AbstractLevelDOWN.prototype._open = function(options, callback) {
    nextTick(callback);
  };
  AbstractLevelDOWN.prototype.close = function(callback) {
    var self2 = this;
    var oldStatus = this.status;
    if (typeof callback !== "function") {
      throw new Error("close() requires a callback argument");
    }
    this.status = "closing";
    this._close(function(err) {
      if (err) {
        self2.status = oldStatus;
        return callback(err);
      }
      self2.status = "closed";
      callback();
    });
  };
  AbstractLevelDOWN.prototype._close = function(callback) {
    nextTick(callback);
  };
  AbstractLevelDOWN.prototype.get = function(key, options, callback) {
    if (typeof options === "function")
      callback = options;
    if (typeof callback !== "function") {
      throw new Error("get() requires a callback argument");
    }
    var err = this._checkKey(key);
    if (err)
      return nextTick(callback, err);
    key = this._serializeKey(key);
    if (typeof options !== "object" || options === null)
      options = {};
    options.asBuffer = options.asBuffer !== false;
    this._get(key, options, callback);
  };
  AbstractLevelDOWN.prototype._get = function(key, options, callback) {
    nextTick(function() {
      callback(new Error("NotFound"));
    });
  };
  AbstractLevelDOWN.prototype.put = function(key, value, options, callback) {
    if (typeof options === "function")
      callback = options;
    if (typeof callback !== "function") {
      throw new Error("put() requires a callback argument");
    }
    var err = this._checkKey(key) || this._checkValue(value);
    if (err)
      return nextTick(callback, err);
    key = this._serializeKey(key);
    value = this._serializeValue(value);
    if (typeof options !== "object" || options === null)
      options = {};
    this._put(key, value, options, callback);
  };
  AbstractLevelDOWN.prototype._put = function(key, value, options, callback) {
    nextTick(callback);
  };
  AbstractLevelDOWN.prototype.del = function(key, options, callback) {
    if (typeof options === "function")
      callback = options;
    if (typeof callback !== "function") {
      throw new Error("del() requires a callback argument");
    }
    var err = this._checkKey(key);
    if (err)
      return nextTick(callback, err);
    key = this._serializeKey(key);
    if (typeof options !== "object" || options === null)
      options = {};
    this._del(key, options, callback);
  };
  AbstractLevelDOWN.prototype._del = function(key, options, callback) {
    nextTick(callback);
  };
  AbstractLevelDOWN.prototype.batch = function(array, options, callback) {
    if (!arguments.length)
      return this._chainedBatch();
    if (typeof options === "function")
      callback = options;
    if (typeof array === "function")
      callback = array;
    if (typeof callback !== "function") {
      throw new Error("batch(array) requires a callback argument");
    }
    if (!Array.isArray(array)) {
      return nextTick(callback, new Error("batch(array) requires an array argument"));
    }
    if (array.length === 0) {
      return nextTick(callback);
    }
    if (typeof options !== "object" || options === null)
      options = {};
    var serialized = new Array(array.length);
    for (var i = 0; i < array.length; i++) {
      if (typeof array[i] !== "object" || array[i] === null) {
        return nextTick(callback, new Error("batch(array) element must be an object and not `null`"));
      }
      var e = xtend(array[i]);
      if (e.type !== "put" && e.type !== "del") {
        return nextTick(callback, new Error("`type` must be 'put' or 'del'"));
      }
      var err = this._checkKey(e.key);
      if (err)
        return nextTick(callback, err);
      e.key = this._serializeKey(e.key);
      if (e.type === "put") {
        var valueErr = this._checkValue(e.value);
        if (valueErr)
          return nextTick(callback, valueErr);
        e.value = this._serializeValue(e.value);
      }
      serialized[i] = e;
    }
    this._batch(serialized, options, callback);
  };
  AbstractLevelDOWN.prototype._batch = function(array, options, callback) {
    nextTick(callback);
  };
  AbstractLevelDOWN.prototype.clear = function(options, callback) {
    if (typeof options === "function") {
      callback = options;
    } else if (typeof callback !== "function") {
      throw new Error("clear() requires a callback argument");
    }
    options = cleanRangeOptions(this, options);
    options.reverse = !!options.reverse;
    options.limit = "limit" in options ? options.limit : -1;
    this._clear(options, callback);
  };
  AbstractLevelDOWN.prototype._clear = function(options, callback) {
    options.keys = true;
    options.values = false;
    options.keyAsBuffer = true;
    options.valueAsBuffer = true;
    var iterator = this._iterator(options);
    var emptyOptions = {};
    var self2 = this;
    var next = function(err) {
      if (err) {
        return iterator.end(function() {
          callback(err);
        });
      }
      iterator.next(function(err2, key) {
        if (err2)
          return next(err2);
        if (key === void 0)
          return iterator.end(callback);
        self2._del(key, emptyOptions, next);
      });
    };
    next();
  };
  AbstractLevelDOWN.prototype._setupIteratorOptions = function(options) {
    options = cleanRangeOptions(this, options);
    options.reverse = !!options.reverse;
    options.keys = options.keys !== false;
    options.values = options.values !== false;
    options.limit = "limit" in options ? options.limit : -1;
    options.keyAsBuffer = options.keyAsBuffer !== false;
    options.valueAsBuffer = options.valueAsBuffer !== false;
    return options;
  };
  function cleanRangeOptions(db, options) {
    var result = {};
    for (var k in options) {
      if (!hasOwnProperty.call(options, k))
        continue;
      var opt = options[k];
      if (isRangeOption(k)) {
        opt = db._serializeKey(opt);
      }
      result[k] = opt;
    }
    return result;
  }
  function isRangeOption(k) {
    return rangeOptions.indexOf(k) !== -1;
  }
  AbstractLevelDOWN.prototype.iterator = function(options) {
    if (typeof options !== "object" || options === null)
      options = {};
    options = this._setupIteratorOptions(options);
    return this._iterator(options);
  };
  AbstractLevelDOWN.prototype._iterator = function(options) {
    return new AbstractIterator(this);
  };
  AbstractLevelDOWN.prototype._chainedBatch = function() {
    return new AbstractChainedBatch(this);
  };
  AbstractLevelDOWN.prototype._serializeKey = function(key) {
    return key;
  };
  AbstractLevelDOWN.prototype._serializeValue = function(value) {
    return value;
  };
  AbstractLevelDOWN.prototype._checkKey = function(key) {
    if (key === null || key === void 0) {
      return new Error("key cannot be `null` or `undefined`");
    } else if (Buffer2.isBuffer(key) && key.length === 0) {
      return new Error("key cannot be an empty Buffer");
    } else if (key === "") {
      return new Error("key cannot be an empty String");
    } else if (Array.isArray(key) && key.length === 0) {
      return new Error("key cannot be an empty Array");
    }
  };
  AbstractLevelDOWN.prototype._checkValue = function(value) {
    if (value === null || value === void 0) {
      return new Error("value cannot be `null` or `undefined`");
    }
  };
  AbstractLevelDOWN.prototype._nextTick = nextTick;
  module2.exports = AbstractLevelDOWN;
});

// node_modules/encoding-down/node_modules/abstract-leveldown/index.js
var require_abstract_leveldown4 = __commonJS((exports2) => {
  exports2.AbstractLevelDOWN = require_abstract_leveldown3();
  exports2.AbstractIterator = require_abstract_iterator2();
  exports2.AbstractChainedBatch = require_abstract_chained_batch2();
});

// node_modules/level-codec/lib/encodings.js
var require_encodings2 = __commonJS((exports2) => {
  var Buffer2 = require_buffer().Buffer;
  exports2.utf8 = exports2["utf-8"] = {
    encode: function(data) {
      return isBinary(data) ? data : String(data);
    },
    decode: identity,
    buffer: false,
    type: "utf8"
  };
  exports2.json = {
    encode: JSON.stringify,
    decode: JSON.parse,
    buffer: false,
    type: "json"
  };
  exports2.binary = {
    encode: function(data) {
      return isBinary(data) ? data : Buffer2.from(data);
    },
    decode: identity,
    buffer: true,
    type: "binary"
  };
  exports2.none = {
    encode: identity,
    decode: identity,
    buffer: false,
    type: "id"
  };
  exports2.id = exports2.none;
  var bufferEncodings = [
    "hex",
    "ascii",
    "base64",
    "ucs2",
    "ucs-2",
    "utf16le",
    "utf-16le"
  ];
  bufferEncodings.forEach(function(type) {
    exports2[type] = {
      encode: function(data) {
        return isBinary(data) ? data : Buffer2.from(data, type);
      },
      decode: function(buffer) {
        return buffer.toString(type);
      },
      buffer: true,
      type
    };
  });
  function identity(value) {
    return value;
  }
  function isBinary(data) {
    return data === void 0 || data === null || Buffer2.isBuffer(data);
  }
});

// node_modules/level-codec/index.js
var require_level_codec = __commonJS((exports2, module2) => {
  var encodings = require_encodings2();
  module2.exports = Codec;
  function Codec(opts) {
    if (!(this instanceof Codec)) {
      return new Codec(opts);
    }
    this.opts = opts || {};
    this.encodings = encodings;
  }
  Codec.prototype._encoding = function(encoding) {
    if (typeof encoding === "string")
      encoding = encodings[encoding];
    if (!encoding)
      encoding = encodings.id;
    return encoding;
  };
  Codec.prototype._keyEncoding = function(opts, batchOpts) {
    return this._encoding(batchOpts && batchOpts.keyEncoding || opts && opts.keyEncoding || this.opts.keyEncoding);
  };
  Codec.prototype._valueEncoding = function(opts, batchOpts) {
    return this._encoding(batchOpts && (batchOpts.valueEncoding || batchOpts.encoding) || opts && (opts.valueEncoding || opts.encoding) || (this.opts.valueEncoding || this.opts.encoding));
  };
  Codec.prototype.encodeKey = function(key, opts, batchOpts) {
    return this._keyEncoding(opts, batchOpts).encode(key);
  };
  Codec.prototype.encodeValue = function(value, opts, batchOpts) {
    return this._valueEncoding(opts, batchOpts).encode(value);
  };
  Codec.prototype.decodeKey = function(key, opts) {
    return this._keyEncoding(opts).decode(key);
  };
  Codec.prototype.decodeValue = function(value, opts) {
    return this._valueEncoding(opts).decode(value);
  };
  Codec.prototype.encodeBatch = function(ops, opts) {
    var self2 = this;
    return ops.map(function(_op) {
      var op = {
        type: _op.type,
        key: self2.encodeKey(_op.key, opts, _op)
      };
      if (self2.keyAsBuffer(opts, _op))
        op.keyEncoding = "binary";
      if (_op.prefix)
        op.prefix = _op.prefix;
      if ("value" in _op) {
        op.value = self2.encodeValue(_op.value, opts, _op);
        if (self2.valueAsBuffer(opts, _op))
          op.valueEncoding = "binary";
      }
      return op;
    });
  };
  var ltgtKeys = ["lt", "gt", "lte", "gte", "start", "end"];
  Codec.prototype.encodeLtgt = function(ltgt) {
    var self2 = this;
    var ret = {};
    Object.keys(ltgt).forEach(function(key) {
      ret[key] = ltgtKeys.indexOf(key) > -1 ? self2.encodeKey(ltgt[key], ltgt) : ltgt[key];
    });
    return ret;
  };
  Codec.prototype.createStreamDecoder = function(opts) {
    var self2 = this;
    if (opts.keys && opts.values) {
      return function(key, value) {
        return {
          key: self2.decodeKey(key, opts),
          value: self2.decodeValue(value, opts)
        };
      };
    } else if (opts.keys) {
      return function(key) {
        return self2.decodeKey(key, opts);
      };
    } else if (opts.values) {
      return function(_, value) {
        return self2.decodeValue(value, opts);
      };
    } else {
      return function() {
      };
    }
  };
  Codec.prototype.keyAsBuffer = function(opts) {
    return this._keyEncoding(opts).buffer;
  };
  Codec.prototype.valueAsBuffer = function(opts) {
    return this._valueEncoding(opts).buffer;
  };
});

// node_modules/encoding-down/index.js
var require_encoding_down = __commonJS((exports2, module2) => {
  "use strict";
  var AbstractLevelDOWN = require_abstract_leveldown4().AbstractLevelDOWN;
  var AbstractChainedBatch = require_abstract_leveldown4().AbstractChainedBatch;
  var AbstractIterator = require_abstract_leveldown4().AbstractIterator;
  var inherits = require_inherits_browser();
  var Codec = require_level_codec();
  var EncodingError = require_errors9().EncodingError;
  var rangeMethods = ["approximateSize", "compactRange"];
  module2.exports = DB.default = DB;
  function DB(db, opts) {
    if (!(this instanceof DB))
      return new DB(db, opts);
    var manifest = db.supports || {};
    var additionalMethods = manifest.additionalMethods || {};
    AbstractLevelDOWN.call(this, manifest);
    this.supports.encodings = true;
    this.supports.additionalMethods = {};
    rangeMethods.forEach(function(m) {
      var fallback = typeof db[m] === "function";
      if (additionalMethods[m] || fallback) {
        this.supports.additionalMethods[m] = true;
        this[m] = function(start, end, opts2, cb) {
          start = this.codec.encodeKey(start, opts2);
          end = this.codec.encodeKey(end, opts2);
          return this.db[m](start, end, opts2, cb);
        };
      }
    }, this);
    opts = opts || {};
    if (typeof opts.keyEncoding === "undefined")
      opts.keyEncoding = "utf8";
    if (typeof opts.valueEncoding === "undefined")
      opts.valueEncoding = "utf8";
    this.db = db;
    this.codec = new Codec(opts);
  }
  inherits(DB, AbstractLevelDOWN);
  DB.prototype.type = "encoding-down";
  DB.prototype._serializeKey = DB.prototype._serializeValue = function(datum) {
    return datum;
  };
  DB.prototype._open = function(opts, cb) {
    this.db.open(opts, cb);
  };
  DB.prototype._close = function(cb) {
    this.db.close(cb);
  };
  DB.prototype._put = function(key, value, opts, cb) {
    key = this.codec.encodeKey(key, opts);
    value = this.codec.encodeValue(value, opts);
    this.db.put(key, value, opts, cb);
  };
  DB.prototype._get = function(key, opts, cb) {
    var self2 = this;
    key = this.codec.encodeKey(key, opts);
    opts.asBuffer = this.codec.valueAsBuffer(opts);
    this.db.get(key, opts, function(err, value) {
      if (err)
        return cb(err);
      try {
        value = self2.codec.decodeValue(value, opts);
      } catch (err2) {
        return cb(new EncodingError(err2));
      }
      cb(null, value);
    });
  };
  DB.prototype._del = function(key, opts, cb) {
    key = this.codec.encodeKey(key, opts);
    this.db.del(key, opts, cb);
  };
  DB.prototype._chainedBatch = function() {
    return new Batch(this);
  };
  DB.prototype._batch = function(ops, opts, cb) {
    ops = this.codec.encodeBatch(ops, opts);
    this.db.batch(ops, opts, cb);
  };
  DB.prototype._iterator = function(opts) {
    opts.keyAsBuffer = this.codec.keyAsBuffer(opts);
    opts.valueAsBuffer = this.codec.valueAsBuffer(opts);
    return new Iterator(this, opts);
  };
  DB.prototype._clear = function(opts, callback) {
    opts = this.codec.encodeLtgt(opts);
    this.db.clear(opts, callback);
  };
  function Iterator(db, opts) {
    AbstractIterator.call(this, db);
    this.codec = db.codec;
    this.keys = opts.keys;
    this.values = opts.values;
    this.opts = this.codec.encodeLtgt(opts);
    this.it = db.db.iterator(this.opts);
  }
  inherits(Iterator, AbstractIterator);
  Iterator.prototype._next = function(cb) {
    var self2 = this;
    this.it.next(function(err, key, value) {
      if (err)
        return cb(err);
      try {
        if (self2.keys && typeof key !== "undefined") {
          key = self2.codec.decodeKey(key, self2.opts);
        } else {
          key = void 0;
        }
        if (self2.values && typeof value !== "undefined") {
          value = self2.codec.decodeValue(value, self2.opts);
        } else {
          value = void 0;
        }
      } catch (err2) {
        return cb(new EncodingError(err2));
      }
      cb(null, key, value);
    });
  };
  Iterator.prototype._seek = function(key) {
    key = this.codec.encodeKey(key, this.opts);
    this.it.seek(key);
  };
  Iterator.prototype._end = function(cb) {
    this.it.end(cb);
  };
  function Batch(db, codec) {
    AbstractChainedBatch.call(this, db);
    this.codec = db.codec;
    this.batch = db.db.batch();
  }
  inherits(Batch, AbstractChainedBatch);
  Batch.prototype._put = function(key, value) {
    key = this.codec.encodeKey(key);
    value = this.codec.encodeValue(value);
    this.batch.put(key, value);
  };
  Batch.prototype._del = function(key) {
    key = this.codec.encodeKey(key);
    this.batch.del(key);
  };
  Batch.prototype._clear = function() {
    this.batch.clear();
  };
  Batch.prototype._write = function(opts, cb) {
    this.batch.write(opts, cb);
  };
});

// node_modules/level-packager/level-packager.js
var require_level_packager = __commonJS((exports2, module2) => {
  var levelup = require_levelup();
  var encode = require_encoding_down();
  function packager(leveldown) {
    function Level(location2, options, callback) {
      if (typeof location2 === "function") {
        callback = location2;
      } else if (typeof options === "function") {
        callback = options;
      }
      if (!isObject(options)) {
        options = isObject(location2) ? location2 : {};
      }
      return levelup(encode(leveldown(location2, options), options), options, callback);
    }
    function isObject(o) {
      return typeof o === "object" && o !== null;
    }
    ["destroy", "repair"].forEach(function(m) {
      if (typeof leveldown[m] === "function") {
        Level[m] = function() {
          leveldown[m].apply(leveldown, arguments);
        };
      }
    });
    Level.errors = levelup.errors;
    return Level;
  }
  module2.exports = packager;
});

// node_modules/ltgt/index.js
var require_ltgt = __commonJS((exports2) => {
  exports2.compare = function(a, b) {
    if (Buffer.isBuffer(a)) {
      var l = Math.min(a.length, b.length);
      for (var i = 0; i < l; i++) {
        var cmp = a[i] - b[i];
        if (cmp)
          return cmp;
      }
      return a.length - b.length;
    }
    return a < b ? -1 : a > b ? 1 : 0;
  };
  function isDef(val) {
    return val !== void 0 && val !== "";
  }
  function has(range, name) {
    return Object.hasOwnProperty.call(range, name);
  }
  function hasKey(range, name) {
    return Object.hasOwnProperty.call(range, name) && name;
  }
  var lowerBoundKey = exports2.lowerBoundKey = function(range) {
    return hasKey(range, "gt") || hasKey(range, "gte") || hasKey(range, "min") || (range.reverse ? hasKey(range, "end") : hasKey(range, "start")) || void 0;
  };
  var lowerBound = exports2.lowerBound = function(range, def) {
    var k = lowerBoundKey(range);
    return k ? range[k] : def;
  };
  var lowerBoundInclusive = exports2.lowerBoundInclusive = function(range) {
    return has(range, "gt") ? false : true;
  };
  var upperBoundInclusive = exports2.upperBoundInclusive = function(range) {
    return has(range, "lt") ? false : true;
  };
  var lowerBoundExclusive = exports2.lowerBoundExclusive = function(range) {
    return !lowerBoundInclusive(range);
  };
  var upperBoundExclusive = exports2.upperBoundExclusive = function(range) {
    return !upperBoundInclusive(range);
  };
  var upperBoundKey = exports2.upperBoundKey = function(range) {
    return hasKey(range, "lt") || hasKey(range, "lte") || hasKey(range, "max") || (range.reverse ? hasKey(range, "start") : hasKey(range, "end")) || void 0;
  };
  var upperBound = exports2.upperBound = function(range, def) {
    var k = upperBoundKey(range);
    return k ? range[k] : def;
  };
  exports2.start = function(range, def) {
    return range.reverse ? upperBound(range, def) : lowerBound(range, def);
  };
  exports2.end = function(range, def) {
    return range.reverse ? lowerBound(range, def) : upperBound(range, def);
  };
  exports2.startInclusive = function(range) {
    return range.reverse ? upperBoundInclusive(range) : lowerBoundInclusive(range);
  };
  exports2.endInclusive = function(range) {
    return range.reverse ? lowerBoundInclusive(range) : upperBoundInclusive(range);
  };
  function id(e) {
    return e;
  }
  exports2.toLtgt = function(range, _range, map, lower, upper) {
    _range = _range || {};
    map = map || id;
    var defaults = arguments.length > 3;
    var lb = exports2.lowerBoundKey(range);
    var ub = exports2.upperBoundKey(range);
    if (lb) {
      if (lb === "gt")
        _range.gt = map(range.gt, false);
      else
        _range.gte = map(range[lb], false);
    } else if (defaults)
      _range.gte = map(lower, false);
    if (ub) {
      if (ub === "lt")
        _range.lt = map(range.lt, true);
      else
        _range.lte = map(range[ub], true);
    } else if (defaults)
      _range.lte = map(upper, true);
    if (range.reverse != null)
      _range.reverse = !!range.reverse;
    if (has(_range, "max"))
      delete _range.max;
    if (has(_range, "min"))
      delete _range.min;
    if (has(_range, "start"))
      delete _range.start;
    if (has(_range, "end"))
      delete _range.end;
    return _range;
  };
  exports2.contains = function(range, key, compare) {
    compare = compare || exports2.compare;
    var lb = lowerBound(range);
    if (isDef(lb)) {
      var cmp = compare(key, lb);
      if (cmp < 0 || cmp === 0 && lowerBoundExclusive(range))
        return false;
    }
    var ub = upperBound(range);
    if (isDef(ub)) {
      var cmp = compare(key, ub);
      if (cmp > 0 || cmp === 0 && upperBoundExclusive(range))
        return false;
    }
    return true;
  };
  exports2.filter = function(range, compare) {
    return function(key) {
      return exports2.contains(range, key, compare);
    };
  };
});

// node_modules/level-js/util/key-range.js
var require_key_range = __commonJS((exports2, module2) => {
  "use strict";
  var ltgt = require_ltgt();
  var NONE = {};
  module2.exports = function createKeyRange(options) {
    var lower = ltgt.lowerBound(options, NONE);
    var upper = ltgt.upperBound(options, NONE);
    var lowerOpen = ltgt.lowerBoundExclusive(options, NONE);
    var upperOpen = ltgt.upperBoundExclusive(options, NONE);
    if (lower !== NONE && upper !== NONE) {
      return IDBKeyRange.bound(lower, upper, lowerOpen, upperOpen);
    } else if (lower !== NONE) {
      return IDBKeyRange.lowerBound(lower, lowerOpen);
    } else if (upper !== NONE) {
      return IDBKeyRange.upperBound(upper, upperOpen);
    } else {
      return null;
    }
  };
});

// node_modules/level-js/util/deserialize.js
var require_deserialize = __commonJS((exports2, module2) => {
  "use strict";
  var Buffer2 = require_buffer().Buffer;
  var ta2str = function() {
    if (global.TextDecoder) {
      var decoder = new TextDecoder("utf-8");
      return decoder.decode.bind(decoder);
    } else {
      return function ta2str2(ta) {
        return ta2buf(ta).toString();
      };
    }
  }();
  var ab2str = function() {
    if (global.TextDecoder) {
      var decoder = new TextDecoder("utf-8");
      return decoder.decode.bind(decoder);
    } else {
      return function ab2str2(ab) {
        return Buffer2.from(ab).toString();
      };
    }
  }();
  function ta2buf(ta) {
    var buf = Buffer2.from(ta.buffer);
    if (ta.byteLength === ta.buffer.byteLength) {
      return buf;
    } else {
      return buf.slice(ta.byteOffset, ta.byteOffset + ta.byteLength);
    }
  }
  module2.exports = function(data, asBuffer) {
    if (data instanceof Uint8Array) {
      return asBuffer ? ta2buf(data) : ta2str(data);
    } else if (data instanceof ArrayBuffer) {
      return asBuffer ? Buffer2.from(data) : ab2str(data);
    } else {
      return asBuffer ? Buffer2.from(String(data)) : String(data);
    }
  };
});

// node_modules/level-js/iterator.js
var require_iterator = __commonJS((exports2, module2) => {
  "use strict";
  var inherits = require_inherits_browser();
  var AbstractIterator = require_abstract_leveldown2().AbstractIterator;
  var createKeyRange = require_key_range();
  var deserialize = require_deserialize();
  var noop = function() {
  };
  module2.exports = Iterator;
  function Iterator(db, location2, options) {
    AbstractIterator.call(this, db);
    this._limit = options.limit;
    this._count = 0;
    this._callback = null;
    this._cache = [];
    this._completed = false;
    this._aborted = false;
    this._error = null;
    this._transaction = null;
    this._keys = options.keys;
    this._values = options.values;
    this._keyAsBuffer = options.keyAsBuffer;
    this._valueAsBuffer = options.valueAsBuffer;
    if (this._limit === 0) {
      this._completed = true;
      return;
    }
    try {
      var keyRange = createKeyRange(options);
    } catch (e) {
      this._completed = true;
      return;
    }
    this.createIterator(location2, keyRange, options.reverse);
  }
  inherits(Iterator, AbstractIterator);
  Iterator.prototype.createIterator = function(location2, keyRange, reverse) {
    var self2 = this;
    var transaction = this.db.db.transaction([location2], "readonly");
    var store = transaction.objectStore(location2);
    var req = store.openCursor(keyRange, reverse ? "prev" : "next");
    req.onsuccess = function(ev) {
      var cursor = ev.target.result;
      if (cursor)
        self2.onItem(cursor);
    };
    this._transaction = transaction;
    transaction.onabort = function() {
      self2.onAbort(self2._transaction.error || new Error("aborted by user"));
    };
    transaction.oncomplete = function() {
      self2.onComplete();
    };
  };
  Iterator.prototype.onItem = function(cursor) {
    this._cache.push(cursor.key, cursor.value);
    if (this._limit <= 0 || ++this._count < this._limit) {
      cursor.continue();
    }
    this.maybeNext();
  };
  Iterator.prototype.onAbort = function(err) {
    this._aborted = true;
    this._error = err;
    this.maybeNext();
  };
  Iterator.prototype.onComplete = function() {
    this._completed = true;
    this.maybeNext();
  };
  Iterator.prototype.maybeNext = function() {
    if (this._callback) {
      this._next(this._callback);
      this._callback = null;
    }
  };
  Iterator.prototype._next = function(callback) {
    if (this._aborted) {
      var err = this._error;
      this._error = null;
      this._nextTick(callback, err);
    } else if (this._cache.length > 0) {
      var key = this._cache.shift();
      var value = this._cache.shift();
      if (this._keys && key !== void 0) {
        key = this._deserializeKey(key, this._keyAsBuffer);
      } else {
        key = void 0;
      }
      if (this._values && value !== void 0) {
        value = this._deserializeValue(value, this._valueAsBuffer);
      } else {
        value = void 0;
      }
      this._nextTick(callback, null, key, value);
    } else if (this._completed) {
      this._nextTick(callback);
    } else {
      this._callback = callback;
    }
  };
  Iterator.prototype._deserializeKey = deserialize;
  Iterator.prototype._deserializeValue = deserialize;
  Iterator.prototype._end = function(callback) {
    if (this._aborted || this._completed) {
      return this._nextTick(callback, this._error);
    }
    this.onItem = noop;
    this.onAbort = callback;
    this.onComplete = callback;
  };
});

// node_modules/level-js/util/serialize.js
var require_serialize2 = __commonJS((exports2, module2) => {
  "use strict";
  var Buffer2 = require_buffer().Buffer;
  var str2bin = function() {
    if (global.TextEncoder) {
      var encoder = new TextEncoder("utf-8");
      return encoder.encode.bind(encoder);
    } else {
      return Buffer2.from;
    }
  }();
  module2.exports = function(data, asBuffer) {
    if (asBuffer) {
      return Buffer2.isBuffer(data) ? data : str2bin(String(data));
    } else {
      return String(data);
    }
  };
});

// node_modules/level-js/util/support.js
var require_support = __commonJS((exports2) => {
  "use strict";
  var Buffer2 = require_buffer().Buffer;
  exports2.test = function(key) {
    return function test(impl) {
      try {
        impl.cmp(key, 0);
        return true;
      } catch (err) {
        return false;
      }
    };
  };
  exports2.bufferKeys = exports2.test(Buffer2.alloc(0));
});

// node_modules/level-js/util/clear.js
var require_clear2 = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = function clear(db, location2, keyRange, options, callback) {
    if (options.limit === 0)
      return db._nextTick(callback);
    var transaction = db.db.transaction([location2], "readwrite");
    var store = transaction.objectStore(location2);
    var count = 0;
    transaction.oncomplete = function() {
      callback();
    };
    transaction.onabort = function() {
      callback(transaction.error || new Error("aborted by user"));
    };
    var method = store.openKeyCursor ? "openKeyCursor" : "openCursor";
    var direction = options.reverse ? "prev" : "next";
    store[method](keyRange, direction).onsuccess = function(ev) {
      var cursor = ev.target.result;
      if (cursor) {
        store.delete(cursor.key).onsuccess = function() {
          if (options.limit <= 0 || ++count < options.limit) {
            cursor.continue();
          }
        };
      }
    };
  };
});

// node_modules/level-js/index.js
var require_level_js = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = Level;
  var AbstractLevelDOWN = require_abstract_leveldown2().AbstractLevelDOWN;
  var inherits = require_inherits_browser();
  var Iterator = require_iterator();
  var serialize = require_serialize2();
  var deserialize = require_deserialize();
  var support = require_support();
  var clear = require_clear2();
  var createKeyRange = require_key_range();
  var DEFAULT_PREFIX = "level-js-";
  function Level(location2, opts) {
    if (!(this instanceof Level))
      return new Level(location2, opts);
    AbstractLevelDOWN.call(this, {
      bufferKeys: support.bufferKeys(indexedDB),
      snapshots: true,
      permanence: true,
      clear: true
    });
    opts = opts || {};
    if (typeof location2 !== "string") {
      throw new Error("constructor requires a location string argument");
    }
    this.location = location2;
    this.prefix = opts.prefix == null ? DEFAULT_PREFIX : opts.prefix;
    this.version = parseInt(opts.version || 1, 10);
  }
  inherits(Level, AbstractLevelDOWN);
  Level.prototype.type = "level-js";
  Level.prototype._open = function(options, callback) {
    var req = indexedDB.open(this.prefix + this.location, this.version);
    var self2 = this;
    req.onerror = function() {
      callback(req.error || new Error("unknown error"));
    };
    req.onsuccess = function() {
      self2.db = req.result;
      callback();
    };
    req.onupgradeneeded = function(ev) {
      var db = ev.target.result;
      if (!db.objectStoreNames.contains(self2.location)) {
        db.createObjectStore(self2.location);
      }
    };
  };
  Level.prototype.store = function(mode) {
    var transaction = this.db.transaction([this.location], mode);
    return transaction.objectStore(this.location);
  };
  Level.prototype.await = function(request, callback) {
    var transaction = request.transaction;
    transaction.onabort = function() {
      callback(transaction.error || new Error("aborted by user"));
    };
    transaction.oncomplete = function() {
      callback(null, request.result);
    };
  };
  Level.prototype._get = function(key, options, callback) {
    var store = this.store("readonly");
    try {
      var req = store.get(key);
    } catch (err) {
      return this._nextTick(callback, err);
    }
    this.await(req, function(err, value) {
      if (err)
        return callback(err);
      if (value === void 0) {
        return callback(new Error("NotFound"));
      }
      callback(null, deserialize(value, options.asBuffer));
    });
  };
  Level.prototype._del = function(key, options, callback) {
    var store = this.store("readwrite");
    try {
      var req = store.delete(key);
    } catch (err) {
      return this._nextTick(callback, err);
    }
    this.await(req, callback);
  };
  Level.prototype._put = function(key, value, options, callback) {
    var store = this.store("readwrite");
    try {
      var req = store.put(value, key);
    } catch (err) {
      return this._nextTick(callback, err);
    }
    this.await(req, callback);
  };
  Level.prototype._serializeKey = function(key) {
    return serialize(key, this.supports.bufferKeys);
  };
  Level.prototype._serializeValue = function(value) {
    return serialize(value, true);
  };
  Level.prototype._iterator = function(options) {
    return new Iterator(this, this.location, options);
  };
  Level.prototype._batch = function(operations, options, callback) {
    if (operations.length === 0)
      return this._nextTick(callback);
    var store = this.store("readwrite");
    var transaction = store.transaction;
    var index = 0;
    var error;
    transaction.onabort = function() {
      callback(error || transaction.error || new Error("aborted by user"));
    };
    transaction.oncomplete = function() {
      callback();
    };
    function loop() {
      var op = operations[index++];
      var key = op.key;
      try {
        var req = op.type === "del" ? store.delete(key) : store.put(op.value, key);
      } catch (err) {
        error = err;
        transaction.abort();
        return;
      }
      if (index < operations.length) {
        req.onsuccess = loop;
      }
    }
    loop();
  };
  Level.prototype._clear = function(options, callback) {
    try {
      var keyRange = createKeyRange(options);
    } catch (e) {
      return this._nextTick(callback);
    }
    if (options.limit >= 0) {
      return clear(this, this.location, keyRange, options, callback);
    }
    try {
      var store = this.store("readwrite");
      var req = keyRange ? store.delete(keyRange) : store.clear();
    } catch (err) {
      return this._nextTick(callback, err);
    }
    this.await(req, callback);
  };
  Level.prototype._close = function(callback) {
    this.db.close();
    this._nextTick(callback);
  };
  Level.prototype.upgrade = function(callback) {
    if (this.status !== "open") {
      return this._nextTick(callback, new Error("cannot upgrade() before open()"));
    }
    var it = this.iterator();
    var batchOptions = {};
    var self2 = this;
    it._deserializeKey = it._deserializeValue = identity;
    next();
    function next(err) {
      if (err)
        return finish(err);
      it.next(each);
    }
    function each(err, key, value) {
      if (err || key === void 0) {
        return finish(err);
      }
      var newKey = self2._serializeKey(deserialize(key, true));
      var newValue = self2._serializeValue(deserialize(value, true));
      self2._batch([
        {type: "del", key},
        {type: "put", key: newKey, value: newValue}
      ], batchOptions, next);
    }
    function finish(err) {
      it.end(function(err2) {
        callback(err || err2);
      });
    }
    function identity(data) {
      return data;
    }
  };
  Level.destroy = function(location2, prefix, callback) {
    if (typeof prefix === "function") {
      callback = prefix;
      prefix = DEFAULT_PREFIX;
    }
    var request = indexedDB.deleteDatabase(prefix + location2);
    request.onsuccess = function() {
      callback();
    };
    request.onerror = function(err) {
      callback(err);
    };
  };
});

// node_modules/level/browser.js
var require_browser7 = __commonJS((exports2, module2) => {
  module2.exports = require_level_packager()(require_level_js());
});

// node_modules/datastore-level/src/index.js
var require_src32 = __commonJS((exports2, module2) => {
  "use strict";
  var {
    Key,
    Errors,
    Adapter,
    utils: {
      filter,
      map,
      take,
      sortAll
    }
  } = require_src15();
  var LevelDatastore = class extends Adapter {
    constructor(path, opts) {
      super();
      this.path = path;
      this.opts = opts;
      if (opts && opts.db) {
        this.database = opts.db;
        delete opts.db;
      } else {
        this.database = require_browser7();
      }
    }
    _initDb() {
      return new Promise((resolve, reject) => {
        this.db = this.database(this.path, {
          ...this.opts,
          valueEncoding: "binary",
          compression: false
        }, (err) => {
          if (err) {
            return reject(err);
          }
          resolve(this.db);
        });
      });
    }
    async open() {
      try {
        if (this.db) {
          await this.db.open();
        } else {
          this.db = await this._initDb();
        }
      } catch (err) {
        throw Errors.dbOpenFailedError(err);
      }
    }
    async put(key, value) {
      try {
        await this.db.put(key.toString(), value);
      } catch (err) {
        throw Errors.dbWriteFailedError(err);
      }
    }
    async get(key) {
      let data;
      try {
        data = await this.db.get(key.toString());
      } catch (err) {
        if (err.notFound)
          throw Errors.notFoundError(err);
        throw Errors.dbWriteFailedError(err);
      }
      return data;
    }
    async has(key) {
      try {
        await this.db.get(key.toString());
      } catch (err) {
        if (err.notFound)
          return false;
        throw err;
      }
      return true;
    }
    async delete(key) {
      try {
        await this.db.del(key.toString());
      } catch (err) {
        throw Errors.dbDeleteFailedError(err);
      }
    }
    close() {
      return this.db && this.db.close();
    }
    batch() {
      const ops = [];
      return {
        put: (key, value) => {
          ops.push({
            type: "put",
            key: key.toString(),
            value
          });
        },
        delete: (key) => {
          ops.push({
            type: "del",
            key: key.toString()
          });
        },
        commit: () => {
          return this.db.batch(ops);
        }
      };
    }
    query(q) {
      let values = true;
      if (q.keysOnly != null) {
        values = !q.keysOnly;
      }
      const opts = {
        keys: true,
        values,
        keyAsBuffer: true
      };
      if (q.prefix != null) {
        const prefix = q.prefix.toString();
        opts.gte = prefix;
        opts.lt = prefix + "\xFF";
      }
      let it = levelIteratorToIterator(this.db.iterator(opts));
      it = map(it, ({key, value}) => {
        if (values) {
          return {key, value};
        }
        return {key};
      });
      if (Array.isArray(q.filters)) {
        it = q.filters.reduce((it2, f) => filter(it2, f), it);
      }
      if (Array.isArray(q.orders)) {
        it = q.orders.reduce((it2, f) => sortAll(it2, f), it);
      }
      const {offset, limit} = q;
      if (offset) {
        let i = 0;
        it = filter(it, () => i++ >= offset);
      }
      if (limit) {
        it = take(it, limit);
      }
      return it;
    }
  };
  function levelIteratorToIterator(li) {
    return {
      [Symbol.asyncIterator]() {
        return {
          next: () => new Promise((resolve, reject) => {
            li.next((err, key, value) => {
              if (err)
                return reject(err);
              if (key == null) {
                return li.end((err2) => {
                  if (err2)
                    return reject(err2);
                  resolve({done: true, value: void 0});
                });
              }
              resolve({done: false, value: {key: new Key(key, false), value}});
            });
          }),
          return: () => new Promise((resolve, reject) => {
            li.end((err) => {
              if (err)
                return reject(err);
              resolve({done: true, value: void 0});
            });
          })
        };
      }
    };
  }
  module2.exports = LevelDatastore;
});

// node_modules/ipfs-repo/src/default-options-browser.js
var require_default_options_browser = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = {
    lock: "memory",
    storageBackends: {
      root: require_src32(),
      blocks: require_src32(),
      keys: require_src32(),
      datastore: require_src32(),
      pins: require_src32()
    },
    storageBackendOptions: {
      root: {
        extension: "",
        prefix: "",
        version: 2
      },
      blocks: {
        sharding: false,
        prefix: "",
        version: 2
      },
      keys: {
        sharding: false,
        prefix: "",
        version: 2
      },
      datastore: {
        sharding: false,
        prefix: "",
        version: 2
      },
      pins: {
        sharding: false,
        prefix: "",
        version: 2
      }
    }
  };
});

// node_modules/ipfs-repo/src/default-datastore.js
var require_default_datastore = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = {
    Spec: {
      type: "mount",
      mounts: [
        {
          mountpoint: "/blocks",
          type: "measure",
          prefix: "flatfs.datastore",
          child: {
            type: "flatfs",
            path: "blocks",
            sync: true,
            shardFunc: "/repo/flatfs/shard/v1/next-to-last/2"
          }
        },
        {
          mountpoint: "/",
          type: "measure",
          prefix: "leveldb.datastore",
          child: {
            type: "levelds",
            path: "datastore",
            compression: "none"
          }
        }
      ]
    }
  };
});

// node_modules/ipfs-repo/src/lock-memory.js
var require_lock_memory2 = __commonJS((exports2) => {
  "use strict";
  var errors = require_errors8();
  var debug = require_browser4();
  var log = debug("ipfs:repo:lock");
  var lockFile = "repo.lock";
  var LOCKS = {};
  exports2.lock = async (dir) => {
    const file = dir + "/" + lockFile;
    log("locking %s", file);
    if (LOCKS[file] === true) {
      throw new errors.LockExistsError(`Lock already being held for file: ${file}`);
    }
    LOCKS[file] = true;
    const closer = {
      async close() {
        if (LOCKS[file]) {
          delete LOCKS[file];
        }
      }
    };
    return closer;
  };
  exports2.locked = async (dir) => {
    const file = dir + "/" + lockFile;
    log(`checking lock: ${file}`);
    return Boolean(LOCKS[file]);
  };
});

// node_modules/ipfs-repo/src/index.js
var require_src33 = __commonJS((exports2, module2) => {
  "use strict";
  var _get = require_just_safe_get();
  var debug = require_browser4();
  var Big = require_bignumber();
  var errcode = require_err_code();
  var migrator = require_src31();
  var bytes = require_bytes2();
  var pathJoin = require_path_join_browser();
  var constants = require_constants7();
  var backends = require_backends();
  var version = require_version3();
  var config = require_config3();
  var spec = require_spec();
  var apiAddr = require_api_addr();
  var blockstore = require_blockstore();
  var defaultOptions = require_default_options_browser();
  var defaultDatastore = require_default_datastore();
  var ERRORS = require_errors8();
  var log = debug("ipfs:repo");
  var noLimit = Number.MAX_SAFE_INTEGER;
  var AUTO_MIGRATE_CONFIG_KEY = "repoAutoMigrate";
  var lockers = {
    memory: require_lock_memory2(),
    fs: require_lock_memory2()
  };
  var IpfsRepo = class {
    constructor(repoPath, options) {
      if (typeof repoPath !== "string") {
        throw new Error("missing repoPath");
      }
      this.options = buildOptions(options);
      this.closed = true;
      this.path = repoPath;
      this._locker = this._getLocker();
      this.root = backends.create("root", this.path, this.options);
      this.version = version(this.root);
      this.config = config(this.root);
      this.spec = spec(this.root);
      this.apiAddr = apiAddr(this.root);
    }
    async init(config2) {
      log("initializing at: %s", this.path);
      await this._openRoot();
      await this.config.set(buildConfig(config2));
      await this.spec.set(buildDatastoreSpec(config2));
      await this.version.set(constants.repoVersion);
    }
    async isInitialized() {
      if (!this.closed) {
        return true;
      }
      try {
        await this._openRoot();
        await this._checkInitialized();
        await this.root.close();
        return true;
      } catch (err) {
        return false;
      }
    }
    async open() {
      if (!this.closed) {
        throw errcode(new Error("repo is already open"), ERRORS.ERR_REPO_ALREADY_OPEN);
      }
      log("opening at: %s", this.path);
      try {
        await this._openRoot();
        await this._checkInitialized();
        this.lockfile = await this._openLock(this.path);
        log("acquired repo.lock");
        const isCompatible = await this.version.check(constants.repoVersion);
        if (!isCompatible) {
          if (await this._isAutoMigrationEnabled()) {
            await this._migrate(constants.repoVersion);
          } else {
            throw new ERRORS.InvalidRepoVersionError("Incompatible repo versions. Automatic migrations disabled. Please migrate the repo manually.");
          }
        }
        log("creating datastore");
        this.datastore = backends.create("datastore", pathJoin(this.path, "datastore"), this.options);
        await this.datastore.open();
        log("creating blocks");
        const blocksBaseStore = backends.create("blocks", pathJoin(this.path, "blocks"), this.options);
        await blocksBaseStore.open();
        this.blocks = await blockstore(blocksBaseStore, this.options.storageBackendOptions.blocks);
        log("creating keystore");
        this.keys = backends.create("keys", pathJoin(this.path, "keys"), this.options);
        await this.keys.open();
        log("creating pins");
        this.pins = backends.create("pins", pathJoin(this.path, "pins"), this.options);
        await this.pins.open();
        this.closed = false;
        log("all opened");
      } catch (err) {
        if (this.lockfile) {
          try {
            await this._closeLock();
            this.lockfile = null;
          } catch (err2) {
            log("error removing lock", err2);
          }
        }
        throw err;
      }
    }
    _getLocker() {
      if (typeof this.options.lock === "string") {
        if (!lockers[this.options.lock]) {
          throw new Error("Unknown lock type: " + this.options.lock);
        }
        return lockers[this.options.lock];
      }
      if (!this.options.lock) {
        throw new Error("No lock provided");
      }
      return this.options.lock;
    }
    async _openRoot() {
      try {
        await this.root.open();
      } catch (err) {
        if (err.message !== "Already open") {
          throw err;
        }
      }
    }
    async _openLock(path) {
      const lockfile = await this._locker.lock(path);
      if (typeof lockfile.close !== "function") {
        throw errcode(new Error("Locks must have a close method"), "ERR_NO_CLOSE_FUNCTION");
      }
      return lockfile;
    }
    _closeLock() {
      return this.lockfile.close();
    }
    async _checkInitialized() {
      log("init check");
      let config2;
      try {
        [config2] = await Promise.all([
          this.config.exists(),
          this.spec.exists(),
          this.version.exists()
        ]);
      } catch (err) {
        if (err.code === "ERR_NOT_FOUND") {
          throw errcode(new Error("repo is not initialized yet"), ERRORS.ERR_REPO_NOT_INITIALIZED, {
            path: this.path
          });
        }
        throw err;
      }
      if (!config2) {
        throw errcode(new Error("repo is not initialized yet"), ERRORS.ERR_REPO_NOT_INITIALIZED, {
          path: this.path
        });
      }
    }
    async close() {
      if (this.closed) {
        throw errcode(new Error("repo is already closed"), ERRORS.ERR_REPO_ALREADY_CLOSED);
      }
      log("closing at: %s", this.path);
      try {
        await this.apiAddr.delete();
      } catch (err) {
        if (err.code !== ERRORS.ERR_REPO_NOT_INITIALIZED && !err.message.startsWith("ENOENT")) {
          throw err;
        }
      }
      await Promise.all([
        this.root,
        this.blocks,
        this.keys,
        this.datastore,
        this.pins
      ].map((store) => store.close()));
      log("unlocking");
      this.closed = true;
      await this._closeLock();
      this.lockfile = null;
    }
    async exists() {
      return this.version.exists();
    }
    async stat() {
      const [storageMax, blocks, version2, datastore, keys] = await Promise.all([
        this._storageMaxStat(),
        this._blockStat(),
        this.version.get(),
        getSize(this.datastore),
        getSize(this.keys)
      ]);
      const size = blocks.size.plus(datastore).plus(keys);
      return {
        repoPath: this.path,
        storageMax,
        version: version2,
        numObjects: blocks.count,
        repoSize: size
      };
    }
    async _isAutoMigrationEnabled() {
      if (this.options.autoMigrate !== void 0) {
        return this.options.autoMigrate;
      }
      let autoMigrateConfig;
      try {
        autoMigrateConfig = await this.config.get(AUTO_MIGRATE_CONFIG_KEY);
      } catch (e) {
        if (e.code === ERRORS.NotFoundError.code) {
          autoMigrateConfig = true;
        } else {
          throw e;
        }
      }
      return autoMigrateConfig;
    }
    async _migrate(toVersion) {
      const currentRepoVersion = await this.version.get();
      if (currentRepoVersion > toVersion) {
        log("reverting to version " + toVersion);
        return migrator.revert(this.path, this.options, toVersion, {
          ignoreLock: true,
          onProgress: this.options.onMigrationProgress
        });
      } else {
        log("migrating to version " + toVersion);
        return migrator.migrate(this.path, this.options, toVersion, {
          ignoreLock: true,
          onProgress: this.options.onMigrationProgress
        });
      }
    }
    async _storageMaxStat() {
      try {
        const max = await this.config.get("Datastore.StorageMax");
        return new Big(bytes(max));
      } catch (err) {
        return new Big(noLimit);
      }
    }
    async _blockStat() {
      let count = new Big(0);
      let size = new Big(0);
      for await (const block of this.blocks.query({})) {
        count = count.plus(1);
        size = size.plus(block.data.byteLength).plus(block.cid.bytes.byteLength);
      }
      return {count, size};
    }
  };
  async function getSize(queryFn) {
    const sum = new Big(0);
    for await (const block of queryFn.query({})) {
      sum.plus(block.value.byteLength).plus(block.key.uint8Array().byteLength);
    }
    return sum;
  }
  module2.exports = IpfsRepo;
  module2.exports.utils = {blockstore: require_blockstore_utils()};
  module2.exports.repoVersion = constants.repoVersion;
  module2.exports.errors = ERRORS;
  function buildOptions(_options) {
    const options = Object.assign({}, defaultOptions, _options);
    options.storageBackends = Object.assign({}, defaultOptions.storageBackends, options.storageBackends);
    options.storageBackendOptions = Object.assign({}, defaultOptions.storageBackendOptions, options.storageBackendOptions);
    return options;
  }
  function buildConfig(_config) {
    _config.datastore = Object.assign({}, defaultDatastore, _get(_config, "datastore", {}));
    return _config;
  }
  function buildDatastoreSpec(_config) {
    const spec2 = Object.assign({}, defaultDatastore.Spec, _get(_config, "datastore.Spec", {}));
    return {
      type: spec2.type,
      mounts: spec2.mounts.map((mounting) => ({
        mountpoint: mounting.mountpoint,
        type: mounting.child.type,
        path: mounting.child.path,
        shardFunc: mounting.child.shardFunc
      }))
    };
  }
});

// node_modules/ipfs-core/src/components/repo/version.js
var require_version4 = __commonJS((exports2, module2) => {
  "use strict";
  var {repoVersion} = require_src33();
  var withTimeoutOption = require_with_timeout_option();
  module2.exports = ({repo}) => {
    async function version(options) {
      try {
        await repo._checkInitialized(options);
      } catch (err) {
        const match = [
          /Key not found in database \[\/version\]/,
          /ENOENT/,
          /repo is not initialized yet/
        ].some((m) => {
          return m.test(err.message);
        });
        if (match) {
          return repoVersion;
        }
        throw err;
      }
      return repo.version.get(options);
    }
    return withTimeoutOption(version);
  };
});

// node_modules/ipfs-core/src/components/repo/index.js
var require_repo = __commonJS((exports2, module2) => {
  "use strict";
  var createGC = require_gc();
  var createStat = require_stat5();
  var createVersion = require_version4();
  var RepoAPI = class {
    constructor({gcLock, pin, repo, refs}) {
      this.gc = createGC({gcLock, pin, refs, repo});
      this.stat = createStat({repo});
      this.version = createVersion({repo});
    }
  };
  module2.exports = RepoAPI;
});

// node_modules/ipfs-core/src/components/stats/bw.js
var require_bw = __commonJS((exports2, module2) => {
  "use strict";
  var {default: Big} = require_bignumber();
  var {default: parseDuration} = require_parse_duration();
  var errCode = require_err_code();
  var withTimeoutOption = require_with_timeout_option();
  function getBandwidthStats(libp2p, opts) {
    let stats;
    if (!libp2p.metrics) {
      stats = void 0;
    } else if (opts.peer) {
      stats = libp2p.metrics.forPeer(opts.peer);
    } else if (opts.proto) {
      stats = libp2p.metrics.forProtocol(opts.proto);
    } else {
      stats = libp2p.metrics.global;
    }
    if (!stats) {
      return {
        totalIn: new Big(0),
        totalOut: new Big(0),
        rateIn: new Big(0),
        rateOut: new Big(0)
      };
    }
    const {movingAverages, snapshot} = stats;
    return {
      totalIn: snapshot.dataReceived,
      totalOut: snapshot.dataSent,
      rateIn: new Big(movingAverages.dataReceived[6e4].movingAverage() / 60),
      rateOut: new Big(movingAverages.dataSent[6e4].movingAverage() / 60)
    };
  }
  module2.exports = ({network}) => {
    const bw = async function* (options = {}) {
      const {libp2p} = await network.use(options);
      if (!options.poll) {
        yield getBandwidthStats(libp2p, options);
        return;
      }
      const interval = options.interval || 1e3;
      let ms = -1;
      try {
        ms = typeof interval === "string" ? parseDuration(interval) || -1 : interval;
        if (!ms || ms < 0)
          throw new Error("invalid duration");
      } catch (err) {
        throw errCode(err, "ERR_INVALID_POLL_INTERVAL");
      }
      let timeoutId;
      try {
        while (true) {
          yield getBandwidthStats(libp2p, options);
          await new Promise((resolve) => {
            timeoutId = setTimeout(resolve, ms);
          });
        }
      } finally {
        clearTimeout(timeoutId);
      }
    };
    return withTimeoutOption(bw);
  };
});

// node_modules/ipfs-core/src/components/stats/index.js
var require_stats = __commonJS((exports2, module2) => {
  "use strict";
  var createBW = require_bw();
  var createRepo = require_stat5();
  var createBitswap = require_stat();
  var StatsAPI = class {
    constructor({repo, network}) {
      this.repo = createRepo({repo});
      this.bw = createBW({network});
      this.bitswap = createBitswap({network});
    }
  };
  module2.exports = StatsAPI;
});

// node_modules/ipfs-block-service/src/index.js
var require_src34 = __commonJS((exports2, module2) => {
  "use strict";
  var {map} = require_dist2();
  var errcode = require_err_code();
  var BlockService = class {
    constructor(ipfsRepo) {
      this._repo = ipfsRepo;
      this._bitswap = null;
    }
    setExchange(bitswap) {
      this._bitswap = bitswap;
    }
    unsetExchange() {
      this._bitswap = null;
    }
    hasExchange() {
      return this._bitswap != null;
    }
    put(block, options) {
      if (this.hasExchange()) {
        return this._bitswap.put(block, options);
      } else {
        return this._repo.blocks.put(block, options);
      }
    }
    putMany(blocks, options) {
      if (this.hasExchange()) {
        return this._bitswap.putMany(blocks, options);
      } else {
        return this._repo.blocks.putMany(blocks, options);
      }
    }
    get(cid, options) {
      if (this.hasExchange()) {
        return this._bitswap.get(cid, options);
      } else {
        return this._repo.blocks.get(cid, options);
      }
    }
    getMany(cids, options) {
      if (!Array.isArray(cids)) {
        throw new Error("first arg must be an array of cids");
      }
      if (this.hasExchange()) {
        return this._bitswap.getMany(cids, options);
      } else {
        const getRepoBlocks = map((cid) => this._repo.blocks.get(cid, options));
        return getRepoBlocks(cids);
      }
    }
    async delete(cid, options) {
      if (!await this._repo.blocks.has(cid)) {
        throw errcode(new Error("blockstore: block not found"), "ERR_BLOCK_NOT_FOUND");
      }
      return this._repo.blocks.delete(cid, options);
    }
    deleteMany(cids, options) {
      const repo = this._repo;
      return this._repo.blocks.deleteMany(async function* () {
        for await (const cid of cids) {
          if (!await repo.blocks.has(cid)) {
            throw errcode(new Error("blockstore: block not found"), "ERR_BLOCK_NOT_FOUND");
          }
          yield cid;
        }
      }(), options);
    }
  };
  module2.exports = BlockService;
});

// node_modules/ipld-raw/src/index.js
var require_src35 = __commonJS((exports2, module2) => {
  "use strict";
  var CID = require_src7();
  var multihashing = require_src14();
  var multicodec = require_src6();
  module2.exports = {
    codec: multicodec.RAW,
    defaultHashAlg: multicodec.SHA2_256,
    resolver: {
      resolve: (binaryBlob, path) => {
        if (path !== "/") {
          throw new Error("Only the root path / may be resolved");
        }
        return {
          value: binaryBlob,
          remainderPath: ""
        };
      },
      tree: (binaryBlob) => {
        return {
          done: true
        };
      }
    },
    util: {
      deserialize: (data) => {
        return data;
      },
      serialize: (data) => {
        return data;
      },
      cid: async (binaryBlob, userOptions) => {
        const defaultOptions = {cidVersion: 1, hashAlg: module2.exports.defaultHashAlg};
        const options = Object.assign(defaultOptions, userOptions);
        const multihash = await multihashing(binaryBlob, options.hashAlg);
        const codecName = multicodec.print[module2.exports.codec];
        const cid = new CID(options.cidVersion, codecName, multihash);
        return cid;
      }
    }
  };
});

// node_modules/ipfs-core/src/runtime/ipld.js
var require_ipld = __commonJS((exports2, module2) => {
  "use strict";
  var mergeOptions = require_merge_options();
  var multicodec = require_src6();
  var IpldFormats = {
    get [multicodec.DAG_PB]() {
      return require_src16();
    },
    get [multicodec.DAG_CBOR]() {
      return require_src19();
    },
    get [multicodec.RAW]() {
      return require_src35();
    }
  };
  module2.exports = (blockService, options = {}, log) => {
    return mergeOptions.call({concatArrays: true}, {
      blockService,
      loadFormat: (codec) => {
        log("Loading IPLD format", codec);
        if (IpldFormats[codec]) {
          return IpldFormats[codec];
        } else {
          throw new Error(`Missing IPLD format "${multicodec.getName(codec)}"`);
        }
      }
    }, options);
  };
});

// node_modules/ipld/node_modules/merge-options/index.js
var require_merge_options2 = __commonJS((exports2, module2) => {
  "use strict";
  var isOptionObject = require_is_plain_obj();
  var {hasOwnProperty} = Object.prototype;
  var {propertyIsEnumerable} = Object;
  var defineProperty = (obj, name, value) => Object.defineProperty(obj, name, {
    value,
    writable: true,
    enumerable: true,
    configurable: true
  });
  var globalThis2 = exports2;
  var defaultMergeOpts = {
    concatArrays: false,
    ignoreUndefined: false
  };
  var getEnumerableOwnPropertyKeys = (value) => {
    const keys = [];
    for (const key in value) {
      if (hasOwnProperty.call(value, key)) {
        keys.push(key);
      }
    }
    if (Object.getOwnPropertySymbols) {
      const symbols = Object.getOwnPropertySymbols(value);
      for (const symbol of symbols) {
        if (propertyIsEnumerable.call(value, symbol)) {
          keys.push(symbol);
        }
      }
    }
    return keys;
  };
  function clone(value) {
    if (Array.isArray(value)) {
      return cloneArray(value);
    }
    if (isOptionObject(value)) {
      return cloneOptionObject(value);
    }
    return value;
  }
  function cloneArray(array) {
    const result = array.slice(0, 0);
    getEnumerableOwnPropertyKeys(array).forEach((key) => {
      defineProperty(result, key, clone(array[key]));
    });
    return result;
  }
  function cloneOptionObject(obj) {
    const result = Object.getPrototypeOf(obj) === null ? Object.create(null) : {};
    getEnumerableOwnPropertyKeys(obj).forEach((key) => {
      defineProperty(result, key, clone(obj[key]));
    });
    return result;
  }
  var mergeKeys = (merged, source, keys, config) => {
    keys.forEach((key) => {
      if (typeof source[key] === "undefined" && config.ignoreUndefined) {
        return;
      }
      if (key in merged && merged[key] !== Object.getPrototypeOf(merged)) {
        defineProperty(merged, key, merge(merged[key], source[key], config));
      } else {
        defineProperty(merged, key, clone(source[key]));
      }
    });
    return merged;
  };
  var concatArrays = (merged, source, config) => {
    let result = merged.slice(0, 0);
    let resultIndex = 0;
    [merged, source].forEach((array) => {
      const indices = [];
      for (let k = 0; k < array.length; k++) {
        if (!hasOwnProperty.call(array, k)) {
          continue;
        }
        indices.push(String(k));
        if (array === merged) {
          defineProperty(result, resultIndex++, array[k]);
        } else {
          defineProperty(result, resultIndex++, clone(array[k]));
        }
      }
      result = mergeKeys(result, array, getEnumerableOwnPropertyKeys(array).filter((key) => !indices.includes(key)), config);
    });
    return result;
  };
  function merge(merged, source, config) {
    if (config.concatArrays && Array.isArray(merged) && Array.isArray(source)) {
      return concatArrays(merged, source, config);
    }
    if (!isOptionObject(source) || !isOptionObject(merged)) {
      return clone(source);
    }
    return mergeKeys(merged, source, getEnumerableOwnPropertyKeys(source), config);
  }
  module2.exports = function(...options) {
    const config = merge(clone(defaultMergeOpts), this !== globalThis2 && this || {}, defaultMergeOpts);
    let merged = {_: {}};
    for (const option of options) {
      if (option === void 0) {
        continue;
      }
      if (!isOptionObject(option)) {
        throw new TypeError("`" + option + "` is not an Option Object");
      }
      merged = merge(merged, {_: option}, config);
    }
    return merged._;
  };
});

// node_modules/typical/index.mjs
var require_typical = __commonJS((exports2) => {
  __export(exports2, {
    default: () => typical_default,
    isArrayLike: () => isArrayLike,
    isClass: () => isClass,
    isDefined: () => isDefined,
    isDefinedValue: () => isDefinedValue,
    isFunction: () => isFunction,
    isIterable: () => isIterable,
    isNull: () => isNull,
    isNumber: () => isNumber,
    isObject: () => isObject,
    isPlainObject: () => isPlainObject,
    isPrimitive: () => isPrimitive,
    isPromise: () => isPromise,
    isString: () => isString,
    isUndefined: () => isUndefined
  });
  function isNumber(n) {
    return !isNaN(parseFloat(n)) && isFinite(n);
  }
  function isPlainObject(input) {
    return input !== null && typeof input === "object" && input.constructor === Object;
  }
  function isArrayLike(input) {
    return isObject(input) && typeof input.length === "number";
  }
  function isObject(input) {
    return typeof input === "object" && input !== null;
  }
  function isDefined(input) {
    return typeof input !== "undefined";
  }
  function isUndefined(input) {
    return !isDefined(input);
  }
  function isNull(input) {
    return input === null;
  }
  function isDefinedValue(input) {
    return isDefined(input) && !isNull(input) && !Number.isNaN(input);
  }
  function isClass(input) {
    if (typeof input === "function") {
      return /^class /.test(Function.prototype.toString.call(input));
    } else {
      return false;
    }
  }
  function isPrimitive(input) {
    if (input === null)
      return true;
    switch (typeof input) {
      case "string":
      case "number":
      case "symbol":
      case "undefined":
      case "boolean":
        return true;
      default:
        return false;
    }
  }
  function isPromise(input) {
    if (input) {
      const isPromise2 = isDefined(Promise) && input instanceof Promise;
      const isThenable = input.then && typeof input.then === "function";
      return !!(isPromise2 || isThenable);
    } else {
      return false;
    }
  }
  function isIterable(input) {
    if (input === null || !isDefined(input)) {
      return false;
    } else {
      return typeof input[Symbol.iterator] === "function" || typeof input[Symbol.asyncIterator] === "function";
    }
  }
  function isString(input) {
    return typeof input === "string";
  }
  function isFunction(input) {
    return typeof input === "function";
  }
  var typical_default = {
    isNumber,
    isPlainObject,
    isArrayLike,
    isObject,
    isDefined,
    isUndefined,
    isNull,
    isDefinedValue,
    isClass,
    isPrimitive,
    isPromise,
    isIterable,
    isString,
    isFunction
  };
});

// node_modules/ipld/src/util.js
var require_util12 = __commonJS((exports2) => {
  "use strict";
  exports2.first = async (iterator) => {
    for await (const value of iterator) {
      return value;
    }
  };
  exports2.last = async (iterator) => {
    let value;
    for await (value of iterator) {
    }
    return value;
  };
  exports2.all = async (iterator) => {
    const values = [];
    for await (const value of iterator) {
      values.push(value);
    }
    return values;
  };
  exports2.extendIterator = (iterator) => {
    iterator.first = () => exports2.first(iterator);
    iterator.last = () => exports2.last(iterator);
    iterator.all = () => exports2.all(iterator);
    return iterator;
  };
});

// node_modules/ipld/src/index.js
var require_src36 = __commonJS((exports2, module2) => {
  "use strict";
  var Block = require_src26();
  var CID = require_src7();
  var mergeOptions = require_merge_options2();
  var ipldDagCbor = require_src19();
  var ipldDagPb = require_src16();
  var ipldRaw = require_src35();
  var multicodec = require_src6();
  var typical = require_typical();
  var {extendIterator} = require_util12();
  var IPLDResolver = class {
    constructor(userOptions) {
      const options = mergeOptions(IPLDResolver.defaultOptions, userOptions);
      if (!options.blockService) {
        throw new Error("Missing blockservice");
      }
      this.bs = options.blockService;
      this.resolvers = {};
      if (typeof options.loadFormat !== "function") {
        this.loadFormat = (codec) => {
          const codecName = multicodec.print[codec];
          throw new Error(`No resolver found for codec "${codecName}"`);
        };
      } else {
        this.loadFormat = options.loadFormat;
      }
      for (const format of options.formats) {
        this.addFormat(format);
      }
    }
    addFormat(format) {
      const codec = format.codec;
      if (this.resolvers[format.codec]) {
        const codecName = multicodec.print[codec];
        throw new Error(`Resolver already exists for codec "${codecName}"`);
      }
      this.resolvers[codec] = format;
      return this;
    }
    removeFormat(codec) {
      if (this.resolvers[codec]) {
        delete this.resolvers[codec];
      }
      return this;
    }
    resolve(cid, path, options) {
      if (!CID.isCID(cid)) {
        throw new Error("`cid` argument must be a CID");
      }
      if (typeof path !== "string") {
        throw new Error("`path` argument must be a string");
      }
      const generator = async function* () {
        while (cid !== null) {
          const format = await this.getFormat(cid.codec);
          const block = await this.bs.get(cid, options);
          const result = format.resolver.resolve(block.data, path);
          path = result.remainderPath;
          let value = result.value;
          if (Object.keys(value).length === 1 && "/" in value) {
            try {
              value = new CID(value["/"]);
            } catch (_error) {
              value = null;
            }
          }
          cid = CID.isCID(value) ? value : null;
          yield {
            remainderPath: path,
            value
          };
        }
      }.bind(this);
      return extendIterator(generator());
    }
    async get(cid, options) {
      const block = await this.bs.get(cid, options);
      const format = await this.getFormat(block.cid.codec);
      const node = format.util.deserialize(block.data);
      return node;
    }
    getMany(cids, options) {
      if (!typical.isIterable(cids) || typeof cids === "string" || cids instanceof Uint8Array) {
        throw new Error("`cids` must be an iterable of CIDs");
      }
      const generator = async function* () {
        for await (const cid of cids) {
          yield this.get(cid, options);
        }
      }.bind(this);
      return extendIterator(generator());
    }
    async put(node, format, userOptions) {
      if (format === void 0) {
        throw new Error("`put` requires a format");
      }
      if (typeof format !== "number") {
        throw new Error("`format` parameter must be number (multicodec)");
      }
      const formatImpl = await this.getFormat(format);
      const defaultOptions = {
        hashAlg: formatImpl.defaultHashAlg,
        cidVersion: 1,
        onlyHash: false
      };
      const options = mergeOptions(defaultOptions, userOptions);
      const cidOptions = {
        cidVersion: options.cidVersion,
        hashAlg: options.hashAlg,
        onlyHash: options.onlyHash
      };
      const serialized = formatImpl.util.serialize(node);
      const cid = await formatImpl.util.cid(serialized, cidOptions);
      if (!options.onlyHash) {
        const block = new Block(serialized, cid);
        await this.bs.put(block, options);
      }
      return cid;
    }
    putMany(nodes, format, userOptions) {
      if (!typical.isIterable(nodes) || typeof nodes === "string" || nodes instanceof Uint8Array) {
        throw new Error("`nodes` must be an iterable");
      }
      if (format === void 0) {
        throw new Error("`put` requires a format");
      }
      if (typeof format !== "number") {
        throw new Error("`format` parameter must be number (multicodec)");
      }
      let options;
      let formatImpl;
      const generator = async function* () {
        for await (const node of nodes) {
          if (options === void 0) {
            formatImpl = await this.getFormat(format);
            const defaultOptions = {
              hashAlg: formatImpl.defaultHashAlg,
              cidVersion: 1,
              onlyHash: false
            };
            options = mergeOptions(defaultOptions, userOptions);
          }
          yield this.put(node, format, options);
        }
      }.bind(this);
      return extendIterator(generator());
    }
    async remove(cid, options) {
      return this.bs.delete(cid, options);
    }
    removeMany(cids, options) {
      if (!typical.isIterable(cids) || typeof cids === "string" || cids instanceof Uint8Array) {
        throw new Error("`cids` must be an iterable of CIDs");
      }
      const generator = async function* () {
        for await (const cid of cids) {
          yield this.remove(cid, options);
        }
      }.bind(this);
      return extendIterator(generator());
    }
    tree(cid, offsetPath, userOptions) {
      if (typeof offsetPath === "object") {
        userOptions = offsetPath;
        offsetPath = void 0;
      }
      offsetPath = offsetPath || "";
      const defaultOptions = {
        recursive: false
      };
      const options = mergeOptions(defaultOptions, userOptions);
      const maybeRecurse = async (block, treePath) => {
        const format = await this.getFormat(block.cid.codec);
        const result = format.resolver.resolve(block.data, treePath);
        if (CID.isCID(result.value)) {
          return result.value;
        } else {
          return null;
        }
      };
      const generator = async function* () {
        const treePaths = [];
        let block;
        const queue = [{cid, basePath: ""}];
        let basePath;
        while (treePaths.length > 0 || queue.length > 0) {
          if (treePaths.length === 0 && queue.length > 0) {
            ({cid, basePath} = queue.shift());
            const format = await this.getFormat(cid.codec);
            block = await this.bs.get(cid, options);
            const paths = format.resolver.tree(block.data);
            treePaths.push(...paths);
          }
          const treePath = treePaths.shift();
          let fullPath = basePath + treePath;
          if (options.recursive) {
            cid = await maybeRecurse(block, treePath);
            if (cid !== null) {
              queue.push({cid, basePath: fullPath + "/"});
            }
          }
          if (fullPath.startsWith(offsetPath) && fullPath.length > offsetPath.length) {
            if (offsetPath.length > 0) {
              fullPath = fullPath.slice(offsetPath.length + 1);
            }
            yield fullPath;
          }
        }
      }.bind(this);
      return extendIterator(generator());
    }
    async getFormat(codec) {
      if (typeof codec === "string") {
        const constantName = codec.toUpperCase().replace(/-/g, "_");
        codec = multicodec[constantName];
      }
      if (this.resolvers[codec]) {
        return this.resolvers[codec];
      }
      const format = await this.loadFormat(codec);
      this.addFormat(format);
      return format;
    }
  };
  IPLDResolver.defaultOptions = {
    formats: [ipldDagCbor, ipldDagPb, ipldRaw]
  };
  module2.exports = IPLDResolver;
});

// node_modules/ipfs-core/src/components/ipld.js
var require_ipld2 = __commonJS((exports2, module2) => {
  "use strict";
  var getDefaultIpldOptions = require_ipld();
  var Ipld = require_src36();
  var createIPLD = ({blockService, print, options}) => new Ipld(getDefaultIpldOptions(blockService, options, print));
  module2.exports = createIPLD;
});

// node_modules/ipfs-core/src/runtime/repo-browser.js
var require_repo_browser = __commonJS((exports2, module2) => {
  "use strict";
  var IPFSRepo = require_src33();
  module2.exports = (options = {}) => {
    const repoPath = options.path || "ipfs";
    return new IPFSRepo(repoPath, {autoMigrate: options.autoMigrate});
  };
});

// node_modules/libp2p-interfaces/src/topology/index.js
var require_topology = __commonJS((exports2, module2) => {
  "use strict";
  var noop = () => {
  };
  var topologySymbol = Symbol.for("@libp2p/js-interfaces/topology");
  var Topology = class {
    constructor({
      min = 0,
      max = Infinity,
      handlers = {}
    }) {
      this.min = min;
      this.max = max;
      this._onConnect = handlers.onConnect || noop;
      this._onDisconnect = handlers.onDisconnect || noop;
      this.peers = new Set();
    }
    get [Symbol.toStringTag]() {
      return "Topology";
    }
    get [topologySymbol]() {
      return true;
    }
    static isTopology(other) {
      return Boolean(other && other[topologySymbol]);
    }
    set registrar(registrar) {
      this._registrar = registrar;
    }
    disconnect(peerId) {
      this._onDisconnect(peerId);
    }
  };
  module2.exports = Topology;
});

// node_modules/libp2p-interfaces/src/topology/multicodec-topology.js
var require_multicodec_topology = __commonJS((exports2, module2) => {
  "use strict";
  var Topology = require_topology();
  var multicodecTopologySymbol = Symbol.for("@libp2p/js-interfaces/topology/multicodec-topology");
  var MulticodecTopology = class extends Topology {
    constructor({
      min,
      max,
      multicodecs,
      handlers
    }) {
      super({min, max, handlers});
      if (!multicodecs) {
        throw new Error("one or more multicodec should be provided");
      }
      if (!handlers) {
        throw new Error("the handlers should be provided");
      }
      if (typeof handlers.onConnect !== "function") {
        throw new Error("the 'onConnect' handler must be provided");
      }
      if (typeof handlers.onDisconnect !== "function") {
        throw new Error("the 'onDisconnect' handler must be provided");
      }
      this.multicodecs = Array.isArray(multicodecs) ? multicodecs : [multicodecs];
      this._registrar = void 0;
      this._onProtocolChange = this._onProtocolChange.bind(this);
      this._onPeerConnect = this._onPeerConnect.bind(this);
    }
    get [Symbol.toStringTag]() {
      return "Topology";
    }
    get [multicodecTopologySymbol]() {
      return true;
    }
    static isMulticodecTopology(other) {
      return Boolean(other && other[multicodecTopologySymbol]);
    }
    set registrar(registrar) {
      this._registrar = registrar;
      this._registrar.peerStore.on("change:protocols", this._onProtocolChange);
      this._registrar.connectionManager.on("peer:connect", this._onPeerConnect);
      this._updatePeers(this._registrar.peerStore.peers.values());
    }
    _updatePeers(peerDataIterable) {
      for (const {id, protocols} of peerDataIterable) {
        if (this.multicodecs.filter((multicodec) => protocols.includes(multicodec)).length) {
          this.peers.add(id.toB58String());
          const connection = this._registrar.getConnection(id);
          connection && this._onConnect(id, connection);
        } else {
          this.peers.delete(id.toB58String());
        }
      }
    }
    _onProtocolChange({peerId, protocols}) {
      const hadPeer = this.peers.has(peerId.toB58String());
      const hasProtocol = protocols.filter((protocol) => this.multicodecs.includes(protocol));
      if (hadPeer && hasProtocol.length === 0) {
        this._onDisconnect(peerId);
      }
      for (const protocol of protocols) {
        if (this.multicodecs.includes(protocol)) {
          const peerData = this._registrar.peerStore.get(peerId);
          this._updatePeers([peerData]);
          return;
        }
      }
    }
    _onPeerConnect(connection) {
      const peerId = connection.remotePeer;
      const protocols = this._registrar.peerStore.protoBook.get(peerId);
      if (!protocols) {
        return;
      }
      if (this.multicodecs.find((multicodec) => protocols.includes(multicodec))) {
        this.peers.add(peerId.toB58String());
        this._onConnect(peerId, connection);
      }
    }
  };
  module2.exports = MulticodecTopology;
});

// node_modules/libp2p-interfaces/src/pubsub/errors.js
var require_errors11 = __commonJS((exports2) => {
  "use strict";
  exports2.codes = {
    ERR_INVALID_SIGNATURE_POLICY: "ERR_INVALID_SIGNATURE_POLICY",
    ERR_UNHANDLED_SIGNATURE_POLICY: "ERR_UNHANDLED_SIGNATURE_POLICY",
    ERR_MISSING_SIGNATURE: "ERR_MISSING_SIGNATURE",
    ERR_MISSING_SEQNO: "ERR_MISSING_SEQNO",
    ERR_INVALID_SIGNATURE: "ERR_INVALID_SIGNATURE",
    ERR_UNEXPECTED_FROM: "ERR_UNEXPECTED_FROM",
    ERR_UNEXPECTED_SIGNATURE: "ERR_UNEXPECTED_SIGNATURE",
    ERR_UNEXPECTED_KEY: "ERR_UNEXPECTED_KEY",
    ERR_UNEXPECTED_SEQNO: "ERR_UNEXPECTED_SEQNO"
  };
});

// node_modules/libp2p-interfaces/src/pubsub/message/rpc.proto.js
var require_rpc_proto = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = `
message RPC {
  repeated SubOpts subscriptions = 1;
  repeated Message msgs = 2;

  message SubOpts {
    optional bool subscribe = 1; // subscribe or unsubcribe
    optional string topicID = 2;
  }

  message Message {
    optional bytes from = 1;
    optional bytes data = 2;
    optional bytes seqno = 3;
    repeated string topicIDs = 4;
    optional bytes signature = 5;
    optional bytes key = 6;
  }
}`;
});

// node_modules/libp2p-interfaces/src/pubsub/message/topic-descriptor.proto.js
var require_topic_descriptor_proto = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = `
// topicCID = cid(merkledag_protobuf(topicDescriptor)); (not the topic.name)
message TopicDescriptor {
  optional string name = 1;
  optional AuthOpts auth = 2;
  optional EncOpts enc = 2;

  message AuthOpts {
    optional AuthMode mode = 1;
    repeated bytes keys = 2; // root keys to trust

    enum AuthMode {
      NONE = 0; // no authentication, anyone can publish
      KEY = 1; // only messages signed by keys in the topic descriptor are accepted
      WOT = 2; // web of trust, certificates can allow publisher set to grow
    }
  }

  message EncOpts {
    optional EncMode mode = 1;
    repeated bytes keyHashes = 2; // the hashes of the shared keys used (salted)

    enum EncMode {
      NONE = 0; // no encryption, anyone can read
      SHAREDKEY = 1; // messages are encrypted with shared key
      WOT = 2; // web of trust, certificates can allow publisher set to grow
    }
  }
}`;
});

// node_modules/libp2p-interfaces/src/pubsub/message/index.js
var require_message = __commonJS((exports2, module2) => {
  "use strict";
  var protons = require_src8();
  var rpcProto = protons(require_rpc_proto());
  var RPC = rpcProto.RPC;
  var topicDescriptorProto = protons(require_topic_descriptor_proto());
  exports2 = module2.exports;
  exports2.rpc = rpcProto;
  exports2.td = topicDescriptorProto;
  exports2.RPC = RPC;
  exports2.Message = RPC.Message;
  exports2.SubOpts = RPC.SubOpts;
});

// node_modules/it-length-prefixed/src/varint-encode.js
var require_varint_encode = __commonJS((exports2, module2) => {
  "use strict";
  var Varint = require_varint3();
  var {Buffer: Buffer2} = require_buffer();
  var varintEncode = (value, target, offset) => {
    const ret = Varint.encode(value, target, offset);
    varintEncode.bytes = Varint.encode.bytes;
    return target || Buffer2.from(ret);
  };
  module2.exports = varintEncode;
});

// node_modules/it-length-prefixed/src/encode.js
var require_encode7 = __commonJS((exports2, module2) => {
  "use strict";
  var {Buffer: Buffer2} = require_buffer();
  var BufferList = require_BufferList();
  var varintEncode = require_varint_encode();
  var MIN_POOL_SIZE = 8;
  var DEFAULT_POOL_SIZE = 10 * 1024;
  function encode(options) {
    options = options || {};
    const poolSize = Math.max(options.poolSize || DEFAULT_POOL_SIZE, options.minPoolSize || MIN_POOL_SIZE);
    const encodeLength = options.lengthEncoder || varintEncode;
    return (source) => async function* () {
      let pool = Buffer2.alloc(poolSize);
      let poolOffset = 0;
      for await (const chunk of source) {
        encodeLength(chunk.length, pool, poolOffset);
        const encodedLength = pool.slice(poolOffset, poolOffset + encodeLength.bytes);
        poolOffset += encodeLength.bytes;
        if (pool.length - poolOffset < MIN_POOL_SIZE) {
          pool = Buffer2.alloc(poolSize);
          poolOffset = 0;
        }
        yield new BufferList().append(encodedLength).append(chunk);
      }
    }();
  }
  encode.single = (chunk, options) => {
    options = options || {};
    const encodeLength = options.lengthEncoder || varintEncode;
    return new BufferList([encodeLength(chunk.length), chunk]);
  };
  module2.exports = encode;
  module2.exports.MIN_POOL_SIZE = MIN_POOL_SIZE;
  module2.exports.DEFAULT_POOL_SIZE = DEFAULT_POOL_SIZE;
});

// node_modules/it-length-prefixed/src/varint-decode.js
var require_varint_decode = __commonJS((exports2, module2) => {
  "use strict";
  var {Buffer: Buffer2} = require_buffer();
  var Varint = require_varint3();
  var toBufferProxy = (bl) => new Proxy({}, {
    get: (_, prop) => prop[0] === "l" ? bl[prop] : bl.get(parseInt(prop))
  });
  var varintDecode = (data) => {
    const len = Varint.decode(Buffer2.isBuffer(data) ? data : toBufferProxy(data));
    varintDecode.bytes = Varint.decode.bytes;
    return len;
  };
  module2.exports = varintDecode;
});

// node_modules/it-length-prefixed/src/decode.js
var require_decode7 = __commonJS((exports2, module2) => {
  "use strict";
  var {Buffer: Buffer2} = require_buffer();
  var BufferList = require_BufferList();
  var varintDecode = require_varint_decode();
  var MAX_LENGTH_LENGTH = 8;
  var MAX_DATA_LENGTH = 1024 * 1024 * 4;
  var Empty = Buffer2.alloc(0);
  var ReadModes = {LENGTH: "readLength", DATA: "readData"};
  var ReadHandlers = {
    [ReadModes.LENGTH]: (chunk, buffer, state, options) => {
      buffer = buffer.append(chunk);
      let dataLength;
      try {
        dataLength = options.lengthDecoder(buffer);
      } catch (err) {
        if (buffer.length > options.maxLengthLength) {
          throw Object.assign(err, {message: "message length too long", code: "ERR_MSG_LENGTH_TOO_LONG"});
        }
        if (err instanceof RangeError) {
          return {mode: ReadModes.LENGTH, buffer};
        }
        throw err;
      }
      if (dataLength > options.maxDataLength) {
        throw Object.assign(new Error("message data too long"), {code: "ERR_MSG_DATA_TOO_LONG"});
      }
      chunk = buffer.shallowSlice(options.lengthDecoder.bytes);
      buffer = new BufferList();
      if (options.onLength)
        options.onLength(dataLength);
      if (dataLength <= 0) {
        if (options.onData)
          options.onData(Empty);
        return {mode: ReadModes.LENGTH, chunk, buffer, data: Empty};
      }
      return {mode: ReadModes.DATA, chunk, buffer, state: {dataLength}};
    },
    [ReadModes.DATA]: (chunk, buffer, state, options) => {
      buffer = buffer.append(chunk);
      if (buffer.length < state.dataLength) {
        return {mode: ReadModes.DATA, buffer, state};
      }
      const {dataLength} = state;
      const data = buffer.shallowSlice(0, dataLength);
      chunk = buffer.length > dataLength ? buffer.shallowSlice(dataLength) : null;
      buffer = new BufferList();
      if (options.onData)
        options.onData(data);
      return {mode: ReadModes.LENGTH, chunk, buffer, data};
    }
  };
  function decode(options) {
    options = options || {};
    options.lengthDecoder = options.lengthDecoder || varintDecode;
    options.maxLengthLength = options.maxLengthLength || MAX_LENGTH_LENGTH;
    options.maxDataLength = options.maxDataLength || MAX_DATA_LENGTH;
    return (source) => async function* () {
      let buffer = new BufferList();
      let mode = ReadModes.LENGTH;
      let state;
      for await (let chunk of source) {
        while (chunk) {
          const result = ReadHandlers[mode](chunk, buffer, state, options);
          ({mode, chunk, buffer, state} = result);
          if (result.data)
            yield result.data;
        }
      }
      if (buffer.length) {
        throw Object.assign(new Error("unexpected end of input"), {code: "ERR_UNEXPECTED_EOF"});
      }
    }();
  }
  decode.fromReader = (reader, options) => {
    options = options || {};
    let byteLength = 1;
    const varByteSource = {
      [Symbol.asyncIterator]() {
        return this;
      },
      next: async () => {
        try {
          return await reader.next(byteLength);
        } catch (err) {
          if (err.code === "ERR_UNDER_READ") {
            return {done: true, value: null};
          }
          throw err;
        } finally {
          byteLength = 1;
        }
      }
    };
    options.onLength = (l) => {
      byteLength = l;
    };
    return decode(options)(varByteSource);
  };
  module2.exports = decode;
  module2.exports.MAX_LENGTH_LENGTH = MAX_LENGTH_LENGTH;
  module2.exports.MAX_DATA_LENGTH = MAX_DATA_LENGTH;
});

// node_modules/it-length-prefixed/src/int32BE-encode.js
var require_int32BE_encode = __commonJS((exports2, module2) => {
  "use strict";
  var {Buffer: Buffer2} = require_buffer();
  var int32BEEncode = (value, target, offset) => {
    target = target || Buffer2.allocUnsafe(4);
    target.writeInt32BE(value, offset);
    return target;
  };
  int32BEEncode.bytes = 4;
  module2.exports = int32BEEncode;
});

// node_modules/it-length-prefixed/src/int32BE-decode.js
var require_int32BE_decode = __commonJS((exports2, module2) => {
  "use strict";
  var int32BEDecode = (data) => {
    if (data.length < 4)
      throw RangeError("Could not decode int32BE");
    return data.readInt32BE(0);
  };
  int32BEDecode.bytes = 4;
  module2.exports = int32BEDecode;
});

// node_modules/it-length-prefixed/src/index.js
var require_src37 = __commonJS((exports2) => {
  "use strict";
  exports2.encode = require_encode7();
  exports2.decode = require_decode7();
  exports2.varintEncode = require_varint_encode();
  exports2.varintDecode = require_varint_decode();
  exports2.int32BEEncode = require_int32BE_encode();
  exports2.int32BEDecode = require_int32BE_decode();
});

// node_modules/get-iterator/index.js
var require_get_iterator = __commonJS((exports2, module2) => {
  module2.exports = function getIterator(obj) {
    if (obj) {
      if (typeof obj[Symbol.iterator] === "function") {
        return obj[Symbol.iterator]();
      }
      if (typeof obj[Symbol.asyncIterator] === "function") {
        return obj[Symbol.asyncIterator]();
      }
      if (typeof obj.next === "function") {
        return obj;
      }
    }
    throw new Error("argument is not an iterator or iterable");
  };
});

// node_modules/abortable-iterator/AbortError.js
var require_AbortError = __commonJS((exports2, module2) => {
  module2.exports = class AbortError extends Error {
    constructor(message, code) {
      super(message || "The operation was aborted");
      this.type = "aborted";
      this.code = code || "ABORT_ERR";
    }
  };
});

// node_modules/abortable-iterator/index.js
var require_abortable_iterator = __commonJS((exports2, module2) => {
  var getIterator = require_get_iterator();
  var AbortError = require_AbortError();
  var toAbortableSource = (source, signal, options) => toMultiAbortableSource(source, Array.isArray(signal) ? signal : [{signal, options}]);
  var toMultiAbortableSource = (source, signals) => {
    source = getIterator(source);
    signals = signals.map(({signal, options}) => ({signal, options: options || {}}));
    async function* abortable() {
      let nextAbortHandler;
      const abortHandler = () => {
        if (nextAbortHandler)
          nextAbortHandler();
      };
      for (const {signal} of signals) {
        signal.addEventListener("abort", abortHandler);
      }
      while (true) {
        let result;
        try {
          for (const {signal, options} of signals) {
            if (signal.aborted) {
              const {abortMessage, abortCode} = options;
              throw new AbortError(abortMessage, abortCode);
            }
          }
          const abort = new Promise((resolve, reject) => {
            nextAbortHandler = () => {
              const {options} = signals.find(({signal}) => signal.aborted);
              const {abortMessage, abortCode} = options;
              reject(new AbortError(abortMessage, abortCode));
            };
          });
          result = await Promise.race([abort, source.next()]);
          nextAbortHandler = null;
        } catch (err) {
          for (const {signal} of signals) {
            signal.removeEventListener("abort", abortHandler);
          }
          const aborter = signals.find(({signal}) => signal.aborted);
          const isKnownAborter = err.type === "aborted" && aborter;
          if (isKnownAborter && aborter.options.onAbort) {
            await aborter.options.onAbort(source);
          }
          if (typeof source.return === "function") {
            await source.return();
          }
          if (isKnownAborter && aborter.options.returnOnAbort) {
            return;
          }
          throw err;
        }
        if (result.done)
          break;
        yield result.value;
      }
      for (const {signal} of signals) {
        signal.removeEventListener("abort", abortHandler);
      }
    }
    return abortable();
  };
  var toAbortableSink = (sink, signal, options) => toMultiAbortableSink(sink, Array.isArray(signal) ? signal : [{signal, options}]);
  var toMultiAbortableSink = (sink, signals) => (source) => sink(toMultiAbortableSource(source, signals));
  var toAbortableDuplex = (duplex, signal, options) => toMultiAbortableDuplex(duplex, Array.isArray(signal) ? signal : [{signal, options}]);
  var toMultiAbortableDuplex = (duplex, signals) => ({
    sink: toMultiAbortableSink(duplex.sink, signals),
    source: toMultiAbortableSource(duplex.source, signals)
  });
  module2.exports = toAbortableSource;
  module2.exports.AbortError = AbortError;
  module2.exports.source = toAbortableSource;
  module2.exports.sink = toAbortableSink;
  module2.exports.transform = toAbortableSink;
  module2.exports.duplex = toAbortableDuplex;
});

// node_modules/libp2p-interfaces/src/pubsub/peer-streams.js
var require_peer_streams = __commonJS((exports2, module2) => {
  "use strict";
  var EventEmitter = require_events();
  var lp = require_src37();
  var pushable = require_it_pushable();
  var {pipe} = require_it_pipe();
  var {source: abortable} = require_abortable_iterator();
  var AbortController = require_browser3().default;
  var debug = require_browser4();
  var log = debug("libp2p-pubsub:peer-streams");
  log.error = debug("libp2p-pubsub:peer-streams:error");
  var PeerStreams = class extends EventEmitter {
    constructor({id, protocol}) {
      super();
      this.id = id;
      this.protocol = protocol;
      this._rawOutboundStream = null;
      this._rawInboundStream = null;
      this._inboundAbortController = new AbortController();
      this.outboundStream = null;
      this.inboundStream = null;
    }
    get isReadable() {
      return Boolean(this.inboundStream);
    }
    get isWritable() {
      return Boolean(this.outboundStream);
    }
    write(data) {
      if (!this.outboundStream) {
        const id = this.id.toB58String();
        throw new Error("No writable connection to " + id);
      }
      this.outboundStream.push(data);
    }
    attachInboundStream(stream) {
      this._rawInboundStream = stream;
      this.inboundStream = abortable(pipe(this._rawInboundStream, lp.decode()), this._inboundAbortController.signal, {returnOnAbort: true});
      this.emit("stream:inbound");
      return this.inboundStream;
    }
    async attachOutboundStream(stream) {
      const _prevStream = this.outboundStream;
      if (this.outboundStream) {
        await this.outboundStream.end();
      }
      this._rawOutboundStream = stream;
      this.outboundStream = pushable({
        onEnd: (shouldEmit) => {
          this._rawOutboundStream && this._rawOutboundStream.reset && this._rawOutboundStream.reset();
          this._rawOutboundStream = null;
          this.outboundStream = null;
          if (shouldEmit) {
            this.emit("close");
          }
        }
      });
      pipe(this.outboundStream, lp.encode(), this._rawOutboundStream).catch((err) => {
        log.error(err);
      });
      if (!_prevStream) {
        this.emit("stream:outbound");
      }
    }
    close() {
      if (this.outboundStream) {
        this.outboundStream.end();
      }
      if (this.inboundStream) {
        this._inboundAbortController.abort();
      }
      this._rawOutboundStream = null;
      this.outboundStream = null;
      this._rawInboundStream = null;
      this.inboundStream = null;
      this.emit("close");
    }
  };
  module2.exports = PeerStreams;
});

// node_modules/libp2p-interfaces/src/pubsub/signature-policy.js
var require_signature_policy = __commonJS((exports2) => {
  "use strict";
  var SignaturePolicy = {
    StrictSign: "StrictSign",
    StrictNoSign: "StrictNoSign"
  };
  exports2.SignaturePolicy = SignaturePolicy;
});

// node_modules/libp2p-interfaces/node_modules/uint8arrays/to-string.js
var require_to_string10 = __commonJS((exports2, module2) => {
  "use strict";
  var {encoding: getCodec} = require_src4();
  var {TextDecoder: TextDecoder2} = require_lib_browser();
  var utf8Decoder = new TextDecoder2("utf8");
  function uint8ArrayToAsciiString(array) {
    let string = "";
    for (let i = 0; i < array.length; i++) {
      string += String.fromCharCode(array[i]);
    }
    return string;
  }
  function toString(array, encoding = "utf8") {
    if (encoding === "utf8" || encoding === "utf-8") {
      return utf8Decoder.decode(array);
    }
    if (encoding === "ascii") {
      return uint8ArrayToAsciiString(array);
    }
    return getCodec(encoding).encode(array);
  }
  module2.exports = toString;
});

// node_modules/libp2p-interfaces/node_modules/uint8arrays/from-string.js
var require_from_string10 = __commonJS((exports2, module2) => {
  "use strict";
  var {encoding: getCodec} = require_src4();
  var {TextEncoder: TextEncoder2} = require_lib_browser();
  var utf8Encoder = new TextEncoder2();
  function asciiStringToUint8Array(string) {
    const array = new Uint8Array(string.length);
    for (let i = 0; i < string.length; i++) {
      array[i] = string.charCodeAt(i);
    }
    return array;
  }
  function fromString(string, encoding = "utf8") {
    if (encoding === "utf8" || encoding === "utf-8") {
      return utf8Encoder.encode(string);
    }
    if (encoding === "ascii") {
      return asciiStringToUint8Array(string);
    }
    return getCodec(encoding).decode(string);
  }
  module2.exports = fromString;
});

// node_modules/libp2p-interfaces/src/pubsub/utils.js
var require_utils23 = __commonJS((exports2, module2) => {
  "use strict";
  var randomBytes = require_random_bytes();
  var uint8ArrayToString = require_to_string10();
  var uint8ArrayFromString = require_from_string10();
  var PeerId = require_src9();
  var multihash = require_src5();
  exports2 = module2.exports;
  exports2.randomSeqno = () => {
    return randomBytes(8);
  };
  exports2.msgId = (from, seqno) => {
    const fromBytes = PeerId.createFromB58String(from).id;
    const msgId = new Uint8Array(fromBytes.length + seqno.length);
    msgId.set(fromBytes, 0);
    msgId.set(seqno, fromBytes.length);
    return msgId;
  };
  exports2.noSignMsgId = (data) => multihash.encode(data, "sha2-256");
  exports2.anyMatch = (a, b) => {
    let bHas;
    if (Array.isArray(b)) {
      bHas = (val) => b.indexOf(val) > -1;
    } else {
      bHas = (val) => b.has(val);
    }
    for (const val of a) {
      if (bHas(val)) {
        return true;
      }
    }
    return false;
  };
  exports2.ensureArray = (maybeArray) => {
    if (!Array.isArray(maybeArray)) {
      return [maybeArray];
    }
    return maybeArray;
  };
  exports2.normalizeInRpcMessage = (message, peerId) => {
    const m = Object.assign({}, message);
    if (message.from instanceof Uint8Array) {
      m.from = uint8ArrayToString(message.from, "base58btc");
    }
    if (peerId) {
      m.receivedFrom = peerId;
    }
    return m;
  };
  exports2.normalizeOutRpcMessage = (message) => {
    const m = Object.assign({}, message);
    if (typeof message.from === "string") {
      m.from = uint8ArrayFromString(message.from, "base58btc");
    }
    if (typeof message.data === "string") {
      m.data = uint8ArrayFromString(message.data);
    }
    return m;
  };
});

// node_modules/libp2p-interfaces/node_modules/uint8arrays/concat.js
var require_concat7 = __commonJS((exports2, module2) => {
  "use strict";
  function concat(arrays, length) {
    if (!length) {
      length = arrays.reduce((acc, curr) => acc + curr.length, 0);
    }
    const output = new Uint8Array(length);
    let offset = 0;
    for (const arr of arrays) {
      output.set(arr, offset);
      offset += arr.length;
    }
    return output;
  }
  module2.exports = concat;
});

// node_modules/libp2p-interfaces/src/pubsub/message/sign.js
var require_sign = __commonJS((exports2, module2) => {
  "use strict";
  var PeerId = require_src9();
  var {Message} = require_message();
  var uint8ArrayConcat = require_concat7();
  var uint8ArrayFromString = require_from_string10();
  var SignPrefix = uint8ArrayFromString("libp2p-pubsub:");
  async function signMessage(peerId, message) {
    const bytes = uint8ArrayConcat([
      SignPrefix,
      Message.encode(message)
    ]);
    const signature = await peerId.privKey.sign(bytes);
    return {
      ...message,
      signature,
      key: peerId.pubKey.bytes
    };
  }
  async function verifySignature(message) {
    if (!message.signature) {
      throw new Error("Message must contain a signature to be verified");
    }
    const bytes = uint8ArrayConcat([
      SignPrefix,
      Message.encode({
        ...message,
        from: message.from && PeerId.createFromCID(message.from).toBytes(),
        signature: void 0,
        key: void 0
      })
    ]);
    const pubKey = await messagePublicKey(message);
    return pubKey.verify(bytes, message.signature);
  }
  async function messagePublicKey(message) {
    if (!message.from) {
      throw new Error("Could not get the public key from the originator id");
    }
    const from = PeerId.createFromCID(message.from);
    if (message.key) {
      const keyPeerId = await PeerId.createFromPubKey(message.key);
      if (keyPeerId.equals(from))
        return keyPeerId.pubKey;
      throw new Error("Public Key does not match the originator");
    } else if (from.pubKey) {
      return from.pubKey;
    } else {
      throw new Error("Could not get the public key from the originator id");
    }
  }
  module2.exports = {
    messagePublicKey,
    signMessage,
    SignPrefix,
    verifySignature
  };
});

// node_modules/libp2p-interfaces/src/pubsub/index.js
var require_pubsub2 = __commonJS((exports2, module2) => {
  "use strict";
  var debug = require_browser4();
  var EventEmitter = require_events();
  var errcode = require_err_code();
  var {pipe} = require_it_pipe();
  var MulticodecTopology = require_multicodec_topology();
  var {codes} = require_errors11();
  var message = require_message();
  var PeerStreams = require_peer_streams();
  var {SignaturePolicy} = require_signature_policy();
  var utils = require_utils23();
  var {
    signMessage,
    verifySignature
  } = require_sign();
  var PubsubBaseProtocol = class extends EventEmitter {
    constructor({
      debugName,
      multicodecs,
      libp2p,
      globalSignaturePolicy = SignaturePolicy.StrictSign,
      canRelayMessage = false,
      emitSelf = false
    }) {
      if (typeof debugName !== "string") {
        throw new Error("a debugname `string` is required");
      }
      if (!multicodecs) {
        throw new Error("multicodecs are required");
      }
      if (!libp2p) {
        throw new Error("libp2p is required");
      }
      super();
      this.log = debug(debugName);
      this.log.err = debug(`${debugName}:error`);
      this.multicodecs = utils.ensureArray(multicodecs);
      this._libp2p = libp2p;
      this.registrar = libp2p.registrar;
      this.peerId = libp2p.peerId;
      this.started = false;
      this.topics = new Map();
      this.subscriptions = new Set();
      this.peers = new Map();
      if (!SignaturePolicy[globalSignaturePolicy]) {
        throw errcode(new Error("Invalid global signature policy"), codes.ERR_INVALID_SIGUATURE_POLICY);
      }
      this.globalSignaturePolicy = globalSignaturePolicy;
      this.canRelayMessage = canRelayMessage;
      this.emitSelf = emitSelf;
      this.topicValidators = new Map();
      this._registrarId = void 0;
      this._onIncomingStream = this._onIncomingStream.bind(this);
      this._onPeerConnected = this._onPeerConnected.bind(this);
      this._onPeerDisconnected = this._onPeerDisconnected.bind(this);
    }
    start() {
      if (this.started) {
        return;
      }
      this.log("starting");
      this.registrar.handle(this.multicodecs, this._onIncomingStream);
      const topology = new MulticodecTopology({
        multicodecs: this.multicodecs,
        handlers: {
          onConnect: this._onPeerConnected,
          onDisconnect: this._onPeerDisconnected
        }
      });
      this._registrarId = this.registrar.register(topology);
      this.log("started");
      this.started = true;
    }
    stop() {
      if (!this.started) {
        return;
      }
      this.registrar.unregister(this._registrarId);
      this.log("stopping");
      this.peers.forEach((peerStreams) => peerStreams.close());
      this.peers = new Map();
      this.subscriptions = new Set();
      this.started = false;
      this.log("stopped");
    }
    _onIncomingStream({protocol, stream, connection}) {
      const peerId = connection.remotePeer;
      const idB58Str = peerId.toB58String();
      const peer = this._addPeer(peerId, protocol);
      const inboundStream = peer.attachInboundStream(stream);
      this._processMessages(idB58Str, inboundStream, peer);
    }
    async _onPeerConnected(peerId, conn) {
      const idB58Str = peerId.toB58String();
      this.log("connected", idB58Str);
      try {
        const {stream, protocol} = await conn.newStream(this.multicodecs);
        const peer = this._addPeer(peerId, protocol);
        await peer.attachOutboundStream(stream);
      } catch (err) {
        this.log.err(err);
      }
      this._sendSubscriptions(idB58Str, Array.from(this.subscriptions), true);
    }
    _onPeerDisconnected(peerId, err) {
      const idB58Str = peerId.toB58String();
      this.log("connection ended", idB58Str, err ? err.message : "");
      this._removePeer(peerId);
    }
    _addPeer(peerId, protocol) {
      const id = peerId.toB58String();
      const existing = this.peers.get(id);
      if (existing) {
        return existing;
      }
      this.log("new peer", id);
      const peerStreams = new PeerStreams({
        id: peerId,
        protocol
      });
      this.peers.set(id, peerStreams);
      peerStreams.once("close", () => this._removePeer(peerId));
      return peerStreams;
    }
    _removePeer(peerId) {
      if (!peerId)
        return;
      const id = peerId.toB58String();
      const peerStreams = this.peers.get(id);
      if (!peerStreams)
        return;
      peerStreams.removeAllListeners();
      peerStreams.close();
      this.log("delete peer", id);
      this.peers.delete(id);
      for (const peers of this.topics.values()) {
        peers.delete(id);
      }
      return peerStreams;
    }
    async _processMessages(idB58Str, stream, peerStreams) {
      try {
        await pipe(stream, async (source) => {
          for await (const data of source) {
            const rpcBytes = data instanceof Uint8Array ? data : data.slice();
            const rpcMsg = this._decodeRpc(rpcBytes);
            this._processRpc(idB58Str, peerStreams, rpcMsg);
          }
        });
      } catch (err) {
        this._onPeerDisconnected(peerStreams.id, err);
      }
    }
    _processRpc(idB58Str, peerStreams, rpc) {
      this.log("rpc from", idB58Str);
      const subs = rpc.subscriptions;
      const msgs = rpc.msgs;
      if (subs.length) {
        subs.forEach((subOpt) => this._processRpcSubOpt(idB58Str, subOpt));
        this.emit("pubsub:subscription-change", peerStreams.id, subs);
      }
      if (!this._acceptFrom(idB58Str)) {
        this.log("received message from unacceptable peer %s", idB58Str);
        return false;
      }
      if (msgs.length) {
        msgs.forEach((message2) => {
          if (!(this.canRelayMessage || message2.topicIDs.some((topic) => this.subscriptions.has(topic)))) {
            this.log("received message we didn't subscribe to. Dropping.");
            return;
          }
          const msg = utils.normalizeInRpcMessage(message2, idB58Str);
          this._processRpcMessage(msg);
        });
      }
      return true;
    }
    _processRpcSubOpt(id, subOpt) {
      const t = subOpt.topicID;
      let topicSet = this.topics.get(t);
      if (!topicSet) {
        topicSet = new Set();
        this.topics.set(t, topicSet);
      }
      if (subOpt.subscribe) {
        topicSet.add(id);
      } else {
        topicSet.delete(id);
      }
    }
    async _processRpcMessage(msg) {
      if (this.peerId.toB58String() === msg.from && !this.emitSelf) {
        return;
      }
      try {
        await this.validate(msg);
      } catch (err) {
        this.log("Message is invalid, dropping it. %O", err);
        return;
      }
      this._emitMessage(msg);
      this._publish(utils.normalizeOutRpcMessage(msg));
    }
    _emitMessage(message2) {
      message2.topicIDs.forEach((topic) => {
        if (this.subscriptions.has(topic)) {
          this.emit(topic, message2);
        }
      });
    }
    getMsgId(msg) {
      const signaturePolicy = this.globalSignaturePolicy;
      switch (signaturePolicy) {
        case SignaturePolicy.StrictSign:
          return utils.msgId(msg.from, msg.seqno);
        case SignaturePolicy.StrictNoSign:
          return utils.noSignMsgId(msg.data);
        default:
          throw errcode(new Error("Cannot get message id: unhandled signature policy: " + signaturePolicy), codes.ERR_UNHANDLED_SIGNATURE_POLICY);
      }
    }
    _acceptFrom(id) {
      return true;
    }
    _decodeRpc(bytes) {
      return message.rpc.RPC.decode(bytes);
    }
    _encodeRpc(rpc) {
      return message.rpc.RPC.encode(rpc);
    }
    _sendRpc(id, rpc) {
      const peerStreams = this.peers.get(id);
      if (!peerStreams || !peerStreams.isWritable) {
        const msg = `Cannot send RPC to ${id} as there is no open stream to it available`;
        this.log.err(msg);
        return;
      }
      peerStreams.write(this._encodeRpc(rpc));
    }
    _sendSubscriptions(id, topics, subscribe) {
      return this._sendRpc(id, {
        subscriptions: topics.map((t) => ({topicID: t, subscribe}))
      });
    }
    async validate(message2) {
      const signaturePolicy = this.globalSignaturePolicy;
      switch (signaturePolicy) {
        case SignaturePolicy.StrictNoSign:
          if (message2.from) {
            throw errcode(new Error("StrictNoSigning: from should not be present"), codes.ERR_UNEXPECTED_FROM);
          }
          if (message2.signature) {
            throw errcode(new Error("StrictNoSigning: signature should not be present"), codes.ERR_UNEXPECTED_SIGNATURE);
          }
          if (message2.key) {
            throw errcode(new Error("StrictNoSigning: key should not be present"), codes.ERR_UNEXPECTED_KEY);
          }
          if (message2.seqno) {
            throw errcode(new Error("StrictNoSigning: seqno should not be present"), codes.ERR_UNEXPECTED_SEQNO);
          }
          break;
        case SignaturePolicy.StrictSign:
          if (!message2.signature) {
            throw errcode(new Error("StrictSigning: Signing required and no signature was present"), codes.ERR_MISSING_SIGNATURE);
          }
          if (!message2.seqno) {
            throw errcode(new Error("StrictSigning: Signing required and no seqno was present"), codes.ERR_MISSING_SEQNO);
          }
          if (!await verifySignature(message2)) {
            throw errcode(new Error("StrictSigning: Invalid message signature"), codes.ERR_INVALID_SIGNATURE);
          }
          break;
        default:
          throw errcode(new Error("Cannot validate message: unhandled signature policy: " + signaturePolicy), codes.ERR_UNHANDLED_SIGNATURE_POLICY);
      }
      for (const topic of message2.topicIDs) {
        const validatorFn = this.topicValidators.get(topic);
        if (!validatorFn) {
          continue;
        }
        await validatorFn(topic, message2);
      }
    }
    _buildMessage(message2) {
      const signaturePolicy = this.globalSignaturePolicy;
      switch (signaturePolicy) {
        case SignaturePolicy.StrictSign:
          message2.from = this.peerId.toB58String();
          message2.seqno = utils.randomSeqno();
          return signMessage(this.peerId, utils.normalizeOutRpcMessage(message2));
        case SignaturePolicy.StrictNoSign:
          return message2;
        default:
          throw errcode(new Error("Cannot build message: unhandled signature policy: " + signaturePolicy), codes.ERR_UNHANDLED_SIGNATURE_POLICY);
      }
    }
    getSubscribers(topic) {
      if (!this.started) {
        throw errcode(new Error("not started yet"), "ERR_NOT_STARTED_YET");
      }
      if (!topic || typeof topic !== "string") {
        throw errcode(new Error("a string topic must be provided"), "ERR_NOT_VALID_TOPIC");
      }
      const peersInTopic = this.topics.get(topic);
      if (!peersInTopic) {
        return [];
      }
      return Array.from(peersInTopic);
    }
    async publish(topic, message2) {
      if (!this.started) {
        throw new Error("Pubsub has not started");
      }
      this.log("publish", topic, message2);
      const from = this.peerId.toB58String();
      let msgObject = {
        receivedFrom: from,
        data: message2,
        topicIDs: [topic]
      };
      const outMsg = await this._buildMessage(msgObject);
      msgObject = utils.normalizeInRpcMessage(outMsg);
      this.emitSelf && this._emitMessage(msgObject);
      await this._publish(msgObject);
    }
    _publish(message2) {
      throw errcode(new Error("publish must be implemented by the subclass"), "ERR_NOT_IMPLEMENTED");
    }
    subscribe(topic) {
      if (!this.started) {
        throw new Error("Pubsub has not started");
      }
      if (!this.subscriptions.has(topic)) {
        this.subscriptions.add(topic);
        this.peers.forEach((_, id) => this._sendSubscriptions(id, [topic], true));
      }
    }
    unsubscribe(topic) {
      if (!this.started) {
        throw new Error("Pubsub is not started");
      }
      if (this.subscriptions.has(topic) && this.listenerCount(topic) === 0) {
        this.subscriptions.delete(topic);
        this.peers.forEach((_, id) => this._sendSubscriptions(id, [topic], false));
      }
    }
    getTopics() {
      if (!this.started) {
        throw new Error("Pubsub is not started");
      }
      return Array.from(this.subscriptions);
    }
  };
  PubsubBaseProtocol.message = message;
  PubsubBaseProtocol.utils = utils;
  PubsubBaseProtocol.SignaturePolicy = SignaturePolicy;
  module2.exports = PubsubBaseProtocol;
});

// node_modules/libp2p-gossipsub/src/utils/create-gossip-rpc.js
var require_create_gossip_rpc = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.createGossipRpc = void 0;
  function createGossipRpc(msgs = [], control = {}) {
    return {
      subscriptions: [],
      msgs,
      control: Object.assign({ihave: [], iwant: [], graft: [], prune: []}, control)
    };
  }
  exports2.createGossipRpc = createGossipRpc;
});

// node_modules/libp2p-gossipsub/src/utils/shuffle.js
var require_shuffle = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.shuffle = void 0;
  function shuffle(arr) {
    if (arr.length <= 1) {
      return arr;
    }
    const randInt = () => {
      return Math.floor(Math.random() * Math.floor(arr.length));
    };
    for (let i = 0; i < arr.length; i++) {
      const j = randInt();
      const tmp = arr[i];
      arr[i] = arr[j];
      arr[j] = tmp;
    }
    return arr;
  }
  exports2.shuffle = shuffle;
});

// node_modules/libp2p-gossipsub/src/constants.js
var require_constants8 = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.ERR_TOPIC_VALIDATOR_IGNORE = exports2.ERR_TOPIC_VALIDATOR_REJECT = exports2.TimeCacheDuration = exports2.GossipsubIWantFollowupTime = exports2.GossipsubMaxIHaveMessages = exports2.GossipsubMaxIHaveLength = exports2.GossipsubGraftFloodThreshold = exports2.GossipsubOpportunisticGraftPeers = exports2.GossipsubOpportunisticGraftTicks = exports2.GossipsubDirectConnectInitialDelay = exports2.GossipsubDirectConnectTicks = exports2.GossipsubConnectionTimeout = exports2.GossipsubMaxPendingConnections = exports2.GossipsubConnectors = exports2.GossipsubPruneBackoffTicks = exports2.GossipsubPruneBackoff = exports2.GossipsubPrunePeers = exports2.GossipsubFanoutTTL = exports2.GossipsubHeartbeatInterval = exports2.GossipsubHeartbeatInitialDelay = exports2.GossipsubGossipRetransmission = exports2.GossipsubGossipFactor = exports2.GossipsubDlazy = exports2.GossipsubHistoryGossip = exports2.GossipsubHistoryLength = exports2.GossipsubDout = exports2.GossipsubDscore = exports2.GossipsubDhi = exports2.GossipsubDlo = exports2.GossipsubD = exports2.GossipsubIDv11 = exports2.GossipsubIDv10 = exports2.FloodsubID = exports2.minute = exports2.second = void 0;
  exports2.second = 1e3;
  exports2.minute = 60 * exports2.second;
  exports2.FloodsubID = "/floodsub/1.0.0";
  exports2.GossipsubIDv10 = "/meshsub/1.0.0";
  exports2.GossipsubIDv11 = "/meshsub/1.1.0";
  exports2.GossipsubD = 6;
  exports2.GossipsubDlo = 4;
  exports2.GossipsubDhi = 12;
  exports2.GossipsubDscore = 4;
  exports2.GossipsubDout = 2;
  exports2.GossipsubHistoryLength = 5;
  exports2.GossipsubHistoryGossip = 3;
  exports2.GossipsubDlazy = 6;
  exports2.GossipsubGossipFactor = 0.25;
  exports2.GossipsubGossipRetransmission = 3;
  exports2.GossipsubHeartbeatInitialDelay = 100;
  exports2.GossipsubHeartbeatInterval = exports2.second;
  exports2.GossipsubFanoutTTL = exports2.minute;
  exports2.GossipsubPrunePeers = 16;
  exports2.GossipsubPruneBackoff = exports2.minute;
  exports2.GossipsubPruneBackoffTicks = 15;
  exports2.GossipsubConnectors = 8;
  exports2.GossipsubMaxPendingConnections = 128;
  exports2.GossipsubConnectionTimeout = 30 * exports2.second;
  exports2.GossipsubDirectConnectTicks = 300;
  exports2.GossipsubDirectConnectInitialDelay = exports2.second;
  exports2.GossipsubOpportunisticGraftTicks = 60;
  exports2.GossipsubOpportunisticGraftPeers = 2;
  exports2.GossipsubGraftFloodThreshold = 10 * exports2.second;
  exports2.GossipsubMaxIHaveLength = 5e3;
  exports2.GossipsubMaxIHaveMessages = 10;
  exports2.GossipsubIWantFollowupTime = 3 * exports2.second;
  exports2.TimeCacheDuration = 120 * 1e3;
  exports2.ERR_TOPIC_VALIDATOR_REJECT = "ERR_TOPIC_VALIDATOR_REJECT";
  exports2.ERR_TOPIC_VALIDATOR_IGNORE = "ERR_TOPIC_VALIDATOR_IGNORE";
});

// node_modules/libp2p-gossipsub/src/utils/has-gossip-protocol.js
var require_has_gossip_protocol = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.hasGossipProtocol = void 0;
  var constants_1 = require_constants8();
  function hasGossipProtocol(protocol) {
    return protocol === constants_1.GossipsubIDv10 || protocol === constants_1.GossipsubIDv11;
  }
  exports2.hasGossipProtocol = hasGossipProtocol;
});

// node_modules/libp2p-gossipsub/src/utils/messageIdToString.js
var require_messageIdToString = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.messageIdToString = void 0;
  var toString = require_to_string2();
  function messageIdToString(msgId) {
    return toString(msgId, "base64");
  }
  exports2.messageIdToString = messageIdToString;
});

// node_modules/libp2p-gossipsub/src/utils/index.js
var require_utils24 = __commonJS((exports2) => {
  "use strict";
  var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    Object.defineProperty(o, k2, {enumerable: true, get: function() {
      return m[k];
    }});
  } : function(o, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
        __createBinding(exports3, m, p);
  };
  Object.defineProperty(exports2, "__esModule", {value: true});
  __exportStar(require_create_gossip_rpc(), exports2);
  __exportStar(require_shuffle(), exports2);
  __exportStar(require_has_gossip_protocol(), exports2);
  __exportStar(require_messageIdToString(), exports2);
});

// node_modules/libp2p-gossipsub/src/message-cache.js
var require_message_cache = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.MessageCache = void 0;
  var utils_1 = require_utils24();
  var MessageCache = class {
    constructor(gossip, history, msgIdFn) {
      this.msgs = new Map();
      this.peertx = new Map();
      this.history = [];
      for (let i = 0; i < history; i++) {
        this.history[i] = [];
      }
      this.gossip = gossip;
      this.msgIdFn = msgIdFn;
    }
    put(msg) {
      const msgID = this.getMsgId(msg);
      const msgIdStr = utils_1.messageIdToString(msgID);
      this.msgs.set(msgIdStr, msg);
      this.history[0].push({msgID, topics: msg.topicIDs});
    }
    getMsgId(msg) {
      return this.msgIdFn(msg);
    }
    get(msgID) {
      return this.msgs.get(utils_1.messageIdToString(msgID));
    }
    getForPeer(msgID, p) {
      const msgIdStr = utils_1.messageIdToString(msgID);
      const msg = this.msgs.get(msgIdStr);
      if (!msg) {
        return [void 0, 0];
      }
      let peertx = this.peertx.get(msgIdStr);
      if (!peertx) {
        peertx = new Map();
        this.peertx.set(msgIdStr, peertx);
      }
      const count = (peertx.get(p) || 0) + 1;
      peertx.set(p, count);
      return [msg, count];
    }
    getGossipIDs(topic) {
      const msgIDs = [];
      for (let i = 0; i < this.gossip; i++) {
        this.history[i].forEach((entry) => {
          for (const t of entry.topics) {
            if (t === topic) {
              msgIDs.push(entry.msgID);
              break;
            }
          }
        });
      }
      return msgIDs;
    }
    shift() {
      const last = this.history[this.history.length - 1];
      last.forEach((entry) => {
        const msgIdStr = utils_1.messageIdToString(entry.msgID);
        this.msgs.delete(msgIdStr);
        this.peertx.delete(msgIdStr);
      });
      this.history.pop();
      this.history.unshift([]);
    }
  };
  exports2.MessageCache = MessageCache;
});

// node_modules/libp2p-gossipsub/src/message/rpc.proto.js
var require_rpc_proto2 = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.default = `
message RPC {
  repeated SubOpts subscriptions = 1;
  repeated Message msgs = 2;
  optional ControlMessage control = 3;

  message SubOpts {
    optional bool subscribe = 1; // subscribe or unsubcribe
    optional string topicID = 2;
  }

  message Message {
    optional bytes from = 1;
    optional bytes data = 2;
    optional bytes seqno = 3;
    repeated string topicIDs = 4; 
    optional bytes signature = 5;
    optional bytes key = 6;
  }

  message ControlMessage {
    repeated ControlIHave ihave = 1;
    repeated ControlIWant iwant = 2;
    repeated ControlGraft graft = 3;
    repeated ControlPrune prune = 4;
  }

  message ControlIHave {
    optional string topicID = 1;
    repeated bytes messageIDs = 2;
  }

  message ControlIWant {
    repeated bytes messageIDs = 1;  
  }

  message ControlGraft {
    optional string topicID = 1;
  }

  message ControlPrune {
    optional string topicID = 1;
    repeated PeerInfo peers = 2;
    optional uint64 backoff = 3;
  }

  message PeerInfo {
    optional bytes peerID = 1;
    optional bytes signedPeerRecord = 2;
  }
}`;
});

// node_modules/libp2p-gossipsub/src/message/index.js
var require_message2 = __commonJS((exports2) => {
  "use strict";
  var __importDefault = exports2 && exports2.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {default: mod};
  };
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.RPCCodec = void 0;
  var rpc_proto_1 = __importDefault(require_rpc_proto2());
  var protons = require_src8();
  var rpcProto = protons(rpc_proto_1.default);
  exports2.RPCCodec = rpcProto.RPC;
});

// node_modules/libp2p-gossipsub/src/get-gossip-peers.js
var require_get_gossip_peers = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.getGossipPeers = void 0;
  var utils_1 = require_utils24();
  function getGossipPeers(router, topic, count, filter = () => true) {
    const peersInTopic = router.topics.get(topic);
    if (!peersInTopic) {
      return new Set();
    }
    let peers = [];
    peersInTopic.forEach((id) => {
      const peerStreams = router.peers.get(id);
      if (!peerStreams) {
        return;
      }
      if (utils_1.hasGossipProtocol(peerStreams.protocol) && filter(id)) {
        peers.push(id);
      }
    });
    peers = utils_1.shuffle(peers);
    if (count > 0 && peers.length > count) {
      peers = peers.slice(0, count);
    }
    return new Set(peers);
  }
  exports2.getGossipPeers = getGossipPeers;
});

// node_modules/libp2p-gossipsub/src/heartbeat.js
var require_heartbeat = __commonJS((exports2) => {
  "use strict";
  var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    Object.defineProperty(o, k2, {enumerable: true, get: function() {
      return m[k];
    }});
  } : function(o, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {enumerable: true, value: v});
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports2 && exports2.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.Heartbeat = void 0;
  var constants = __importStar(require_constants8());
  var get_gossip_peers_1 = require_get_gossip_peers();
  var utils_1 = require_utils24();
  var Heartbeat = class {
    constructor(gossipsub) {
      this.gossipsub = gossipsub;
    }
    start() {
      if (this._heartbeatTimer) {
        return;
      }
      const heartbeat = this._heartbeat.bind(this);
      const timeout = setTimeout(() => {
        heartbeat();
        this._heartbeatTimer.runPeriodically(heartbeat, constants.GossipsubHeartbeatInterval);
      }, constants.GossipsubHeartbeatInitialDelay);
      this._heartbeatTimer = {
        _intervalId: void 0,
        runPeriodically: (fn, period) => {
          this._heartbeatTimer._intervalId = setInterval(fn, period);
        },
        cancel: () => {
          clearTimeout(timeout);
          clearInterval(this._heartbeatTimer._intervalId);
        }
      };
    }
    stop() {
      if (!this._heartbeatTimer) {
        return;
      }
      this._heartbeatTimer.cancel();
      this._heartbeatTimer = null;
    }
    _heartbeat() {
      const {D, Dlo, Dhi, Dscore, Dout} = this.gossipsub._options;
      this.gossipsub.heartbeatTicks++;
      const scores = new Map();
      const getScore = (id) => {
        let s = scores.get(id);
        if (s === void 0) {
          s = this.gossipsub.score.score(id);
          scores.set(id, s);
        }
        return s;
      };
      const tograft = new Map();
      const toprune = new Map();
      const noPX = new Map();
      this.gossipsub._clearBackoff();
      this.gossipsub.peerhave.clear();
      this.gossipsub.iasked.clear();
      this.gossipsub._applyIwantPenalties();
      this.gossipsub._directConnect();
      this.gossipsub.mesh.forEach((peers, topic) => {
        const prunePeer = (id) => {
          this.gossipsub.log("HEARTBEAT: Remove mesh link to %s in %s", id, topic);
          this.gossipsub.score.prune(id, topic);
          this.gossipsub._addBackoff(id, topic);
          peers.delete(id);
          const topics = toprune.get(id);
          if (!topics) {
            toprune.set(id, [topic]);
          } else {
            topics.push(topic);
          }
        };
        const graftPeer = (id) => {
          this.gossipsub.log("HEARTBEAT: Add mesh link to %s in %s", id, topic);
          this.gossipsub.score.graft(id, topic);
          peers.add(id);
          const topics = tograft.get(id);
          if (!topics) {
            tograft.set(id, [topic]);
          } else {
            topics.push(topic);
          }
        };
        peers.forEach((id) => {
          const score = getScore(id);
          if (score < 0) {
            this.gossipsub.log("HEARTBEAT: Prune peer %s with negative score: score=%d, topic=%s", id, score, topic);
            prunePeer(id);
            noPX.set(id, true);
          }
        });
        if (peers.size < Dlo) {
          const backoff = this.gossipsub.backoff.get(topic);
          const ineed = D - peers.size;
          const peersSet = get_gossip_peers_1.getGossipPeers(this.gossipsub, topic, ineed, (id) => {
            return !peers.has(id) && !this.gossipsub.direct.has(id) && (!backoff || !backoff.has(id)) && getScore(id) >= 0;
          });
          peersSet.forEach(graftPeer);
        }
        if (peers.size > Dhi) {
          let peersArray = Array.from(peers);
          peersArray.sort((a, b) => getScore(b) - getScore(a));
          peersArray = peersArray.slice(0, Dscore).concat(utils_1.shuffle(peersArray.slice(Dscore)));
          let outbound = 0;
          peersArray.slice(0, D).forEach((p) => {
            if (this.gossipsub.outbound.get(p)) {
              outbound++;
            }
          });
          if (outbound < Dout) {
            const rotate = (i) => {
              const p = peersArray[i];
              for (let j = i; j > 0; j--) {
                peersArray[j] = peersArray[j - 1];
              }
              peersArray[0] = p;
            };
            if (outbound > 0) {
              let ihave = outbound;
              for (let i = 1; i < D && ihave > 0; i++) {
                if (this.gossipsub.outbound.get(peersArray[i])) {
                  rotate(i);
                  ihave--;
                }
              }
            }
            let ineed = D - outbound;
            for (let i = D; i < peersArray.length && ineed > 0; i++) {
              if (this.gossipsub.outbound.get(peersArray[i])) {
                rotate(i);
                ineed--;
              }
            }
          }
          peersArray.slice(D).forEach(prunePeer);
        }
        if (peers.size >= Dlo) {
          let outbound = 0;
          peers.forEach((p) => {
            if (this.gossipsub.outbound.get(p)) {
              outbound++;
            }
          });
          if (outbound < Dout) {
            const ineed = Dout - outbound;
            const backoff = this.gossipsub.backoff.get(topic);
            get_gossip_peers_1.getGossipPeers(this.gossipsub, topic, ineed, (id) => {
              return !peers.has(id) && !this.gossipsub.direct.has(id) && (!backoff || !backoff.has(id)) && getScore(id) >= 0;
            }).forEach(graftPeer);
          }
        }
        if (this.gossipsub.heartbeatTicks % constants.GossipsubOpportunisticGraftTicks === 0 && peers.size > 1) {
          const peersList = Array.from(peers).sort((a, b) => getScore(a) - getScore(b));
          const medianIndex = peers.size / 2;
          const medianScore = getScore(peersList[medianIndex]);
          if (medianScore < this.gossipsub._options.scoreThresholds.opportunisticGraftThreshold) {
            const backoff = this.gossipsub.backoff.get(topic);
            const peersToGraft = get_gossip_peers_1.getGossipPeers(this.gossipsub, topic, constants.GossipsubOpportunisticGraftPeers, (id) => {
              return peers.has(id) && !this.gossipsub.direct.has(id) && (!backoff || !backoff.has(id)) && getScore(id) > medianScore;
            });
            peersToGraft.forEach((id) => {
              this.gossipsub.log("HEARTBEAT: Opportunistically graft peer %s on topic %s", id, topic);
              graftPeer(id);
            });
          }
        }
        this.gossipsub._emitGossip(topic, peers);
      });
      const now = this.gossipsub._now();
      this.gossipsub.lastpub.forEach((lastpb, topic) => {
        if (lastpb + constants.GossipsubFanoutTTL < now) {
          this.gossipsub.fanout.delete(topic);
          this.gossipsub.lastpub.delete(topic);
        }
      });
      this.gossipsub.fanout.forEach((fanoutPeers, topic) => {
        const topicPeers = this.gossipsub.topics.get(topic);
        fanoutPeers.forEach((id) => {
          if (!topicPeers.has(id) || getScore(id) < this.gossipsub._options.scoreThresholds.publishThreshold) {
            fanoutPeers.delete(id);
          }
        });
        if (fanoutPeers.size < D) {
          const ineed = D - fanoutPeers.size;
          const peersSet = get_gossip_peers_1.getGossipPeers(this.gossipsub, topic, ineed, (id) => {
            return !fanoutPeers.has(id) && !this.gossipsub.direct.has(id) && getScore(id) >= this.gossipsub._options.scoreThresholds.publishThreshold;
          });
          peersSet.forEach((id) => {
            fanoutPeers.add(id);
          });
        }
        this.gossipsub._emitGossip(topic, fanoutPeers);
      });
      this.gossipsub._sendGraftPrune(tograft, toprune, noPX);
      this.gossipsub._flush();
      this.gossipsub.messageCache.shift();
      this.gossipsub.emit("gossipsub:heartbeat");
    }
  };
  exports2.Heartbeat = Heartbeat;
});

// node_modules/libp2p-gossipsub/src/score/constants.js
var require_constants9 = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.ERR_INVALID_PEER_SCORE_THRESHOLDS = exports2.ERR_INVALID_PEER_SCORE_PARAMS = void 0;
  exports2.ERR_INVALID_PEER_SCORE_PARAMS = "ERR_INVALID_PEER_SCORE_PARAMS";
  exports2.ERR_INVALID_PEER_SCORE_THRESHOLDS = "ERR_INVALID_PEER_SCORE_THRESHOLDS";
});

// node_modules/libp2p-gossipsub/src/score/peer-score-params.js
var require_peer_score_params = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.validateTopicScoreParams = exports2.validatePeerScoreParams = exports2.createTopicScoreParams = exports2.createPeerScoreParams = exports2.defaultTopicScoreParams = exports2.defaultPeerScoreParams = void 0;
  var constants_1 = require_constants9();
  var errcode = require_err_code();
  exports2.defaultPeerScoreParams = {
    topics: {},
    topicScoreCap: 10,
    appSpecificScore: () => 0,
    appSpecificWeight: 10,
    IPColocationFactorWeight: -5,
    IPColocationFactorThreshold: 10,
    IPColocationFactorWhitelist: new Set(),
    behaviourPenaltyWeight: -10,
    behaviourPenaltyDecay: 0.2,
    decayInterval: 1e3,
    decayToZero: 0.1,
    retainScore: 3600 * 1e3
  };
  exports2.defaultTopicScoreParams = {
    topicWeight: 0.5,
    timeInMeshWeight: 1,
    timeInMeshQuantum: 1,
    timeInMeshCap: 3600,
    firstMessageDeliveriesWeight: 1,
    firstMessageDeliveriesDecay: 0.5,
    firstMessageDeliveriesCap: 2e3,
    meshMessageDeliveriesWeight: -1,
    meshMessageDeliveriesDecay: 0.5,
    meshMessageDeliveriesCap: 100,
    meshMessageDeliveriesThreshold: 20,
    meshMessageDeliveriesWindow: 10,
    meshMessageDeliveriesActivation: 5e3,
    meshFailurePenaltyWeight: -1,
    meshFailurePenaltyDecay: 0.5,
    invalidMessageDeliveriesWeight: -1,
    invalidMessageDeliveriesDecay: 0.3
  };
  function createPeerScoreParams(p = {}) {
    return Object.assign(Object.assign(Object.assign({}, exports2.defaultPeerScoreParams), p), {topics: p.topics ? Object.entries(p.topics).reduce((topics, [topic, topicScoreParams]) => {
      topics[topic] = createTopicScoreParams(topicScoreParams);
      return topics;
    }, {}) : {}});
  }
  exports2.createPeerScoreParams = createPeerScoreParams;
  function createTopicScoreParams(p = {}) {
    return Object.assign(Object.assign({}, exports2.defaultTopicScoreParams), p);
  }
  exports2.createTopicScoreParams = createTopicScoreParams;
  function validatePeerScoreParams(p) {
    for (const [topic, params] of Object.entries(p.topics)) {
      try {
        validateTopicScoreParams(params);
      } catch (e) {
        throw errcode(new Error(`invalid score parameters for topic ${topic}: ${e.message}`), constants_1.ERR_INVALID_PEER_SCORE_PARAMS);
      }
    }
    if (p.topicScoreCap < 0) {
      throw errcode(new Error("invalid topic score cap; must be positive (or 0 for no cap)"), constants_1.ERR_INVALID_PEER_SCORE_PARAMS);
    }
    if (p.appSpecificScore === null || p.appSpecificScore === void 0) {
      throw errcode(new Error("missing application specific score function"), constants_1.ERR_INVALID_PEER_SCORE_PARAMS);
    }
    if (p.IPColocationFactorWeight > 0) {
      throw errcode(new Error("invalid IPColocationFactorWeight; must be negative (or 0 to disable)"), constants_1.ERR_INVALID_PEER_SCORE_PARAMS);
    }
    if (p.IPColocationFactorWeight !== 0 && p.IPColocationFactorThreshold < 1) {
      throw errcode(new Error("invalid IPColocationFactorThreshold; must be at least 1"), constants_1.ERR_INVALID_PEER_SCORE_PARAMS);
    }
    if (p.behaviourPenaltyWeight > 0) {
      throw errcode(new Error("invalid BehaviourPenaltyWeight; must be negative (or 0 to disable)"), constants_1.ERR_INVALID_PEER_SCORE_PARAMS);
    }
    if (p.behaviourPenaltyWeight !== 0 && (p.behaviourPenaltyDecay <= 0 || p.behaviourPenaltyDecay >= 1)) {
      throw errcode(new Error("invalid BehaviourPenaltyDecay; must be between 0 and 1"), constants_1.ERR_INVALID_PEER_SCORE_PARAMS);
    }
    if (p.decayInterval < 1e3) {
      throw errcode(new Error("invalid DecayInterval; must be at least 1s"), constants_1.ERR_INVALID_PEER_SCORE_PARAMS);
    }
    if (p.decayToZero <= 0 || p.decayToZero >= 1) {
      throw errcode(new Error("invalid DecayToZero; must be between 0 and 1"), constants_1.ERR_INVALID_PEER_SCORE_PARAMS);
    }
  }
  exports2.validatePeerScoreParams = validatePeerScoreParams;
  function validateTopicScoreParams(p) {
    if (p.topicWeight < 0) {
      throw errcode(new Error("invalid topic weight; must be >= 0"), constants_1.ERR_INVALID_PEER_SCORE_PARAMS);
    }
    if (p.timeInMeshQuantum === 0) {
      throw errcode(new Error("invalid TimeInMeshQuantum; must be non zero"), constants_1.ERR_INVALID_PEER_SCORE_PARAMS);
    }
    if (p.timeInMeshWeight < 0) {
      throw errcode(new Error("invalid TimeInMeshWeight; must be positive (or 0 to disable)"), constants_1.ERR_INVALID_PEER_SCORE_PARAMS);
    }
    if (p.timeInMeshWeight !== 0 && p.timeInMeshQuantum <= 0) {
      throw errcode(new Error("invalid TimeInMeshQuantum; must be positive"), constants_1.ERR_INVALID_PEER_SCORE_PARAMS);
    }
    if (p.timeInMeshWeight !== 0 && p.timeInMeshCap <= 0) {
      throw errcode(new Error("invalid TimeInMeshCap; must be positive"), constants_1.ERR_INVALID_PEER_SCORE_PARAMS);
    }
    if (p.firstMessageDeliveriesWeight < 0) {
      throw errcode(new Error("invallid FirstMessageDeliveriesWeight; must be positive (or 0 to disable)"), constants_1.ERR_INVALID_PEER_SCORE_PARAMS);
    }
    if (p.firstMessageDeliveriesWeight !== 0 && (p.firstMessageDeliveriesDecay <= 0 || p.firstMessageDeliveriesDecay >= 1)) {
      throw errcode(new Error("invalid FirstMessageDeliveriesDecay; must be between 0 and 1"), constants_1.ERR_INVALID_PEER_SCORE_PARAMS);
    }
    if (p.firstMessageDeliveriesWeight !== 0 && p.firstMessageDeliveriesCap <= 0) {
      throw errcode(new Error("invalid FirstMessageDeliveriesCap; must be positive"), constants_1.ERR_INVALID_PEER_SCORE_PARAMS);
    }
    if (p.meshMessageDeliveriesWeight > 0) {
      throw errcode(new Error("invalid MeshMessageDeliveriesWeight; must be negative (or 0 to disable)"), constants_1.ERR_INVALID_PEER_SCORE_PARAMS);
    }
    if (p.meshMessageDeliveriesWeight !== 0 && (p.meshMessageDeliveriesDecay <= 0 || p.meshMessageDeliveriesDecay >= 1)) {
      throw errcode(new Error("invalid MeshMessageDeliveriesDecay; must be between 0 and 1"), constants_1.ERR_INVALID_PEER_SCORE_PARAMS);
    }
    if (p.meshMessageDeliveriesWeight !== 0 && p.meshMessageDeliveriesCap <= 0) {
      throw errcode(new Error("invalid MeshMessageDeliveriesCap; must be positive"), constants_1.ERR_INVALID_PEER_SCORE_PARAMS);
    }
    if (p.meshMessageDeliveriesWeight !== 0 && p.meshMessageDeliveriesThreshold <= 0) {
      throw errcode(new Error("invalid MeshMessageDeliveriesThreshold; must be positive"), constants_1.ERR_INVALID_PEER_SCORE_PARAMS);
    }
    if (p.meshMessageDeliveriesWindow < 0) {
      throw errcode(new Error("invalid MeshMessageDeliveriesWindow; must be non-negative"), constants_1.ERR_INVALID_PEER_SCORE_PARAMS);
    }
    if (p.meshMessageDeliveriesWeight !== 0 && p.meshMessageDeliveriesActivation < 1e3) {
      throw errcode(new Error("invalid MeshMessageDeliveriesActivation; must be at least 1s"), constants_1.ERR_INVALID_PEER_SCORE_PARAMS);
    }
    if (p.meshFailurePenaltyWeight > 0) {
      throw errcode(new Error("invalid MeshFailurePenaltyWeight; must be negative (or 0 to disable)"), constants_1.ERR_INVALID_PEER_SCORE_PARAMS);
    }
    if (p.meshFailurePenaltyWeight !== 0 && (p.meshFailurePenaltyDecay <= 0 || p.meshFailurePenaltyDecay >= 1)) {
      throw errcode(new Error("invalid MeshFailurePenaltyDecay; must be between 0 and 1"), constants_1.ERR_INVALID_PEER_SCORE_PARAMS);
    }
    if (p.invalidMessageDeliveriesWeight > 0) {
      throw errcode(new Error("invalid InvalidMessageDeliveriesWeight; must be negative (or 0 to disable)"), constants_1.ERR_INVALID_PEER_SCORE_PARAMS);
    }
    if (p.invalidMessageDeliveriesDecay <= 0 || p.invalidMessageDeliveriesDecay >= 1) {
      throw errcode(new Error("invalid InvalidMessageDeliveriesDecay; must be between 0 and 1"), constants_1.ERR_INVALID_PEER_SCORE_PARAMS);
    }
  }
  exports2.validateTopicScoreParams = validateTopicScoreParams;
});

// node_modules/libp2p-gossipsub/src/score/peer-score-thresholds.js
var require_peer_score_thresholds = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.validatePeerScoreThresholds = exports2.createPeerScoreThresholds = exports2.defaultPeerScoreThresholds = void 0;
  var constants_1 = require_constants9();
  var errcode = require_err_code();
  exports2.defaultPeerScoreThresholds = {
    gossipThreshold: -10,
    publishThreshold: -50,
    graylistThreshold: -80,
    acceptPXThreshold: 10,
    opportunisticGraftThreshold: 20
  };
  function createPeerScoreThresholds(p = {}) {
    return Object.assign(Object.assign({}, exports2.defaultPeerScoreThresholds), p);
  }
  exports2.createPeerScoreThresholds = createPeerScoreThresholds;
  function validatePeerScoreThresholds(p) {
    if (p.gossipThreshold > 0) {
      throw errcode(new Error("invalid gossip threshold; it must be <= 0"), constants_1.ERR_INVALID_PEER_SCORE_THRESHOLDS);
    }
    if (p.publishThreshold > 0 || p.publishThreshold > p.gossipThreshold) {
      throw errcode(new Error("invalid publish threshold; it must be <= 0 and <= gossip threshold"), constants_1.ERR_INVALID_PEER_SCORE_THRESHOLDS);
    }
    if (p.graylistThreshold > 0 || p.graylistThreshold > p.publishThreshold) {
      throw errcode(new Error("invalid graylist threshold; it must be <= 0 and <= publish threshold"), constants_1.ERR_INVALID_PEER_SCORE_THRESHOLDS);
    }
    if (p.acceptPXThreshold < 0) {
      throw errcode(new Error("invalid accept PX threshold; it must be >= 0"), constants_1.ERR_INVALID_PEER_SCORE_THRESHOLDS);
    }
    if (p.opportunisticGraftThreshold < 0) {
      throw errcode(new Error("invalid opportunistic grafting threshold; it must be >= 0"), constants_1.ERR_INVALID_PEER_SCORE_THRESHOLDS);
    }
  }
  exports2.validatePeerScoreThresholds = validatePeerScoreThresholds;
});

// node_modules/libp2p-gossipsub/src/score/peer-stats.js
var require_peer_stats = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.ensureTopicStats = exports2.createTopicStats = exports2.createPeerStats = void 0;
  function createPeerStats(ps = {}) {
    return Object.assign(Object.assign({connected: false, expire: 0, ips: [], behaviourPenalty: 0}, ps), {topics: ps.topics ? Object.entries(ps.topics).reduce((topics, [topic, topicStats]) => {
      topics[topic] = createTopicStats(topicStats);
      return topics;
    }, {}) : {}});
  }
  exports2.createPeerStats = createPeerStats;
  function createTopicStats(ts = {}) {
    return Object.assign({inMesh: false, graftTime: 0, meshTime: 0, firstMessageDeliveries: 0, meshMessageDeliveries: 0, meshMessageDeliveriesActive: false, meshFailurePenalty: 0, invalidMessageDeliveries: 0}, ts);
  }
  exports2.createTopicStats = createTopicStats;
  function ensureTopicStats(topic, ps, params) {
    let ts = ps.topics[topic];
    if (ts) {
      return ts;
    }
    if (!params.topics[topic]) {
      return void 0;
    }
    ps.topics[topic] = ts = createTopicStats();
    return ts;
  }
  exports2.ensureTopicStats = ensureTopicStats;
});

// node_modules/libp2p-gossipsub/src/score/compute-score.js
var require_compute_score = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.computeScore = void 0;
  function computeScore(peer, pstats, params, peerIPs) {
    let score = 0;
    Object.entries(pstats.topics).forEach(([topic, tstats]) => {
      const topicParams = params.topics[topic];
      if (!topicParams) {
        return;
      }
      let topicScore = 0;
      if (tstats.inMesh) {
        let p1 = tstats.meshTime / topicParams.timeInMeshQuantum;
        if (p1 > topicParams.timeInMeshCap) {
          p1 = topicParams.timeInMeshCap;
        }
        topicScore += p1 * topicParams.timeInMeshWeight;
      }
      const p2 = tstats.firstMessageDeliveries;
      topicScore += p2 * topicParams.firstMessageDeliveriesWeight;
      if (tstats.meshMessageDeliveriesActive) {
        if (tstats.meshMessageDeliveries < topicParams.meshMessageDeliveriesThreshold) {
          const deficit = topicParams.meshMessageDeliveriesThreshold - tstats.meshMessageDeliveries;
          const p3 = deficit * deficit;
          topicScore += p3 * topicParams.meshMessageDeliveriesWeight;
        }
      }
      const p3b = tstats.meshFailurePenalty;
      topicScore += p3b * topicParams.meshFailurePenaltyWeight;
      const p4 = tstats.invalidMessageDeliveries * tstats.invalidMessageDeliveries;
      topicScore += p4 * topicParams.invalidMessageDeliveriesWeight;
      score += topicScore * topicParams.topicWeight;
    });
    if (params.topicScoreCap > 0 && score > params.topicScoreCap) {
      score = params.topicScoreCap;
    }
    const p5 = params.appSpecificScore(peer);
    score += p5 * params.appSpecificWeight;
    pstats.ips.forEach((ip) => {
      if (params.IPColocationFactorWhitelist.has(ip)) {
        return;
      }
      const peersInIP = peerIPs.get(ip);
      const numPeersInIP = peersInIP ? peersInIP.size : 0;
      if (numPeersInIP > params.IPColocationFactorThreshold) {
        const surplus = numPeersInIP - params.IPColocationFactorThreshold;
        const p6 = surplus * surplus;
        score += p6 * params.IPColocationFactorWeight;
      }
    });
    const p7 = pstats.behaviourPenalty * pstats.behaviourPenalty;
    score += p7 * params.behaviourPenaltyWeight;
    return score;
  }
  exports2.computeScore = computeScore;
});

// node_modules/denque/index.js
var require_denque = __commonJS((exports2, module2) => {
  "use strict";
  function Denque(array, options) {
    var options = options || {};
    this._head = 0;
    this._tail = 0;
    this._capacity = options.capacity;
    this._capacityMask = 3;
    this._list = new Array(4);
    if (Array.isArray(array)) {
      this._fromArray(array);
    }
  }
  Denque.prototype.peekAt = function peekAt(index) {
    var i = index;
    if (i !== (i | 0)) {
      return void 0;
    }
    var len = this.size();
    if (i >= len || i < -len)
      return void 0;
    if (i < 0)
      i += len;
    i = this._head + i & this._capacityMask;
    return this._list[i];
  };
  Denque.prototype.get = function get(i) {
    return this.peekAt(i);
  };
  Denque.prototype.peek = function peek() {
    if (this._head === this._tail)
      return void 0;
    return this._list[this._head];
  };
  Denque.prototype.peekFront = function peekFront() {
    return this.peek();
  };
  Denque.prototype.peekBack = function peekBack() {
    return this.peekAt(-1);
  };
  Object.defineProperty(Denque.prototype, "length", {
    get: function length() {
      return this.size();
    }
  });
  Denque.prototype.size = function size() {
    if (this._head === this._tail)
      return 0;
    if (this._head < this._tail)
      return this._tail - this._head;
    else
      return this._capacityMask + 1 - (this._head - this._tail);
  };
  Denque.prototype.unshift = function unshift(item) {
    if (item === void 0)
      return this.size();
    var len = this._list.length;
    this._head = this._head - 1 + len & this._capacityMask;
    this._list[this._head] = item;
    if (this._tail === this._head)
      this._growArray();
    if (this._capacity && this.size() > this._capacity)
      this.pop();
    if (this._head < this._tail)
      return this._tail - this._head;
    else
      return this._capacityMask + 1 - (this._head - this._tail);
  };
  Denque.prototype.shift = function shift() {
    var head = this._head;
    if (head === this._tail)
      return void 0;
    var item = this._list[head];
    this._list[head] = void 0;
    this._head = head + 1 & this._capacityMask;
    if (head < 2 && this._tail > 1e4 && this._tail <= this._list.length >>> 2)
      this._shrinkArray();
    return item;
  };
  Denque.prototype.push = function push(item) {
    if (item === void 0)
      return this.size();
    var tail = this._tail;
    this._list[tail] = item;
    this._tail = tail + 1 & this._capacityMask;
    if (this._tail === this._head) {
      this._growArray();
    }
    if (this._capacity && this.size() > this._capacity) {
      this.shift();
    }
    if (this._head < this._tail)
      return this._tail - this._head;
    else
      return this._capacityMask + 1 - (this._head - this._tail);
  };
  Denque.prototype.pop = function pop() {
    var tail = this._tail;
    if (tail === this._head)
      return void 0;
    var len = this._list.length;
    this._tail = tail - 1 + len & this._capacityMask;
    var item = this._list[this._tail];
    this._list[this._tail] = void 0;
    if (this._head < 2 && tail > 1e4 && tail <= len >>> 2)
      this._shrinkArray();
    return item;
  };
  Denque.prototype.removeOne = function removeOne(index) {
    var i = index;
    if (i !== (i | 0)) {
      return void 0;
    }
    if (this._head === this._tail)
      return void 0;
    var size = this.size();
    var len = this._list.length;
    if (i >= size || i < -size)
      return void 0;
    if (i < 0)
      i += size;
    i = this._head + i & this._capacityMask;
    var item = this._list[i];
    var k;
    if (index < size / 2) {
      for (k = index; k > 0; k--) {
        this._list[i] = this._list[i = i - 1 + len & this._capacityMask];
      }
      this._list[i] = void 0;
      this._head = this._head + 1 + len & this._capacityMask;
    } else {
      for (k = size - 1 - index; k > 0; k--) {
        this._list[i] = this._list[i = i + 1 + len & this._capacityMask];
      }
      this._list[i] = void 0;
      this._tail = this._tail - 1 + len & this._capacityMask;
    }
    return item;
  };
  Denque.prototype.remove = function remove(index, count) {
    var i = index;
    var removed;
    var del_count = count;
    if (i !== (i | 0)) {
      return void 0;
    }
    if (this._head === this._tail)
      return void 0;
    var size = this.size();
    var len = this._list.length;
    if (i >= size || i < -size || count < 1)
      return void 0;
    if (i < 0)
      i += size;
    if (count === 1 || !count) {
      removed = new Array(1);
      removed[0] = this.removeOne(i);
      return removed;
    }
    if (i === 0 && i + count >= size) {
      removed = this.toArray();
      this.clear();
      return removed;
    }
    if (i + count > size)
      count = size - i;
    var k;
    removed = new Array(count);
    for (k = 0; k < count; k++) {
      removed[k] = this._list[this._head + i + k & this._capacityMask];
    }
    i = this._head + i & this._capacityMask;
    if (index + count === size) {
      this._tail = this._tail - count + len & this._capacityMask;
      for (k = count; k > 0; k--) {
        this._list[i = i + 1 + len & this._capacityMask] = void 0;
      }
      return removed;
    }
    if (index === 0) {
      this._head = this._head + count + len & this._capacityMask;
      for (k = count - 1; k > 0; k--) {
        this._list[i = i + 1 + len & this._capacityMask] = void 0;
      }
      return removed;
    }
    if (i < size / 2) {
      this._head = this._head + index + count + len & this._capacityMask;
      for (k = index; k > 0; k--) {
        this.unshift(this._list[i = i - 1 + len & this._capacityMask]);
      }
      i = this._head - 1 + len & this._capacityMask;
      while (del_count > 0) {
        this._list[i = i - 1 + len & this._capacityMask] = void 0;
        del_count--;
      }
      if (index < 0)
        this._tail = i;
    } else {
      this._tail = i;
      i = i + count + len & this._capacityMask;
      for (k = size - (count + index); k > 0; k--) {
        this.push(this._list[i++]);
      }
      i = this._tail;
      while (del_count > 0) {
        this._list[i = i + 1 + len & this._capacityMask] = void 0;
        del_count--;
      }
    }
    if (this._head < 2 && this._tail > 1e4 && this._tail <= len >>> 2)
      this._shrinkArray();
    return removed;
  };
  Denque.prototype.splice = function splice(index, count) {
    var i = index;
    if (i !== (i | 0)) {
      return void 0;
    }
    var size = this.size();
    if (i < 0)
      i += size;
    if (i > size)
      return void 0;
    if (arguments.length > 2) {
      var k;
      var temp;
      var removed;
      var arg_len = arguments.length;
      var len = this._list.length;
      var arguments_index = 2;
      if (!size || i < size / 2) {
        temp = new Array(i);
        for (k = 0; k < i; k++) {
          temp[k] = this._list[this._head + k & this._capacityMask];
        }
        if (count === 0) {
          removed = [];
          if (i > 0) {
            this._head = this._head + i + len & this._capacityMask;
          }
        } else {
          removed = this.remove(i, count);
          this._head = this._head + i + len & this._capacityMask;
        }
        while (arg_len > arguments_index) {
          this.unshift(arguments[--arg_len]);
        }
        for (k = i; k > 0; k--) {
          this.unshift(temp[k - 1]);
        }
      } else {
        temp = new Array(size - (i + count));
        var leng = temp.length;
        for (k = 0; k < leng; k++) {
          temp[k] = this._list[this._head + i + count + k & this._capacityMask];
        }
        if (count === 0) {
          removed = [];
          if (i != size) {
            this._tail = this._head + i + len & this._capacityMask;
          }
        } else {
          removed = this.remove(i, count);
          this._tail = this._tail - leng + len & this._capacityMask;
        }
        while (arguments_index < arg_len) {
          this.push(arguments[arguments_index++]);
        }
        for (k = 0; k < leng; k++) {
          this.push(temp[k]);
        }
      }
      return removed;
    } else {
      return this.remove(i, count);
    }
  };
  Denque.prototype.clear = function clear() {
    this._head = 0;
    this._tail = 0;
  };
  Denque.prototype.isEmpty = function isEmpty() {
    return this._head === this._tail;
  };
  Denque.prototype.toArray = function toArray() {
    return this._copyArray(false);
  };
  Denque.prototype._fromArray = function _fromArray(array) {
    for (var i = 0; i < array.length; i++)
      this.push(array[i]);
  };
  Denque.prototype._copyArray = function _copyArray(fullCopy) {
    var newArray = [];
    var list = this._list;
    var len = list.length;
    var i;
    if (fullCopy || this._head > this._tail) {
      for (i = this._head; i < len; i++)
        newArray.push(list[i]);
      for (i = 0; i < this._tail; i++)
        newArray.push(list[i]);
    } else {
      for (i = this._head; i < this._tail; i++)
        newArray.push(list[i]);
    }
    return newArray;
  };
  Denque.prototype._growArray = function _growArray() {
    if (this._head) {
      this._list = this._copyArray(true);
      this._head = 0;
    }
    this._tail = this._list.length;
    this._list.length *= 2;
    this._capacityMask = this._capacityMask << 1 | 1;
  };
  Denque.prototype._shrinkArray = function _shrinkArray() {
    this._list.length >>>= 1;
    this._capacityMask >>>= 1;
  };
  module2.exports = Denque;
});

// node_modules/libp2p-gossipsub/src/score/message-deliveries.js
var require_message_deliveries = __commonJS((exports2) => {
  "use strict";
  var __importDefault = exports2 && exports2.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {default: mod};
  };
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.MessageDeliveries = exports2.DeliveryRecordStatus = void 0;
  var constants_1 = require_constants8();
  var denque_1 = __importDefault(require_denque());
  var utils_1 = require_utils24();
  var DeliveryRecordStatus;
  (function(DeliveryRecordStatus2) {
    DeliveryRecordStatus2[DeliveryRecordStatus2["unknown"] = 0] = "unknown";
    DeliveryRecordStatus2[DeliveryRecordStatus2["valid"] = 1] = "valid";
    DeliveryRecordStatus2[DeliveryRecordStatus2["invalid"] = 2] = "invalid";
    DeliveryRecordStatus2[DeliveryRecordStatus2["ignored"] = 3] = "ignored";
  })(DeliveryRecordStatus = exports2.DeliveryRecordStatus || (exports2.DeliveryRecordStatus = {}));
  var MessageDeliveries = class {
    constructor() {
      this.records = new Map();
      this.queue = new denque_1.default();
    }
    ensureRecord(msgId) {
      const msgIdStr = utils_1.messageIdToString(msgId);
      let drec = this.records.get(msgIdStr);
      if (drec) {
        return drec;
      }
      drec = {
        status: DeliveryRecordStatus.unknown,
        firstSeen: Date.now(),
        validated: 0,
        peers: new Set()
      };
      this.records.set(msgIdStr, drec);
      const entry = {
        msgId: msgIdStr,
        expire: Date.now() + constants_1.TimeCacheDuration
      };
      this.queue.push(entry);
      return drec;
    }
    gc() {
      const now = Date.now();
      let head = this.queue.peekFront();
      while (head && head.expire < now) {
        this.records.delete(head.msgId);
        this.queue.shift();
        head = this.queue.peekFront();
      }
    }
    clear() {
      this.records.clear();
      this.queue.clear();
    }
  };
  exports2.MessageDeliveries = MessageDeliveries;
});

// node_modules/libp2p-gossipsub/src/score/peer-score.js
var require_peer_score = __commonJS((exports2) => {
  "use strict";
  var __importDefault = exports2 && exports2.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {default: mod};
  };
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.PeerScore = void 0;
  var peer_score_params_1 = require_peer_score_params();
  var peer_stats_1 = require_peer_stats();
  var compute_score_1 = require_compute_score();
  var message_deliveries_1 = require_message_deliveries();
  var constants_1 = require_constants8();
  var peer_id_1 = __importDefault(require_src9());
  var debug = require_browser4();
  var pubsubErrors = require_errors11();
  var {ERR_INVALID_SIGNATURE, ERR_MISSING_SIGNATURE} = pubsubErrors.codes;
  var log = debug("libp2p:gossipsub:score");
  var PeerScore = class {
    constructor(params, connectionManager, msgId) {
      peer_score_params_1.validatePeerScoreParams(params);
      this.params = params;
      this._connectionManager = connectionManager;
      this.peerStats = new Map();
      this.peerIPs = new Map();
      this.deliveryRecords = new message_deliveries_1.MessageDeliveries();
      this.msgId = msgId;
    }
    start() {
      if (this._backgroundInterval) {
        log("Peer score already running");
        return;
      }
      this._backgroundInterval = setInterval(() => this.background(), this.params.decayInterval);
      log("started");
    }
    stop() {
      if (!this._backgroundInterval) {
        log("Peer score already stopped");
        return;
      }
      clearInterval(this._backgroundInterval);
      delete this._backgroundInterval;
      this.peerIPs.clear();
      this.peerStats.clear();
      this.deliveryRecords.clear();
      log("stopped");
    }
    background() {
      this._refreshScores();
      this._updateIPs();
      this.deliveryRecords.gc();
    }
    _refreshScores() {
      const now = Date.now();
      const decayToZero = this.params.decayToZero;
      this.peerStats.forEach((pstats, id) => {
        if (!pstats.connected) {
          if (now > pstats.expire) {
            this._removeIPs(id, pstats.ips);
            this.peerStats.delete(id);
          }
          return;
        }
        Object.entries(pstats.topics).forEach(([topic, tstats]) => {
          const tparams = this.params.topics[topic];
          if (!tparams) {
            return;
          }
          tstats.firstMessageDeliveries *= tparams.firstMessageDeliveriesDecay;
          if (tstats.firstMessageDeliveries < decayToZero) {
            tstats.firstMessageDeliveries = 0;
          }
          tstats.meshMessageDeliveries *= tparams.meshMessageDeliveriesDecay;
          if (tstats.meshMessageDeliveries < decayToZero) {
            tstats.meshMessageDeliveries = 0;
          }
          tstats.meshFailurePenalty *= tparams.meshFailurePenaltyDecay;
          if (tstats.meshFailurePenalty < decayToZero) {
            tstats.meshFailurePenalty = 0;
          }
          tstats.invalidMessageDeliveries *= tparams.invalidMessageDeliveriesDecay;
          if (tstats.invalidMessageDeliveries < decayToZero) {
            tstats.invalidMessageDeliveries = 0;
          }
          if (tstats.inMesh) {
            tstats.meshTime = now - tstats.graftTime;
            if (tstats.meshTime > tparams.meshMessageDeliveriesActivation) {
              tstats.meshMessageDeliveriesActive = true;
            }
          }
        });
        pstats.behaviourPenalty *= this.params.behaviourPenaltyDecay;
        if (pstats.behaviourPenalty < decayToZero) {
          pstats.behaviourPenalty = 0;
        }
      });
    }
    score(id) {
      const pstats = this.peerStats.get(id);
      if (!pstats) {
        return 0;
      }
      return compute_score_1.computeScore(id, pstats, this.params, this.peerIPs);
    }
    addPenalty(id, penalty) {
      const pstats = this.peerStats.get(id);
      if (!pstats) {
        return;
      }
      pstats.behaviourPenalty += penalty;
    }
    addPeer(id) {
      const pstats = peer_stats_1.createPeerStats({
        connected: true
      });
      this.peerStats.set(id, pstats);
      const ips = this._getIPs(id);
      this._setIPs(id, ips, pstats.ips);
      pstats.ips = ips;
    }
    removePeer(id) {
      const pstats = this.peerStats.get(id);
      if (!pstats) {
        return;
      }
      if (this.score(id) > 0) {
        this._removeIPs(id, pstats.ips);
        this.peerStats.delete(id);
        return;
      }
      Object.entries(pstats.topics).forEach(([topic, tstats]) => {
        tstats.firstMessageDeliveries = 0;
        const threshold = this.params.topics[topic].meshMessageDeliveriesThreshold;
        if (tstats.inMesh && tstats.meshMessageDeliveriesActive && tstats.meshMessageDeliveries < threshold) {
          const deficit = threshold - tstats.meshMessageDeliveries;
          tstats.meshFailurePenalty += deficit * deficit;
        }
        tstats.inMesh = false;
      });
      pstats.connected = false;
      pstats.expire = Date.now() + this.params.retainScore;
    }
    graft(id, topic) {
      const pstats = this.peerStats.get(id);
      if (!pstats) {
        return;
      }
      const tstats = peer_stats_1.ensureTopicStats(topic, pstats, this.params);
      if (!tstats) {
        return;
      }
      tstats.inMesh = true;
      tstats.graftTime = Date.now();
      tstats.meshTime = 0;
      tstats.meshMessageDeliveriesActive = false;
    }
    prune(id, topic) {
      const pstats = this.peerStats.get(id);
      if (!pstats) {
        return;
      }
      const tstats = peer_stats_1.ensureTopicStats(topic, pstats, this.params);
      if (!tstats) {
        return;
      }
      const threshold = this.params.topics[topic].meshMessageDeliveriesThreshold;
      if (tstats.meshMessageDeliveriesActive && tstats.meshMessageDeliveries < threshold) {
        const deficit = threshold - tstats.meshMessageDeliveries;
        tstats.meshFailurePenalty += deficit * deficit;
      }
      tstats.inMesh = false;
    }
    validateMessage(message) {
      this.deliveryRecords.ensureRecord(this.msgId(message));
    }
    deliverMessage(message) {
      const id = message.receivedFrom;
      this._markFirstMessageDelivery(id, message);
      const drec = this.deliveryRecords.ensureRecord(this.msgId(message));
      const now = Date.now();
      if (drec.status !== message_deliveries_1.DeliveryRecordStatus.unknown) {
        log("unexpected delivery: message from %s was first seen %s ago and has delivery status %d", id, now - drec.firstSeen, message_deliveries_1.DeliveryRecordStatus[drec.status]);
        return;
      }
      drec.status = message_deliveries_1.DeliveryRecordStatus.valid;
      drec.validated = now;
      drec.peers.forEach((p) => {
        if (p !== id) {
          this._markDuplicateMessageDelivery(p, message);
        }
      });
    }
    rejectMessage(message, reason) {
      const id = message.receivedFrom;
      switch (reason) {
        case ERR_MISSING_SIGNATURE:
        case ERR_INVALID_SIGNATURE:
          this._markInvalidMessageDelivery(id, message);
          return;
      }
      const drec = this.deliveryRecords.ensureRecord(this.msgId(message));
      if (drec.status !== message_deliveries_1.DeliveryRecordStatus.unknown) {
        log("unexpected rejection: message from %s was first seen %s ago and has delivery status %d", id, Date.now() - drec.firstSeen, message_deliveries_1.DeliveryRecordStatus[drec.status]);
        return;
      }
      switch (reason) {
        case constants_1.ERR_TOPIC_VALIDATOR_IGNORE:
          drec.status = message_deliveries_1.DeliveryRecordStatus.ignored;
          return;
      }
      drec.status = message_deliveries_1.DeliveryRecordStatus.invalid;
      this._markInvalidMessageDelivery(id, message);
      drec.peers.forEach((p) => {
        this._markInvalidMessageDelivery(p, message);
      });
    }
    duplicateMessage(message) {
      const id = message.receivedFrom;
      const drec = this.deliveryRecords.ensureRecord(this.msgId(message));
      if (drec.peers.has(id)) {
        return;
      }
      switch (drec.status) {
        case message_deliveries_1.DeliveryRecordStatus.unknown:
          drec.peers.add(id);
          break;
        case message_deliveries_1.DeliveryRecordStatus.valid:
          drec.peers.add(id);
          this._markDuplicateMessageDelivery(id, message, drec.validated);
          break;
        case message_deliveries_1.DeliveryRecordStatus.invalid:
          this._markInvalidMessageDelivery(id, message);
          break;
      }
    }
    _markInvalidMessageDelivery(id, message) {
      const pstats = this.peerStats.get(id);
      if (!pstats) {
        return;
      }
      message.topicIDs.forEach((topic) => {
        const tstats = peer_stats_1.ensureTopicStats(topic, pstats, this.params);
        if (!tstats) {
          return;
        }
        tstats.invalidMessageDeliveries += 1;
      });
    }
    _markFirstMessageDelivery(id, message) {
      const pstats = this.peerStats.get(id);
      if (!pstats) {
        return;
      }
      message.topicIDs.forEach((topic) => {
        const tstats = peer_stats_1.ensureTopicStats(topic, pstats, this.params);
        if (!tstats) {
          return;
        }
        let cap = this.params.topics[topic].firstMessageDeliveriesCap;
        tstats.firstMessageDeliveries += 1;
        if (tstats.firstMessageDeliveries > cap) {
          tstats.firstMessageDeliveries = cap;
        }
        if (!tstats.inMesh) {
          return;
        }
        cap = this.params.topics[topic].meshMessageDeliveriesCap;
        tstats.meshMessageDeliveries += 1;
        if (tstats.meshMessageDeliveries > cap) {
          tstats.meshMessageDeliveries = cap;
        }
      });
    }
    _markDuplicateMessageDelivery(id, message, validatedTime = 0) {
      const pstats = this.peerStats.get(id);
      if (!pstats) {
        return;
      }
      const now = validatedTime ? Date.now() : 0;
      message.topicIDs.forEach((topic) => {
        const tstats = peer_stats_1.ensureTopicStats(topic, pstats, this.params);
        if (!tstats) {
          return;
        }
        if (!tstats.inMesh) {
          return;
        }
        const tparams = this.params.topics[topic];
        if (validatedTime && now > validatedTime + tparams.meshMessageDeliveriesWindow) {
          return;
        }
        const cap = tparams.meshMessageDeliveriesCap;
        tstats.meshMessageDeliveries += 1;
        if (tstats.meshMessageDeliveries > cap) {
          tstats.meshMessageDeliveries = cap;
        }
      });
    }
    _getIPs(id) {
      return this._connectionManager.getAll(peer_id_1.default.createFromB58String(id)).map((c) => c.remoteAddr.toOptions().host);
    }
    _setIPs(id, newIPs, oldIPs) {
      addNewIPs:
        for (const ip of newIPs) {
          for (const xip of oldIPs) {
            if (ip === xip) {
              continue addNewIPs;
            }
          }
          let peers = this.peerIPs.get(ip);
          if (!peers) {
            peers = new Set();
            this.peerIPs.set(ip, peers);
          }
          peers.add(id);
        }
      removeOldIPs:
        for (const ip of oldIPs) {
          for (const xip of newIPs) {
            if (ip === xip) {
              continue removeOldIPs;
            }
          }
          const peers = this.peerIPs.get(ip);
          if (!peers) {
            continue;
          }
          peers.delete(id);
          if (!peers.size) {
            this.peerIPs.delete(ip);
          }
        }
    }
    _removeIPs(id, ips) {
      ips.forEach((ip) => {
        const peers = this.peerIPs.get(ip);
        if (!peers) {
          return;
        }
        peers.delete(id);
        if (!peers.size) {
          this.peerIPs.delete(ip);
        }
      });
    }
    _updateIPs() {
      this.peerStats.forEach((pstats, id) => {
        const newIPs = this._getIPs(id);
        this._setIPs(id, newIPs, pstats.ips);
        pstats.ips = newIPs;
      });
    }
  };
  exports2.PeerScore = PeerScore;
});

// node_modules/libp2p-gossipsub/src/score/index.js
var require_score = __commonJS((exports2) => {
  "use strict";
  var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    Object.defineProperty(o, k2, {enumerable: true, get: function() {
      return m[k];
    }});
  } : function(o, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
        __createBinding(exports3, m, p);
  };
  Object.defineProperty(exports2, "__esModule", {value: true});
  __exportStar(require_peer_score_params(), exports2);
  __exportStar(require_peer_score_thresholds(), exports2);
  __exportStar(require_peer_score(), exports2);
});

// node_modules/libp2p-gossipsub/src/tracer.js
var require_tracer = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.IWantTracer = void 0;
  var constants_1 = require_constants8();
  var utils_1 = require_utils24();
  var pubsubErrors = require_errors11();
  var {ERR_INVALID_SIGNATURE, ERR_MISSING_SIGNATURE} = pubsubErrors.codes;
  var IWantTracer = class {
    constructor(getMsgId) {
      this.getMsgId = getMsgId;
      this.promises = new Map();
    }
    addPromise(p, msgIds) {
      const ix = Math.floor(Math.random() * msgIds.length);
      const msgId = msgIds[ix];
      const msgIdStr = utils_1.messageIdToString(msgId);
      let peers = this.promises.get(msgIdStr);
      if (!peers) {
        peers = new Map();
        this.promises.set(msgIdStr, peers);
      }
      if (!peers.has(p)) {
        peers.set(p, Date.now() + constants_1.GossipsubIWantFollowupTime);
      }
    }
    getBrokenPromises() {
      const now = Date.now();
      const result = new Map();
      this.promises.forEach((peers, msgId) => {
        peers.forEach((expire, p) => {
          if (expire < now) {
            result.set(p, (result.get(p) || 0) + 1);
            peers.delete(p);
          }
        });
        if (!peers.size) {
          this.promises.delete(msgId);
        }
      });
      return result;
    }
    deliverMessage(msg) {
      const msgId = this.getMsgId(msg);
      const msgIdStr = utils_1.messageIdToString(msgId);
      this.promises.delete(msgIdStr);
    }
    rejectMessage(msg, reason) {
      switch (reason) {
        case ERR_INVALID_SIGNATURE:
        case ERR_MISSING_SIGNATURE:
          return;
      }
      const msgId = this.getMsgId(msg);
      const msgIdStr = utils_1.messageIdToString(msgId);
      this.promises.delete(msgIdStr);
    }
    clear() {
      this.promises.clear();
    }
  };
  exports2.IWantTracer = IWantTracer;
});

// node_modules/lodash.throttle/index.js
var require_lodash = __commonJS((exports2, module2) => {
  var FUNC_ERROR_TEXT = "Expected a function";
  var NAN = 0 / 0;
  var symbolTag = "[object Symbol]";
  var reTrim = /^\s+|\s+$/g;
  var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
  var reIsBinary = /^0b[01]+$/i;
  var reIsOctal = /^0o[0-7]+$/i;
  var freeParseInt = parseInt;
  var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
  var freeSelf = typeof self == "object" && self && self.Object === Object && self;
  var root = freeGlobal || freeSelf || Function("return this")();
  var objectProto = Object.prototype;
  var objectToString = objectProto.toString;
  var nativeMax = Math.max;
  var nativeMin = Math.min;
  var now = function() {
    return root.Date.now();
  };
  function debounce(func, wait, options) {
    var lastArgs, lastThis, maxWait, result, timerId, lastCallTime, lastInvokeTime = 0, leading = false, maxing = false, trailing = true;
    if (typeof func != "function") {
      throw new TypeError(FUNC_ERROR_TEXT);
    }
    wait = toNumber(wait) || 0;
    if (isObject(options)) {
      leading = !!options.leading;
      maxing = "maxWait" in options;
      maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
      trailing = "trailing" in options ? !!options.trailing : trailing;
    }
    function invokeFunc(time) {
      var args = lastArgs, thisArg = lastThis;
      lastArgs = lastThis = void 0;
      lastInvokeTime = time;
      result = func.apply(thisArg, args);
      return result;
    }
    function leadingEdge(time) {
      lastInvokeTime = time;
      timerId = setTimeout(timerExpired, wait);
      return leading ? invokeFunc(time) : result;
    }
    function remainingWait(time) {
      var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime, result2 = wait - timeSinceLastCall;
      return maxing ? nativeMin(result2, maxWait - timeSinceLastInvoke) : result2;
    }
    function shouldInvoke(time) {
      var timeSinceLastCall = time - lastCallTime, timeSinceLastInvoke = time - lastInvokeTime;
      return lastCallTime === void 0 || timeSinceLastCall >= wait || timeSinceLastCall < 0 || maxing && timeSinceLastInvoke >= maxWait;
    }
    function timerExpired() {
      var time = now();
      if (shouldInvoke(time)) {
        return trailingEdge(time);
      }
      timerId = setTimeout(timerExpired, remainingWait(time));
    }
    function trailingEdge(time) {
      timerId = void 0;
      if (trailing && lastArgs) {
        return invokeFunc(time);
      }
      lastArgs = lastThis = void 0;
      return result;
    }
    function cancel() {
      if (timerId !== void 0) {
        clearTimeout(timerId);
      }
      lastInvokeTime = 0;
      lastArgs = lastCallTime = lastThis = timerId = void 0;
    }
    function flush() {
      return timerId === void 0 ? result : trailingEdge(now());
    }
    function debounced() {
      var time = now(), isInvoking = shouldInvoke(time);
      lastArgs = arguments;
      lastThis = this;
      lastCallTime = time;
      if (isInvoking) {
        if (timerId === void 0) {
          return leadingEdge(lastCallTime);
        }
        if (maxing) {
          timerId = setTimeout(timerExpired, wait);
          return invokeFunc(lastCallTime);
        }
      }
      if (timerId === void 0) {
        timerId = setTimeout(timerExpired, wait);
      }
      return result;
    }
    debounced.cancel = cancel;
    debounced.flush = flush;
    return debounced;
  }
  function throttle(func, wait, options) {
    var leading = true, trailing = true;
    if (typeof func != "function") {
      throw new TypeError(FUNC_ERROR_TEXT);
    }
    if (isObject(options)) {
      leading = "leading" in options ? !!options.leading : leading;
      trailing = "trailing" in options ? !!options.trailing : trailing;
    }
    return debounce(func, wait, {
      leading,
      maxWait: wait,
      trailing
    });
  }
  function isObject(value) {
    var type = typeof value;
    return !!value && (type == "object" || type == "function");
  }
  function isObjectLike(value) {
    return !!value && typeof value == "object";
  }
  function isSymbol(value) {
    return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
  }
  function toNumber(value) {
    if (typeof value == "number") {
      return value;
    }
    if (isSymbol(value)) {
      return NAN;
    }
    if (isObject(value)) {
      var other = typeof value.valueOf == "function" ? value.valueOf() : value;
      value = isObject(other) ? other + "" : other;
    }
    if (typeof value != "string") {
      return value === 0 ? value : +value;
    }
    value = value.replace(reTrim, "");
    var isBinary = reIsBinary.test(value);
    return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
  }
  module2.exports = throttle;
});

// node_modules/time-cache/src/index.js
var require_src38 = __commonJS((exports2, module2) => {
  "use strict";
  var throttle = require_lodash();
  exports2 = module2.exports = TimeCache;
  function TimeCache(options) {
    if (!(this instanceof TimeCache)) {
      return new TimeCache(options);
    }
    options = options || {};
    const validity = options.validity || 30;
    const entries = new Map();
    const sweep = throttle(() => {
      entries.forEach((entry, key) => {
        const v = entry.validity || validity;
        const delta = getTimeElapsed(entry.timestamp);
        if (delta > v) {
          entries.delete(key);
        }
      });
    }, 200);
    this.put = (key, value, validity2) => {
      if (!this.has(key)) {
        entries.set(key, {
          value,
          timestamp: new Date(),
          validity: validity2
        });
      }
      sweep();
    };
    this.get = (key) => {
      if (entries.has(key)) {
        return entries.get(key).value;
      } else {
        throw new Error("key does not exist");
      }
    };
    this.has = (key) => {
      return entries.has(key);
    };
  }
  function getTimeElapsed(prevTime) {
    const currentTime = new Date();
    const a = currentTime.getTime() - prevTime.getTime();
    return Math.floor(a / 1e3);
  }
});

// node_modules/libp2p/node_modules/varint/encode.js
var require_encode8 = __commonJS((exports2, module2) => {
  module2.exports = encode;
  var MSB = 128;
  var REST = 127;
  var MSBALL = ~REST;
  var INT = Math.pow(2, 31);
  function encode(num, out, offset) {
    if (Number.MAX_SAFE_INTEGER && num > Number.MAX_SAFE_INTEGER) {
      encode.bytes = 0;
      throw new RangeError("Could not encode varint");
    }
    out = out || [];
    offset = offset || 0;
    var oldOffset = offset;
    while (num >= INT) {
      out[offset++] = num & 255 | MSB;
      num /= 128;
    }
    while (num & MSBALL) {
      out[offset++] = num & 255 | MSB;
      num >>>= 7;
    }
    out[offset] = num | 0;
    encode.bytes = offset - oldOffset + 1;
    return out;
  }
});

// node_modules/libp2p/node_modules/varint/decode.js
var require_decode8 = __commonJS((exports2, module2) => {
  module2.exports = read;
  var MSB = 128;
  var REST = 127;
  function read(buf, offset) {
    var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf.length;
    do {
      if (counter >= l || shift > 49) {
        read.bytes = 0;
        throw new RangeError("Could not decode varint");
      }
      b = buf[counter++];
      res += shift < 28 ? (b & REST) << shift : (b & REST) * Math.pow(2, shift);
      shift += 7;
    } while (b >= MSB);
    read.bytes = counter - offset;
    return res;
  }
});

// node_modules/libp2p/node_modules/varint/length.js
var require_length5 = __commonJS((exports2, module2) => {
  var N1 = Math.pow(2, 7);
  var N2 = Math.pow(2, 14);
  var N3 = Math.pow(2, 21);
  var N4 = Math.pow(2, 28);
  var N5 = Math.pow(2, 35);
  var N6 = Math.pow(2, 42);
  var N7 = Math.pow(2, 49);
  var N8 = Math.pow(2, 56);
  var N9 = Math.pow(2, 63);
  module2.exports = function(value) {
    return value < N1 ? 1 : value < N2 ? 2 : value < N3 ? 3 : value < N4 ? 4 : value < N5 ? 5 : value < N6 ? 6 : value < N7 ? 7 : value < N8 ? 8 : value < N9 ? 9 : 10;
  };
});

// node_modules/libp2p/node_modules/varint/index.js
var require_varint6 = __commonJS((exports2, module2) => {
  module2.exports = {
    encode: require_encode8(),
    decode: require_decode8(),
    encodingLength: require_length5()
  };
});

// node_modules/libp2p/src/errors.js
var require_errors12 = __commonJS((exports2) => {
  "use strict";
  exports2.messages = {
    NOT_STARTED_YET: "The libp2p node is not started yet",
    DHT_DISABLED: "DHT is not available",
    CONN_ENCRYPTION_REQUIRED: "At least one connection encryption module is required"
  };
  exports2.codes = {
    DHT_DISABLED: "ERR_DHT_DISABLED",
    PUBSUB_NOT_STARTED: "ERR_PUBSUB_NOT_STARTED",
    DHT_NOT_STARTED: "ERR_DHT_NOT_STARTED",
    CONN_ENCRYPTION_REQUIRED: "ERR_CONN_ENCRYPTION_REQUIRED",
    ERR_CONNECTION_ENDED: "ERR_CONNECTION_ENDED",
    ERR_CONNECTION_FAILED: "ERR_CONNECTION_FAILED",
    ERR_NODE_NOT_STARTED: "ERR_NODE_NOT_STARTED",
    ERR_ALREADY_ABORTED: "ERR_ALREADY_ABORTED",
    ERR_NO_VALID_ADDRESSES: "ERR_NO_VALID_ADDRESSES",
    ERR_DIALED_SELF: "ERR_DIALED_SELF",
    ERR_DISCOVERED_SELF: "ERR_DISCOVERED_SELF",
    ERR_DUPLICATE_TRANSPORT: "ERR_DUPLICATE_TRANSPORT",
    ERR_ENCRYPTION_FAILED: "ERR_ENCRYPTION_FAILED",
    ERR_HOP_REQUEST_FAILED: "ERR_HOP_REQUEST_FAILED",
    ERR_INVALID_KEY: "ERR_INVALID_KEY",
    ERR_INVALID_MESSAGE: "ERR_INVALID_MESSAGE",
    ERR_INVALID_PARAMETERS: "ERR_INVALID_PARAMETERS",
    ERR_INVALID_PEER: "ERR_INVALID_PEER",
    ERR_MUXER_UNAVAILABLE: "ERR_MUXER_UNAVAILABLE",
    ERR_TIMEOUT: "ERR_TIMEOUT",
    ERR_TRANSPORT_UNAVAILABLE: "ERR_TRANSPORT_UNAVAILABLE",
    ERR_TRANSPORT_DIAL_FAILED: "ERR_TRANSPORT_DIAL_FAILED",
    ERR_UNSUPPORTED_PROTOCOL: "ERR_UNSUPPORTED_PROTOCOL",
    ERR_INVALID_MULTIADDR: "ERR_INVALID_MULTIADDR",
    ERR_SIGNATURE_NOT_VALID: "ERR_SIGNATURE_NOT_VALID"
  };
});

// node_modules/libp2p/src/record/envelope/envelope.proto.js
var require_envelope_proto = __commonJS((exports2, module2) => {
  "use strict";
  var protons = require_src8();
  module2.exports = protons(`
message Envelope {
  // public_key is the public key of the keypair the enclosed payload was
  // signed with.
  bytes public_key = 1;

  // payload_type encodes the type of payload, so that it can be deserialized
  // deterministically.
  bytes payload_type = 2;

  // payload is the actual payload carried inside this envelope.
  bytes payload = 3;

  // signature is the signature produced by the private key corresponding to
  // the enclosed public key, over the payload, prefixing a domain string for
  // additional security.
  bytes signature = 5;
}
`);
});

// node_modules/libp2p/src/record/envelope/index.js
var require_envelope = __commonJS((exports2, module2) => {
  "use strict";
  var errCode = require_err_code();
  var uint8arraysConcat = require_concat2();
  var uint8arraysFromString = require_from_string2();
  var cryptoKeys = require_keys();
  var PeerId = require_src9();
  var varint = require_varint6();
  var uint8arraysEquals = require_equals2();
  var {codes} = require_errors12();
  var Protobuf = require_envelope_proto();
  var Envelope = class {
    constructor({peerId, payloadType, payload, signature}) {
      this.peerId = peerId;
      this.payloadType = payloadType;
      this.payload = payload;
      this.signature = signature;
      this._marshal = void 0;
    }
    marshal() {
      if (this._marshal) {
        return this._marshal;
      }
      const publicKey = cryptoKeys.marshalPublicKey(this.peerId.pubKey);
      this._marshal = Protobuf.Envelope.encode({
        public_key: publicKey,
        payload_type: this.payloadType,
        payload: this.payload,
        signature: this.signature
      });
      return this._marshal;
    }
    equals(other) {
      return uint8arraysEquals(this.peerId.pubKey.bytes, other.peerId.pubKey.bytes) && uint8arraysEquals(this.payloadType, other.payloadType) && uint8arraysEquals(this.payload, other.payload) && uint8arraysEquals(this.signature, other.signature);
    }
    validate(domain) {
      const signData = formatSignaturePayload(domain, this.payloadType, this.payload);
      return this.peerId.pubKey.verify(signData, this.signature);
    }
  };
  var formatSignaturePayload = (domain, payloadType, payload) => {
    const domainUint8Array = uint8arraysFromString(domain);
    const domainLength = varint.encode(domainUint8Array.byteLength);
    const payloadTypeLength = varint.encode(payloadType.length);
    const payloadLength = varint.encode(payload.length);
    return uint8arraysConcat([
      new Uint8Array(domainLength),
      domainUint8Array,
      new Uint8Array(payloadTypeLength),
      payloadType,
      new Uint8Array(payloadLength),
      payload
    ]);
  };
  Envelope.createFromProtobuf = async (data) => {
    const envelopeData = Protobuf.Envelope.decode(data);
    const peerId = await PeerId.createFromPubKey(envelopeData.public_key);
    return new Envelope({
      peerId,
      payloadType: envelopeData.payload_type,
      payload: envelopeData.payload,
      signature: envelopeData.signature
    });
  };
  Envelope.seal = async (record, peerId) => {
    const domain = record.domain;
    const payloadType = record.codec;
    const payload = record.marshal();
    const signData = formatSignaturePayload(domain, payloadType, payload);
    const signature = await peerId.privKey.sign(signData);
    return new Envelope({
      peerId,
      payloadType,
      payload,
      signature
    });
  };
  Envelope.openAndCertify = async (data, domain) => {
    const envelope = await Envelope.createFromProtobuf(data);
    const valid = await envelope.validate(domain);
    if (!valid) {
      throw errCode(new Error("envelope signature is not valid for the given domain"), codes.ERR_SIGNATURE_NOT_VALID);
    }
    return envelope;
  };
  module2.exports = Envelope;
});

// node_modules/libp2p-gossipsub/src/index.js
var require_src39 = __commonJS((exports2, module2) => {
  "use strict";
  var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    Object.defineProperty(o, k2, {enumerable: true, get: function() {
      return m[k];
    }});
  } : function(o, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", {enumerable: true, value: v});
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports2 && exports2.__importStar || function(mod) {
    if (mod && mod.__esModule)
      return mod;
    var result = {};
    if (mod != null) {
      for (var k in mod)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k))
          __createBinding(result, mod, k);
    }
    __setModuleDefault(result, mod);
    return result;
  };
  var __awaiter = exports2 && exports2.__awaiter || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P ? value : new P(function(resolve) {
        resolve(value);
      });
    }
    return new (P || (P = Promise))(function(resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
  var pubsub_1 = __importStar(require_pubsub2());
  var message_cache_1 = require_message_cache();
  var message_1 = require_message2();
  var constants = __importStar(require_constants8());
  var heartbeat_1 = require_heartbeat();
  var get_gossip_peers_1 = require_get_gossip_peers();
  var utils_1 = require_utils24();
  var score_1 = require_score();
  var tracer_1 = require_tracer();
  var TimeCache = require_src38();
  var PeerId = require_src9();
  var Envelope = require_envelope();
  var Gossipsub = class extends pubsub_1.default {
    constructor(libp2p, options = {}) {
      const multicodecs = [constants.GossipsubIDv11, constants.GossipsubIDv10];
      const opts = Object.assign(Object.assign({gossipIncoming: true, fallbackToFloodsub: true, floodPublish: true, doPX: false, directPeers: [], D: constants.GossipsubD, Dlo: constants.GossipsubDlo, Dhi: constants.GossipsubDhi, Dscore: constants.GossipsubDscore, Dout: constants.GossipsubDout, Dlazy: constants.GossipsubDlazy}, options), {scoreParams: score_1.createPeerScoreParams(options.scoreParams), scoreThresholds: score_1.createPeerScoreThresholds(options.scoreThresholds)});
      if (opts.fallbackToFloodsub) {
        multicodecs.push(constants.FloodsubID);
      }
      super(Object.assign({
        debugName: "libp2p:gossipsub",
        multicodecs,
        libp2p
      }, opts));
      this._options = opts;
      this.direct = new Set(opts.directPeers.map((p) => p.id.toB58String()));
      opts.directPeers.forEach((p) => {
        libp2p.peerStore.addressBook.add(p.id, p.addrs);
      });
      this.seenCache = new TimeCache();
      this.mesh = new Map();
      this.fanout = new Map();
      this.lastpub = new Map();
      this.gossip = new Map();
      this.control = new Map();
      this.peerhave = new Map();
      this.iasked = new Map();
      this.backoff = new Map();
      this.outbound = new Map();
      this.messageCache = options.messageCache || new message_cache_1.MessageCache(constants.GossipsubHistoryGossip, constants.GossipsubHistoryLength, this.getMsgId.bind(this));
      this.heartbeat = new heartbeat_1.Heartbeat(this);
      this.heartbeatTicks = 0;
      this.gossipTracer = new tracer_1.IWantTracer(this.getMsgId.bind(this));
      this._libp2p = libp2p;
      this.score = new score_1.PeerScore(this._options.scoreParams, libp2p.connectionManager, this.getMsgId.bind(this));
    }
    _decodeRpc(bytes) {
      return message_1.RPCCodec.decode(bytes);
    }
    _encodeRpc(rpc) {
      return message_1.RPCCodec.encode(rpc);
    }
    _addPeer(peerId, protocol) {
      const p = super._addPeer(peerId, protocol);
      this.score.addPeer(peerId.toB58String());
      let outbound = false;
      for (const c of this._libp2p.connectionManager.getAll(peerId)) {
        if (c.stat.direction === "outbound") {
          if (Array.from(c.registry.values()).some((rvalue) => protocol === rvalue.protocol)) {
            outbound = true;
            break;
          }
        }
      }
      this.outbound.set(p.id.toB58String(), outbound);
      return p;
    }
    _removePeer(peerId) {
      const peerStreams = super._removePeer(peerId);
      const id = peerId.toB58String();
      for (const peers of this.mesh.values()) {
        peers.delete(id);
      }
      for (const peers of this.fanout.values()) {
        peers.delete(id);
      }
      this.gossip.delete(id);
      this.control.delete(id);
      this.outbound.delete(id);
      this.score.removePeer(id);
      return peerStreams;
    }
    _processRpc(id, peerStreams, rpc) {
      if (super._processRpc(id, peerStreams, rpc)) {
        if (rpc.control) {
          this._processRpcControlMessage(id, rpc.control);
        }
        return true;
      }
      return false;
    }
    _processRpcControlMessage(id, controlMsg) {
      if (!controlMsg) {
        return;
      }
      const iwant = this._handleIHave(id, controlMsg.ihave);
      const ihave = this._handleIWant(id, controlMsg.iwant);
      const prune = this._handleGraft(id, controlMsg.graft);
      this._handlePrune(id, controlMsg.prune);
      if (!iwant.length && !ihave.length && !prune.length) {
        return;
      }
      const outRpc = utils_1.createGossipRpc(ihave, {iwant, prune});
      this._sendRpc(id, outRpc);
    }
    _processRpcMessage(msg) {
      const _super = Object.create(null, {
        _processRpcMessage: {get: () => super._processRpcMessage}
      });
      return __awaiter(this, void 0, void 0, function* () {
        const msgID = this.getMsgId(msg);
        const msgIdStr = utils_1.messageIdToString(msgID);
        if (this.seenCache.has(msgIdStr)) {
          this.score.duplicateMessage(msg);
          return;
        }
        this.seenCache.put(msgIdStr);
        this.score.validateMessage(msg);
        yield _super._processRpcMessage.call(this, msg);
      });
    }
    _acceptFrom(id) {
      return this.direct.has(id) || this.score.score(id) >= this._options.scoreThresholds.graylistThreshold;
    }
    validate(message) {
      const _super = Object.create(null, {
        validate: {get: () => super.validate}
      });
      return __awaiter(this, void 0, void 0, function* () {
        try {
          yield _super.validate.call(this, message);
        } catch (e) {
          this.score.rejectMessage(message, e.code);
          this.gossipTracer.rejectMessage(message, e.code);
          throw e;
        }
      });
    }
    _handleIHave(id, ihave) {
      if (!ihave.length) {
        return [];
      }
      const score = this.score.score(id);
      if (score < this._options.scoreThresholds.gossipThreshold) {
        this.log("IHAVE: ignoring peer %s with score below threshold [ score = %d ]", id, score);
        return [];
      }
      const peerhave = (this.peerhave.get(id) || 0) + 1;
      this.peerhave.set(id, peerhave);
      if (peerhave > constants.GossipsubMaxIHaveMessages) {
        this.log("IHAVE: peer %s has advertised too many times (%d) within this heartbeat interval; ignoring", id, peerhave);
        return [];
      }
      const iasked = this.iasked.get(id) || 0;
      if (iasked >= constants.GossipsubMaxIHaveLength) {
        this.log("IHAVE: peer %s has already advertised too many messages (%d); ignoring", id, iasked);
        return [];
      }
      const iwant = new Map();
      ihave.forEach(({topicID, messageIDs}) => {
        if (!topicID || !this.mesh.has(topicID)) {
          return;
        }
        messageIDs.forEach((msgID) => {
          const msgIdStr = utils_1.messageIdToString(msgID);
          if (this.seenCache.has(msgIdStr)) {
            return;
          }
          iwant.set(msgIdStr, msgID);
        });
      });
      if (!iwant.size) {
        return [];
      }
      let iask = iwant.size;
      if (iask + iasked > constants.GossipsubMaxIHaveLength) {
        iask = constants.GossipsubMaxIHaveLength - iasked;
      }
      this.log("IHAVE: Asking for %d out of %d messages from %s", iask, iwant.size, id);
      let iwantList = Array.from(iwant.values());
      utils_1.shuffle(iwantList);
      iwantList = iwantList.slice(0, iask);
      this.iasked.set(id, iasked + iask);
      this.gossipTracer.addPromise(id, iwantList);
      return [{
        messageIDs: iwantList
      }];
    }
    _handleIWant(id, iwant) {
      if (!iwant.length) {
        return [];
      }
      const score = this.score.score(id);
      if (score < this._options.scoreThresholds.gossipThreshold) {
        this.log("IWANT: ignoring peer %s with score below threshold [score = %d]", id, score);
        return [];
      }
      const ihave = new Map();
      iwant.forEach(({messageIDs}) => {
        messageIDs.forEach((msgID) => {
          const [msg, count] = this.messageCache.getForPeer(msgID, id);
          if (!msg) {
            return;
          }
          if (count > constants.GossipsubGossipRetransmission) {
            this.log("IWANT: Peer %s has asked for message %s too many times: ignoring request", id, msgID);
            return;
          }
          ihave.set(utils_1.messageIdToString(msgID), msg);
        });
      });
      if (!ihave.size) {
        return [];
      }
      this.log("IWANT: Sending %d messages to %s", ihave.size, id);
      return Array.from(ihave.values()).map(pubsub_1.utils.normalizeOutRpcMessage);
    }
    _handleGraft(id, graft) {
      const prune = [];
      const score = this.score.score(id);
      const now = this._now();
      let doPX = this._options.doPX;
      graft.forEach(({topicID}) => {
        var _a;
        if (!topicID) {
          return;
        }
        const peersInMesh = this.mesh.get(topicID);
        if (!peersInMesh) {
          doPX = false;
          return;
        }
        if (peersInMesh.has(id)) {
          return;
        }
        if (this.direct.has(id)) {
          this.log("GRAFT: ignoring request from direct peer %s", id);
          prune.push(topicID);
          doPX = false;
          return;
        }
        const expire = (_a = this.backoff.get(topicID)) === null || _a === void 0 ? void 0 : _a.get(id);
        if (typeof expire === "number" && now < expire) {
          this.log("GRAFT: ignoring backed off peer %s", id);
          this.score.addPenalty(id, 1);
          doPX = false;
          const floodCutoff = expire + constants.GossipsubGraftFloodThreshold - constants.GossipsubPruneBackoff;
          if (now < floodCutoff) {
            this.score.addPenalty(id, 1);
          }
          this._addBackoff(id, topicID);
          prune.push(topicID);
          return;
        }
        if (score < 0) {
          this.log("GRAFT: ignoring peer %s with negative score: score=%d, topic=%s", id, score, topicID);
          prune.push(topicID);
          doPX = false;
          this._addBackoff(id, topicID);
          return;
        }
        if (peersInMesh.size >= this._options.Dhi && !this.outbound.get(id)) {
          prune.push(topicID);
          this._addBackoff(id, topicID);
          return;
        }
        this.log("GRAFT: Add mesh link from %s in %s", id, topicID);
        this.score.graft(id, topicID);
        peersInMesh.add(id);
      });
      if (!prune.length) {
        return [];
      }
      return prune.map((topic) => this._makePrune(id, topic, doPX));
    }
    _handlePrune(id, prune) {
      const score = this.score.score(id);
      prune.forEach(({topicID, backoff, peers}) => {
        if (!topicID) {
          return;
        }
        const peersInMesh = this.mesh.get(topicID);
        if (!peersInMesh) {
          return;
        }
        this.log("PRUNE: Remove mesh link to %s in %s", id, topicID);
        this.score.prune(id, topicID);
        peersInMesh.delete(id);
        if (typeof backoff === "number" && backoff > 0) {
          this._doAddBackoff(id, topicID, backoff * 1e3);
        } else {
          this._addBackoff(id, topicID);
        }
        if (peers && peers.length) {
          if (score < this._options.scoreThresholds.acceptPXThreshold) {
            this.log("PRUNE: ignoring PX from peer %s with insufficient score [score = %d, topic = %s]", id, score, topicID);
            return;
          }
          this._pxConnect(peers);
        }
      });
    }
    _addBackoff(id, topic) {
      this._doAddBackoff(id, topic, constants.GossipsubPruneBackoff);
    }
    _doAddBackoff(id, topic, interval) {
      let backoff = this.backoff.get(topic);
      if (!backoff) {
        backoff = new Map();
        this.backoff.set(topic, backoff);
      }
      const expire = this._now() + interval;
      const existingExpire = backoff.get(id) || 0;
      if (existingExpire < expire) {
        backoff.set(id, expire);
      }
    }
    _applyIwantPenalties() {
      this.gossipTracer.getBrokenPromises().forEach((count, p) => {
        this.log("peer %s didn't follow up in %d IWANT requests; adding penalty", p, count);
        this.score.addPenalty(p, count);
      });
    }
    _clearBackoff() {
      if (this.heartbeatTicks % constants.GossipsubPruneBackoffTicks !== 0) {
        return;
      }
      const now = this._now();
      this.backoff.forEach((backoff, topic) => {
        backoff.forEach((expire, id) => {
          if (expire < now) {
            backoff.delete(id);
          }
        });
        if (backoff.size === 0) {
          this.backoff.delete(topic);
        }
      });
    }
    _directConnect() {
      if (this.heartbeatTicks % constants.GossipsubDirectConnectTicks !== 0) {
        return;
      }
      const toconnect = [];
      this.direct.forEach((id) => {
        const peer = this.peers.get(id);
        if (!peer || !peer.isWritable) {
          toconnect.push(id);
        }
      });
      if (toconnect.length) {
        toconnect.forEach((id) => {
          this._connect(id);
        });
      }
    }
    _pxConnect(peers) {
      return __awaiter(this, void 0, void 0, function* () {
        if (peers.length > constants.GossipsubPrunePeers) {
          utils_1.shuffle(peers);
          peers = peers.slice(0, constants.GossipsubPrunePeers);
        }
        const toconnect = [];
        yield Promise.all(peers.map((pi) => __awaiter(this, void 0, void 0, function* () {
          if (!pi.peerID) {
            return;
          }
          const p = PeerId.createFromBytes(pi.peerID);
          const id = p.toB58String();
          if (this.peers.has(id)) {
            return;
          }
          if (!pi.signedPeerRecord) {
            toconnect.push(id);
            return;
          }
          try {
            const envelope = yield Envelope.openAndCertify(pi.signedPeerRecord, "libp2p-peer-record");
            const eid = envelope.peerId.toB58String();
            if (id !== eid) {
              this.log("bogus peer record obtained through px: peer ID %s doesn't match expected peer %s", eid, id);
              return;
            }
            if (!this._libp2p.peerStore.addressBook.consumePeerRecord(envelope)) {
              this.log("bogus peer record obtained through px: could not add peer record to address book");
              return;
            }
            toconnect.push(id);
          } catch (e) {
            this.log("bogus peer record obtained through px: invalid signature or not a peer record");
          }
        })));
        if (!toconnect.length) {
          return;
        }
        toconnect.forEach((id) => this._connect(id));
      });
    }
    start() {
      super.start();
      this.heartbeat.start();
      this.score.start();
      this._directPeerInitial = setTimeout(() => {
        this.direct.forEach((id) => {
          this._connect(id);
        });
      }, constants.GossipsubDirectConnectInitialDelay);
    }
    stop() {
      super.stop();
      this.heartbeat.stop();
      this.score.stop();
      this.mesh = new Map();
      this.fanout = new Map();
      this.lastpub = new Map();
      this.gossip = new Map();
      this.control = new Map();
      this.peerhave = new Map();
      this.iasked = new Map();
      this.backoff = new Map();
      this.outbound = new Map();
      this.gossipTracer.clear();
      clearTimeout(this._directPeerInitial);
    }
    _connect(id) {
      this.log("Initiating connection with %s", id);
      this._libp2p.dialProtocol(PeerId.createFromB58String(id), this.multicodecs);
    }
    subscribe(topic) {
      super.subscribe(topic);
      this.join(topic);
    }
    unsubscribe(topic) {
      super.unsubscribe(topic);
      this.leave(topic);
    }
    join(topic) {
      if (!this.started) {
        throw new Error("Gossipsub has not started");
      }
      this.log("JOIN %s", topic);
      const fanoutPeers = this.fanout.get(topic);
      if (fanoutPeers) {
        fanoutPeers.forEach((id) => {
          if (this.score.score(id) < 0) {
            fanoutPeers.delete(id);
          }
        });
        if (fanoutPeers.size < this._options.D) {
          get_gossip_peers_1.getGossipPeers(this, topic, this._options.D - fanoutPeers.size, (id) => {
            return !fanoutPeers.has(id) && !this.direct.has(id) && this.score.score(id) >= 0;
          }).forEach((id) => fanoutPeers.add(id));
        }
        this.mesh.set(topic, fanoutPeers);
        this.fanout.delete(topic);
        this.lastpub.delete(topic);
      } else {
        const peers = get_gossip_peers_1.getGossipPeers(this, topic, this._options.D, (id) => {
          return !this.direct.has(id) && this.score.score(id) >= 0;
        });
        this.mesh.set(topic, peers);
      }
      this.mesh.get(topic).forEach((id) => {
        this.log("JOIN: Add mesh link to %s in %s", id, topic);
        this._sendGraft(id, topic);
      });
    }
    leave(topic) {
      if (!this.started) {
        throw new Error("Gossipsub has not started");
      }
      this.log("LEAVE %s", topic);
      const meshPeers = this.mesh.get(topic);
      if (meshPeers) {
        meshPeers.forEach((id) => {
          this.log("LEAVE: Remove mesh link to %s in %s", id, topic);
          this._sendPrune(id, topic);
        });
        this.mesh.delete(topic);
      }
    }
    _publish(msg) {
      return __awaiter(this, void 0, void 0, function* () {
        if (msg.receivedFrom !== this.peerId.toB58String()) {
          this.score.deliverMessage(msg);
          this.gossipTracer.deliverMessage(msg);
        }
        const msgID = this.getMsgId(msg);
        const msgIdStr = utils_1.messageIdToString(msgID);
        this.seenCache.put(msgIdStr);
        this.messageCache.put(msg);
        const tosend = new Set();
        msg.topicIDs.forEach((topic) => {
          const peersInTopic = this.topics.get(topic);
          if (!peersInTopic) {
            return;
          }
          if (this._options.floodPublish && msg.from === this.peerId.toB58String()) {
            peersInTopic.forEach((id) => {
              if (this.direct.has(id) || this.score.score(id) >= this._options.scoreThresholds.publishThreshold) {
                tosend.add(id);
              }
            });
          } else {
            this.direct.forEach((id) => {
              tosend.add(id);
            });
            peersInTopic.forEach((id) => {
              const score = this.score.score(id);
              const peerStreams = this.peers.get(id);
              if (!peerStreams) {
                return;
              }
              if (peerStreams.protocol === constants.FloodsubID && score >= this._options.scoreThresholds.publishThreshold) {
                tosend.add(id);
              }
            });
            let meshPeers = this.mesh.get(topic);
            if (!meshPeers || !meshPeers.size) {
              meshPeers = this.fanout.get(topic);
              if (!meshPeers) {
                const peers = get_gossip_peers_1.getGossipPeers(this, topic, this._options.D, (id) => {
                  return this.score.score(id) >= this._options.scoreThresholds.publishThreshold;
                });
                if (peers.size > 0) {
                  meshPeers = peers;
                  this.fanout.set(topic, peers);
                } else {
                  meshPeers = new Set();
                }
              }
              this.lastpub.set(topic, this._now());
            }
            meshPeers.forEach((peer) => {
              tosend.add(peer);
            });
          }
        });
        const rpc = utils_1.createGossipRpc([
          pubsub_1.utils.normalizeOutRpcMessage(msg)
        ]);
        tosend.forEach((id) => {
          if (id === msg.from) {
            return;
          }
          this._sendRpc(id, rpc);
        });
      });
    }
    _sendGraft(id, topic) {
      const graft = [{
        topicID: topic
      }];
      const out = utils_1.createGossipRpc([], {graft});
      this._sendRpc(id, out);
    }
    _sendPrune(id, topic) {
      const prune = [
        this._makePrune(id, topic, this._options.doPX)
      ];
      const out = utils_1.createGossipRpc([], {prune});
      this._sendRpc(id, out);
    }
    _sendRpc(id, outRpc) {
      const peerStreams = this.peers.get(id);
      if (!peerStreams || !peerStreams.isWritable) {
        return;
      }
      const ctrl = this.control.get(id);
      if (ctrl) {
        this._piggybackControl(id, outRpc, ctrl);
        this.control.delete(id);
      }
      const ihave = this.gossip.get(id);
      if (ihave) {
        this._piggybackGossip(id, outRpc, ihave);
        this.gossip.delete(id);
      }
      peerStreams.write(message_1.RPCCodec.encode(outRpc));
    }
    _piggybackControl(id, outRpc, ctrl) {
      const tograft = (ctrl.graft || []).filter(({topicID}) => (topicID && this.mesh.get(topicID) || new Set()).has(id));
      const toprune = (ctrl.prune || []).filter(({topicID}) => !(topicID && this.mesh.get(topicID) || new Set()).has(id));
      if (!tograft.length && !toprune.length) {
        return;
      }
      if (outRpc.control) {
        outRpc.control.graft = outRpc.control.graft.concat(tograft);
        outRpc.control.prune = outRpc.control.prune.concat(toprune);
      } else {
        outRpc.control = {ihave: [], iwant: [], graft: tograft, prune: toprune};
      }
    }
    _piggybackGossip(id, outRpc, ihave) {
      if (!outRpc.control) {
        outRpc.control = {ihave: [], iwant: [], graft: [], prune: []};
      }
      outRpc.control.ihave = ihave;
    }
    _sendGraftPrune(tograft, toprune, noPX) {
      const doPX = this._options.doPX;
      for (const [id, topics] of tograft) {
        const graft = topics.map((topicID) => ({topicID}));
        let prune = [];
        const pruning = toprune.get(id);
        if (pruning) {
          prune = pruning.map((topicID) => this._makePrune(id, topicID, doPX && !noPX.get(id)));
          toprune.delete(id);
        }
        const outRpc = utils_1.createGossipRpc([], {graft, prune});
        this._sendRpc(id, outRpc);
      }
      for (const [id, topics] of toprune) {
        const prune = topics.map((topicID) => this._makePrune(id, topicID, doPX && !noPX.get(id)));
        const outRpc = utils_1.createGossipRpc([], {prune});
        this._sendRpc(id, outRpc);
      }
    }
    _emitGossip(topic, exclude) {
      const messageIDs = this.messageCache.getGossipIDs(topic);
      if (!messageIDs.length) {
        return;
      }
      utils_1.shuffle(messageIDs);
      if (messageIDs.length > constants.GossipsubMaxIHaveLength) {
        this.log("too many messages for gossip; will truncate IHAVE list (%d messages)", messageIDs.length);
      }
      const peersToGossip = [];
      const topicPeers = this.topics.get(topic);
      if (!topicPeers) {
        return;
      }
      topicPeers.forEach((id) => {
        const peerStreams = this.peers.get(id);
        if (!peerStreams) {
          return;
        }
        if (!exclude.has(id) && !this.direct.has(id) && utils_1.hasGossipProtocol(peerStreams.protocol) && this.score.score(id) >= this._options.scoreThresholds.gossipThreshold) {
          peersToGossip.push(id);
        }
      });
      let target = this._options.Dlazy;
      const factor = constants.GossipsubGossipFactor * peersToGossip.length;
      if (factor > target) {
        target = factor;
      }
      if (target > peersToGossip.length) {
        target = peersToGossip.length;
      } else {
        utils_1.shuffle(peersToGossip);
      }
      peersToGossip.slice(0, target).forEach((id) => {
        let peerMessageIDs = messageIDs;
        if (messageIDs.length > constants.GossipsubMaxIHaveLength) {
          peerMessageIDs = utils_1.shuffle(peerMessageIDs.slice()).slice(0, constants.GossipsubMaxIHaveLength);
        }
        this._pushGossip(id, {
          topicID: topic,
          messageIDs: peerMessageIDs
        });
      });
    }
    _flush() {
      for (const [peer, ihave] of this.gossip.entries()) {
        this.gossip.delete(peer);
        const out = utils_1.createGossipRpc([], {ihave});
        this._sendRpc(peer, out);
      }
      for (const [peer, control] of this.control.entries()) {
        this.control.delete(peer);
        const out = utils_1.createGossipRpc([], {graft: control.graft, prune: control.prune});
        this._sendRpc(peer, out);
      }
    }
    _pushGossip(id, controlIHaveMsgs) {
      this.log("Add gossip to %s", id);
      const gossip = this.gossip.get(id) || [];
      this.gossip.set(id, gossip.concat(controlIHaveMsgs));
    }
    _now() {
      return Date.now();
    }
    _makePrune(id, topic, doPX) {
      if (this.peers.get(id).protocol === constants.GossipsubIDv10) {
        return {
          topicID: topic,
          peers: []
        };
      }
      const backoff = constants.GossipsubPruneBackoff / 1e3;
      const px = [];
      if (doPX) {
        const peers = get_gossip_peers_1.getGossipPeers(this, topic, constants.GossipsubPrunePeers, (xid) => {
          return xid !== id && this.score.score(xid) >= 0;
        });
        peers.forEach((p) => {
          const peerId = PeerId.createFromB58String(p);
          px.push({
            peerID: peerId.toBytes(),
            signedPeerRecord: this._libp2p.peerStore.addressBook.getRawEnvelope(peerId)
          });
        });
      }
      return {
        topicID: topic,
        peers: px,
        backoff
      };
    }
  };
  Gossipsub.multicodec = constants.GossipsubIDv11;
  module2.exports = Gossipsub;
});

// node_modules/ipfs-core/src/runtime/libp2p-pubsub-routers-browser.js
var require_libp2p_pubsub_routers_browser = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = {
    gossipsub: require_src39()
  };
});

// node_modules/it-filter/index.js
var require_it_filter = __commonJS((exports2, module2) => {
  "use strict";
  var filter = async function* (source, fn) {
    for await (const entry of source) {
      if (await fn(entry)) {
        yield entry;
      }
    }
  };
  module2.exports = filter;
});

// node_modules/it-take/index.js
var require_it_take = __commonJS((exports2, module2) => {
  "use strict";
  var take = async function* (source, limit) {
    let items = 0;
    if (limit < 1) {
      return;
    }
    for await (const entry of source) {
      yield entry;
      items++;
      if (items === limit) {
        return;
      }
    }
  };
  module2.exports = take;
});

// node_modules/libp2p/src/content-routing/utils.js
var require_utils25 = __commonJS((exports2, module2) => {
  "use strict";
  var errCode = require_err_code();
  var filter = require_it_filter();
  var map = require_it_map();
  var take = require_it_take();
  function storeAddresses(source, peerStore) {
    return map(source, (peer) => {
      peerStore.addressBook.add(peer.id, peer.multiaddrs);
      return peer;
    });
  }
  function uniquePeers(source) {
    const seen = new Set();
    return filter(source, (peer) => {
      if (seen.has(peer.id.toString())) {
        return false;
      }
      seen.add(peer.id.toString());
      return true;
    });
  }
  async function* requirePeers(source, min = 1) {
    let seen = 0;
    for await (const peer of source) {
      seen++;
      yield peer;
    }
    if (seen < min) {
      throw errCode(new Error("not found"), "NOT_FOUND");
    }
  }
  function maybeLimitSource(source, max) {
    if (max) {
      return take(source, max);
    }
    return source;
  }
  module2.exports = {
    storeAddresses,
    uniquePeers,
    requirePeers,
    maybeLimitSource
  };
});

// node_modules/it-merge/index.js
var require_it_merge = __commonJS((exports2, module2) => {
  "use strict";
  var pushable = require_it_pushable();
  var merge = async function* (...sources) {
    const output = pushable();
    setTimeout(async () => {
      try {
        await Promise.all(sources.map(async (source) => {
          for await (const item of source) {
            output.push(item);
          }
        }));
        output.end();
      } catch (err) {
        output.end(err);
      }
    }, 0);
    yield* output;
  };
  module2.exports = merge;
});

// node_modules/set-delayed-interval/src/index.js
var require_src40 = __commonJS((exports2, module2) => {
  "use strict";
  var intervals = new Map();
  var _generateId = () => `${Date.now()}:${Math.floor(Math.random() * 1e6)}`;
  async function _runPeriodically(task, interval, id) {
    while (intervals.get(id)) {
      try {
        await task();
      } catch (err) {
        setTimeout(() => {
          throw err;
        }, 1);
        break;
      }
      if (!intervals.get(id)) {
        break;
      }
      await new Promise((resolve) => {
        const _timeout = setTimeout(resolve, interval);
        intervals.set(id, _timeout);
      });
    }
  }
  function setDelayedInterval(task, interval, delay) {
    delay = delay || interval;
    const id = _generateId();
    const _timeout = setTimeout(() => {
      _runPeriodically(task, interval, id);
    }, delay);
    intervals.set(id, _timeout);
    return id;
  }
  function clearDelayedInterval(id) {
    const _timeout = intervals.get(id);
    if (_timeout) {
      clearTimeout(_timeout);
      intervals.delete(id);
    }
  }
  module2.exports = {
    setDelayedInterval,
    clearDelayedInterval
  };
});

// node_modules/libp2p/src/peer-routing.js
var require_peer_routing = __commonJS((exports2, module2) => {
  "use strict";
  var debug = require_browser4();
  var log = Object.assign(debug("libp2p:peer-routing"), {
    error: debug("libp2p:peer-routing:err")
  });
  var errCode = require_err_code();
  var {
    storeAddresses,
    uniquePeers,
    requirePeers
  } = require_utils25();
  var merge = require_it_merge();
  var {pipe} = require_it_pipe();
  var first = require_it_first();
  var drain = require_it_drain();
  var filter = require_it_filter();
  var {
    setDelayedInterval,
    clearDelayedInterval
  } = require_src40();
  var PeerId = require_src9();
  var PeerRouting = class {
    constructor(libp2p) {
      this._peerId = libp2p.peerId;
      this._peerStore = libp2p.peerStore;
      this._routers = libp2p._modules.peerRouting || [];
      if (libp2p._dht) {
        this._routers.push(libp2p._dht);
      }
      this._refreshManagerOptions = libp2p._options.peerRouting.refreshManager;
      this._findClosestPeersTask = this._findClosestPeersTask.bind(this);
    }
    start() {
      if (!this._routers.length || this._timeoutId || !this._refreshManagerOptions.enabled) {
        return;
      }
      this._timeoutId = setDelayedInterval(this._findClosestPeersTask, this._refreshManagerOptions.interval, this._refreshManagerOptions.bootDelay);
    }
    async _findClosestPeersTask() {
      try {
        await drain(this.getClosestPeers(this._peerId.id));
      } catch (err) {
        log.error(err);
      }
    }
    stop() {
      clearDelayedInterval(this._timeoutId);
    }
    async findPeer(id, options) {
      if (!this._routers.length) {
        throw errCode(new Error("No peer routers available"), "NO_ROUTERS_AVAILABLE");
      }
      const output = await pipe(merge(...this._routers.map((router) => [router.findPeer(id, options)])), (source) => filter(source, Boolean), (source) => storeAddresses(source, this._peerStore), (source) => first(source));
      if (output) {
        return output;
      }
      throw errCode(new Error("not found"), "NOT_FOUND");
    }
    async *getClosestPeers(key, options = {timeout: 3e4}) {
      if (!this._routers.length) {
        throw errCode(new Error("No peer routers available"), "NO_ROUTERS_AVAILABLE");
      }
      yield* pipe(merge(...this._routers.map((router) => router.getClosestPeers(key, options))), (source) => storeAddresses(source, this._peerStore), (source) => uniquePeers(source), (source) => requirePeers(source));
    }
  };
  module2.exports = PeerRouting;
});

// node_modules/libp2p/src/content-routing/index.js
var require_content_routing = __commonJS((exports2, module2) => {
  "use strict";
  var errCode = require_err_code();
  var {messages, codes} = require_errors12();
  var {
    storeAddresses,
    uniquePeers,
    requirePeers,
    maybeLimitSource
  } = require_utils25();
  var merge = require_it_merge();
  var {pipe} = require_it_pipe();
  var ContentRouting = class {
    constructor(libp2p) {
      this.libp2p = libp2p;
      this.routers = libp2p._modules.contentRouting || [];
      this.dht = libp2p._dht;
      if (this.dht) {
        this.routers.push(this.dht);
      }
    }
    async *findProviders(key, options = {}) {
      if (!this.routers.length) {
        throw errCode(new Error("No content this.routers available"), "NO_ROUTERS_AVAILABLE");
      }
      yield* pipe(merge(...this.routers.map((router) => router.findProviders(key, options))), (source) => storeAddresses(source, this.libp2p.peerStore), (source) => uniquePeers(source), (source) => maybeLimitSource(source, options.maxNumProviders), (source) => requirePeers(source));
    }
    async provide(key) {
      if (!this.routers.length) {
        throw errCode(new Error("No content routers available"), "NO_ROUTERS_AVAILABLE");
      }
      await Promise.all(this.routers.map((router) => router.provide(key)));
    }
    put(key, value, options) {
      if (!this.libp2p.isStarted() || !this.dht.isStarted) {
        throw errCode(new Error(messages.NOT_STARTED_YET), codes.DHT_NOT_STARTED);
      }
      return this.dht.put(key, value, options);
    }
    get(key, options) {
      if (!this.libp2p.isStarted() || !this.dht.isStarted) {
        throw errCode(new Error(messages.NOT_STARTED_YET), codes.DHT_NOT_STARTED);
      }
      return this.dht.get(key, options);
    }
    async getMany(key, nVals, options) {
      if (!this.libp2p.isStarted() || !this.dht.isStarted) {
        throw errCode(new Error(messages.NOT_STARTED_YET), codes.DHT_NOT_STARTED);
      }
      return this.dht.getMany(key, nVals, options);
    }
  };
  module2.exports = ContentRouting;
});

// node_modules/libp2p/src/get-peer.js
var require_get_peer = __commonJS((exports2, module2) => {
  "use strict";
  var PeerId = require_src9();
  var multiaddr = require_src11();
  var errCode = require_err_code();
  var {codes} = require_errors12();
  function getPeer(peer) {
    if (typeof peer === "string") {
      peer = multiaddr(peer);
    }
    let addr;
    if (multiaddr.isMultiaddr(peer)) {
      addr = peer;
      try {
        peer = PeerId.createFromB58String(peer.getPeerId());
      } catch (err) {
        throw errCode(new Error(`${peer} is not a valid peer type`), codes.ERR_INVALID_MULTIADDR);
      }
    }
    return {
      id: peer,
      multiaddrs: addr ? [addr] : void 0
    };
  }
  module2.exports = getPeer;
});

// empty:dns
var require_dns2 = __commonJS(() => {
});

// node_modules/ms/index.js
var require_ms2 = __commonJS((exports2, module2) => {
  var s = 1e3;
  var m = s * 60;
  var h = m * 60;
  var d = h * 24;
  var w = d * 7;
  var y = d * 365.25;
  module2.exports = function(val, options) {
    options = options || {};
    var type = typeof val;
    if (type === "string" && val.length > 0) {
      return parse(val);
    } else if (type === "number" && isFinite(val)) {
      return options.long ? fmtLong(val) : fmtShort(val);
    }
    throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(val));
  };
  function parse(str) {
    str = String(str);
    if (str.length > 100) {
      return;
    }
    var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);
    if (!match) {
      return;
    }
    var n = parseFloat(match[1]);
    var type = (match[2] || "ms").toLowerCase();
    switch (type) {
      case "years":
      case "year":
      case "yrs":
      case "yr":
      case "y":
        return n * y;
      case "weeks":
      case "week":
      case "w":
        return n * w;
      case "days":
      case "day":
      case "d":
        return n * d;
      case "hours":
      case "hour":
      case "hrs":
      case "hr":
      case "h":
        return n * h;
      case "minutes":
      case "minute":
      case "mins":
      case "min":
      case "m":
        return n * m;
      case "seconds":
      case "second":
      case "secs":
      case "sec":
      case "s":
        return n * s;
      case "milliseconds":
      case "millisecond":
      case "msecs":
      case "msec":
      case "ms":
        return n;
      default:
        return void 0;
    }
  }
  function fmtShort(ms) {
    var msAbs = Math.abs(ms);
    if (msAbs >= d) {
      return Math.round(ms / d) + "d";
    }
    if (msAbs >= h) {
      return Math.round(ms / h) + "h";
    }
    if (msAbs >= m) {
      return Math.round(ms / m) + "m";
    }
    if (msAbs >= s) {
      return Math.round(ms / s) + "s";
    }
    return ms + "ms";
  }
  function fmtLong(ms) {
    var msAbs = Math.abs(ms);
    if (msAbs >= d) {
      return plural(ms, msAbs, d, "day");
    }
    if (msAbs >= h) {
      return plural(ms, msAbs, h, "hour");
    }
    if (msAbs >= m) {
      return plural(ms, msAbs, m, "minute");
    }
    if (msAbs >= s) {
      return plural(ms, msAbs, s, "second");
    }
    return ms + " ms";
  }
  function plural(ms, msAbs, n, name) {
    var isPlural = msAbs >= n * 1.5;
    return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
  }
});

// node_modules/receptacle/index.js
var require_receptacle = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = Receptacle;
  var toMS = require_ms2();
  var cache = Receptacle.prototype;
  var counter = new Date() % 1e9;
  function getUID() {
    return (Math.random() * 1e9 >>> 0) + counter++;
  }
  function Receptacle(options) {
    options = options || {};
    this.id = options.id || getUID();
    this.max = options.max || Infinity;
    this.items = options.items || [];
    this._lookup = {};
    this.size = this.items.length;
    this.lastModified = new Date(options.lastModified || new Date());
    for (var item, ttl, i = this.items.length; i--; ) {
      item = this.items[i];
      ttl = new Date(item.expires) - new Date();
      this._lookup[item.key] = item;
      if (ttl > 0)
        this.expire(item.key, ttl);
      else if (ttl <= 0)
        this.delete(item.key);
    }
  }
  cache.has = function(key) {
    return key in this._lookup;
  };
  cache.get = function(key) {
    if (!this.has(key))
      return null;
    var record = this._lookup[key];
    if (record.refresh)
      this.expire(key, record.refresh);
    this.items.splice(this.items.indexOf(record), 1);
    this.items.push(record);
    return record.value;
  };
  cache.meta = function(key) {
    if (!this.has(key))
      return null;
    var record = this._lookup[key];
    if (!("meta" in record))
      return null;
    return record.meta;
  };
  cache.set = function(key, value, options) {
    var oldRecord = this._lookup[key];
    var record = this._lookup[key] = {key, value};
    this.lastModified = new Date();
    if (oldRecord) {
      clearTimeout(oldRecord.timeout);
      this.items.splice(this.items.indexOf(oldRecord), 1, record);
    } else {
      if (this.size >= this.max)
        this.delete(this.items[0].key);
      this.items.push(record);
      this.size++;
    }
    if (options) {
      if ("ttl" in options)
        this.expire(key, options.ttl);
      if ("meta" in options)
        record.meta = options.meta;
      if (options.refresh)
        record.refresh = options.ttl;
    }
    return this;
  };
  cache.delete = function(key) {
    var record = this._lookup[key];
    if (!record)
      return false;
    this.lastModified = new Date();
    this.items.splice(this.items.indexOf(record), 1);
    clearTimeout(record.timeout);
    delete this._lookup[key];
    this.size--;
    return this;
  };
  cache.expire = function(key, ttl) {
    var ms = ttl || 0;
    var record = this._lookup[key];
    if (!record)
      return this;
    if (typeof ms === "string")
      ms = toMS(ttl);
    if (typeof ms !== "number")
      throw new TypeError("Expiration time must be a string or number.");
    clearTimeout(record.timeout);
    record.timeout = setTimeout(this.delete.bind(this, record.key), ms);
    record.expires = Number(new Date()) + ms;
    return this;
  };
  cache.clear = function() {
    for (var i = this.items.length; i--; )
      this.delete(this.items[i].key);
    return this;
  };
  cache.toJSON = function() {
    var items = new Array(this.items.length);
    var item;
    for (var i = items.length; i--; ) {
      item = this.items[i];
      items[i] = {
        key: item.key,
        meta: item.meta,
        value: item.value,
        expires: item.expires,
        refresh: item.refresh
      };
    }
    return {
      id: this.id,
      max: isFinite(this.max) ? this.max : void 0,
      lastModified: this.lastModified,
      items
    };
  };
});

// node_modules/dns-over-http-resolver/src/utils.js
var require_utils26 = __commonJS((exports2, module2) => {
  "use strict";
  var {default: nativeFetch, Headers} = require_src();
  function buildResource({serverResolver, hostname, recordType}) {
    return `${serverResolver}?name=${hostname}&type=${recordType}`;
  }
  module2.exports.buildResource = buildResource;
  function fetch(resource) {
    return nativeFetch(resource, {
      headers: new Headers({
        accept: "application/dns-json"
      })
    });
  }
  module2.exports.fetch = fetch;
  function getCacheKey(hostname, recordType) {
    return `${recordType}_${hostname}`;
  }
  module2.exports.getCacheKey = getCacheKey;
});

// node_modules/dns-over-http-resolver/src/index.js
var require_src41 = __commonJS((exports2, module2) => {
  "use strict";
  var debug = require_browser4();
  var log = debug("dns-over-http-resolver");
  log.error = debug("dns-over-http-resolver:error");
  var Receptacle = require_receptacle();
  var {
    buildResource,
    fetch,
    getCacheKey
  } = require_utils26();
  var Resolver = class {
    constructor({maxCache = 100} = {}) {
      this._cache = new Receptacle({max: maxCache});
      this._servers = [
        "https://cloudflare-dns.com/dns-query",
        "https://dns.google/resolve"
      ];
    }
    getServers() {
      return this._servers;
    }
    _getShuffledServers() {
      const newServers = [].concat(this._servers);
      for (let i = newServers.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * i);
        const temp = newServers[i];
        newServers[i] = newServers[j];
        newServers[j] = temp;
      }
      return newServers;
    }
    setServers(servers) {
      this._servers = servers;
    }
    resolve(hostname, rrType = "A") {
      switch (rrType) {
        case "A":
          return this.resolve4(hostname);
        case "AAAA":
          return this.resolve6(hostname);
        case "TXT":
          return this.resolveTxt(hostname);
        default:
          throw new Error(`${rrType} is not supported`);
      }
    }
    async resolve4(hostname) {
      const recordType = "A";
      const cached = this._cache.get(getCacheKey(hostname, recordType));
      if (cached) {
        return cached;
      }
      for (const server of this._getShuffledServers()) {
        try {
          const response = await fetch(buildResource({
            serverResolver: server,
            hostname,
            recordType
          }));
          const d = await response.json();
          const data = d.Answer.map((a) => a.data);
          const ttl = Math.min(d.Answer.map((a) => a.TTL));
          this._cache.set(getCacheKey(hostname, recordType), data, {ttl});
          return data;
        } catch (err) {
          log.error(`${server} could not resolve ${hostname} record ${recordType}`);
        }
      }
      throw new Error(`Could not resolve ${hostname} record ${recordType}`);
    }
    async resolve6(hostname) {
      const recordType = "AAAA";
      const cached = this._cache.get(getCacheKey(hostname, recordType));
      if (cached) {
        return cached;
      }
      for (const server of this._getShuffledServers()) {
        try {
          const response = await fetch(buildResource({
            serverResolver: server,
            hostname,
            recordType
          }));
          const d = await response.json();
          const data = d.Answer.map((a) => a.data);
          const ttl = Math.min(d.Answer.map((a) => a.TTL));
          this._cache.set(getCacheKey(hostname, recordType), data, {ttl});
          return data;
        } catch (err) {
          log.error(`${server} could not resolve ${hostname} record ${recordType}`);
        }
      }
      throw new Error(`Could not resolve ${hostname} record ${recordType}`);
    }
    async resolveTxt(hostname) {
      const recordType = "TXT";
      const cached = this._cache.get(getCacheKey(hostname, recordType));
      if (cached) {
        return cached;
      }
      for (const server of this._getShuffledServers()) {
        try {
          const response = await fetch(buildResource({
            serverResolver: server,
            hostname,
            recordType
          }));
          const d = await response.json();
          const data = d.Answer.map((a) => [a.data.replace(/['"]+/g, "")]);
          const ttl = Math.min(d.Answer.map((a) => a.TTL));
          this._cache.set(getCacheKey(hostname, recordType), data, {ttl});
          return data;
        } catch (err) {
          log.error(`${server} could not resolve ${hostname} record ${recordType}`);
        }
      }
      throw new Error(`Could not resolve ${hostname} record ${recordType}`);
    }
  };
  Resolver.Resolver = Resolver;
  module2.exports = Resolver;
});

// node_modules/multiaddr/src/resolvers/dns.js
var require_dns3 = __commonJS((exports2, module2) => {
  "use strict";
  var dns;
  try {
    dns = require_dns2().promises;
    if (!dns) {
      throw new Error("no dns available");
    }
  } catch (err) {
    dns = require_src41();
  }
  module2.exports = dns;
});

// node_modules/multiaddr/src/resolvers/index.js
var require_resolvers2 = __commonJS((exports2, module2) => {
  "use strict";
  var Multiaddr = require_src11();
  var protocols = require_protocols_table();
  var {code: dnsaddrCode} = protocols("dnsaddr");
  async function dnsaddrResolver(addr) {
    const {Resolver} = require_dns3();
    const resolver = new Resolver();
    const peerId = addr.getPeerId();
    const [, hostname] = addr.stringTuples().find(([proto]) => proto === dnsaddrCode) || [];
    const records = await resolver.resolveTxt(`_dnsaddr.${hostname}`);
    let addresses = records.flat().map((a) => a.split("=")[1]);
    if (peerId) {
      addresses = addresses.filter((entry) => entry.includes(peerId));
    }
    return addresses;
  }
  module2.exports = {
    dnsaddrResolver
  };
});

// node_modules/libp2p/src/constants.js
var require_constants10 = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = {
    DIAL_TIMEOUT: 3e4,
    MAX_PARALLEL_DIALS: 100,
    MAX_PER_PEER_DIALS: 4,
    METRICS: {
      computeThrottleMaxQueueSize: 1e3,
      computeThrottleTimeout: 2e3,
      movingAverageIntervals: [
        60 * 1e3,
        5 * 60 * 1e3,
        15 * 60 * 1e3
      ],
      maxOldPeersRetention: 50
    }
  };
});

// node_modules/libp2p/package.json
var require_package4 = __commonJS((exports2, module2) => {
  module2.exports = {
    name: "libp2p",
    version: "0.30.7",
    description: "JavaScript implementation of libp2p, a modular peer to peer network stack",
    leadMaintainer: "Jacob Heun <jacobheun@gmail.com>",
    main: "src/index.js",
    types: "dist/src/index.d.ts",
    typesVersions: {
      "*": {
        "src/*": [
          "dist/src/*",
          "dist/src/*/index"
        ]
      }
    },
    files: [
      "dist",
      "src"
    ],
    scripts: {
      lint: "aegir lint",
      build: "aegir build",
      test: "npm run test:node && npm run test:browser",
      "test:node": 'aegir test -t node -f "./test/**/*.{node,spec}.js"',
      "test:browser": "aegir test -t browser",
      "test:examples": "cd examples && npm run test:all",
      release: "aegir release -t node -t browser",
      "release-minor": "aegir release --type minor -t node -t browser",
      "release-major": "aegir release --type major -t node -t browser",
      coverage: "nyc --reporter=text --reporter=lcov npm run test:node"
    },
    repository: {
      type: "git",
      url: "https://github.com/libp2p/js-libp2p.git"
    },
    keywords: [
      "libp2p",
      "network",
      "p2p",
      "peer",
      "peer-to-peer",
      "IPFS"
    ],
    bugs: {
      url: "https://github.com/libp2p/js-libp2p/issues"
    },
    homepage: "https://libp2p.io",
    license: "MIT",
    engines: {
      node: ">=12.0.0",
      npm: ">=6.0.0"
    },
    browser: {
      "@motrix/nat-api": false
    },
    dependencies: {
      "@motrix/nat-api": "^0.3.1",
      "abort-controller": "^3.0.0",
      "aggregate-error": "^3.1.0",
      "any-signal": "^2.1.1",
      "bignumber.js": "^9.0.1",
      cids: "^1.1.5",
      "class-is": "^1.1.0",
      debug: "^4.3.1",
      "err-code": "^2.0.0",
      events: "^3.2.0",
      hashlru: "^2.3.0",
      "interface-datastore": "^3.0.3",
      "ipfs-utils": "^6.0.0",
      "it-all": "^1.0.4",
      "it-buffer": "^0.1.2",
      "it-drain": "^1.0.3",
      "it-filter": "^1.0.1",
      "it-first": "^1.0.4",
      "it-handshake": "^1.0.2",
      "it-length-prefixed": "^3.1.0",
      "it-map": "^1.0.4",
      "it-merge": "1.0.0",
      "it-pipe": "^1.1.0",
      "it-protocol-buffers": "^0.2.0",
      "it-take": "1.0.0",
      "libp2p-crypto": "^0.19.0",
      "libp2p-interfaces": "^0.8.1",
      "libp2p-utils": "^0.2.2",
      mafmt: "^8.0.0",
      "merge-options": "^3.0.4",
      "moving-average": "^1.0.0",
      multiaddr: "^8.1.0",
      multicodec: "^2.1.0",
      "multihashing-async": "^2.0.1",
      "multistream-select": "^1.0.0",
      "mutable-proxy": "^1.0.0",
      "node-forge": "^0.10.0",
      "p-any": "^3.0.0",
      "p-fifo": "^1.0.0",
      "p-retry": "^4.2.0",
      "p-settle": "^4.0.1",
      "peer-id": "^0.14.2",
      "private-ip": "^2.0.0",
      "promisify-es6": "^1.0.3",
      protons: "^2.0.0",
      retimer: "^2.0.0",
      "sanitize-filename": "^1.6.3",
      "set-delayed-interval": "^1.0.0",
      "streaming-iterables": "^5.0.2",
      "timeout-abort-controller": "^1.1.1",
      varint: "^6.0.0",
      xsalsa20: "^1.0.2"
    },
    devDependencies: {
      "@nodeutils/defaults-deep": "^1.1.0",
      "abortable-iterator": "^3.0.0",
      aegir: "^29.2.0",
      "chai-bytes": "^0.1.2",
      "chai-string": "^1.5.0",
      delay: "^4.4.0",
      "interop-libp2p": "^0.3.0",
      "into-stream": "^6.0.0",
      "ipfs-http-client": "^48.2.2",
      "it-concat": "^1.0.0",
      "it-pair": "^1.0.0",
      "it-pushable": "^1.4.0",
      libp2p: ".",
      "libp2p-bootstrap": "^0.12.0",
      "libp2p-delegated-content-routing": "^0.9.0",
      "libp2p-delegated-peer-routing": "^0.8.0",
      "libp2p-floodsub": "^0.24.0",
      "libp2p-gossipsub": "^0.8.0",
      "libp2p-kad-dht": "^0.20.5",
      "libp2p-mdns": "^0.15.0",
      "libp2p-mplex": "^0.10.1",
      "libp2p-noise": "^2.0.0",
      "libp2p-secio": "^0.13.1",
      "libp2p-tcp": "^0.15.1",
      "libp2p-webrtc-star": "^0.20.0",
      "libp2p-websockets": "^0.15.0",
      multihashes: "^3.0.1",
      nock: "^13.0.3",
      "p-defer": "^3.0.0",
      "p-times": "^3.0.0",
      "p-wait-for": "^3.2.0",
      rimraf: "^3.0.2",
      sinon: "^9.2.4",
      uint8arrays: "^2.0.5"
    },
    contributors: [
      "David Dias <daviddias.p@gmail.com>",
      "Jacob Heun <jacobheun@gmail.com>",
      "Vasco Santos <vasco.santos@moxy.studio>",
      "Alan Shaw <alan@tableflip.io>",
      "Alex Potsides <alex@achingbrain.net>",
      "Cayman <caymannava@gmail.com>",
      "Pedro Teixeira <i@pgte.me>",
      "Friedel Ziegelmayer <dignifiedquire@gmail.com>",
      "Maciej Kr\xFCger <mkg20001@gmail.com>",
      "Hugo Dias <mail@hugodias.me>",
      "Volker Mische <volker.mische@gmail.com>",
      "dirkmc <dirkmdev@gmail.com>",
      "Richard Littauer <richard.littauer@gmail.com>",
      "a1300 <matthias-knopp@gmx.net>",
      "Ryan Bell <ryan@piing.net>",
      "Andrew Nesbitt <andrewnez@gmail.com>",
      "Elven <mon.samuel@qq.com>",
      "Giovanni T. Parra <fiatjaf@gmail.com>",
      "Samlior <samlior@foxmail.com>",
      "Thomas Eizinger <thomas@eizinger.io>",
      "\u1D20\u026A\u1D04\u1D1B\u1D0F\u0280 \u0299\u1D0A\u1D07\u029F\u1D0B\u029C\u1D0F\u029F\u1D0D <victorbjelkholm@gmail.com>",
      "Didrik Nordstr\xF6m <didrik@betamos.se>",
      "Irakli Gozalishvili <rfobic@gmail.com>",
      "Joel Gustafson <joelg@mit.edu>",
      "Julien Bouquillon <contact@revolunet.com>",
      "Kevin Kwok <antimatter15@gmail.com>",
      "Kevin Lacker <lacker@gmail.com>",
      "Ethan Lam <elmemphis2000@gmail.com>",
      "Nuno Nogueira <nunofmn@gmail.com>",
      "Dmitriy Ryajov <dryajov@gmail.com>",
      "RasmusErik Voel Jensen <github@solsort.com>",
      "Diogo Silva <fsdiogo@gmail.com>",
      "Smite Chow <xiaopengyou@live.com>",
      "Soeren <nikorpoulsen@gmail.com>",
      "S\xF6nke Hahn <soenkehahn@gmail.com>",
      "Tiago Alves <alvesjtiago@gmail.com>",
      "Daijiro Wachi <daijiro.wachi@gmail.com>",
      "Yusef Napora <yusef@napora.org>",
      "Zane Starr <zcstarr@gmail.com>",
      "robertkiel <robert.kiel@validitylabs.org>",
      "Cindy Wu <ciindy.wu@gmail.com>",
      "Chris Bratlien <chrisbratlien@gmail.com>",
      "ebinks <elizabethjbinks@gmail.com>",
      "Francis Gulotta <wizard@roborooter.com>",
      "Florian-Merle <florian.david.merle@gmail.com>",
      "Bernd Strehl <bernd.strehl@gmail.com>",
      "Henrique Dias <hacdias@gmail.com>",
      "isan_rivkin <isanrivkin@gmail.com>",
      "Felipe Martins <felipebrasil93@gmail.com>",
      "Fei Liu <liu.feiwood@gmail.com>"
    ]
  };
});

// node_modules/libp2p/src/identify/consts.js
var require_consts = __commonJS((exports2, module2) => {
  "use strict";
  var libp2pVersion = require_package4().version;
  module2.exports.PROTOCOL_VERSION = "ipfs/0.1.0";
  module2.exports.AGENT_VERSION = `js-libp2p/${libp2pVersion}`;
  module2.exports.MULTICODEC_IDENTIFY = "/ipfs/id/1.0.0";
  module2.exports.MULTICODEC_IDENTIFY_PUSH = "/ipfs/id/push/1.0.0";
});

// node_modules/libp2p/src/circuit/constants.js
var require_constants11 = __commonJS((exports2, module2) => {
  "use strict";
  var minute = 60 * 1e3;
  module2.exports = {
    ADVERTISE_BOOT_DELAY: 15 * minute,
    ADVERTISE_TTL: 30 * minute,
    CIRCUIT_PROTO_CODE: 290,
    HOP_METADATA_KEY: "hop_relay",
    HOP_METADATA_VALUE: "true",
    RELAY_RENDEZVOUS_NS: "/libp2p/relay"
  };
});

// node_modules/netmask/lib/netmask.js
var require_netmask = __commonJS((exports2) => {
  (function() {
    var Netmask, ip2long, long2ip;
    long2ip = function(long) {
      var a, b, c, d;
      a = (long & 255 << 24) >>> 24;
      b = (long & 255 << 16) >>> 16;
      c = (long & 255 << 8) >>> 8;
      d = long & 255;
      return [a, b, c, d].join(".");
    };
    ip2long = function(ip) {
      var b, byte, i, j, len;
      b = (ip + "").split(".");
      if (b.length === 0 || b.length > 4) {
        throw new Error("Invalid IP");
      }
      for (i = j = 0, len = b.length; j < len; i = ++j) {
        byte = b[i];
        if (isNaN(parseInt(byte, 10))) {
          throw new Error("Invalid byte: " + byte);
        }
        if (byte < 0 || byte > 255) {
          throw new Error("Invalid byte: " + byte);
        }
      }
      return ((b[0] || 0) << 24 | (b[1] || 0) << 16 | (b[2] || 0) << 8 | (b[3] || 0)) >>> 0;
    };
    Netmask = function() {
      function Netmask2(net, mask) {
        var error, error1, error2, i, j, ref;
        if (typeof net !== "string") {
          throw new Error("Missing `net' parameter");
        }
        if (!mask) {
          ref = net.split("/", 2), net = ref[0], mask = ref[1];
        }
        if (!mask) {
          switch (net.split(".").length) {
            case 1:
              mask = 8;
              break;
            case 2:
              mask = 16;
              break;
            case 3:
              mask = 24;
              break;
            case 4:
              mask = 32;
              break;
            default:
              throw new Error("Invalid net address: " + net);
          }
        }
        if (typeof mask === "string" && mask.indexOf(".") > -1) {
          try {
            this.maskLong = ip2long(mask);
          } catch (error12) {
            error = error12;
            throw new Error("Invalid mask: " + mask);
          }
          for (i = j = 32; j >= 0; i = --j) {
            if (this.maskLong === 4294967295 << 32 - i >>> 0) {
              this.bitmask = i;
              break;
            }
          }
        } else if (mask) {
          this.bitmask = parseInt(mask, 10);
          this.maskLong = 0;
          if (this.bitmask > 0) {
            this.maskLong = 4294967295 << 32 - this.bitmask >>> 0;
          }
        } else {
          throw new Error("Invalid mask: empty");
        }
        try {
          this.netLong = (ip2long(net) & this.maskLong) >>> 0;
        } catch (error22) {
          error = error22;
          throw new Error("Invalid net address: " + net);
        }
        if (!(this.bitmask <= 32)) {
          throw new Error("Invalid mask for ip4: " + mask);
        }
        this.size = Math.pow(2, 32 - this.bitmask);
        this.base = long2ip(this.netLong);
        this.mask = long2ip(this.maskLong);
        this.hostmask = long2ip(~this.maskLong);
        this.first = this.bitmask <= 30 ? long2ip(this.netLong + 1) : this.base;
        this.last = this.bitmask <= 30 ? long2ip(this.netLong + this.size - 2) : long2ip(this.netLong + this.size - 1);
        this.broadcast = this.bitmask <= 30 ? long2ip(this.netLong + this.size - 1) : void 0;
      }
      Netmask2.prototype.contains = function(ip) {
        if (typeof ip === "string" && (ip.indexOf("/") > 0 || ip.split(".").length !== 4)) {
          ip = new Netmask2(ip);
        }
        if (ip instanceof Netmask2) {
          return this.contains(ip.base) && this.contains(ip.broadcast || ip.last);
        } else {
          return (ip2long(ip) & this.maskLong) >>> 0 === (this.netLong & this.maskLong) >>> 0;
        }
      };
      Netmask2.prototype.next = function(count) {
        if (count == null) {
          count = 1;
        }
        return new Netmask2(long2ip(this.netLong + this.size * count), this.mask);
      };
      Netmask2.prototype.forEach = function(fn) {
        var index, j, k, len, long, range, ref, ref1, results, results1;
        range = function() {
          results = [];
          for (var j2 = ref = ip2long(this.first), ref12 = ip2long(this.last); ref <= ref12 ? j2 <= ref12 : j2 >= ref12; ref <= ref12 ? j2++ : j2--) {
            results.push(j2);
          }
          return results;
        }.apply(this);
        results1 = [];
        for (index = k = 0, len = range.length; k < len; index = ++k) {
          long = range[index];
          results1.push(fn(long2ip(long), long, index));
        }
        return results1;
      };
      Netmask2.prototype.toString = function() {
        return this.base + "/" + this.bitmask;
      };
      return Netmask2;
    }();
    exports2.ip2long = ip2long;
    exports2.long2ip = long2ip;
    exports2.Netmask = Netmask;
  }).call(exports2);
});

// node_modules/private-ip/lib/index.js
var require_lib7 = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  var Netmask = require_netmask().Netmask;
  var isIp = require_is_ip();
  function ipv4Check(params) {
    var privateRanges = ["0.0.0.0/8", "10.0.0.0/8", "100.64.0.0/10", "127.0.0.0/8", "169.254.0.0/16", "172.16.0.0/12", "192.0.0.0/24", "192.0.0.0/29", "192.0.0.8/32", "192.0.0.9/32", "192.0.0.10/32", "192.0.0.170/32", "192.0.0.171/32", "192.0.2.0/24", "192.31.196.0/24", "192.52.193.0/24", "192.88.99.0/24", "192.168.0.0/16", "192.175.48.0/24", "198.18.0.0/15", "198.51.100.0/24", "203.0.113.0/24", "240.0.0.0/4", "255.255.255.255/32"].map(function(b) {
      return new Netmask(b);
    });
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = void 0;
    try {
      for (var _iterator = privateRanges[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var r = _step.value;
        if (r.contains(params))
          return true;
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }
    return false;
  }
  function ipv6Check(params) {
    return /^::$/.test(params) || /^::1$/.test(params) || /^::f{4}:([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})$/.test(params) || /^::f{4}:0.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})$/.test(params) || /^64:ff9b::([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})$/.test(params) || /^100::([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(params) || /^2001::([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(params) || /^2001:2[0-9a-fA-F]:([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(params) || /^2001:db8:([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(params) || /^2002:([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4}):?([0-9a-fA-F]{0,4})$/.test(params) || /^f[c-d]([0-9a-fA-F]{2,2}):/i.test(params) || /^fe[8-9a-bA-B][0-9a-fA-F]:/i.test(params) || /^ff([0-9a-fA-F]{2,2}):/i.test(params);
  }
  exports2.default = function(ip) {
    if (isIp.v4(ip) || ip.startsWith("0")) {
      return ipv4Check(ip);
    }
    return ipv6Check(ip);
  };
});

// node_modules/private-ip/index.js
var require_private_ip = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = require_lib7().default;
});

// node_modules/libp2p-utils/src/multiaddr/is-private.js
var require_is_private = __commonJS((exports2, module2) => {
  "use strict";
  var isIpPrivate = require_private_ip();
  function isPrivate(ma) {
    const {address} = ma.nodeAddress();
    return isIpPrivate(address);
  }
  module2.exports = isPrivate;
});

// node_modules/libp2p-utils/src/address-sort.js
var require_address_sort = __commonJS((exports2, module2) => {
  "use strict";
  var isPrivate = require_is_private();
  function addressesPublicFirstCompareFunction(a, b) {
    const isAPrivate = isPrivate(a.multiaddr);
    const isBPrivate = isPrivate(b.multiaddr);
    if (isAPrivate && !isBPrivate) {
      return 1;
    } else if (!isAPrivate && isBPrivate) {
      return -1;
    }
    if (a.isCertified && !b.isCertified) {
      return -1;
    } else if (!a.isCertified && b.isCertified) {
      return 1;
    }
    return 0;
  }
  function publicAddressesFirst(addresses) {
    return [...addresses].sort(addressesPublicFirstCompareFunction);
  }
  module2.exports.publicAddressesFirst = publicAddressesFirst;
});

// node_modules/p-reflect/index.js
var require_p_reflect = __commonJS((exports2, module2) => {
  "use strict";
  var pReflect = async (promise) => {
    try {
      const value = await promise;
      return {
        isFulfilled: true,
        isRejected: false,
        value
      };
    } catch (error) {
      return {
        isFulfilled: false,
        isRejected: true,
        reason: error
      };
    }
  };
  module2.exports = pReflect;
  module2.exports.default = pReflect;
});

// node_modules/p-try/index.js
var require_p_try = __commonJS((exports2, module2) => {
  "use strict";
  var pTry = (fn, ...arguments_) => new Promise((resolve) => {
    resolve(fn(...arguments_));
  });
  module2.exports = pTry;
  module2.exports.default = pTry;
});

// node_modules/p-limit/index.js
var require_p_limit = __commonJS((exports2, module2) => {
  "use strict";
  var pTry = require_p_try();
  var pLimit = (concurrency) => {
    if (!((Number.isInteger(concurrency) || concurrency === Infinity) && concurrency > 0)) {
      return Promise.reject(new TypeError("Expected `concurrency` to be a number from 1 and up"));
    }
    const queue = [];
    let activeCount = 0;
    const next = () => {
      activeCount--;
      if (queue.length > 0) {
        queue.shift()();
      }
    };
    const run = (fn, resolve, ...args) => {
      activeCount++;
      const result = pTry(fn, ...args);
      resolve(result);
      result.then(next, next);
    };
    const enqueue = (fn, resolve, ...args) => {
      if (activeCount < concurrency) {
        run(fn, resolve, ...args);
      } else {
        queue.push(run.bind(null, fn, resolve, ...args));
      }
    };
    const generator = (fn, ...args) => new Promise((resolve) => enqueue(fn, resolve, ...args));
    Object.defineProperties(generator, {
      activeCount: {
        get: () => activeCount
      },
      pendingCount: {
        get: () => queue.length
      },
      clearQueue: {
        value: () => {
          queue.length = 0;
        }
      }
    });
    return generator;
  };
  module2.exports = pLimit;
  module2.exports.default = pLimit;
});

// node_modules/p-settle/index.js
var require_p_settle = __commonJS((exports2, module2) => {
  "use strict";
  var pReflect = require_p_reflect();
  var pLimit = require_p_limit();
  module2.exports = async (array, options = {}) => {
    const {concurrency = Infinity} = options;
    const limit = pLimit(concurrency);
    return Promise.all(array.map((element) => {
      if (element && typeof element.then === "function") {
        return pReflect(element);
      }
      if (typeof element === "function") {
        return pReflect(limit(() => element()));
      }
      return pReflect(Promise.resolve(element));
    }));
  };
});

// node_modules/libp2p-utils/src/array-equals.js
var require_array_equals = __commonJS((exports2, module2) => {
  "use strict";
  function arrayEquals(a, b) {
    return a.length === b.length && b.sort() && a.sort().every((item, index) => b[index].equals(item));
  }
  module2.exports = arrayEquals;
});

// node_modules/libp2p/src/record/peer-record/peer-record.proto.js
var require_peer_record_proto = __commonJS((exports2, module2) => {
  "use strict";
  var protons = require_src8();
  module2.exports = protons(`
message PeerRecord {
    // AddressInfo is a wrapper around a binary multiaddr. It is defined as a
    // separate message to allow us to add per-address metadata in the future.
    message AddressInfo {
        bytes multiaddr = 1;
    }

    // peer_id contains a libp2p peer id in its binary representation.
    bytes peer_id = 1;

    // seq contains a monotonically-increasing sequence counter to order PeerRecords in time.
    uint64 seq = 2;

    // addresses is a list of public listen addresses for the peer.
    repeated AddressInfo addresses = 3;
}
`);
});

// node_modules/libp2p/src/record/peer-record/consts.js
var require_consts2 = __commonJS((exports2, module2) => {
  "use strict";
  var multicodec = require_src6();
  var domain = multicodec.getName(multicodec.LIBP2P_PEER_RECORD) || "libp2p-peer-record";
  var payloadType = Uint8Array.from([3, 1]);
  module2.exports = {
    ENVELOPE_DOMAIN_PEER_RECORD: domain,
    ENVELOPE_PAYLOAD_TYPE_PEER_RECORD: payloadType
  };
});

// node_modules/libp2p/src/record/peer-record/index.js
var require_peer_record = __commonJS((exports2, module2) => {
  "use strict";
  var multiaddr = require_src11();
  var PeerId = require_src9();
  var arrayEquals = require_array_equals();
  var Protobuf = require_peer_record_proto();
  var {
    ENVELOPE_DOMAIN_PEER_RECORD,
    ENVELOPE_PAYLOAD_TYPE_PEER_RECORD
  } = require_consts2();
  var PeerRecord = class {
    constructor({peerId, multiaddrs = [], seqNumber = Date.now()}) {
      this.domain = ENVELOPE_DOMAIN_PEER_RECORD;
      this.codec = ENVELOPE_PAYLOAD_TYPE_PEER_RECORD;
      this.peerId = peerId;
      this.multiaddrs = multiaddrs;
      this.seqNumber = seqNumber;
      this._marshal = void 0;
    }
    marshal() {
      if (this._marshal) {
        return this._marshal;
      }
      this._marshal = Protobuf.PeerRecord.encode({
        peer_id: this.peerId.toBytes(),
        seq: this.seqNumber,
        addresses: this.multiaddrs.map((m) => ({
          multiaddr: m.bytes
        }))
      });
      return this._marshal;
    }
    equals(other) {
      if (!(other instanceof PeerRecord)) {
        return false;
      }
      if (!this.peerId.equals(other.peerId)) {
        return false;
      }
      if (this.seqNumber !== other.seqNumber) {
        return false;
      }
      if (!arrayEquals(this.multiaddrs, other.multiaddrs)) {
        return false;
      }
      return true;
    }
  };
  PeerRecord.createFromProtobuf = (buf) => {
    const peerRecord = Protobuf.PeerRecord.decode(buf);
    const peerId = PeerId.createFromBytes(peerRecord.peer_id);
    const multiaddrs = (peerRecord.addresses || []).map((a) => multiaddr(a.multiaddr));
    const seqNumber = peerRecord.seq;
    return new PeerRecord({peerId, multiaddrs, seqNumber});
  };
  PeerRecord.DOMAIN = ENVELOPE_DOMAIN_PEER_RECORD;
  module2.exports = PeerRecord;
});

// node_modules/libp2p/src/record/utils.js
var require_utils27 = __commonJS((exports2, module2) => {
  "use strict";
  var Envelope = require_envelope();
  var PeerRecord = require_peer_record();
  async function updateSelfPeerRecord(libp2p) {
    const peerRecord = new PeerRecord({
      peerId: libp2p.peerId,
      multiaddrs: libp2p.multiaddrs
    });
    const envelope = await Envelope.seal(peerRecord, libp2p.peerId);
    libp2p.peerStore.addressBook.consumePeerRecord(envelope);
  }
  module2.exports.updateSelfPeerRecord = updateSelfPeerRecord;
});

// node_modules/libp2p/src/transport-manager.js
var require_transport_manager = __commonJS((exports2, module2) => {
  "use strict";
  var debug = require_browser4();
  var log = Object.assign(debug("libp2p:transports"), {
    error: debug("libp2p:transports:err")
  });
  var pSettle = require_p_settle();
  var {codes} = require_errors12();
  var errCode = require_err_code();
  var {updateSelfPeerRecord} = require_utils27();
  var TransportManager = class {
    constructor({libp2p, upgrader, faultTolerance = FAULT_TOLERANCE.FATAL_ALL}) {
      this.libp2p = libp2p;
      this.upgrader = upgrader;
      this._transports = new Map();
      this._listeners = new Map();
      this._listenerOptions = new Map();
      this.faultTolerance = faultTolerance;
    }
    add(key, Transport, transportOptions = {}) {
      log("adding %s", key);
      if (!key) {
        throw errCode(new Error(`Transport must have a valid key, was given '${key}'`), codes.ERR_INVALID_KEY);
      }
      if (this._transports.has(key)) {
        throw errCode(new Error("There is already a transport with this key"), codes.ERR_DUPLICATE_TRANSPORT);
      }
      const transport = new Transport({
        ...transportOptions,
        libp2p: this.libp2p,
        upgrader: this.upgrader
      });
      this._transports.set(key, transport);
      this._listenerOptions.set(key, transportOptions.listenerOptions || {});
      if (!this._listeners.has(key)) {
        this._listeners.set(key, []);
      }
    }
    async close() {
      const tasks = [];
      for (const [key, listeners] of this._listeners) {
        log("closing listeners for %s", key);
        while (listeners.length) {
          const listener = listeners.pop();
          listener.removeAllListeners("listening");
          listener.removeAllListeners("close");
          tasks.push(listener.close());
        }
      }
      await Promise.all(tasks);
      log("all listeners closed");
      for (const key of this._listeners.keys()) {
        this._listeners.set(key, []);
      }
    }
    async dial(ma, options) {
      const transport = this.transportForMultiaddr(ma);
      if (!transport) {
        throw errCode(new Error(`No transport available for address ${String(ma)}`), codes.ERR_TRANSPORT_UNAVAILABLE);
      }
      try {
        return await transport.dial(ma, options);
      } catch (err) {
        if (!err.code)
          err.code = codes.ERR_TRANSPORT_DIAL_FAILED;
        throw err;
      }
    }
    getAddrs() {
      let addrs = [];
      for (const listeners of this._listeners.values()) {
        for (const listener of listeners) {
          addrs = [...addrs, ...listener.getAddrs()];
        }
      }
      return addrs;
    }
    getTransports() {
      return this._transports.values();
    }
    transportForMultiaddr(ma) {
      for (const transport of this._transports.values()) {
        const addrs = transport.filter([ma]);
        if (addrs.length)
          return transport;
      }
      return null;
    }
    async listen(addrs) {
      if (!addrs || addrs.length === 0) {
        log("no addresses were provided for listening, this node is dial only");
        return;
      }
      const couldNotListen = [];
      for (const [key, transport] of this._transports.entries()) {
        const supportedAddrs = transport.filter(addrs);
        const tasks = [];
        for (const addr of supportedAddrs) {
          log("creating listener for %s on %s", key, addr);
          const listener = transport.createListener(this._listenerOptions.get(key));
          this._listeners.get(key).push(listener);
          listener.on("listening", () => updateSelfPeerRecord(this.libp2p));
          listener.on("close", () => updateSelfPeerRecord(this.libp2p));
          tasks.push(listener.listen(addr));
        }
        if (tasks.length === 0) {
          couldNotListen.push(key);
          continue;
        }
        const results = await pSettle(tasks);
        const isListening = results.find((r) => r.isFulfilled === true);
        if (!isListening) {
          throw errCode(new Error(`Transport (${key}) could not listen on any available address`), codes.ERR_NO_VALID_ADDRESSES);
        }
      }
      if (couldNotListen.length === this._transports.size) {
        const message = `no valid addresses were provided for transports [${couldNotListen}]`;
        if (this.faultTolerance === FAULT_TOLERANCE.FATAL_ALL) {
          throw errCode(new Error(message), codes.ERR_NO_VALID_ADDRESSES);
        }
        log(`libp2p in dial mode only: ${message}`);
      }
    }
    async remove(key) {
      log("removing %s", key);
      if (this._listeners.has(key)) {
        for (const listener of this._listeners.get(key)) {
          listener.removeAllListeners("listening");
          listener.removeAllListeners("close");
          await listener.close();
        }
      }
      this._transports.delete(key);
      this._listeners.delete(key);
    }
    async removeAll() {
      const tasks = [];
      for (const key of this._transports.keys()) {
        tasks.push(this.remove(key));
      }
      await Promise.all(tasks);
    }
  };
  var FAULT_TOLERANCE = {
    FATAL_ALL: 0,
    NO_FATAL: 1
  };
  TransportManager.FaultTolerance = FAULT_TOLERANCE;
  module2.exports = TransportManager;
});

// node_modules/libp2p/src/config.js
var require_config4 = __commonJS((exports2, module2) => {
  "use strict";
  var mergeOptions = require_merge_options();
  var {dnsaddrResolver} = require_resolvers2();
  var Constants = require_constants10();
  var {AGENT_VERSION} = require_consts();
  var RelayConstants = require_constants11();
  var {publicAddressesFirst} = require_address_sort();
  var {FaultTolerance} = require_transport_manager();
  var DefaultConfig = {
    addresses: {
      listen: [],
      announce: [],
      noAnnounce: []
    },
    connectionManager: {
      minConnections: 25
    },
    transportManager: {
      faultTolerance: FaultTolerance.FATAL_ALL
    },
    dialer: {
      maxParallelDials: Constants.MAX_PARALLEL_DIALS,
      maxDialsPerPeer: Constants.MAX_PER_PEER_DIALS,
      dialTimeout: Constants.DIAL_TIMEOUT,
      resolvers: {
        dnsaddr: dnsaddrResolver
      },
      addressSorter: publicAddressesFirst
    },
    host: {
      agentVersion: AGENT_VERSION
    },
    metrics: {
      enabled: false
    },
    peerStore: {
      persistence: false,
      threshold: 5
    },
    peerRouting: {
      refreshManager: {
        enabled: true,
        interval: 6e5,
        bootDelay: 1e4
      }
    },
    config: {
      dht: {
        enabled: false,
        kBucketSize: 20,
        randomWalk: {
          enabled: false,
          queriesPerPeriod: 1,
          interval: 3e5,
          timeout: 1e4
        }
      },
      nat: {
        enabled: true,
        ttl: 7200,
        keepAlive: true,
        gateway: null,
        externalIp: null,
        pmp: {
          enabled: false
        }
      },
      peerDiscovery: {
        autoDial: true
      },
      pubsub: {
        enabled: true
      },
      relay: {
        enabled: true,
        advertise: {
          bootDelay: RelayConstants.ADVERTISE_BOOT_DELAY,
          enabled: false,
          ttl: RelayConstants.ADVERTISE_TTL
        },
        hop: {
          enabled: false,
          active: false
        },
        autoRelay: {
          enabled: false,
          maxListeners: 2
        }
      },
      transport: {}
    }
  };
  module2.exports.validate = (opts) => {
    opts = mergeOptions(DefaultConfig, opts);
    if (opts.modules.transport.length < 1)
      throw new Error("'options.modules.transport' must contain at least 1 transport");
    return opts;
  };
});

// node_modules/libp2p/src/address-manager/index.js
var require_address_manager = __commonJS((exports2, module2) => {
  "use strict";
  var EventEmitter = require_events();
  var multiaddr = require_src11();
  var PeerId = require_src9();
  var AddressManager = class extends EventEmitter {
    constructor(peerId, {listen = [], announce = []} = {}) {
      super();
      this.peerId = peerId;
      this.listen = new Set(listen.map((ma) => ma.toString()));
      this.announce = new Set(announce.map((ma) => ma.toString()));
      this.observed = new Set();
    }
    getListenAddrs() {
      return Array.from(this.listen).map((a) => multiaddr(a));
    }
    getAnnounceAddrs() {
      return Array.from(this.announce).map((a) => multiaddr(a));
    }
    getObservedAddrs() {
      return Array.from(this.observed).map((a) => multiaddr(a));
    }
    addObservedAddr(addr) {
      let ma = multiaddr(addr);
      const remotePeer = ma.getPeerId();
      if (remotePeer) {
        const remotePeerId = PeerId.createFromB58String(remotePeer);
        if (remotePeerId.equals(this.peerId)) {
          ma = ma.decapsulate(multiaddr(`/p2p/${this.peerId}`));
        }
      }
      const addrString = ma.toString();
      if (this.observed.has(addrString)) {
        return;
      }
      this.observed.add(addrString);
      this.emit("change:addresses");
    }
  };
  module2.exports = AddressManager;
});

// node_modules/libp2p/src/connection-manager/visibility-change-emitter.js
var require_visibility_change_emitter = __commonJS((exports2, module2) => {
  "use strict";
  var EventEmitter = require_events();
  var debug = require_browser4()("latency-monitor:VisibilityChangeEmitter");
  var VisibilityChangeEmitter = class extends EventEmitter {
    constructor() {
      super();
      if (typeof document === "undefined") {
        debug('This is not a browser, no "document" found. Stopping.');
        return;
      }
      this._initializeVisibilityVarNames();
      this._addVisibilityChangeListener();
    }
    _initializeVisibilityVarNames() {
      let hidden;
      let visibilityChange;
      if (typeof document.hidden !== "undefined") {
        hidden = "hidden";
        visibilityChange = "visibilitychange";
      } else if (typeof document.mozHidden !== "undefined") {
        hidden = "mozHidden";
        visibilityChange = "mozvisibilitychange";
      } else if (typeof document.msHidden !== "undefined") {
        hidden = "msHidden";
        visibilityChange = "msvisibilitychange";
      } else if (typeof document.webkitHidden !== "undefined") {
        hidden = "webkitHidden";
        visibilityChange = "webkitvisibilitychange";
      }
      this._hidden = hidden;
      this._visibilityChange = visibilityChange;
    }
    _addVisibilityChangeListener() {
      if (typeof document.addEventListener === "undefined" || typeof document[this._hidden] === "undefined") {
        debug("Checking page visibility requires a browser that supports the Page Visibility API.");
      } else {
        document.addEventListener(this._visibilityChange, this._handleVisibilityChange.bind(this), false);
      }
    }
    isVisible() {
      if (this._hidden === void 0 || document[this._hidden] === void 0) {
        return void 0;
      }
      return !document[this._hidden];
    }
    _handleVisibilityChange() {
      const visible = !document[this._hidden];
      debug(visible ? "Page Visible" : "Page Hidden");
      this.emit("visibilityChange", visible);
    }
  };
  module2.exports = VisibilityChangeEmitter;
});

// node_modules/libp2p/src/connection-manager/latency-monitor.js
var require_latency_monitor = __commonJS((exports2, module2) => {
  "use strict";
  var EventEmitter = require_events();
  var VisibilityChangeEmitter = require_visibility_change_emitter();
  var debug = require_browser4()("latency-monitor:LatencyMonitor");
  var LatencyMonitor = class extends EventEmitter {
    constructor({latencyCheckIntervalMs, dataEmitIntervalMs, asyncTestFn, latencyRandomPercentage} = {}) {
      super();
      const that = this;
      that.latencyCheckIntervalMs = latencyCheckIntervalMs || 500;
      that.latencyRandomPercentage = latencyRandomPercentage || 10;
      that._latecyCheckMultiply = 2 * (that.latencyRandomPercentage / 100) * that.latencyCheckIntervalMs;
      that._latecyCheckSubtract = that._latecyCheckMultiply / 2;
      that.dataEmitIntervalMs = dataEmitIntervalMs === null || dataEmitIntervalMs === 0 ? void 0 : dataEmitIntervalMs || 5 * 1e3;
      debug("latencyCheckIntervalMs: %s dataEmitIntervalMs: %s", that.latencyCheckIntervalMs, that.dataEmitIntervalMs);
      if (that.dataEmitIntervalMs) {
        debug("Expecting ~%s events per summary", that.latencyCheckIntervalMs / that.dataEmitIntervalMs);
      } else {
        debug("Not emitting summaries");
      }
      that.asyncTestFn = asyncTestFn;
      if (globalThis.process && globalThis.process.hrtime) {
        debug("Using process.hrtime for timing");
        that.now = globalThis.process.hrtime;
        that.getDeltaMS = (startTime) => {
          const hrtime = that.now(startTime);
          return hrtime[0] * 1e3 + hrtime[1] / 1e6;
        };
      } else if (typeof window !== "undefined" && window.performance && window.performance.now) {
        debug("Using performance.now for timing");
        that.now = window.performance.now.bind(window.performance);
        that.getDeltaMS = (startTime) => Math.round(that.now() - startTime);
      } else {
        debug("Using Date.now for timing");
        that.now = Date.now;
        that.getDeltaMS = (startTime) => that.now() - startTime;
      }
      that._latencyData = that._initLatencyData();
      if (isBrowser()) {
        that._visibilityChangeEmitter = new VisibilityChangeEmitter();
        that._visibilityChangeEmitter.on("visibilityChange", (pageInFocus) => {
          if (pageInFocus) {
            that._startTimers();
          } else {
            that._emitSummary();
            that._stopTimers();
          }
        });
      }
      if (!that._visibilityChangeEmitter || that._visibilityChangeEmitter.isVisible()) {
        that._startTimers();
      }
    }
    _startTimers() {
      if (this._checkLatencyID) {
        return;
      }
      this._checkLatency();
      if (this.dataEmitIntervalMs) {
        this._emitIntervalID = setInterval(() => this._emitSummary(), this.dataEmitIntervalMs);
        if (typeof this._emitIntervalID.unref === "function") {
          this._emitIntervalID.unref();
        }
      }
    }
    _stopTimers() {
      if (this._checkLatencyID) {
        clearTimeout(this._checkLatencyID);
        this._checkLatencyID = void 0;
      }
      if (this._emitIntervalID) {
        clearInterval(this._emitIntervalID);
        this._emitIntervalID = void 0;
      }
    }
    _emitSummary() {
      const summary = this.getSummary();
      if (summary.events > 0) {
        this.emit("data", summary);
      }
    }
    getSummary() {
      const latency = {
        events: this._latencyData.events,
        minMs: this._latencyData.minMs,
        maxMs: this._latencyData.maxMs,
        avgMs: this._latencyData.events ? this._latencyData.totalMs / this._latencyData.events : Number.POSITIVE_INFINITY,
        lengthMs: this.getDeltaMS(this._latencyData.startTime)
      };
      this._latencyData = this._initLatencyData();
      debug("Summary: %O", latency);
      return latency;
    }
    _checkLatency() {
      const that = this;
      const randomness = Math.random() * that._latecyCheckMultiply - that._latecyCheckSubtract;
      const localData = {
        deltaOffset: Math.ceil(that.latencyCheckIntervalMs + randomness),
        startTime: that.now()
      };
      const cb = () => {
        if (!this._checkLatencyID) {
          return;
        }
        const deltaMS = that.getDeltaMS(localData.startTime) - localData.deltaOffset;
        that._checkLatency();
        that._latencyData.events++;
        that._latencyData.minMs = Math.min(that._latencyData.minMs, deltaMS);
        that._latencyData.maxMs = Math.max(that._latencyData.maxMs, deltaMS);
        that._latencyData.totalMs += deltaMS;
        debug("MS: %s Data: %O", deltaMS, that._latencyData);
      };
      debug("localData: %O", localData);
      this._checkLatencyID = setTimeout(() => {
        if (that.asyncTestFn) {
          localData.deltaOffset = 0;
          localData.startTime = that.now();
          that.asyncTestFn(cb);
        } else {
          localData.deltaOffset -= 1;
          cb();
        }
      }, localData.deltaOffset);
      if (typeof this._checkLatencyID.unref === "function") {
        this._checkLatencyID.unref();
      }
    }
    _initLatencyData() {
      return {
        startTime: this.now(),
        minMs: Number.POSITIVE_INFINITY,
        maxMs: Number.NEGATIVE_INFINITY,
        events: 0,
        totalMs: 0
      };
    }
  };
  function isBrowser() {
    return typeof window !== "undefined";
  }
  module2.exports = LatencyMonitor;
});

// node_modules/libp2p/src/connection-manager/index.js
var require_connection_manager = __commonJS((exports2, module2) => {
  "use strict";
  var debug = require_browser4();
  var log = Object.assign(debug("libp2p:connection-manager"), {
    error: debug("libp2p:connection-manager:err")
  });
  var errcode = require_err_code();
  var mergeOptions = require_merge_options();
  var LatencyMonitor = require_latency_monitor();
  var retimer = require_retimer();
  var EventEmitter = require_events();
  var PeerId = require_src9();
  var {
    codes: {ERR_INVALID_PARAMETERS}
  } = require_errors12();
  var defaultOptions = {
    maxConnections: Infinity,
    minConnections: 0,
    maxData: Infinity,
    maxSentData: Infinity,
    maxReceivedData: Infinity,
    maxEventLoopDelay: Infinity,
    pollInterval: 2e3,
    autoDialInterval: 1e4,
    movingAverageInterval: 6e4,
    defaultPeerValue: 1
  };
  var ConnectionManager = class extends EventEmitter {
    constructor(libp2p, options = {}) {
      super();
      this._libp2p = libp2p;
      this._peerId = libp2p.peerId.toB58String();
      this._options = mergeOptions.call({ignoreUndefined: true}, defaultOptions, options);
      if (this._options.maxConnections < this._options.minConnections) {
        throw errcode(new Error("Connection Manager maxConnections must be greater than minConnections"), ERR_INVALID_PARAMETERS);
      }
      log("options: %j", this._options);
      this._peerValues = new Map();
      this.connections = new Map();
      this._started = false;
      this._timer = null;
      this._autoDialTimeout = null;
      this._checkMetrics = this._checkMetrics.bind(this);
      this._autoDial = this._autoDial.bind(this);
    }
    get size() {
      return Array.from(this.connections.values()).reduce((accumulator, value) => accumulator + value.length, 0);
    }
    start() {
      if (this._libp2p.metrics) {
        this._timer = this._timer || retimer(this._checkMetrics, this._options.pollInterval);
      }
      this._latencyMonitor = new LatencyMonitor({
        latencyCheckIntervalMs: this._options.pollInterval,
        dataEmitIntervalMs: this._options.pollInterval
      });
      this._onLatencyMeasure = this._onLatencyMeasure.bind(this);
      this._latencyMonitor.on("data", this._onLatencyMeasure);
      this._started = true;
      log("started");
      this._options.autoDial && this._autoDial();
    }
    async stop() {
      this._autoDialTimeout && this._autoDialTimeout.clear();
      this._timer && this._timer.clear();
      this._latencyMonitor && this._latencyMonitor.removeListener("data", this._onLatencyMeasure);
      this._started = false;
      await this._close();
      log("stopped");
    }
    async _close() {
      const tasks = [];
      for (const connectionList of this.connections.values()) {
        for (const connection of connectionList) {
          tasks.push(connection.close());
        }
      }
      await Promise.all(tasks);
      this.connections.clear();
    }
    setPeerValue(peerId, value) {
      if (value < 0 || value > 1) {
        throw new Error("value should be a number between 0 and 1");
      }
      this._peerValues.set(peerId.toB58String(), value);
    }
    _checkMetrics() {
      if (this._libp2p.metrics) {
        const movingAverages = this._libp2p.metrics.global.movingAverages;
        const received = movingAverages.dataReceived[this._options.movingAverageInterval].movingAverage();
        this._checkMaxLimit("maxReceivedData", received);
        const sent = movingAverages.dataSent[this._options.movingAverageInterval].movingAverage();
        this._checkMaxLimit("maxSentData", sent);
        const total = received + sent;
        this._checkMaxLimit("maxData", total);
        log("metrics update", total);
        this._timer = retimer(this._checkMetrics, this._options.pollInterval);
      }
    }
    onConnect(connection) {
      const peerId = connection.remotePeer;
      const peerIdStr = peerId.toB58String();
      const storedConn = this.connections.get(peerIdStr);
      this.emit("peer:connect", connection);
      if (storedConn) {
        storedConn.push(connection);
      } else {
        this.connections.set(peerIdStr, [connection]);
      }
      this._libp2p.peerStore.keyBook.set(peerId, peerId.pubKey);
      if (!this._peerValues.has(peerIdStr)) {
        this._peerValues.set(peerIdStr, this._options.defaultPeerValue);
      }
      this._checkMaxLimit("maxConnections", this.size);
    }
    onDisconnect(connection) {
      const peerId = connection.remotePeer.toB58String();
      let storedConn = this.connections.get(peerId);
      if (storedConn && storedConn.length > 1) {
        storedConn = storedConn.filter((conn) => conn.id !== connection.id);
        this.connections.set(peerId, storedConn);
      } else if (storedConn) {
        this.connections.delete(peerId);
        this._peerValues.delete(connection.remotePeer.toB58String());
        this.emit("peer:disconnect", connection);
      }
    }
    get(peerId) {
      const connections = this.getAll(peerId);
      if (connections.length) {
        return connections[0];
      }
      return null;
    }
    getAll(peerId) {
      if (!PeerId.isPeerId(peerId)) {
        throw errcode(new Error("peerId must be an instance of peer-id"), ERR_INVALID_PARAMETERS);
      }
      const id = peerId.toB58String();
      const connections = this.connections.get(id);
      if (connections) {
        return connections.filter((connection) => connection.stat.status === "open");
      }
      return [];
    }
    _onLatencyMeasure(summary) {
      this._checkMaxLimit("maxEventLoopDelay", summary.avgMs);
    }
    _checkMaxLimit(name, value) {
      const limit = this._options[name];
      log("checking limit of %s. current value: %d of %d", name, value, limit);
      if (value > limit) {
        log("%s: limit exceeded: %s, %d", this._peerId, name, value);
        this._maybeDisconnectOne();
      }
    }
    async _autoDial() {
      const minConnections = this._options.minConnections;
      if (this.size >= minConnections) {
        this._autoDialTimeout = retimer(this._autoDial, this._options.autoDialInterval);
        return;
      }
      const peers = Array.from(this._libp2p.peerStore.peers.values()).sort((a, b) => {
        if (b.protocols && b.protocols.length && (!a.protocols || !a.protocols.length)) {
          return 1;
        } else if (b.id.pubKey && !a.id.pubKey) {
          return 1;
        }
        return -1;
      });
      for (let i = 0; i < peers.length && this.size < minConnections; i++) {
        if (!this.get(peers[i].id)) {
          log("connecting to a peerStore stored peer %s", peers[i].id.toB58String());
          try {
            await this._libp2p.dialer.connectToPeer(peers[i].id);
            if (!this._started) {
              return;
            }
          } catch (err) {
            log.error("could not connect to peerStore stored peer", err);
          }
        }
      }
      this._autoDialTimeout = retimer(this._autoDial, this._options.autoDialInterval);
    }
    _maybeDisconnectOne() {
      if (this._options.minConnections < this.connections.size) {
        const peerValues = Array.from(this._peerValues).sort(byPeerValue);
        log("%s: sorted peer values: %j", this._peerId, peerValues);
        const disconnectPeer = peerValues[0];
        if (disconnectPeer) {
          const peerId = disconnectPeer[0];
          log("%s: lowest value peer is %s", this._peerId, peerId);
          log("%s: closing a connection to %j", this._peerId, peerId);
          for (const connections of this.connections.values()) {
            if (connections[0].remotePeer.toB58String() === peerId) {
              connections[0].close();
              break;
            }
          }
        }
      }
    }
  };
  module2.exports = ConnectionManager;
  function byPeerValue(peerValueEntryA, peerValueEntryB) {
    return peerValueEntryA[1] - peerValueEntryB[1];
  }
});

// node_modules/libp2p/src/circuit/protocol/index.js
var require_protocol = __commonJS((exports2, module2) => {
  "use strict";
  var protobuf = require_src8();
  module2.exports = protobuf(`
message CircuitRelay {

  enum Status {
    SUCCESS                    = 100;
    HOP_SRC_ADDR_TOO_LONG      = 220;
    HOP_DST_ADDR_TOO_LONG      = 221;
    HOP_SRC_MULTIADDR_INVALID  = 250;
    HOP_DST_MULTIADDR_INVALID  = 251;
    HOP_NO_CONN_TO_DST         = 260;
    HOP_CANT_DIAL_DST          = 261;
    HOP_CANT_OPEN_DST_STREAM   = 262;
    HOP_CANT_SPEAK_RELAY       = 270;
    HOP_CANT_RELAY_TO_SELF     = 280;
    STOP_SRC_ADDR_TOO_LONG     = 320;
    STOP_DST_ADDR_TOO_LONG     = 321;
    STOP_SRC_MULTIADDR_INVALID = 350;
    STOP_DST_MULTIADDR_INVALID = 351;
    STOP_RELAY_REFUSED         = 390;
    MALFORMED_MESSAGE          = 400;
  }

  enum Type { // RPC identifier, either HOP, STOP or STATUS
    HOP = 1;
    STOP = 2;
    STATUS = 3;
    CAN_HOP = 4;
  }

  message Peer {
    required bytes id = 1;    // peer id
    repeated bytes addrs = 2; // peer's known addresses
  }

  optional Type type = 1;     // Type of the message

  optional Peer srcPeer = 2;  // srcPeer and dstPeer are used when Type is HOP or STATUS
  optional Peer dstPeer = 3;

  optional Status code = 4;   // Status code, used when Type is STATUS
}
`);
});

// node_modules/libp2p-utils/src/stream-to-ma-conn.js
var require_stream_to_ma_conn = __commonJS((exports2, module2) => {
  "use strict";
  var abortable = require_abortable_iterator();
  var log = require_browser4()("libp2p:stream:converter");
  function streamToMaConnection({stream, remoteAddr, localAddr}, options = {}) {
    const {sink, source} = stream;
    const maConn = {
      async sink(source2) {
        if (options.signal) {
          source2 = abortable(source2, options.signal);
        }
        try {
          await sink(source2);
        } catch (err) {
          if (err.type !== "aborted") {
            log(err);
          }
        }
        close();
      },
      source: options.signal ? abortable(source, options.signal) : source,
      conn: stream,
      localAddr,
      remoteAddr,
      timeline: {open: Date.now()},
      close() {
        sink([]);
        close();
      }
    };
    function close() {
      if (!maConn.timeline.close) {
        maConn.timeline.close = Date.now();
      }
    }
    return maConn;
  }
  module2.exports = streamToMaConnection;
});

// node_modules/libp2p/src/circuit/multicodec.js
var require_multicodec = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = {
    relay: "/libp2p/circuit/relay/0.1.0"
  };
});

// node_modules/libp2p/src/circuit/listener.js
var require_listener = __commonJS((exports2, module2) => {
  "use strict";
  var {EventEmitter} = require_events();
  var multiaddr = require_src11();
  module2.exports = (libp2p) => {
    const listeningAddrs = new Map();
    async function listen(addr) {
      const addrString = String(addr).split("/p2p-circuit").find((a) => a !== "");
      const relayConn = await libp2p.dial(multiaddr(addrString));
      const relayedAddr = relayConn.remoteAddr.encapsulate("/p2p-circuit");
      listeningAddrs.set(relayConn.remotePeer.toB58String(), relayedAddr);
      listener.emit("listening");
    }
    function getAddrs() {
      const addrs = [];
      for (const addr of listeningAddrs.values()) {
        addrs.push(addr);
      }
      return addrs;
    }
    const listener = Object.assign(new EventEmitter(), {
      close: () => Promise.resolve(),
      listen,
      getAddrs
    });
    libp2p.connectionManager.on("peer:disconnect", (connection) => {
      const deleted = listeningAddrs.delete(connection.remotePeer.toB58String());
      if (deleted) {
        listener.emit("close");
      }
    });
    return listener;
  };
});

// node_modules/libp2p/src/circuit/circuit/utils.js
var require_utils28 = __commonJS((exports2, module2) => {
  "use strict";
  var multiaddr = require_src11();
  var {CircuitRelay} = require_protocol();
  function writeResponse(streamHandler, status) {
    streamHandler.write({
      type: CircuitRelay.Type.STATUS,
      code: status
    });
  }
  function validateAddrs(msg, streamHandler) {
    try {
      msg.dstPeer.addrs.forEach((addr) => {
        return multiaddr(addr);
      });
    } catch (err) {
      writeResponse(streamHandler, msg.type === CircuitRelay.Type.HOP ? CircuitRelay.Status.HOP_DST_MULTIADDR_INVALID : CircuitRelay.Status.STOP_DST_MULTIADDR_INVALID);
      throw err;
    }
    try {
      msg.srcPeer.addrs.forEach((addr) => {
        return multiaddr(addr);
      });
    } catch (err) {
      writeResponse(streamHandler, msg.type === CircuitRelay.Type.HOP ? CircuitRelay.Status.HOP_SRC_MULTIADDR_INVALID : CircuitRelay.Status.STOP_SRC_MULTIADDR_INVALID);
      throw err;
    }
  }
  module2.exports = {
    validateAddrs
  };
});

// node_modules/it-reader/index.js
var require_it_reader = __commonJS((exports2, module2) => {
  var BufferList = require_BufferList();
  module2.exports = (source) => {
    const reader = async function* () {
      let bytes = yield;
      let bl = new BufferList();
      for await (const chunk of source) {
        if (!bytes) {
          bytes = yield bl.append(chunk);
          bl = new BufferList();
          continue;
        }
        bl.append(chunk);
        while (bl.length >= bytes) {
          const data = bl.shallowSlice(0, bytes);
          bl.consume(bytes);
          bytes = yield data;
          if (!bytes) {
            if (bl.length) {
              bytes = yield bl;
              bl = new BufferList();
            }
            break;
          }
        }
      }
      if (bytes) {
        throw Object.assign(new Error(`stream ended before ${bytes} bytes became available`), {code: "ERR_UNDER_READ", buffer: bl});
      }
    }();
    reader.next();
    return reader;
  };
});

// node_modules/p-defer/index.js
var require_p_defer = __commonJS((exports2, module2) => {
  "use strict";
  var pDefer = () => {
    const deferred = {};
    deferred.promise = new Promise((resolve, reject) => {
      deferred.resolve = resolve;
      deferred.reject = reject;
    });
    return deferred;
  };
  module2.exports = pDefer;
});

// node_modules/it-handshake/src/index.js
var require_src42 = __commonJS((exports2, module2) => {
  "use strict";
  var Reader = require_it_reader();
  var Writer = require_it_pushable();
  var defer = require_p_defer();
  module2.exports = (stream) => {
    const writer = Writer();
    const reader = Reader(stream.source);
    const sourcePromise = defer();
    let sinkErr;
    const sinkPromise = stream.sink(async function* () {
      yield* writer;
      const source = await sourcePromise.promise;
      yield* source;
    }());
    sinkPromise.catch((err) => {
      sinkErr = err;
    });
    const rest = {
      sink: (source) => {
        if (sinkErr) {
          return Promise.reject(sinkErr);
        }
        sourcePromise.resolve(source);
        return sinkPromise;
      },
      source: reader
    };
    return {
      reader,
      writer,
      stream: rest,
      rest: () => writer.end(),
      write: writer.push,
      read: async () => {
        return (await reader.next()).value;
      }
    };
  };
});

// node_modules/libp2p/src/circuit/circuit/stream-handler.js
var require_stream_handler = __commonJS((exports2, module2) => {
  "use strict";
  var debug = require_browser4();
  var log = Object.assign(debug("libp2p:circuit:stream-handler"), {
    error: debug("libp2p:circuit:stream-handler:err")
  });
  var lp = require_src37();
  var handshake = require_src42();
  var {CircuitRelay: CircuitPB} = require_protocol();
  var StreamHandler = class {
    constructor({stream, maxLength = 4096}) {
      this.stream = stream;
      this.shake = handshake(this.stream);
      this.decoder = lp.decode.fromReader(this.shake.reader, {maxDataLength: maxLength});
    }
    async read() {
      const msg = await this.decoder.next();
      if (msg.value) {
        const value = CircuitPB.decode(msg.value.slice());
        log("read message type", value.type);
        return value;
      }
      log("read received no value, closing stream");
      this.close();
    }
    write(msg) {
      log("write message type %s", msg.type);
      this.shake.write(lp.encode.single(CircuitPB.encode(msg)));
    }
    rest() {
      this.shake.rest();
      return this.shake.stream;
    }
    end(msg) {
      this.write(msg);
      this.close();
    }
    close() {
      log("closing the stream");
      this.rest().sink([]);
    }
  };
  module2.exports = StreamHandler;
});

// node_modules/libp2p/src/circuit/circuit/stop.js
var require_stop2 = __commonJS((exports2, module2) => {
  "use strict";
  var debug = require_browser4();
  var log = Object.assign(debug("libp2p:circuit:stop"), {
    error: debug("libp2p:circuit:stop:err")
  });
  var {CircuitRelay: CircuitPB} = require_protocol();
  var multicodec = require_multicodec();
  var StreamHandler = require_stream_handler();
  var {validateAddrs} = require_utils28();
  module2.exports.handleStop = function handleStop({
    connection,
    request,
    streamHandler
  }) {
    try {
      validateAddrs(request, streamHandler);
    } catch (err) {
      return log.error("invalid stop request via peer %s", connection.remotePeer.toB58String(), err);
    }
    log("stop request is valid");
    streamHandler.write({
      type: CircuitPB.Type.STATUS,
      code: CircuitPB.Status.SUCCESS
    });
    return streamHandler.rest();
  };
  module2.exports.stop = async function stop({
    connection,
    request
  }) {
    const {stream} = await connection.newStream([multicodec.relay]);
    log("starting stop request to %s", connection.remotePeer.toB58String());
    const streamHandler = new StreamHandler({stream});
    streamHandler.write(request);
    const response = await streamHandler.read();
    if (response.code === CircuitPB.Status.SUCCESS) {
      log("stop request to %s was successful", connection.remotePeer.toB58String());
      return streamHandler.rest();
    }
    log("stop request failed with code %d", response.code);
    streamHandler.close();
  };
});

// node_modules/libp2p/src/circuit/circuit/hop.js
var require_hop = __commonJS((exports2, module2) => {
  "use strict";
  var debug = require_browser4();
  var log = Object.assign(debug("libp2p:circuit:hop"), {
    error: debug("libp2p:circuit:hop:err")
  });
  var errCode = require_err_code();
  var PeerId = require_src9();
  var {validateAddrs} = require_utils28();
  var StreamHandler = require_stream_handler();
  var {CircuitRelay: CircuitPB} = require_protocol();
  var {pipe} = require_it_pipe();
  var {codes: Errors} = require_errors12();
  var {stop} = require_stop2();
  var multicodec = require_multicodec();
  async function handleHop({
    connection,
    request,
    streamHandler,
    circuit
  }) {
    if (!circuit._options.hop.enabled) {
      log("HOP request received but we are not acting as a relay");
      return streamHandler.end({
        type: CircuitPB.Type.STATUS,
        code: CircuitPB.Status.HOP_CANT_SPEAK_RELAY
      });
    }
    try {
      validateAddrs(request, streamHandler);
    } catch (err) {
      return log.error("invalid hop request via peer %s", connection.remotePeer.toB58String(), err);
    }
    const destinationPeer = new PeerId(request.dstPeer.id);
    const destinationConnection = circuit._connectionManager.get(destinationPeer);
    if (!destinationConnection && !circuit._options.hop.active) {
      log("HOP request received but we are not connected to the destination peer");
      return streamHandler.end({
        type: CircuitPB.Type.STATUS,
        code: CircuitPB.Status.HOP_NO_CONN_TO_DST
      });
    }
    if (!destinationConnection) {
      return;
    }
    const stopRequest = {
      type: CircuitPB.Type.STOP,
      dstPeer: request.dstPeer,
      srcPeer: request.srcPeer
    };
    let destinationStream;
    try {
      destinationStream = await stop({
        connection: destinationConnection,
        request: stopRequest
      });
    } catch (err) {
      return log.error(err);
    }
    log("hop request from %s is valid", connection.remotePeer.toB58String());
    streamHandler.write({
      type: CircuitPB.Type.STATUS,
      code: CircuitPB.Status.SUCCESS
    });
    const sourceStream = streamHandler.rest();
    return pipe(sourceStream, destinationStream, sourceStream);
  }
  async function hop({
    connection,
    request
  }) {
    const {stream} = await connection.newStream([multicodec.relay]);
    const streamHandler = new StreamHandler({stream});
    streamHandler.write(request);
    const response = await streamHandler.read();
    if (response.code === CircuitPB.Status.SUCCESS) {
      log("hop request was successful");
      return streamHandler.rest();
    }
    log("hop request failed with code %d, closing stream", response.code);
    streamHandler.close();
    throw errCode(new Error(`HOP request failed with code ${response.code}`), Errors.ERR_HOP_REQUEST_FAILED);
  }
  async function canHop({
    connection
  }) {
    const {stream} = await connection.newStream([multicodec.relay]);
    const streamHandler = new StreamHandler({stream});
    streamHandler.write({
      type: CircuitPB.Type.CAN_HOP
    });
    const response = await streamHandler.read();
    await streamHandler.close();
    if (response.code !== CircuitPB.Status.SUCCESS) {
      return false;
    }
    return true;
  }
  function handleCanHop({
    connection,
    streamHandler,
    circuit
  }) {
    const canHop2 = circuit._options.hop.enabled;
    log("can hop (%s) request from %s", canHop2, connection.remotePeer.toB58String());
    streamHandler.end({
      type: CircuitPB.Type.STATUS,
      code: canHop2 ? CircuitPB.Status.SUCCESS : CircuitPB.Status.HOP_CANT_SPEAK_RELAY
    });
  }
  module2.exports = {
    handleHop,
    hop,
    canHop,
    handleCanHop
  };
});

// node_modules/libp2p/src/circuit/transport.js
var require_transport = __commonJS((exports2, module2) => {
  "use strict";
  var debug = require_browser4();
  var log = Object.assign(debug("libp2p:circuit"), {
    error: debug("libp2p:circuit:err")
  });
  var mafmt = require_src12();
  var multiaddr = require_src11();
  var PeerId = require_src9();
  var {CircuitRelay: CircuitPB} = require_protocol();
  var toConnection = require_stream_to_ma_conn();
  var {relay: multicodec} = require_multicodec();
  var createListener = require_listener();
  var {handleCanHop, handleHop, hop} = require_hop();
  var {handleStop} = require_stop2();
  var StreamHandler = require_stream_handler();
  var transportSymbol = Symbol.for("@libp2p/js-libp2p-circuit/circuit");
  var Circuit = class {
    constructor({libp2p, upgrader}) {
      this._dialer = libp2p.dialer;
      this._registrar = libp2p.registrar;
      this._connectionManager = libp2p.connectionManager;
      this._upgrader = upgrader;
      this._options = libp2p._config.relay;
      this._libp2p = libp2p;
      this.peerId = libp2p.peerId;
      this._registrar.handle(multicodec, this._onProtocol.bind(this));
    }
    async _onProtocol({connection, stream}) {
      const streamHandler = new StreamHandler({stream});
      const request = await streamHandler.read();
      if (!request) {
        return;
      }
      const circuit = this;
      let virtualConnection;
      switch (request.type) {
        case CircuitPB.Type.CAN_HOP: {
          log("received CAN_HOP request from %s", connection.remotePeer.toB58String());
          await handleCanHop({circuit, connection, streamHandler});
          break;
        }
        case CircuitPB.Type.HOP: {
          log("received HOP request from %s", connection.remotePeer.toB58String());
          virtualConnection = await handleHop({
            connection,
            request,
            streamHandler,
            circuit
          });
          break;
        }
        case CircuitPB.Type.STOP: {
          log("received STOP request from %s", connection.remotePeer.toB58String());
          virtualConnection = await handleStop({
            connection,
            request,
            streamHandler
          });
          break;
        }
        default: {
          log("Request of type %s not supported", request.type);
        }
      }
      if (virtualConnection) {
        const remoteAddr = multiaddr(request.dstPeer.addrs[0]);
        const localAddr = multiaddr(request.srcPeer.addrs[0]);
        const maConn = toConnection({
          stream: virtualConnection,
          remoteAddr,
          localAddr
        });
        const type = request.type === CircuitPB.Type.HOP ? "relay" : "inbound";
        log("new %s connection %s", type, maConn.remoteAddr);
        const conn = await this._upgrader.upgradeInbound(maConn);
        log("%s connection %s upgraded", type, maConn.remoteAddr);
        this.handler && this.handler(conn);
      }
    }
    async dial(ma, options) {
      const addrs = ma.toString().split("/p2p-circuit");
      const relayAddr = multiaddr(addrs[0]);
      const destinationAddr = multiaddr(addrs[addrs.length - 1]);
      const relayPeer = PeerId.createFromCID(relayAddr.getPeerId());
      const destinationPeer = PeerId.createFromCID(destinationAddr.getPeerId());
      let disconnectOnFailure = false;
      let relayConnection = this._connectionManager.get(relayPeer);
      if (!relayConnection) {
        relayConnection = await this._dialer.connectToPeer(relayAddr, options);
        disconnectOnFailure = true;
      }
      try {
        const virtualConnection = await hop({
          connection: relayConnection,
          request: {
            type: CircuitPB.Type.HOP,
            srcPeer: {
              id: this.peerId.toBytes(),
              addrs: this._libp2p.multiaddrs.map((addr) => addr.bytes)
            },
            dstPeer: {
              id: destinationPeer.toBytes(),
              addrs: [multiaddr(destinationAddr).bytes]
            }
          }
        });
        const localAddr = relayAddr.encapsulate(`/p2p-circuit/p2p/${this.peerId.toB58String()}`);
        const maConn = toConnection({
          stream: virtualConnection,
          remoteAddr: ma,
          localAddr
        });
        log("new outbound connection %s", maConn.remoteAddr);
        return this._upgrader.upgradeOutbound(maConn);
      } catch (err) {
        log.error("Circuit relay dial failed", err);
        disconnectOnFailure && await relayConnection.close();
        throw err;
      }
    }
    createListener(options, handler) {
      if (typeof options === "function") {
        handler = options;
        options = {};
      }
      this.handler = handler;
      return createListener(this._libp2p);
    }
    filter(multiaddrs) {
      multiaddrs = Array.isArray(multiaddrs) ? multiaddrs : [multiaddrs];
      return multiaddrs.filter((ma) => {
        return mafmt.Circuit.matches(ma);
      });
    }
    get [Symbol.toStringTag]() {
      return "Circuit";
    }
    static isTransport(other) {
      return Boolean(other && other[transportSymbol]);
    }
  };
  module2.exports = Circuit;
});

// node_modules/libp2p/src/circuit/utils.js
var require_utils29 = __commonJS((exports2, module2) => {
  "use strict";
  var CID = require_src7();
  var multihashing = require_src14();
  var TextEncoder2 = require_text_encoder();
  module2.exports.namespaceToCid = async (namespace) => {
    const bytes = new TextEncoder2().encode(namespace);
    const hash = await multihashing(bytes, "sha2-256");
    return new CID(hash);
  };
});

// node_modules/libp2p/src/circuit/auto-relay.js
var require_auto_relay = __commonJS((exports2, module2) => {
  "use strict";
  var debug = require_browser4();
  var log = Object.assign(debug("libp2p:auto-relay"), {
    error: debug("libp2p:auto-relay:err")
  });
  var uint8ArrayFromString = require_from_string2();
  var uint8ArrayToString = require_to_string2();
  var multiaddr = require_src11();
  var PeerId = require_src9();
  var {relay: multicodec} = require_multicodec();
  var {canHop} = require_hop();
  var {namespaceToCid} = require_utils29();
  var {
    CIRCUIT_PROTO_CODE,
    HOP_METADATA_KEY,
    HOP_METADATA_VALUE,
    RELAY_RENDEZVOUS_NS
  } = require_constants11();
  var AutoRelay = class {
    constructor({libp2p, maxListeners = 1}) {
      this._libp2p = libp2p;
      this._peerId = libp2p.peerId;
      this._peerStore = libp2p.peerStore;
      this._connectionManager = libp2p.connectionManager;
      this._transportManager = libp2p.transportManager;
      this._addressSorter = libp2p.dialer.addressSorter;
      this.maxListeners = maxListeners;
      this._listenRelays = new Set();
      this._onProtocolChange = this._onProtocolChange.bind(this);
      this._onPeerDisconnected = this._onPeerDisconnected.bind(this);
      this._peerStore.on("change:protocols", this._onProtocolChange);
      this._connectionManager.on("peer:disconnect", this._onPeerDisconnected);
    }
    async _onProtocolChange({peerId, protocols}) {
      const id = peerId.toB58String();
      const hasProtocol = protocols.find((protocol) => protocol === multicodec);
      if (!hasProtocol && this._listenRelays.has(id)) {
        this._removeListenRelay(id);
        return;
      } else if (!hasProtocol || this._listenRelays.has(id)) {
        return;
      }
      try {
        const connection = this._connectionManager.get(peerId);
        if (!connection) {
          return;
        }
        if (connection.remoteAddr.protoCodes().includes(CIRCUIT_PROTO_CODE)) {
          log(`relayed connection to ${id} will not be used to hop on`);
          return;
        }
        const supportsHop = await canHop({connection});
        if (supportsHop) {
          this._peerStore.metadataBook.set(peerId, HOP_METADATA_KEY, uint8ArrayFromString(HOP_METADATA_VALUE));
          await this._addListenRelay(connection, id);
        }
      } catch (err) {
        log.error(err);
      }
    }
    _onPeerDisconnected(connection) {
      const peerId = connection.remotePeer;
      const id = peerId.toB58String();
      if (!this._listenRelays.has(id)) {
        return;
      }
      this._removeListenRelay(id);
    }
    async _addListenRelay(connection, id) {
      if (this._listenRelays.size >= this.maxListeners) {
        return;
      }
      const remoteAddrs = this._peerStore.addressBook.getMultiaddrsForPeer(connection.remotePeer, this._addressSorter);
      if (!remoteAddrs || !remoteAddrs.length) {
        return;
      }
      const listenAddr = `${remoteAddrs[0].toString()}/p2p-circuit`;
      this._listenRelays.add(id);
      try {
        await this._transportManager.listen([multiaddr(listenAddr)]);
      } catch (err) {
        log.error(err);
        this._listenRelays.delete(id);
      }
    }
    _removeListenRelay(id) {
      if (this._listenRelays.delete(id)) {
        this._listenOnAvailableHopRelays([id]);
      }
    }
    async _listenOnAvailableHopRelays(peersToIgnore = []) {
      if (this._listenRelays.size >= this.maxListeners) {
        return;
      }
      const knownHopsToDial = [];
      for (const [id, metadataMap] of this._peerStore.metadataBook.data.entries()) {
        if (this._listenRelays.has(id) || peersToIgnore.includes(id)) {
          continue;
        }
        const supportsHop = metadataMap.get(HOP_METADATA_KEY);
        if (!supportsHop || uint8ArrayToString(supportsHop) !== HOP_METADATA_VALUE) {
          continue;
        }
        const peerId = PeerId.createFromCID(id);
        const connection = this._connectionManager.get(peerId);
        if (!connection) {
          knownHopsToDial.push(peerId);
          continue;
        }
        await this._addListenRelay(connection, id);
        if (this._listenRelays.size >= this.maxListeners) {
          return;
        }
      }
      for (const peerId of knownHopsToDial) {
        const connection = await this._libp2p.dial(peerId);
        await this._addListenRelay(connection, peerId.toB58String());
        if (this._listenRelays.size >= this.maxListeners) {
          return;
        }
      }
      try {
        const cid = await namespaceToCid(RELAY_RENDEZVOUS_NS);
        for await (const provider of this._libp2p.contentRouting.findProviders(cid)) {
          if (!provider.multiaddrs.length) {
            continue;
          }
          const peerId = provider.id;
          this._peerStore.addressBook.add(peerId, provider.multiaddrs);
          const connection = await this._libp2p.dial(peerId);
          await this._addListenRelay(connection, peerId.toB58String());
          if (this._listenRelays.size >= this.maxListeners) {
            return;
          }
        }
      } catch (err) {
        log.error(err);
      }
    }
  };
  module2.exports = AutoRelay;
});

// node_modules/libp2p/src/circuit/index.js
var require_circuit = __commonJS((exports2, module2) => {
  "use strict";
  var debug = require_browser4();
  var log = Object.assign(debug("libp2p:relay"), {
    error: debug("libp2p:relay:err")
  });
  var {
    setDelayedInterval,
    clearDelayedInterval
  } = require_src40();
  var AutoRelay = require_auto_relay();
  var {namespaceToCid} = require_utils29();
  var {
    ADVERTISE_BOOT_DELAY,
    ADVERTISE_TTL,
    RELAY_RENDEZVOUS_NS
  } = require_constants11();
  var Relay = class {
    constructor(libp2p) {
      this._libp2p = libp2p;
      this._options = {
        advertise: {
          bootDelay: ADVERTISE_BOOT_DELAY,
          enabled: true,
          ttl: ADVERTISE_TTL,
          ...libp2p._config.relay.advertise
        },
        ...libp2p._config.relay
      };
      this._autoRelay = this._options.autoRelay.enabled && new AutoRelay({libp2p, ...this._options.autoRelay});
      this._advertiseService = this._advertiseService.bind(this);
    }
    start() {
      const canHop = this._options.hop.enabled;
      if (canHop && this._options.advertise.enabled) {
        this._timeout = setDelayedInterval(this._advertiseService, this._options.advertise.ttl, this._options.advertise.bootDelay);
      }
    }
    stop() {
      clearDelayedInterval(this._timeout);
    }
    async _advertiseService() {
      try {
        const cid = await namespaceToCid(RELAY_RENDEZVOUS_NS);
        await this._libp2p.contentRouting.provide(cid);
      } catch (err) {
        if (err.code === "NO_ROUTERS_AVAILABLE") {
          log.error("a content router, such as a DHT, must be provided in order to advertise the relay service", err);
          this.stop();
        } else {
          log.error(err);
        }
      }
    }
  };
  module2.exports = Relay;
});

// node_modules/p-fifo/index.js
var require_p_fifo = __commonJS((exports2, module2) => {
  var Fifo = require_fast_fifo();
  var defer = require_p_defer();
  module2.exports = class PFifo {
    constructor() {
      this._buffer = new Fifo();
      this._waitingConsumers = new Fifo();
    }
    push(chunk) {
      const {promise, resolve} = defer();
      this._buffer.push({chunk, resolve});
      this._consume();
      return promise;
    }
    _consume() {
      while (!this._waitingConsumers.isEmpty() && !this._buffer.isEmpty()) {
        const nextConsumer = this._waitingConsumers.shift();
        const nextChunk = this._buffer.shift();
        nextConsumer.resolve(nextChunk.chunk);
        nextChunk.resolve();
      }
    }
    shift() {
      const {promise, resolve} = defer();
      this._waitingConsumers.push({resolve});
      this._consume();
      return promise;
    }
    isEmpty() {
      return this._buffer.isEmpty();
    }
  };
});

// node_modules/indent-string/index.js
var require_indent_string = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = (string, count = 1, options) => {
    options = {
      indent: " ",
      includeEmptyLines: false,
      ...options
    };
    if (typeof string !== "string") {
      throw new TypeError(`Expected \`input\` to be a \`string\`, got \`${typeof string}\``);
    }
    if (typeof count !== "number") {
      throw new TypeError(`Expected \`count\` to be a \`number\`, got \`${typeof count}\``);
    }
    if (typeof options.indent !== "string") {
      throw new TypeError(`Expected \`options.indent\` to be a \`string\`, got \`${typeof options.indent}\``);
    }
    if (count === 0) {
      return string;
    }
    const regex = options.includeEmptyLines ? /^/gm : /^(?!\s*$)/gm;
    return string.replace(regex, options.indent.repeat(count));
  };
});

// empty:os
var require_os = __commonJS(() => {
});

// node_modules/clean-stack/index.js
var require_clean_stack = __commonJS((exports2, module2) => {
  "use strict";
  var os = require_os();
  var extractPathRegex = /\s+at.*(?:\(|\s)(.*)\)?/;
  var pathRegex = /^(?:(?:(?:node|(?:internal\/[\w/]*|.*node_modules\/(?:babel-polyfill|pirates)\/.*)?\w+)\.js:\d+:\d+)|native)/;
  var homeDir = typeof os.homedir === "undefined" ? "" : os.homedir();
  module2.exports = (stack, options) => {
    options = Object.assign({pretty: false}, options);
    return stack.replace(/\\/g, "/").split("\n").filter((line) => {
      const pathMatches = line.match(extractPathRegex);
      if (pathMatches === null || !pathMatches[1]) {
        return true;
      }
      const match = pathMatches[1];
      if (match.includes(".app/Contents/Resources/electron.asar") || match.includes(".app/Contents/Resources/default_app.asar")) {
        return false;
      }
      return !pathRegex.test(match);
    }).filter((line) => line.trim() !== "").map((line) => {
      if (options.pretty) {
        return line.replace(extractPathRegex, (m, p1) => m.replace(p1, p1.replace(homeDir, "~")));
      }
      return line;
    }).join("\n");
  };
});

// node_modules/aggregate-error/index.js
var require_aggregate_error = __commonJS((exports2, module2) => {
  "use strict";
  var indentString = require_indent_string();
  var cleanStack = require_clean_stack();
  var cleanInternalStack = (stack) => stack.replace(/\s+at .*aggregate-error\/index.js:\d+:\d+\)?/g, "");
  var AggregateError2 = class extends Error {
    constructor(errors) {
      if (!Array.isArray(errors)) {
        throw new TypeError(`Expected input to be an Array, got ${typeof errors}`);
      }
      errors = [...errors].map((error) => {
        if (error instanceof Error) {
          return error;
        }
        if (error !== null && typeof error === "object") {
          return Object.assign(new Error(error.message), error);
        }
        return new Error(error);
      });
      let message = errors.map((error) => {
        return typeof error.stack === "string" ? cleanInternalStack(cleanStack(error.stack)) : String(error);
      }).join("\n");
      message = "\n" + indentString(message, 4);
      super(message);
      this.name = "AggregateError";
      Object.defineProperty(this, "_errors", {value: errors});
    }
    *[Symbol.iterator]() {
      for (const error of this._errors) {
        yield error;
      }
    }
  };
  module2.exports = AggregateError2;
});

// node_modules/p-cancelable/index.js
var require_p_cancelable = __commonJS((exports2, module2) => {
  "use strict";
  var CancelError = class extends Error {
    constructor(reason) {
      super(reason || "Promise was canceled");
      this.name = "CancelError";
    }
    get isCanceled() {
      return true;
    }
  };
  var PCancelable = class {
    static fn(userFn) {
      return (...arguments_) => {
        return new PCancelable((resolve, reject, onCancel) => {
          arguments_.push(onCancel);
          userFn(...arguments_).then(resolve, reject);
        });
      };
    }
    constructor(executor) {
      this._cancelHandlers = [];
      this._isPending = true;
      this._isCanceled = false;
      this._rejectOnCancel = true;
      this._promise = new Promise((resolve, reject) => {
        this._reject = reject;
        const onResolve = (value) => {
          this._isPending = false;
          resolve(value);
        };
        const onReject = (error) => {
          this._isPending = false;
          reject(error);
        };
        const onCancel = (handler) => {
          if (!this._isPending) {
            throw new Error("The `onCancel` handler was attached after the promise settled.");
          }
          this._cancelHandlers.push(handler);
        };
        Object.defineProperties(onCancel, {
          shouldReject: {
            get: () => this._rejectOnCancel,
            set: (boolean) => {
              this._rejectOnCancel = boolean;
            }
          }
        });
        return executor(onResolve, onReject, onCancel);
      });
    }
    then(onFulfilled, onRejected) {
      return this._promise.then(onFulfilled, onRejected);
    }
    catch(onRejected) {
      return this._promise.catch(onRejected);
    }
    finally(onFinally) {
      return this._promise.finally(onFinally);
    }
    cancel(reason) {
      if (!this._isPending || this._isCanceled) {
        return;
      }
      if (this._cancelHandlers.length > 0) {
        try {
          for (const handler of this._cancelHandlers) {
            handler();
          }
        } catch (error) {
          this._reject(error);
        }
      }
      this._isCanceled = true;
      if (this._rejectOnCancel) {
        this._reject(new CancelError(reason));
      }
    }
    get isCanceled() {
      return this._isCanceled;
    }
  };
  Object.setPrototypeOf(PCancelable.prototype, Promise.prototype);
  module2.exports = PCancelable;
  module2.exports.CancelError = CancelError;
});

// node_modules/p-some/index.js
var require_p_some = __commonJS((exports2, module2) => {
  "use strict";
  var AggregateError2 = require_aggregate_error();
  var PCancelable = require_p_cancelable();
  var FilterError = class extends Error {
  };
  var pSome = (iterable, options) => new PCancelable((resolve, reject, onCancel) => {
    const {
      count,
      filter = () => true
    } = options;
    if (!Number.isFinite(count)) {
      reject(new TypeError(`Expected a finite number, got ${typeof options.count}`));
      return;
    }
    const values = [];
    const errors = [];
    let elementCount = 0;
    let isSettled = false;
    const completed = new Set();
    const maybeSettle = () => {
      if (values.length === count) {
        resolve(values);
        isSettled = true;
      }
      if (elementCount - errors.length < count) {
        reject(new AggregateError2(errors));
        isSettled = true;
      }
      return isSettled;
    };
    const cancelPending = () => {
      for (const promise of iterable) {
        if (!completed.has(promise) && typeof promise.cancel === "function") {
          promise.cancel();
        }
      }
    };
    onCancel(cancelPending);
    for (const element of iterable) {
      elementCount++;
      (async () => {
        try {
          const value = await element;
          if (isSettled) {
            return;
          }
          if (!filter(value)) {
            throw new FilterError("Value does not satisfy filter");
          }
          values.push(value);
        } catch (error) {
          errors.push(error);
        } finally {
          completed.add(element);
          if (!isSettled && maybeSettle()) {
            cancelPending();
          }
        }
      })();
    }
    if (count > elementCount) {
      reject(new RangeError(`Expected input to contain at least ${options.count} items, but contains ${elementCount} items`));
      cancelPending();
    }
  });
  module2.exports = pSome;
  module2.exports.AggregateError = AggregateError2;
  module2.exports.FilterError = FilterError;
});

// node_modules/p-any/index.js
var require_p_any = __commonJS((exports2, module2) => {
  "use strict";
  var pSome = require_p_some();
  var PCancelable = require_p_cancelable();
  module2.exports = (iterable, options) => {
    const anyCancelable = pSome(iterable, {...options, count: 1});
    return PCancelable.fn(async (onCancel) => {
      onCancel(() => {
        anyCancelable.cancel();
      });
      const [value] = await anyCancelable;
      return value;
    })();
  };
  module2.exports.AggregateError = pSome.AggregateError;
});

// node_modules/libp2p/src/dialer/dial-request.js
var require_dial_request = __commonJS((exports2, module2) => {
  "use strict";
  var errCode = require_err_code();
  var AbortController = require_browser3().default;
  var {anySignal} = require_any_signal();
  var FIFO = require_p_fifo();
  var pAny = require_p_any();
  var DialRequest = class {
    constructor({
      addrs,
      dialAction,
      dialer
    }) {
      this.addrs = addrs;
      this.dialer = dialer;
      this.dialAction = dialAction;
    }
    async run(options = {}) {
      const tokens = this.dialer.getTokens(this.addrs.length);
      if (tokens.length < 1) {
        throw errCode(new Error("No dial tokens available"), "ERR_NO_DIAL_TOKENS");
      }
      const tokenHolder = new FIFO();
      tokens.forEach((token) => tokenHolder.push(token));
      const dialAbortControllers = this.addrs.map(() => new AbortController());
      let completedDials = 0;
      try {
        return await pAny(this.addrs.map(async (addr, i) => {
          const token = await tokenHolder.shift();
          let conn;
          try {
            const signal = dialAbortControllers[i].signal;
            conn = await this.dialAction(addr, {...options, signal: options.signal ? anySignal([signal, options.signal]) : signal});
            dialAbortControllers.splice(i, 1);
          } finally {
            completedDials++;
            if (this.addrs.length - completedDials >= tokens.length) {
              tokenHolder.push(token);
            } else {
              this.dialer.releaseToken(tokens.splice(tokens.indexOf(token), 1)[0]);
            }
          }
          return conn;
        }));
      } finally {
        dialAbortControllers.map((c) => c.abort());
        tokens.forEach((token) => this.dialer.releaseToken(token));
      }
    }
  };
  module2.exports = DialRequest;
});

// node_modules/libp2p/src/dialer/index.js
var require_dialer = __commonJS((exports2, module2) => {
  "use strict";
  var debug = require_browser4();
  var log = Object.assign(debug("libp2p:dialer"), {
    error: debug("libp2p:dialer:err")
  });
  var errCode = require_err_code();
  var multiaddr = require_src11();
  var TimeoutController = require_timeout_abort_controller();
  var {anySignal} = require_any_signal();
  var DialRequest = require_dial_request();
  var {publicAddressesFirst} = require_address_sort();
  var getPeer = require_get_peer();
  var {codes} = require_errors12();
  var {
    DIAL_TIMEOUT,
    MAX_PARALLEL_DIALS,
    MAX_PER_PEER_DIALS
  } = require_constants10();
  var Dialer = class {
    constructor({
      transportManager,
      peerStore,
      addressSorter = publicAddressesFirst,
      concurrency = MAX_PARALLEL_DIALS,
      timeout = DIAL_TIMEOUT,
      perPeerLimit = MAX_PER_PEER_DIALS,
      resolvers = {}
    }) {
      this.transportManager = transportManager;
      this.peerStore = peerStore;
      this.addressSorter = addressSorter;
      this.concurrency = concurrency;
      this.timeout = timeout;
      this.perPeerLimit = perPeerLimit;
      this.tokens = [...new Array(concurrency)].map((_, index) => index);
      this._pendingDials = new Map();
      for (const [key, value] of Object.entries(resolvers)) {
        multiaddr.resolvers.set(key, value);
      }
    }
    destroy() {
      for (const dial of this._pendingDials.values()) {
        try {
          dial.controller.abort();
        } catch (err) {
          log.error(err);
        }
      }
      this._pendingDials.clear();
    }
    async connectToPeer(peer, options = {}) {
      const dialTarget = await this._createDialTarget(peer);
      if (!dialTarget.addrs.length) {
        throw errCode(new Error("The dial request has no addresses"), codes.ERR_NO_VALID_ADDRESSES);
      }
      const pendingDial = this._pendingDials.get(dialTarget.id) || this._createPendingDial(dialTarget, options);
      try {
        const connection = await pendingDial.promise;
        log("dial succeeded to %s", dialTarget.id);
        return connection;
      } catch (err) {
        if (pendingDial.controller.signal.aborted) {
          err.code = codes.ERR_TIMEOUT;
        }
        log.error(err);
        throw err;
      } finally {
        pendingDial.destroy();
      }
    }
    async _createDialTarget(peer) {
      const {id, multiaddrs} = getPeer(peer);
      if (multiaddrs) {
        this.peerStore.addressBook.add(id, multiaddrs);
      }
      let knownAddrs = this.peerStore.addressBook.getMultiaddrsForPeer(id, this.addressSorter) || [];
      if (multiaddr.isMultiaddr(peer)) {
        knownAddrs = knownAddrs.filter((addr) => !peer.equals(addr));
        knownAddrs.unshift(peer);
      }
      const addrs = [];
      for (const a of knownAddrs) {
        const resolvedAddrs = await this._resolve(a);
        resolvedAddrs.forEach((ra) => addrs.push(ra));
      }
      return {
        id: id.toB58String(),
        addrs
      };
    }
    _createPendingDial(dialTarget, options = {}) {
      const dialAction = (addr, options2) => {
        if (options2.signal.aborted)
          throw errCode(new Error("already aborted"), codes.ERR_ALREADY_ABORTED);
        return this.transportManager.dial(addr, options2);
      };
      const dialRequest = new DialRequest({
        addrs: dialTarget.addrs,
        dialAction,
        dialer: this
      });
      const timeoutController = new TimeoutController(this.timeout);
      const signals = [timeoutController.signal];
      options.signal && signals.push(options.signal);
      const signal = anySignal(signals);
      const pendingDial = {
        dialRequest,
        controller: timeoutController,
        promise: dialRequest.run({...options, signal}),
        destroy: () => {
          timeoutController.clear();
          this._pendingDials.delete(dialTarget.id);
        }
      };
      this._pendingDials.set(dialTarget.id, pendingDial);
      return pendingDial;
    }
    getTokens(num) {
      const total = Math.min(num, this.perPeerLimit, this.tokens.length);
      const tokens = this.tokens.splice(0, total);
      log("%d tokens request, returning %d, %d remaining", num, total, this.tokens.length);
      return tokens;
    }
    releaseToken(token) {
      if (this.tokens.indexOf(token) > -1)
        return;
      log("token %d released", token);
      this.tokens.push(token);
    }
    async _resolve(ma) {
      const resolvableProto = ma.protoNames().includes("dnsaddr");
      if (!resolvableProto) {
        return [ma];
      }
      const resolvedMultiaddrs = await this._resolveRecord(ma);
      const recursiveMultiaddrs = await Promise.all(resolvedMultiaddrs.map((nm) => {
        return this._resolve(nm);
      }));
      const addrs = recursiveMultiaddrs.flat();
      return addrs.reduce((array, newM) => {
        if (!array.find((m) => m.equals(newM))) {
          array.push(newM);
        }
        return array;
      }, []);
    }
    async _resolveRecord(ma) {
      try {
        ma = multiaddr(ma.toString());
        const multiaddrs = await ma.resolve();
        return multiaddrs;
      } catch (_) {
        log.error(`multiaddr ${ma} could not be resolved`);
        return [];
      }
    }
  };
  module2.exports = Dialer;
});

// node_modules/truncate-utf8-bytes/lib/truncate.js
var require_truncate = __commonJS((exports2, module2) => {
  "use strict";
  function isHighSurrogate(codePoint) {
    return codePoint >= 55296 && codePoint <= 56319;
  }
  function isLowSurrogate(codePoint) {
    return codePoint >= 56320 && codePoint <= 57343;
  }
  module2.exports = function truncate(getLength, string, byteLength) {
    if (typeof string !== "string") {
      throw new Error("Input must be string");
    }
    var charLength = string.length;
    var curByteLength = 0;
    var codePoint;
    var segment;
    for (var i = 0; i < charLength; i += 1) {
      codePoint = string.charCodeAt(i);
      segment = string[i];
      if (isHighSurrogate(codePoint) && isLowSurrogate(string.charCodeAt(i + 1))) {
        i += 1;
        segment += string[i];
      }
      curByteLength += getLength(segment);
      if (curByteLength === byteLength) {
        return string.slice(0, i + 1);
      } else if (curByteLength > byteLength) {
        return string.slice(0, i - segment.length + 1);
      }
    }
    return string;
  };
});

// node_modules/utf8-byte-length/browser.js
var require_browser8 = __commonJS((exports2, module2) => {
  "use strict";
  function isHighSurrogate(codePoint) {
    return codePoint >= 55296 && codePoint <= 56319;
  }
  function isLowSurrogate(codePoint) {
    return codePoint >= 56320 && codePoint <= 57343;
  }
  module2.exports = function getByteLength(string) {
    if (typeof string !== "string") {
      throw new Error("Input must be string");
    }
    var charLength = string.length;
    var byteLength = 0;
    var codePoint = null;
    var prevCodePoint = null;
    for (var i = 0; i < charLength; i++) {
      codePoint = string.charCodeAt(i);
      if (isLowSurrogate(codePoint)) {
        if (prevCodePoint != null && isHighSurrogate(prevCodePoint)) {
          byteLength += 1;
        } else {
          byteLength += 3;
        }
      } else if (codePoint <= 127) {
        byteLength += 1;
      } else if (codePoint >= 128 && codePoint <= 2047) {
        byteLength += 2;
      } else if (codePoint >= 2048 && codePoint <= 65535) {
        byteLength += 3;
      }
      prevCodePoint = codePoint;
    }
    return byteLength;
  };
});

// node_modules/truncate-utf8-bytes/browser.js
var require_browser9 = __commonJS((exports2, module2) => {
  "use strict";
  var truncate = require_truncate();
  var getLength = require_browser8();
  module2.exports = truncate.bind(null, getLength);
});

// node_modules/sanitize-filename/index.js
var require_sanitize_filename = __commonJS((exports2, module2) => {
  "use strict";
  var truncate = require_browser9();
  var illegalRe = /[\/\?<>\\:\*\|"]/g;
  var controlRe = /[\x00-\x1f\x80-\x9f]/g;
  var reservedRe = /^\.+$/;
  var windowsReservedRe = /^(con|prn|aux|nul|com[0-9]|lpt[0-9])(\..*)?$/i;
  var windowsTrailingRe = /[\. ]+$/;
  function sanitize(input, replacement) {
    if (typeof input !== "string") {
      throw new Error("Input must be string");
    }
    var sanitized = input.replace(illegalRe, replacement).replace(controlRe, replacement).replace(reservedRe, replacement).replace(windowsReservedRe, replacement).replace(windowsTrailingRe, replacement);
    return truncate(sanitized, 255);
  }
  module2.exports = function(input, options) {
    var replacement = options && options.replacement || "";
    var output = sanitize(input, replacement);
    if (replacement === "") {
      return output;
    }
    return sanitize(output, "");
  };
});

// node_modules/node-forge/lib/pkcs7asn1.js
var require_pkcs7asn1 = __commonJS((exports2, module2) => {
  var forge = require_forge();
  require_asn1();
  require_util3();
  var asn1 = forge.asn1;
  var p7v = module2.exports = forge.pkcs7asn1 = forge.pkcs7asn1 || {};
  forge.pkcs7 = forge.pkcs7 || {};
  forge.pkcs7.asn1 = p7v;
  var contentInfoValidator = {
    name: "ContentInfo",
    tagClass: asn1.Class.UNIVERSAL,
    type: asn1.Type.SEQUENCE,
    constructed: true,
    value: [{
      name: "ContentInfo.ContentType",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.OID,
      constructed: false,
      capture: "contentType"
    }, {
      name: "ContentInfo.content",
      tagClass: asn1.Class.CONTEXT_SPECIFIC,
      type: 0,
      constructed: true,
      optional: true,
      captureAsn1: "content"
    }]
  };
  p7v.contentInfoValidator = contentInfoValidator;
  var encryptedContentInfoValidator = {
    name: "EncryptedContentInfo",
    tagClass: asn1.Class.UNIVERSAL,
    type: asn1.Type.SEQUENCE,
    constructed: true,
    value: [{
      name: "EncryptedContentInfo.contentType",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.OID,
      constructed: false,
      capture: "contentType"
    }, {
      name: "EncryptedContentInfo.contentEncryptionAlgorithm",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "EncryptedContentInfo.contentEncryptionAlgorithm.algorithm",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.OID,
        constructed: false,
        capture: "encAlgorithm"
      }, {
        name: "EncryptedContentInfo.contentEncryptionAlgorithm.parameter",
        tagClass: asn1.Class.UNIVERSAL,
        captureAsn1: "encParameter"
      }]
    }, {
      name: "EncryptedContentInfo.encryptedContent",
      tagClass: asn1.Class.CONTEXT_SPECIFIC,
      type: 0,
      capture: "encryptedContent",
      captureAsn1: "encryptedContentAsn1"
    }]
  };
  p7v.envelopedDataValidator = {
    name: "EnvelopedData",
    tagClass: asn1.Class.UNIVERSAL,
    type: asn1.Type.SEQUENCE,
    constructed: true,
    value: [{
      name: "EnvelopedData.Version",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.INTEGER,
      constructed: false,
      capture: "version"
    }, {
      name: "EnvelopedData.RecipientInfos",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SET,
      constructed: true,
      captureAsn1: "recipientInfos"
    }].concat(encryptedContentInfoValidator)
  };
  p7v.encryptedDataValidator = {
    name: "EncryptedData",
    tagClass: asn1.Class.UNIVERSAL,
    type: asn1.Type.SEQUENCE,
    constructed: true,
    value: [{
      name: "EncryptedData.Version",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.INTEGER,
      constructed: false,
      capture: "version"
    }].concat(encryptedContentInfoValidator)
  };
  var signerValidator = {
    name: "SignerInfo",
    tagClass: asn1.Class.UNIVERSAL,
    type: asn1.Type.SEQUENCE,
    constructed: true,
    value: [{
      name: "SignerInfo.version",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.INTEGER,
      constructed: false
    }, {
      name: "SignerInfo.issuerAndSerialNumber",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "SignerInfo.issuerAndSerialNumber.issuer",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        captureAsn1: "issuer"
      }, {
        name: "SignerInfo.issuerAndSerialNumber.serialNumber",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: "serial"
      }]
    }, {
      name: "SignerInfo.digestAlgorithm",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "SignerInfo.digestAlgorithm.algorithm",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.OID,
        constructed: false,
        capture: "digestAlgorithm"
      }, {
        name: "SignerInfo.digestAlgorithm.parameter",
        tagClass: asn1.Class.UNIVERSAL,
        constructed: false,
        captureAsn1: "digestParameter",
        optional: true
      }]
    }, {
      name: "SignerInfo.authenticatedAttributes",
      tagClass: asn1.Class.CONTEXT_SPECIFIC,
      type: 0,
      constructed: true,
      optional: true,
      capture: "authenticatedAttributes"
    }, {
      name: "SignerInfo.digestEncryptionAlgorithm",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      capture: "signatureAlgorithm"
    }, {
      name: "SignerInfo.encryptedDigest",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.OCTETSTRING,
      constructed: false,
      capture: "signature"
    }, {
      name: "SignerInfo.unauthenticatedAttributes",
      tagClass: asn1.Class.CONTEXT_SPECIFIC,
      type: 1,
      constructed: true,
      optional: true,
      capture: "unauthenticatedAttributes"
    }]
  };
  p7v.signedDataValidator = {
    name: "SignedData",
    tagClass: asn1.Class.UNIVERSAL,
    type: asn1.Type.SEQUENCE,
    constructed: true,
    value: [
      {
        name: "SignedData.Version",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: "version"
      },
      {
        name: "SignedData.DigestAlgorithms",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SET,
        constructed: true,
        captureAsn1: "digestAlgorithms"
      },
      contentInfoValidator,
      {
        name: "SignedData.Certificates",
        tagClass: asn1.Class.CONTEXT_SPECIFIC,
        type: 0,
        optional: true,
        captureAsn1: "certificates"
      },
      {
        name: "SignedData.CertificateRevocationLists",
        tagClass: asn1.Class.CONTEXT_SPECIFIC,
        type: 1,
        optional: true,
        captureAsn1: "crls"
      },
      {
        name: "SignedData.SignerInfos",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SET,
        capture: "signerInfos",
        optional: true,
        value: [signerValidator]
      }
    ]
  };
  p7v.recipientInfoValidator = {
    name: "RecipientInfo",
    tagClass: asn1.Class.UNIVERSAL,
    type: asn1.Type.SEQUENCE,
    constructed: true,
    value: [{
      name: "RecipientInfo.version",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.INTEGER,
      constructed: false,
      capture: "version"
    }, {
      name: "RecipientInfo.issuerAndSerial",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "RecipientInfo.issuerAndSerial.issuer",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        captureAsn1: "issuer"
      }, {
        name: "RecipientInfo.issuerAndSerial.serialNumber",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: "serial"
      }]
    }, {
      name: "RecipientInfo.keyEncryptionAlgorithm",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "RecipientInfo.keyEncryptionAlgorithm.algorithm",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.OID,
        constructed: false,
        capture: "encAlgorithm"
      }, {
        name: "RecipientInfo.keyEncryptionAlgorithm.parameter",
        tagClass: asn1.Class.UNIVERSAL,
        constructed: false,
        captureAsn1: "encParameter"
      }]
    }, {
      name: "RecipientInfo.encryptedKey",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.OCTETSTRING,
      constructed: false,
      capture: "encKey"
    }]
  };
});

// node_modules/node-forge/lib/mgf1.js
var require_mgf1 = __commonJS((exports2, module2) => {
  var forge = require_forge();
  require_util3();
  forge.mgf = forge.mgf || {};
  var mgf1 = module2.exports = forge.mgf.mgf1 = forge.mgf1 = forge.mgf1 || {};
  mgf1.create = function(md) {
    var mgf = {
      generate: function(seed, maskLen) {
        var t = new forge.util.ByteBuffer();
        var len = Math.ceil(maskLen / md.digestLength);
        for (var i = 0; i < len; i++) {
          var c = new forge.util.ByteBuffer();
          c.putInt32(i);
          md.start();
          md.update(seed + c.getBytes());
          t.putBuffer(md.digest());
        }
        t.truncate(t.length() - maskLen);
        return t.getBytes();
      }
    };
    return mgf;
  };
});

// node_modules/node-forge/lib/mgf.js
var require_mgf = __commonJS((exports2, module2) => {
  var forge = require_forge();
  require_mgf1();
  module2.exports = forge.mgf = forge.mgf || {};
  forge.mgf.mgf1 = forge.mgf1;
});

// node_modules/node-forge/lib/pss.js
var require_pss = __commonJS((exports2, module2) => {
  var forge = require_forge();
  require_random();
  require_util3();
  var pss = module2.exports = forge.pss = forge.pss || {};
  pss.create = function(options) {
    if (arguments.length === 3) {
      options = {
        md: arguments[0],
        mgf: arguments[1],
        saltLength: arguments[2]
      };
    }
    var hash = options.md;
    var mgf = options.mgf;
    var hLen = hash.digestLength;
    var salt_ = options.salt || null;
    if (typeof salt_ === "string") {
      salt_ = forge.util.createBuffer(salt_);
    }
    var sLen;
    if ("saltLength" in options) {
      sLen = options.saltLength;
    } else if (salt_ !== null) {
      sLen = salt_.length();
    } else {
      throw new Error("Salt length not specified or specific salt not given.");
    }
    if (salt_ !== null && salt_.length() !== sLen) {
      throw new Error("Given salt length does not match length of given salt.");
    }
    var prng = options.prng || forge.random;
    var pssobj = {};
    pssobj.encode = function(md, modBits) {
      var i;
      var emBits = modBits - 1;
      var emLen = Math.ceil(emBits / 8);
      var mHash = md.digest().getBytes();
      if (emLen < hLen + sLen + 2) {
        throw new Error("Message is too long to encrypt.");
      }
      var salt;
      if (salt_ === null) {
        salt = prng.getBytesSync(sLen);
      } else {
        salt = salt_.bytes();
      }
      var m_ = new forge.util.ByteBuffer();
      m_.fillWithByte(0, 8);
      m_.putBytes(mHash);
      m_.putBytes(salt);
      hash.start();
      hash.update(m_.getBytes());
      var h = hash.digest().getBytes();
      var ps = new forge.util.ByteBuffer();
      ps.fillWithByte(0, emLen - sLen - hLen - 2);
      ps.putByte(1);
      ps.putBytes(salt);
      var db = ps.getBytes();
      var maskLen = emLen - hLen - 1;
      var dbMask = mgf.generate(h, maskLen);
      var maskedDB = "";
      for (i = 0; i < maskLen; i++) {
        maskedDB += String.fromCharCode(db.charCodeAt(i) ^ dbMask.charCodeAt(i));
      }
      var mask = 65280 >> 8 * emLen - emBits & 255;
      maskedDB = String.fromCharCode(maskedDB.charCodeAt(0) & ~mask) + maskedDB.substr(1);
      return maskedDB + h + String.fromCharCode(188);
    };
    pssobj.verify = function(mHash, em, modBits) {
      var i;
      var emBits = modBits - 1;
      var emLen = Math.ceil(emBits / 8);
      em = em.substr(-emLen);
      if (emLen < hLen + sLen + 2) {
        throw new Error("Inconsistent parameters to PSS signature verification.");
      }
      if (em.charCodeAt(emLen - 1) !== 188) {
        throw new Error("Encoded message does not end in 0xBC.");
      }
      var maskLen = emLen - hLen - 1;
      var maskedDB = em.substr(0, maskLen);
      var h = em.substr(maskLen, hLen);
      var mask = 65280 >> 8 * emLen - emBits & 255;
      if ((maskedDB.charCodeAt(0) & mask) !== 0) {
        throw new Error("Bits beyond keysize not zero as expected.");
      }
      var dbMask = mgf.generate(h, maskLen);
      var db = "";
      for (i = 0; i < maskLen; i++) {
        db += String.fromCharCode(maskedDB.charCodeAt(i) ^ dbMask.charCodeAt(i));
      }
      db = String.fromCharCode(db.charCodeAt(0) & ~mask) + db.substr(1);
      var checkLen = emLen - hLen - sLen - 2;
      for (i = 0; i < checkLen; i++) {
        if (db.charCodeAt(i) !== 0) {
          throw new Error("Leftmost octets not zero as expected");
        }
      }
      if (db.charCodeAt(checkLen) !== 1) {
        throw new Error("Inconsistent PSS signature, 0x01 marker not found");
      }
      var salt = db.substr(-sLen);
      var m_ = new forge.util.ByteBuffer();
      m_.fillWithByte(0, 8);
      m_.putBytes(mHash);
      m_.putBytes(salt);
      hash.start();
      hash.update(m_.getBytes());
      var h_ = hash.digest().getBytes();
      return h === h_;
    };
    return pssobj;
  };
});

// node_modules/node-forge/lib/x509.js
var require_x509 = __commonJS((exports2, module2) => {
  var forge = require_forge();
  require_aes();
  require_asn1();
  require_des();
  require_md();
  require_mgf();
  require_oids();
  require_pem();
  require_pss();
  require_rsa();
  require_util3();
  var asn1 = forge.asn1;
  var pki = module2.exports = forge.pki = forge.pki || {};
  var oids = pki.oids;
  var _shortNames = {};
  _shortNames["CN"] = oids["commonName"];
  _shortNames["commonName"] = "CN";
  _shortNames["C"] = oids["countryName"];
  _shortNames["countryName"] = "C";
  _shortNames["L"] = oids["localityName"];
  _shortNames["localityName"] = "L";
  _shortNames["ST"] = oids["stateOrProvinceName"];
  _shortNames["stateOrProvinceName"] = "ST";
  _shortNames["O"] = oids["organizationName"];
  _shortNames["organizationName"] = "O";
  _shortNames["OU"] = oids["organizationalUnitName"];
  _shortNames["organizationalUnitName"] = "OU";
  _shortNames["E"] = oids["emailAddress"];
  _shortNames["emailAddress"] = "E";
  var publicKeyValidator = forge.pki.rsa.publicKeyValidator;
  var x509CertificateValidator = {
    name: "Certificate",
    tagClass: asn1.Class.UNIVERSAL,
    type: asn1.Type.SEQUENCE,
    constructed: true,
    value: [{
      name: "Certificate.TBSCertificate",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      captureAsn1: "tbsCertificate",
      value: [
        {
          name: "Certificate.TBSCertificate.version",
          tagClass: asn1.Class.CONTEXT_SPECIFIC,
          type: 0,
          constructed: true,
          optional: true,
          value: [{
            name: "Certificate.TBSCertificate.version.integer",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.INTEGER,
            constructed: false,
            capture: "certVersion"
          }]
        },
        {
          name: "Certificate.TBSCertificate.serialNumber",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.INTEGER,
          constructed: false,
          capture: "certSerialNumber"
        },
        {
          name: "Certificate.TBSCertificate.signature",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.SEQUENCE,
          constructed: true,
          value: [{
            name: "Certificate.TBSCertificate.signature.algorithm",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.OID,
            constructed: false,
            capture: "certinfoSignatureOid"
          }, {
            name: "Certificate.TBSCertificate.signature.parameters",
            tagClass: asn1.Class.UNIVERSAL,
            optional: true,
            captureAsn1: "certinfoSignatureParams"
          }]
        },
        {
          name: "Certificate.TBSCertificate.issuer",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.SEQUENCE,
          constructed: true,
          captureAsn1: "certIssuer"
        },
        {
          name: "Certificate.TBSCertificate.validity",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.SEQUENCE,
          constructed: true,
          value: [{
            name: "Certificate.TBSCertificate.validity.notBefore (utc)",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.UTCTIME,
            constructed: false,
            optional: true,
            capture: "certValidity1UTCTime"
          }, {
            name: "Certificate.TBSCertificate.validity.notBefore (generalized)",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.GENERALIZEDTIME,
            constructed: false,
            optional: true,
            capture: "certValidity2GeneralizedTime"
          }, {
            name: "Certificate.TBSCertificate.validity.notAfter (utc)",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.UTCTIME,
            constructed: false,
            optional: true,
            capture: "certValidity3UTCTime"
          }, {
            name: "Certificate.TBSCertificate.validity.notAfter (generalized)",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.GENERALIZEDTIME,
            constructed: false,
            optional: true,
            capture: "certValidity4GeneralizedTime"
          }]
        },
        {
          name: "Certificate.TBSCertificate.subject",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.SEQUENCE,
          constructed: true,
          captureAsn1: "certSubject"
        },
        publicKeyValidator,
        {
          name: "Certificate.TBSCertificate.issuerUniqueID",
          tagClass: asn1.Class.CONTEXT_SPECIFIC,
          type: 1,
          constructed: true,
          optional: true,
          value: [{
            name: "Certificate.TBSCertificate.issuerUniqueID.id",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.BITSTRING,
            constructed: false,
            captureBitStringValue: "certIssuerUniqueId"
          }]
        },
        {
          name: "Certificate.TBSCertificate.subjectUniqueID",
          tagClass: asn1.Class.CONTEXT_SPECIFIC,
          type: 2,
          constructed: true,
          optional: true,
          value: [{
            name: "Certificate.TBSCertificate.subjectUniqueID.id",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.BITSTRING,
            constructed: false,
            captureBitStringValue: "certSubjectUniqueId"
          }]
        },
        {
          name: "Certificate.TBSCertificate.extensions",
          tagClass: asn1.Class.CONTEXT_SPECIFIC,
          type: 3,
          constructed: true,
          captureAsn1: "certExtensions",
          optional: true
        }
      ]
    }, {
      name: "Certificate.signatureAlgorithm",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.SEQUENCE,
      constructed: true,
      value: [{
        name: "Certificate.signatureAlgorithm.algorithm",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.OID,
        constructed: false,
        capture: "certSignatureOid"
      }, {
        name: "Certificate.TBSCertificate.signature.parameters",
        tagClass: asn1.Class.UNIVERSAL,
        optional: true,
        captureAsn1: "certSignatureParams"
      }]
    }, {
      name: "Certificate.signatureValue",
      tagClass: asn1.Class.UNIVERSAL,
      type: asn1.Type.BITSTRING,
      constructed: false,
      captureBitStringValue: "certSignature"
    }]
  };
  var rsassaPssParameterValidator = {
    name: "rsapss",
    tagClass: asn1.Class.UNIVERSAL,
    type: asn1.Type.SEQUENCE,
    constructed: true,
    value: [{
      name: "rsapss.hashAlgorithm",
      tagClass: asn1.Class.CONTEXT_SPECIFIC,
      type: 0,
      constructed: true,
      value: [{
        name: "rsapss.hashAlgorithm.AlgorithmIdentifier",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Class.SEQUENCE,
        constructed: true,
        optional: true,
        value: [{
          name: "rsapss.hashAlgorithm.AlgorithmIdentifier.algorithm",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.OID,
          constructed: false,
          capture: "hashOid"
        }]
      }]
    }, {
      name: "rsapss.maskGenAlgorithm",
      tagClass: asn1.Class.CONTEXT_SPECIFIC,
      type: 1,
      constructed: true,
      value: [{
        name: "rsapss.maskGenAlgorithm.AlgorithmIdentifier",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Class.SEQUENCE,
        constructed: true,
        optional: true,
        value: [{
          name: "rsapss.maskGenAlgorithm.AlgorithmIdentifier.algorithm",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.OID,
          constructed: false,
          capture: "maskGenOid"
        }, {
          name: "rsapss.maskGenAlgorithm.AlgorithmIdentifier.params",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.SEQUENCE,
          constructed: true,
          value: [{
            name: "rsapss.maskGenAlgorithm.AlgorithmIdentifier.params.algorithm",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.OID,
            constructed: false,
            capture: "maskGenHashOid"
          }]
        }]
      }]
    }, {
      name: "rsapss.saltLength",
      tagClass: asn1.Class.CONTEXT_SPECIFIC,
      type: 2,
      optional: true,
      value: [{
        name: "rsapss.saltLength.saltLength",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Class.INTEGER,
        constructed: false,
        capture: "saltLength"
      }]
    }, {
      name: "rsapss.trailerField",
      tagClass: asn1.Class.CONTEXT_SPECIFIC,
      type: 3,
      optional: true,
      value: [{
        name: "rsapss.trailer.trailer",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Class.INTEGER,
        constructed: false,
        capture: "trailer"
      }]
    }]
  };
  var certificationRequestInfoValidator = {
    name: "CertificationRequestInfo",
    tagClass: asn1.Class.UNIVERSAL,
    type: asn1.Type.SEQUENCE,
    constructed: true,
    captureAsn1: "certificationRequestInfo",
    value: [
      {
        name: "CertificationRequestInfo.integer",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.INTEGER,
        constructed: false,
        capture: "certificationRequestInfoVersion"
      },
      {
        name: "CertificationRequestInfo.subject",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        captureAsn1: "certificationRequestInfoSubject"
      },
      publicKeyValidator,
      {
        name: "CertificationRequestInfo.attributes",
        tagClass: asn1.Class.CONTEXT_SPECIFIC,
        type: 0,
        constructed: true,
        optional: true,
        capture: "certificationRequestInfoAttributes",
        value: [{
          name: "CertificationRequestInfo.attributes",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.SEQUENCE,
          constructed: true,
          value: [{
            name: "CertificationRequestInfo.attributes.type",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.OID,
            constructed: false
          }, {
            name: "CertificationRequestInfo.attributes.value",
            tagClass: asn1.Class.UNIVERSAL,
            type: asn1.Type.SET,
            constructed: true
          }]
        }]
      }
    ]
  };
  var certificationRequestValidator = {
    name: "CertificationRequest",
    tagClass: asn1.Class.UNIVERSAL,
    type: asn1.Type.SEQUENCE,
    constructed: true,
    captureAsn1: "csr",
    value: [
      certificationRequestInfoValidator,
      {
        name: "CertificationRequest.signatureAlgorithm",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.SEQUENCE,
        constructed: true,
        value: [{
          name: "CertificationRequest.signatureAlgorithm.algorithm",
          tagClass: asn1.Class.UNIVERSAL,
          type: asn1.Type.OID,
          constructed: false,
          capture: "csrSignatureOid"
        }, {
          name: "CertificationRequest.signatureAlgorithm.parameters",
          tagClass: asn1.Class.UNIVERSAL,
          optional: true,
          captureAsn1: "csrSignatureParams"
        }]
      },
      {
        name: "CertificationRequest.signature",
        tagClass: asn1.Class.UNIVERSAL,
        type: asn1.Type.BITSTRING,
        constructed: false,
        captureBitStringValue: "csrSignature"
      }
    ]
  };
  pki.RDNAttributesAsArray = function(rdn, md) {
    var rval = [];
    var set, attr, obj;
    for (var si = 0; si < rdn.value.length; ++si) {
      set = rdn.value[si];
      for (var i = 0; i < set.value.length; ++i) {
        obj = {};
        attr = set.value[i];
        obj.type = asn1.derToOid(attr.value[0].value);
        obj.value = attr.value[1].value;
        obj.valueTagClass = attr.value[1].type;
        if (obj.type in oids) {
          obj.name = oids[obj.type];
          if (obj.name in _shortNames) {
            obj.shortName = _shortNames[obj.name];
          }
        }
        if (md) {
          md.update(obj.type);
          md.update(obj.value);
        }
        rval.push(obj);
      }
    }
    return rval;
  };
  pki.CRIAttributesAsArray = function(attributes) {
    var rval = [];
    for (var si = 0; si < attributes.length; ++si) {
      var seq = attributes[si];
      var type = asn1.derToOid(seq.value[0].value);
      var values = seq.value[1].value;
      for (var vi = 0; vi < values.length; ++vi) {
        var obj = {};
        obj.type = type;
        obj.value = values[vi].value;
        obj.valueTagClass = values[vi].type;
        if (obj.type in oids) {
          obj.name = oids[obj.type];
          if (obj.name in _shortNames) {
            obj.shortName = _shortNames[obj.name];
          }
        }
        if (obj.type === oids.extensionRequest) {
          obj.extensions = [];
          for (var ei = 0; ei < obj.value.length; ++ei) {
            obj.extensions.push(pki.certificateExtensionFromAsn1(obj.value[ei]));
          }
        }
        rval.push(obj);
      }
    }
    return rval;
  };
  function _getAttribute(obj, options) {
    if (typeof options === "string") {
      options = {shortName: options};
    }
    var rval = null;
    var attr;
    for (var i = 0; rval === null && i < obj.attributes.length; ++i) {
      attr = obj.attributes[i];
      if (options.type && options.type === attr.type) {
        rval = attr;
      } else if (options.name && options.name === attr.name) {
        rval = attr;
      } else if (options.shortName && options.shortName === attr.shortName) {
        rval = attr;
      }
    }
    return rval;
  }
  var _readSignatureParameters = function(oid, obj, fillDefaults) {
    var params = {};
    if (oid !== oids["RSASSA-PSS"]) {
      return params;
    }
    if (fillDefaults) {
      params = {
        hash: {
          algorithmOid: oids["sha1"]
        },
        mgf: {
          algorithmOid: oids["mgf1"],
          hash: {
            algorithmOid: oids["sha1"]
          }
        },
        saltLength: 20
      };
    }
    var capture = {};
    var errors = [];
    if (!asn1.validate(obj, rsassaPssParameterValidator, capture, errors)) {
      var error = new Error("Cannot read RSASSA-PSS parameter block.");
      error.errors = errors;
      throw error;
    }
    if (capture.hashOid !== void 0) {
      params.hash = params.hash || {};
      params.hash.algorithmOid = asn1.derToOid(capture.hashOid);
    }
    if (capture.maskGenOid !== void 0) {
      params.mgf = params.mgf || {};
      params.mgf.algorithmOid = asn1.derToOid(capture.maskGenOid);
      params.mgf.hash = params.mgf.hash || {};
      params.mgf.hash.algorithmOid = asn1.derToOid(capture.maskGenHashOid);
    }
    if (capture.saltLength !== void 0) {
      params.saltLength = capture.saltLength.charCodeAt(0);
    }
    return params;
  };
  pki.certificateFromPem = function(pem, computeHash, strict) {
    var msg = forge.pem.decode(pem)[0];
    if (msg.type !== "CERTIFICATE" && msg.type !== "X509 CERTIFICATE" && msg.type !== "TRUSTED CERTIFICATE") {
      var error = new Error('Could not convert certificate from PEM; PEM header type is not "CERTIFICATE", "X509 CERTIFICATE", or "TRUSTED CERTIFICATE".');
      error.headerType = msg.type;
      throw error;
    }
    if (msg.procType && msg.procType.type === "ENCRYPTED") {
      throw new Error("Could not convert certificate from PEM; PEM is encrypted.");
    }
    var obj = asn1.fromDer(msg.body, strict);
    return pki.certificateFromAsn1(obj, computeHash);
  };
  pki.certificateToPem = function(cert, maxline) {
    var msg = {
      type: "CERTIFICATE",
      body: asn1.toDer(pki.certificateToAsn1(cert)).getBytes()
    };
    return forge.pem.encode(msg, {maxline});
  };
  pki.publicKeyFromPem = function(pem) {
    var msg = forge.pem.decode(pem)[0];
    if (msg.type !== "PUBLIC KEY" && msg.type !== "RSA PUBLIC KEY") {
      var error = new Error('Could not convert public key from PEM; PEM header type is not "PUBLIC KEY" or "RSA PUBLIC KEY".');
      error.headerType = msg.type;
      throw error;
    }
    if (msg.procType && msg.procType.type === "ENCRYPTED") {
      throw new Error("Could not convert public key from PEM; PEM is encrypted.");
    }
    var obj = asn1.fromDer(msg.body);
    return pki.publicKeyFromAsn1(obj);
  };
  pki.publicKeyToPem = function(key, maxline) {
    var msg = {
      type: "PUBLIC KEY",
      body: asn1.toDer(pki.publicKeyToAsn1(key)).getBytes()
    };
    return forge.pem.encode(msg, {maxline});
  };
  pki.publicKeyToRSAPublicKeyPem = function(key, maxline) {
    var msg = {
      type: "RSA PUBLIC KEY",
      body: asn1.toDer(pki.publicKeyToRSAPublicKey(key)).getBytes()
    };
    return forge.pem.encode(msg, {maxline});
  };
  pki.getPublicKeyFingerprint = function(key, options) {
    options = options || {};
    var md = options.md || forge.md.sha1.create();
    var type = options.type || "RSAPublicKey";
    var bytes;
    switch (type) {
      case "RSAPublicKey":
        bytes = asn1.toDer(pki.publicKeyToRSAPublicKey(key)).getBytes();
        break;
      case "SubjectPublicKeyInfo":
        bytes = asn1.toDer(pki.publicKeyToAsn1(key)).getBytes();
        break;
      default:
        throw new Error('Unknown fingerprint type "' + options.type + '".');
    }
    md.start();
    md.update(bytes);
    var digest = md.digest();
    if (options.encoding === "hex") {
      var hex = digest.toHex();
      if (options.delimiter) {
        return hex.match(/.{2}/g).join(options.delimiter);
      }
      return hex;
    } else if (options.encoding === "binary") {
      return digest.getBytes();
    } else if (options.encoding) {
      throw new Error('Unknown encoding "' + options.encoding + '".');
    }
    return digest;
  };
  pki.certificationRequestFromPem = function(pem, computeHash, strict) {
    var msg = forge.pem.decode(pem)[0];
    if (msg.type !== "CERTIFICATE REQUEST") {
      var error = new Error('Could not convert certification request from PEM; PEM header type is not "CERTIFICATE REQUEST".');
      error.headerType = msg.type;
      throw error;
    }
    if (msg.procType && msg.procType.type === "ENCRYPTED") {
      throw new Error("Could not convert certification request from PEM; PEM is encrypted.");
    }
    var obj = asn1.fromDer(msg.body, strict);
    return pki.certificationRequestFromAsn1(obj, computeHash);
  };
  pki.certificationRequestToPem = function(csr, maxline) {
    var msg = {
      type: "CERTIFICATE REQUEST",
      body: asn1.toDer(pki.certificationRequestToAsn1(csr)).getBytes()
    };
    return forge.pem.encode(msg, {maxline});
  };
  pki.createCertificate = function() {
    var cert = {};
    cert.version = 2;
    cert.serialNumber = "00";
    cert.signatureOid = null;
    cert.signature = null;
    cert.siginfo = {};
    cert.siginfo.algorithmOid = null;
    cert.validity = {};
    cert.validity.notBefore = new Date();
    cert.validity.notAfter = new Date();
    cert.issuer = {};
    cert.issuer.getField = function(sn) {
      return _getAttribute(cert.issuer, sn);
    };
    cert.issuer.addField = function(attr) {
      _fillMissingFields([attr]);
      cert.issuer.attributes.push(attr);
    };
    cert.issuer.attributes = [];
    cert.issuer.hash = null;
    cert.subject = {};
    cert.subject.getField = function(sn) {
      return _getAttribute(cert.subject, sn);
    };
    cert.subject.addField = function(attr) {
      _fillMissingFields([attr]);
      cert.subject.attributes.push(attr);
    };
    cert.subject.attributes = [];
    cert.subject.hash = null;
    cert.extensions = [];
    cert.publicKey = null;
    cert.md = null;
    cert.setSubject = function(attrs, uniqueId) {
      _fillMissingFields(attrs);
      cert.subject.attributes = attrs;
      delete cert.subject.uniqueId;
      if (uniqueId) {
        cert.subject.uniqueId = uniqueId;
      }
      cert.subject.hash = null;
    };
    cert.setIssuer = function(attrs, uniqueId) {
      _fillMissingFields(attrs);
      cert.issuer.attributes = attrs;
      delete cert.issuer.uniqueId;
      if (uniqueId) {
        cert.issuer.uniqueId = uniqueId;
      }
      cert.issuer.hash = null;
    };
    cert.setExtensions = function(exts) {
      for (var i = 0; i < exts.length; ++i) {
        _fillMissingExtensionFields(exts[i], {cert});
      }
      cert.extensions = exts;
    };
    cert.getExtension = function(options) {
      if (typeof options === "string") {
        options = {name: options};
      }
      var rval = null;
      var ext;
      for (var i = 0; rval === null && i < cert.extensions.length; ++i) {
        ext = cert.extensions[i];
        if (options.id && ext.id === options.id) {
          rval = ext;
        } else if (options.name && ext.name === options.name) {
          rval = ext;
        }
      }
      return rval;
    };
    cert.sign = function(key, md) {
      cert.md = md || forge.md.sha1.create();
      var algorithmOid = oids[cert.md.algorithm + "WithRSAEncryption"];
      if (!algorithmOid) {
        var error = new Error("Could not compute certificate digest. Unknown message digest algorithm OID.");
        error.algorithm = cert.md.algorithm;
        throw error;
      }
      cert.signatureOid = cert.siginfo.algorithmOid = algorithmOid;
      cert.tbsCertificate = pki.getTBSCertificate(cert);
      var bytes = asn1.toDer(cert.tbsCertificate);
      cert.md.update(bytes.getBytes());
      cert.signature = key.sign(cert.md);
    };
    cert.verify = function(child) {
      var rval = false;
      if (!cert.issued(child)) {
        var issuer = child.issuer;
        var subject = cert.subject;
        var error = new Error("The parent certificate did not issue the given child certificate; the child certificate's issuer does not match the parent's subject.");
        error.expectedIssuer = issuer.attributes;
        error.actualIssuer = subject.attributes;
        throw error;
      }
      var md = child.md;
      if (md === null) {
        if (child.signatureOid in oids) {
          var oid = oids[child.signatureOid];
          switch (oid) {
            case "sha1WithRSAEncryption":
              md = forge.md.sha1.create();
              break;
            case "md5WithRSAEncryption":
              md = forge.md.md5.create();
              break;
            case "sha256WithRSAEncryption":
              md = forge.md.sha256.create();
              break;
            case "sha384WithRSAEncryption":
              md = forge.md.sha384.create();
              break;
            case "sha512WithRSAEncryption":
              md = forge.md.sha512.create();
              break;
            case "RSASSA-PSS":
              md = forge.md.sha256.create();
              break;
          }
        }
        if (md === null) {
          var error = new Error("Could not compute certificate digest. Unknown signature OID.");
          error.signatureOid = child.signatureOid;
          throw error;
        }
        var tbsCertificate = child.tbsCertificate || pki.getTBSCertificate(child);
        var bytes = asn1.toDer(tbsCertificate);
        md.update(bytes.getBytes());
      }
      if (md !== null) {
        var scheme;
        switch (child.signatureOid) {
          case oids.sha1WithRSAEncryption:
            scheme = void 0;
            break;
          case oids["RSASSA-PSS"]:
            var hash, mgf;
            hash = oids[child.signatureParameters.mgf.hash.algorithmOid];
            if (hash === void 0 || forge.md[hash] === void 0) {
              var error = new Error("Unsupported MGF hash function.");
              error.oid = child.signatureParameters.mgf.hash.algorithmOid;
              error.name = hash;
              throw error;
            }
            mgf = oids[child.signatureParameters.mgf.algorithmOid];
            if (mgf === void 0 || forge.mgf[mgf] === void 0) {
              var error = new Error("Unsupported MGF function.");
              error.oid = child.signatureParameters.mgf.algorithmOid;
              error.name = mgf;
              throw error;
            }
            mgf = forge.mgf[mgf].create(forge.md[hash].create());
            hash = oids[child.signatureParameters.hash.algorithmOid];
            if (hash === void 0 || forge.md[hash] === void 0) {
              throw {
                message: "Unsupported RSASSA-PSS hash function.",
                oid: child.signatureParameters.hash.algorithmOid,
                name: hash
              };
            }
            scheme = forge.pss.create(forge.md[hash].create(), mgf, child.signatureParameters.saltLength);
            break;
        }
        rval = cert.publicKey.verify(md.digest().getBytes(), child.signature, scheme);
      }
      return rval;
    };
    cert.isIssuer = function(parent) {
      var rval = false;
      var i = cert.issuer;
      var s = parent.subject;
      if (i.hash && s.hash) {
        rval = i.hash === s.hash;
      } else if (i.attributes.length === s.attributes.length) {
        rval = true;
        var iattr, sattr;
        for (var n = 0; rval && n < i.attributes.length; ++n) {
          iattr = i.attributes[n];
          sattr = s.attributes[n];
          if (iattr.type !== sattr.type || iattr.value !== sattr.value) {
            rval = false;
          }
        }
      }
      return rval;
    };
    cert.issued = function(child) {
      return child.isIssuer(cert);
    };
    cert.generateSubjectKeyIdentifier = function() {
      return pki.getPublicKeyFingerprint(cert.publicKey, {type: "RSAPublicKey"});
    };
    cert.verifySubjectKeyIdentifier = function() {
      var oid = oids["subjectKeyIdentifier"];
      for (var i = 0; i < cert.extensions.length; ++i) {
        var ext = cert.extensions[i];
        if (ext.id === oid) {
          var ski = cert.generateSubjectKeyIdentifier().getBytes();
          return forge.util.hexToBytes(ext.subjectKeyIdentifier) === ski;
        }
      }
      return false;
    };
    return cert;
  };
  pki.certificateFromAsn1 = function(obj, computeHash) {
    var capture = {};
    var errors = [];
    if (!asn1.validate(obj, x509CertificateValidator, capture, errors)) {
      var error = new Error("Cannot read X.509 certificate. ASN.1 object is not an X509v3 Certificate.");
      error.errors = errors;
      throw error;
    }
    var oid = asn1.derToOid(capture.publicKeyOid);
    if (oid !== pki.oids.rsaEncryption) {
      throw new Error("Cannot read public key. OID is not RSA.");
    }
    var cert = pki.createCertificate();
    cert.version = capture.certVersion ? capture.certVersion.charCodeAt(0) : 0;
    var serial = forge.util.createBuffer(capture.certSerialNumber);
    cert.serialNumber = serial.toHex();
    cert.signatureOid = forge.asn1.derToOid(capture.certSignatureOid);
    cert.signatureParameters = _readSignatureParameters(cert.signatureOid, capture.certSignatureParams, true);
    cert.siginfo.algorithmOid = forge.asn1.derToOid(capture.certinfoSignatureOid);
    cert.siginfo.parameters = _readSignatureParameters(cert.siginfo.algorithmOid, capture.certinfoSignatureParams, false);
    cert.signature = capture.certSignature;
    var validity = [];
    if (capture.certValidity1UTCTime !== void 0) {
      validity.push(asn1.utcTimeToDate(capture.certValidity1UTCTime));
    }
    if (capture.certValidity2GeneralizedTime !== void 0) {
      validity.push(asn1.generalizedTimeToDate(capture.certValidity2GeneralizedTime));
    }
    if (capture.certValidity3UTCTime !== void 0) {
      validity.push(asn1.utcTimeToDate(capture.certValidity3UTCTime));
    }
    if (capture.certValidity4GeneralizedTime !== void 0) {
      validity.push(asn1.generalizedTimeToDate(capture.certValidity4GeneralizedTime));
    }
    if (validity.length > 2) {
      throw new Error("Cannot read notBefore/notAfter validity times; more than two times were provided in the certificate.");
    }
    if (validity.length < 2) {
      throw new Error("Cannot read notBefore/notAfter validity times; they were not provided as either UTCTime or GeneralizedTime.");
    }
    cert.validity.notBefore = validity[0];
    cert.validity.notAfter = validity[1];
    cert.tbsCertificate = capture.tbsCertificate;
    if (computeHash) {
      cert.md = null;
      if (cert.signatureOid in oids) {
        var oid = oids[cert.signatureOid];
        switch (oid) {
          case "sha1WithRSAEncryption":
            cert.md = forge.md.sha1.create();
            break;
          case "md5WithRSAEncryption":
            cert.md = forge.md.md5.create();
            break;
          case "sha256WithRSAEncryption":
            cert.md = forge.md.sha256.create();
            break;
          case "sha384WithRSAEncryption":
            cert.md = forge.md.sha384.create();
            break;
          case "sha512WithRSAEncryption":
            cert.md = forge.md.sha512.create();
            break;
          case "RSASSA-PSS":
            cert.md = forge.md.sha256.create();
            break;
        }
      }
      if (cert.md === null) {
        var error = new Error("Could not compute certificate digest. Unknown signature OID.");
        error.signatureOid = cert.signatureOid;
        throw error;
      }
      var bytes = asn1.toDer(cert.tbsCertificate);
      cert.md.update(bytes.getBytes());
    }
    var imd = forge.md.sha1.create();
    cert.issuer.getField = function(sn) {
      return _getAttribute(cert.issuer, sn);
    };
    cert.issuer.addField = function(attr) {
      _fillMissingFields([attr]);
      cert.issuer.attributes.push(attr);
    };
    cert.issuer.attributes = pki.RDNAttributesAsArray(capture.certIssuer, imd);
    if (capture.certIssuerUniqueId) {
      cert.issuer.uniqueId = capture.certIssuerUniqueId;
    }
    cert.issuer.hash = imd.digest().toHex();
    var smd = forge.md.sha1.create();
    cert.subject.getField = function(sn) {
      return _getAttribute(cert.subject, sn);
    };
    cert.subject.addField = function(attr) {
      _fillMissingFields([attr]);
      cert.subject.attributes.push(attr);
    };
    cert.subject.attributes = pki.RDNAttributesAsArray(capture.certSubject, smd);
    if (capture.certSubjectUniqueId) {
      cert.subject.uniqueId = capture.certSubjectUniqueId;
    }
    cert.subject.hash = smd.digest().toHex();
    if (capture.certExtensions) {
      cert.extensions = pki.certificateExtensionsFromAsn1(capture.certExtensions);
    } else {
      cert.extensions = [];
    }
    cert.publicKey = pki.publicKeyFromAsn1(capture.subjectPublicKeyInfo);
    return cert;
  };
  pki.certificateExtensionsFromAsn1 = function(exts) {
    var rval = [];
    for (var i = 0; i < exts.value.length; ++i) {
      var extseq = exts.value[i];
      for (var ei = 0; ei < extseq.value.length; ++ei) {
        rval.push(pki.certificateExtensionFromAsn1(extseq.value[ei]));
      }
    }
    return rval;
  };
  pki.certificateExtensionFromAsn1 = function(ext) {
    var e = {};
    e.id = asn1.derToOid(ext.value[0].value);
    e.critical = false;
    if (ext.value[1].type === asn1.Type.BOOLEAN) {
      e.critical = ext.value[1].value.charCodeAt(0) !== 0;
      e.value = ext.value[2].value;
    } else {
      e.value = ext.value[1].value;
    }
    if (e.id in oids) {
      e.name = oids[e.id];
      if (e.name === "keyUsage") {
        var ev = asn1.fromDer(e.value);
        var b2 = 0;
        var b3 = 0;
        if (ev.value.length > 1) {
          b2 = ev.value.charCodeAt(1);
          b3 = ev.value.length > 2 ? ev.value.charCodeAt(2) : 0;
        }
        e.digitalSignature = (b2 & 128) === 128;
        e.nonRepudiation = (b2 & 64) === 64;
        e.keyEncipherment = (b2 & 32) === 32;
        e.dataEncipherment = (b2 & 16) === 16;
        e.keyAgreement = (b2 & 8) === 8;
        e.keyCertSign = (b2 & 4) === 4;
        e.cRLSign = (b2 & 2) === 2;
        e.encipherOnly = (b2 & 1) === 1;
        e.decipherOnly = (b3 & 128) === 128;
      } else if (e.name === "basicConstraints") {
        var ev = asn1.fromDer(e.value);
        if (ev.value.length > 0 && ev.value[0].type === asn1.Type.BOOLEAN) {
          e.cA = ev.value[0].value.charCodeAt(0) !== 0;
        } else {
          e.cA = false;
        }
        var value = null;
        if (ev.value.length > 0 && ev.value[0].type === asn1.Type.INTEGER) {
          value = ev.value[0].value;
        } else if (ev.value.length > 1) {
          value = ev.value[1].value;
        }
        if (value !== null) {
          e.pathLenConstraint = asn1.derToInteger(value);
        }
      } else if (e.name === "extKeyUsage") {
        var ev = asn1.fromDer(e.value);
        for (var vi = 0; vi < ev.value.length; ++vi) {
          var oid = asn1.derToOid(ev.value[vi].value);
          if (oid in oids) {
            e[oids[oid]] = true;
          } else {
            e[oid] = true;
          }
        }
      } else if (e.name === "nsCertType") {
        var ev = asn1.fromDer(e.value);
        var b2 = 0;
        if (ev.value.length > 1) {
          b2 = ev.value.charCodeAt(1);
        }
        e.client = (b2 & 128) === 128;
        e.server = (b2 & 64) === 64;
        e.email = (b2 & 32) === 32;
        e.objsign = (b2 & 16) === 16;
        e.reserved = (b2 & 8) === 8;
        e.sslCA = (b2 & 4) === 4;
        e.emailCA = (b2 & 2) === 2;
        e.objCA = (b2 & 1) === 1;
      } else if (e.name === "subjectAltName" || e.name === "issuerAltName") {
        e.altNames = [];
        var gn;
        var ev = asn1.fromDer(e.value);
        for (var n = 0; n < ev.value.length; ++n) {
          gn = ev.value[n];
          var altName = {
            type: gn.type,
            value: gn.value
          };
          e.altNames.push(altName);
          switch (gn.type) {
            case 1:
            case 2:
            case 6:
              break;
            case 7:
              altName.ip = forge.util.bytesToIP(gn.value);
              break;
            case 8:
              altName.oid = asn1.derToOid(gn.value);
              break;
            default:
          }
        }
      } else if (e.name === "subjectKeyIdentifier") {
        var ev = asn1.fromDer(e.value);
        e.subjectKeyIdentifier = forge.util.bytesToHex(ev.value);
      }
    }
    return e;
  };
  pki.certificationRequestFromAsn1 = function(obj, computeHash) {
    var capture = {};
    var errors = [];
    if (!asn1.validate(obj, certificationRequestValidator, capture, errors)) {
      var error = new Error("Cannot read PKCS#10 certificate request. ASN.1 object is not a PKCS#10 CertificationRequest.");
      error.errors = errors;
      throw error;
    }
    var oid = asn1.derToOid(capture.publicKeyOid);
    if (oid !== pki.oids.rsaEncryption) {
      throw new Error("Cannot read public key. OID is not RSA.");
    }
    var csr = pki.createCertificationRequest();
    csr.version = capture.csrVersion ? capture.csrVersion.charCodeAt(0) : 0;
    csr.signatureOid = forge.asn1.derToOid(capture.csrSignatureOid);
    csr.signatureParameters = _readSignatureParameters(csr.signatureOid, capture.csrSignatureParams, true);
    csr.siginfo.algorithmOid = forge.asn1.derToOid(capture.csrSignatureOid);
    csr.siginfo.parameters = _readSignatureParameters(csr.siginfo.algorithmOid, capture.csrSignatureParams, false);
    csr.signature = capture.csrSignature;
    csr.certificationRequestInfo = capture.certificationRequestInfo;
    if (computeHash) {
      csr.md = null;
      if (csr.signatureOid in oids) {
        var oid = oids[csr.signatureOid];
        switch (oid) {
          case "sha1WithRSAEncryption":
            csr.md = forge.md.sha1.create();
            break;
          case "md5WithRSAEncryption":
            csr.md = forge.md.md5.create();
            break;
          case "sha256WithRSAEncryption":
            csr.md = forge.md.sha256.create();
            break;
          case "sha384WithRSAEncryption":
            csr.md = forge.md.sha384.create();
            break;
          case "sha512WithRSAEncryption":
            csr.md = forge.md.sha512.create();
            break;
          case "RSASSA-PSS":
            csr.md = forge.md.sha256.create();
            break;
        }
      }
      if (csr.md === null) {
        var error = new Error("Could not compute certification request digest. Unknown signature OID.");
        error.signatureOid = csr.signatureOid;
        throw error;
      }
      var bytes = asn1.toDer(csr.certificationRequestInfo);
      csr.md.update(bytes.getBytes());
    }
    var smd = forge.md.sha1.create();
    csr.subject.getField = function(sn) {
      return _getAttribute(csr.subject, sn);
    };
    csr.subject.addField = function(attr) {
      _fillMissingFields([attr]);
      csr.subject.attributes.push(attr);
    };
    csr.subject.attributes = pki.RDNAttributesAsArray(capture.certificationRequestInfoSubject, smd);
    csr.subject.hash = smd.digest().toHex();
    csr.publicKey = pki.publicKeyFromAsn1(capture.subjectPublicKeyInfo);
    csr.getAttribute = function(sn) {
      return _getAttribute(csr, sn);
    };
    csr.addAttribute = function(attr) {
      _fillMissingFields([attr]);
      csr.attributes.push(attr);
    };
    csr.attributes = pki.CRIAttributesAsArray(capture.certificationRequestInfoAttributes || []);
    return csr;
  };
  pki.createCertificationRequest = function() {
    var csr = {};
    csr.version = 0;
    csr.signatureOid = null;
    csr.signature = null;
    csr.siginfo = {};
    csr.siginfo.algorithmOid = null;
    csr.subject = {};
    csr.subject.getField = function(sn) {
      return _getAttribute(csr.subject, sn);
    };
    csr.subject.addField = function(attr) {
      _fillMissingFields([attr]);
      csr.subject.attributes.push(attr);
    };
    csr.subject.attributes = [];
    csr.subject.hash = null;
    csr.publicKey = null;
    csr.attributes = [];
    csr.getAttribute = function(sn) {
      return _getAttribute(csr, sn);
    };
    csr.addAttribute = function(attr) {
      _fillMissingFields([attr]);
      csr.attributes.push(attr);
    };
    csr.md = null;
    csr.setSubject = function(attrs) {
      _fillMissingFields(attrs);
      csr.subject.attributes = attrs;
      csr.subject.hash = null;
    };
    csr.setAttributes = function(attrs) {
      _fillMissingFields(attrs);
      csr.attributes = attrs;
    };
    csr.sign = function(key, md) {
      csr.md = md || forge.md.sha1.create();
      var algorithmOid = oids[csr.md.algorithm + "WithRSAEncryption"];
      if (!algorithmOid) {
        var error = new Error("Could not compute certification request digest. Unknown message digest algorithm OID.");
        error.algorithm = csr.md.algorithm;
        throw error;
      }
      csr.signatureOid = csr.siginfo.algorithmOid = algorithmOid;
      csr.certificationRequestInfo = pki.getCertificationRequestInfo(csr);
      var bytes = asn1.toDer(csr.certificationRequestInfo);
      csr.md.update(bytes.getBytes());
      csr.signature = key.sign(csr.md);
    };
    csr.verify = function() {
      var rval = false;
      var md = csr.md;
      if (md === null) {
        if (csr.signatureOid in oids) {
          var oid = oids[csr.signatureOid];
          switch (oid) {
            case "sha1WithRSAEncryption":
              md = forge.md.sha1.create();
              break;
            case "md5WithRSAEncryption":
              md = forge.md.md5.create();
              break;
            case "sha256WithRSAEncryption":
              md = forge.md.sha256.create();
              break;
            case "sha384WithRSAEncryption":
              md = forge.md.sha384.create();
              break;
            case "sha512WithRSAEncryption":
              md = forge.md.sha512.create();
              break;
            case "RSASSA-PSS":
              md = forge.md.sha256.create();
              break;
          }
        }
        if (md === null) {
          var error = new Error("Could not compute certification request digest. Unknown signature OID.");
          error.signatureOid = csr.signatureOid;
          throw error;
        }
        var cri = csr.certificationRequestInfo || pki.getCertificationRequestInfo(csr);
        var bytes = asn1.toDer(cri);
        md.update(bytes.getBytes());
      }
      if (md !== null) {
        var scheme;
        switch (csr.signatureOid) {
          case oids.sha1WithRSAEncryption:
            break;
          case oids["RSASSA-PSS"]:
            var hash, mgf;
            hash = oids[csr.signatureParameters.mgf.hash.algorithmOid];
            if (hash === void 0 || forge.md[hash] === void 0) {
              var error = new Error("Unsupported MGF hash function.");
              error.oid = csr.signatureParameters.mgf.hash.algorithmOid;
              error.name = hash;
              throw error;
            }
            mgf = oids[csr.signatureParameters.mgf.algorithmOid];
            if (mgf === void 0 || forge.mgf[mgf] === void 0) {
              var error = new Error("Unsupported MGF function.");
              error.oid = csr.signatureParameters.mgf.algorithmOid;
              error.name = mgf;
              throw error;
            }
            mgf = forge.mgf[mgf].create(forge.md[hash].create());
            hash = oids[csr.signatureParameters.hash.algorithmOid];
            if (hash === void 0 || forge.md[hash] === void 0) {
              var error = new Error("Unsupported RSASSA-PSS hash function.");
              error.oid = csr.signatureParameters.hash.algorithmOid;
              error.name = hash;
              throw error;
            }
            scheme = forge.pss.create(forge.md[hash].create(), mgf, csr.signatureParameters.saltLength);
            break;
        }
        rval = csr.publicKey.verify(md.digest().getBytes(), csr.signature, scheme);
      }
      return rval;
    };
    return csr;
  };
  function _dnToAsn1(obj) {
    var rval = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);
    var attr, set;
    var attrs = obj.attributes;
    for (var i = 0; i < attrs.length; ++i) {
      attr = attrs[i];
      var value = attr.value;
      var valueTagClass = asn1.Type.PRINTABLESTRING;
      if ("valueTagClass" in attr) {
        valueTagClass = attr.valueTagClass;
        if (valueTagClass === asn1.Type.UTF8) {
          value = forge.util.encodeUtf8(value);
        }
      }
      set = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true, [
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(attr.type).getBytes()),
          asn1.create(asn1.Class.UNIVERSAL, valueTagClass, false, value)
        ])
      ]);
      rval.value.push(set);
    }
    return rval;
  }
  function _fillMissingFields(attrs) {
    var attr;
    for (var i = 0; i < attrs.length; ++i) {
      attr = attrs[i];
      if (typeof attr.name === "undefined") {
        if (attr.type && attr.type in pki.oids) {
          attr.name = pki.oids[attr.type];
        } else if (attr.shortName && attr.shortName in _shortNames) {
          attr.name = pki.oids[_shortNames[attr.shortName]];
        }
      }
      if (typeof attr.type === "undefined") {
        if (attr.name && attr.name in pki.oids) {
          attr.type = pki.oids[attr.name];
        } else {
          var error = new Error("Attribute type not specified.");
          error.attribute = attr;
          throw error;
        }
      }
      if (typeof attr.shortName === "undefined") {
        if (attr.name && attr.name in _shortNames) {
          attr.shortName = _shortNames[attr.name];
        }
      }
      if (attr.type === oids.extensionRequest) {
        attr.valueConstructed = true;
        attr.valueTagClass = asn1.Type.SEQUENCE;
        if (!attr.value && attr.extensions) {
          attr.value = [];
          for (var ei = 0; ei < attr.extensions.length; ++ei) {
            attr.value.push(pki.certificateExtensionToAsn1(_fillMissingExtensionFields(attr.extensions[ei])));
          }
        }
      }
      if (typeof attr.value === "undefined") {
        var error = new Error("Attribute value not specified.");
        error.attribute = attr;
        throw error;
      }
    }
  }
  function _fillMissingExtensionFields(e, options) {
    options = options || {};
    if (typeof e.name === "undefined") {
      if (e.id && e.id in pki.oids) {
        e.name = pki.oids[e.id];
      }
    }
    if (typeof e.id === "undefined") {
      if (e.name && e.name in pki.oids) {
        e.id = pki.oids[e.name];
      } else {
        var error = new Error("Extension ID not specified.");
        error.extension = e;
        throw error;
      }
    }
    if (typeof e.value !== "undefined") {
      return e;
    }
    if (e.name === "keyUsage") {
      var unused = 0;
      var b2 = 0;
      var b3 = 0;
      if (e.digitalSignature) {
        b2 |= 128;
        unused = 7;
      }
      if (e.nonRepudiation) {
        b2 |= 64;
        unused = 6;
      }
      if (e.keyEncipherment) {
        b2 |= 32;
        unused = 5;
      }
      if (e.dataEncipherment) {
        b2 |= 16;
        unused = 4;
      }
      if (e.keyAgreement) {
        b2 |= 8;
        unused = 3;
      }
      if (e.keyCertSign) {
        b2 |= 4;
        unused = 2;
      }
      if (e.cRLSign) {
        b2 |= 2;
        unused = 1;
      }
      if (e.encipherOnly) {
        b2 |= 1;
        unused = 0;
      }
      if (e.decipherOnly) {
        b3 |= 128;
        unused = 7;
      }
      var value = String.fromCharCode(unused);
      if (b3 !== 0) {
        value += String.fromCharCode(b2) + String.fromCharCode(b3);
      } else if (b2 !== 0) {
        value += String.fromCharCode(b2);
      }
      e.value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.BITSTRING, false, value);
    } else if (e.name === "basicConstraints") {
      e.value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);
      if (e.cA) {
        e.value.value.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.BOOLEAN, false, String.fromCharCode(255)));
      }
      if ("pathLenConstraint" in e) {
        e.value.value.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, asn1.integerToDer(e.pathLenConstraint).getBytes()));
      }
    } else if (e.name === "extKeyUsage") {
      e.value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);
      var seq = e.value.value;
      for (var key in e) {
        if (e[key] !== true) {
          continue;
        }
        if (key in oids) {
          seq.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(oids[key]).getBytes()));
        } else if (key.indexOf(".") !== -1) {
          seq.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(key).getBytes()));
        }
      }
    } else if (e.name === "nsCertType") {
      var unused = 0;
      var b2 = 0;
      if (e.client) {
        b2 |= 128;
        unused = 7;
      }
      if (e.server) {
        b2 |= 64;
        unused = 6;
      }
      if (e.email) {
        b2 |= 32;
        unused = 5;
      }
      if (e.objsign) {
        b2 |= 16;
        unused = 4;
      }
      if (e.reserved) {
        b2 |= 8;
        unused = 3;
      }
      if (e.sslCA) {
        b2 |= 4;
        unused = 2;
      }
      if (e.emailCA) {
        b2 |= 2;
        unused = 1;
      }
      if (e.objCA) {
        b2 |= 1;
        unused = 0;
      }
      var value = String.fromCharCode(unused);
      if (b2 !== 0) {
        value += String.fromCharCode(b2);
      }
      e.value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.BITSTRING, false, value);
    } else if (e.name === "subjectAltName" || e.name === "issuerAltName") {
      e.value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);
      var altName;
      for (var n = 0; n < e.altNames.length; ++n) {
        altName = e.altNames[n];
        var value = altName.value;
        if (altName.type === 7 && altName.ip) {
          value = forge.util.bytesFromIP(altName.ip);
          if (value === null) {
            var error = new Error('Extension "ip" value is not a valid IPv4 or IPv6 address.');
            error.extension = e;
            throw error;
          }
        } else if (altName.type === 8) {
          if (altName.oid) {
            value = asn1.oidToDer(asn1.oidToDer(altName.oid));
          } else {
            value = asn1.oidToDer(value);
          }
        }
        e.value.value.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, altName.type, false, value));
      }
    } else if (e.name === "nsComment" && options.cert) {
      if (!/^[\x00-\x7F]*$/.test(e.comment) || e.comment.length < 1 || e.comment.length > 128) {
        throw new Error('Invalid "nsComment" content.');
      }
      e.value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.IA5STRING, false, e.comment);
    } else if (e.name === "subjectKeyIdentifier" && options.cert) {
      var ski = options.cert.generateSubjectKeyIdentifier();
      e.subjectKeyIdentifier = ski.toHex();
      e.value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, ski.getBytes());
    } else if (e.name === "authorityKeyIdentifier" && options.cert) {
      e.value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);
      var seq = e.value.value;
      if (e.keyIdentifier) {
        var keyIdentifier = e.keyIdentifier === true ? options.cert.generateSubjectKeyIdentifier().getBytes() : e.keyIdentifier;
        seq.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, false, keyIdentifier));
      }
      if (e.authorityCertIssuer) {
        var authorityCertIssuer = [
          asn1.create(asn1.Class.CONTEXT_SPECIFIC, 4, true, [
            _dnToAsn1(e.authorityCertIssuer === true ? options.cert.issuer : e.authorityCertIssuer)
          ])
        ];
        seq.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, 1, true, authorityCertIssuer));
      }
      if (e.serialNumber) {
        var serialNumber = forge.util.hexToBytes(e.serialNumber === true ? options.cert.serialNumber : e.serialNumber);
        seq.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, 2, false, serialNumber));
      }
    } else if (e.name === "cRLDistributionPoints") {
      e.value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);
      var seq = e.value.value;
      var subSeq = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);
      var fullNameGeneralNames = asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, []);
      var altName;
      for (var n = 0; n < e.altNames.length; ++n) {
        altName = e.altNames[n];
        var value = altName.value;
        if (altName.type === 7 && altName.ip) {
          value = forge.util.bytesFromIP(altName.ip);
          if (value === null) {
            var error = new Error('Extension "ip" value is not a valid IPv4 or IPv6 address.');
            error.extension = e;
            throw error;
          }
        } else if (altName.type === 8) {
          if (altName.oid) {
            value = asn1.oidToDer(asn1.oidToDer(altName.oid));
          } else {
            value = asn1.oidToDer(value);
          }
        }
        fullNameGeneralNames.value.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, altName.type, false, value));
      }
      subSeq.value.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [fullNameGeneralNames]));
      seq.push(subSeq);
    }
    if (typeof e.value === "undefined") {
      var error = new Error("Extension value not specified.");
      error.extension = e;
      throw error;
    }
    return e;
  }
  function _signatureParametersToAsn1(oid, params) {
    switch (oid) {
      case oids["RSASSA-PSS"]:
        var parts = [];
        if (params.hash.algorithmOid !== void 0) {
          parts.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [
            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
              asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(params.hash.algorithmOid).getBytes()),
              asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, "")
            ])
          ]));
        }
        if (params.mgf.algorithmOid !== void 0) {
          parts.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, 1, true, [
            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
              asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(params.mgf.algorithmOid).getBytes()),
              asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
                asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(params.mgf.hash.algorithmOid).getBytes()),
                asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, "")
              ])
            ])
          ]));
        }
        if (params.saltLength !== void 0) {
          parts.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, 2, true, [
            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, asn1.integerToDer(params.saltLength).getBytes())
          ]));
        }
        return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, parts);
      default:
        return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, "");
    }
  }
  function _CRIAttributesToAsn1(csr) {
    var rval = asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, []);
    if (csr.attributes.length === 0) {
      return rval;
    }
    var attrs = csr.attributes;
    for (var i = 0; i < attrs.length; ++i) {
      var attr = attrs[i];
      var value = attr.value;
      var valueTagClass = asn1.Type.UTF8;
      if ("valueTagClass" in attr) {
        valueTagClass = attr.valueTagClass;
      }
      if (valueTagClass === asn1.Type.UTF8) {
        value = forge.util.encodeUtf8(value);
      }
      var valueConstructed = false;
      if ("valueConstructed" in attr) {
        valueConstructed = attr.valueConstructed;
      }
      var seq = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(attr.type).getBytes()),
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true, [
          asn1.create(asn1.Class.UNIVERSAL, valueTagClass, valueConstructed, value)
        ])
      ]);
      rval.value.push(seq);
    }
    return rval;
  }
  var jan_1_1950 = new Date("1950-01-01T00:00:00Z");
  var jan_1_2050 = new Date("2050-01-01T00:00:00Z");
  function _dateToAsn1(date) {
    if (date >= jan_1_1950 && date < jan_1_2050) {
      return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.UTCTIME, false, asn1.dateToUtcTime(date));
    } else {
      return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.GENERALIZEDTIME, false, asn1.dateToGeneralizedTime(date));
    }
  }
  pki.getTBSCertificate = function(cert) {
    var notBefore = _dateToAsn1(cert.validity.notBefore);
    var notAfter = _dateToAsn1(cert.validity.notAfter);
    var tbs = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
      asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, asn1.integerToDer(cert.version).getBytes())
      ]),
      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, forge.util.hexToBytes(cert.serialNumber)),
      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(cert.siginfo.algorithmOid).getBytes()),
        _signatureParametersToAsn1(cert.siginfo.algorithmOid, cert.siginfo.parameters)
      ]),
      _dnToAsn1(cert.issuer),
      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        notBefore,
        notAfter
      ]),
      _dnToAsn1(cert.subject),
      pki.publicKeyToAsn1(cert.publicKey)
    ]);
    if (cert.issuer.uniqueId) {
      tbs.value.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, 1, true, [
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.BITSTRING, false, String.fromCharCode(0) + cert.issuer.uniqueId)
      ]));
    }
    if (cert.subject.uniqueId) {
      tbs.value.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, 2, true, [
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.BITSTRING, false, String.fromCharCode(0) + cert.subject.uniqueId)
      ]));
    }
    if (cert.extensions.length > 0) {
      tbs.value.push(pki.certificateExtensionsToAsn1(cert.extensions));
    }
    return tbs;
  };
  pki.getCertificationRequestInfo = function(csr) {
    var cri = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, asn1.integerToDer(csr.version).getBytes()),
      _dnToAsn1(csr.subject),
      pki.publicKeyToAsn1(csr.publicKey),
      _CRIAttributesToAsn1(csr)
    ]);
    return cri;
  };
  pki.distinguishedNameToAsn1 = function(dn) {
    return _dnToAsn1(dn);
  };
  pki.certificateToAsn1 = function(cert) {
    var tbsCertificate = cert.tbsCertificate || pki.getTBSCertificate(cert);
    return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
      tbsCertificate,
      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(cert.signatureOid).getBytes()),
        _signatureParametersToAsn1(cert.signatureOid, cert.signatureParameters)
      ]),
      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.BITSTRING, false, String.fromCharCode(0) + cert.signature)
    ]);
  };
  pki.certificateExtensionsToAsn1 = function(exts) {
    var rval = asn1.create(asn1.Class.CONTEXT_SPECIFIC, 3, true, []);
    var seq = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);
    rval.value.push(seq);
    for (var i = 0; i < exts.length; ++i) {
      seq.value.push(pki.certificateExtensionToAsn1(exts[i]));
    }
    return rval;
  };
  pki.certificateExtensionToAsn1 = function(ext) {
    var extseq = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, []);
    extseq.value.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(ext.id).getBytes()));
    if (ext.critical) {
      extseq.value.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.BOOLEAN, false, String.fromCharCode(255)));
    }
    var value = ext.value;
    if (typeof ext.value !== "string") {
      value = asn1.toDer(value).getBytes();
    }
    extseq.value.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, value));
    return extseq;
  };
  pki.certificationRequestToAsn1 = function(csr) {
    var cri = csr.certificationRequestInfo || pki.getCertificationRequestInfo(csr);
    return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
      cri,
      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(csr.signatureOid).getBytes()),
        _signatureParametersToAsn1(csr.signatureOid, csr.signatureParameters)
      ]),
      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.BITSTRING, false, String.fromCharCode(0) + csr.signature)
    ]);
  };
  pki.createCaStore = function(certs) {
    var caStore = {
      certs: {}
    };
    caStore.getIssuer = function(cert2) {
      var rval = getBySubject(cert2.issuer);
      return rval;
    };
    caStore.addCertificate = function(cert2) {
      if (typeof cert2 === "string") {
        cert2 = forge.pki.certificateFromPem(cert2);
      }
      ensureSubjectHasHash(cert2.subject);
      if (!caStore.hasCertificate(cert2)) {
        if (cert2.subject.hash in caStore.certs) {
          var tmp = caStore.certs[cert2.subject.hash];
          if (!forge.util.isArray(tmp)) {
            tmp = [tmp];
          }
          tmp.push(cert2);
          caStore.certs[cert2.subject.hash] = tmp;
        } else {
          caStore.certs[cert2.subject.hash] = cert2;
        }
      }
    };
    caStore.hasCertificate = function(cert2) {
      if (typeof cert2 === "string") {
        cert2 = forge.pki.certificateFromPem(cert2);
      }
      var match = getBySubject(cert2.subject);
      if (!match) {
        return false;
      }
      if (!forge.util.isArray(match)) {
        match = [match];
      }
      var der1 = asn1.toDer(pki.certificateToAsn1(cert2)).getBytes();
      for (var i2 = 0; i2 < match.length; ++i2) {
        var der2 = asn1.toDer(pki.certificateToAsn1(match[i2])).getBytes();
        if (der1 === der2) {
          return true;
        }
      }
      return false;
    };
    caStore.listAllCertificates = function() {
      var certList = [];
      for (var hash in caStore.certs) {
        if (caStore.certs.hasOwnProperty(hash)) {
          var value = caStore.certs[hash];
          if (!forge.util.isArray(value)) {
            certList.push(value);
          } else {
            for (var i2 = 0; i2 < value.length; ++i2) {
              certList.push(value[i2]);
            }
          }
        }
      }
      return certList;
    };
    caStore.removeCertificate = function(cert2) {
      var result;
      if (typeof cert2 === "string") {
        cert2 = forge.pki.certificateFromPem(cert2);
      }
      ensureSubjectHasHash(cert2.subject);
      if (!caStore.hasCertificate(cert2)) {
        return null;
      }
      var match = getBySubject(cert2.subject);
      if (!forge.util.isArray(match)) {
        result = caStore.certs[cert2.subject.hash];
        delete caStore.certs[cert2.subject.hash];
        return result;
      }
      var der1 = asn1.toDer(pki.certificateToAsn1(cert2)).getBytes();
      for (var i2 = 0; i2 < match.length; ++i2) {
        var der2 = asn1.toDer(pki.certificateToAsn1(match[i2])).getBytes();
        if (der1 === der2) {
          result = match[i2];
          match.splice(i2, 1);
        }
      }
      if (match.length === 0) {
        delete caStore.certs[cert2.subject.hash];
      }
      return result;
    };
    function getBySubject(subject) {
      ensureSubjectHasHash(subject);
      return caStore.certs[subject.hash] || null;
    }
    function ensureSubjectHasHash(subject) {
      if (!subject.hash) {
        var md = forge.md.sha1.create();
        subject.attributes = pki.RDNAttributesAsArray(_dnToAsn1(subject), md);
        subject.hash = md.digest().toHex();
      }
    }
    if (certs) {
      for (var i = 0; i < certs.length; ++i) {
        var cert = certs[i];
        caStore.addCertificate(cert);
      }
    }
    return caStore;
  };
  pki.certificateError = {
    bad_certificate: "forge.pki.BadCertificate",
    unsupported_certificate: "forge.pki.UnsupportedCertificate",
    certificate_revoked: "forge.pki.CertificateRevoked",
    certificate_expired: "forge.pki.CertificateExpired",
    certificate_unknown: "forge.pki.CertificateUnknown",
    unknown_ca: "forge.pki.UnknownCertificateAuthority"
  };
  pki.verifyCertificateChain = function(caStore, chain, options) {
    if (typeof options === "function") {
      options = {verify: options};
    }
    options = options || {};
    chain = chain.slice(0);
    var certs = chain.slice(0);
    var validityCheckDate = options.validityCheckDate;
    if (typeof validityCheckDate === "undefined") {
      validityCheckDate = new Date();
    }
    var first = true;
    var error = null;
    var depth = 0;
    do {
      var cert = chain.shift();
      var parent = null;
      var selfSigned = false;
      if (validityCheckDate) {
        if (validityCheckDate < cert.validity.notBefore || validityCheckDate > cert.validity.notAfter) {
          error = {
            message: "Certificate is not valid yet or has expired.",
            error: pki.certificateError.certificate_expired,
            notBefore: cert.validity.notBefore,
            notAfter: cert.validity.notAfter,
            now: validityCheckDate
          };
        }
      }
      if (error === null) {
        parent = chain[0] || caStore.getIssuer(cert);
        if (parent === null) {
          if (cert.isIssuer(cert)) {
            selfSigned = true;
            parent = cert;
          }
        }
        if (parent) {
          var parents = parent;
          if (!forge.util.isArray(parents)) {
            parents = [parents];
          }
          var verified = false;
          while (!verified && parents.length > 0) {
            parent = parents.shift();
            try {
              verified = parent.verify(cert);
            } catch (ex) {
            }
          }
          if (!verified) {
            error = {
              message: "Certificate signature is invalid.",
              error: pki.certificateError.bad_certificate
            };
          }
        }
        if (error === null && (!parent || selfSigned) && !caStore.hasCertificate(cert)) {
          error = {
            message: "Certificate is not trusted.",
            error: pki.certificateError.unknown_ca
          };
        }
      }
      if (error === null && parent && !cert.isIssuer(parent)) {
        error = {
          message: "Certificate issuer is invalid.",
          error: pki.certificateError.bad_certificate
        };
      }
      if (error === null) {
        var se = {
          keyUsage: true,
          basicConstraints: true
        };
        for (var i = 0; error === null && i < cert.extensions.length; ++i) {
          var ext = cert.extensions[i];
          if (ext.critical && !(ext.name in se)) {
            error = {
              message: "Certificate has an unsupported critical extension.",
              error: pki.certificateError.unsupported_certificate
            };
          }
        }
      }
      if (error === null && (!first || chain.length === 0 && (!parent || selfSigned))) {
        var bcExt = cert.getExtension("basicConstraints");
        var keyUsageExt = cert.getExtension("keyUsage");
        if (keyUsageExt !== null) {
          if (!keyUsageExt.keyCertSign || bcExt === null) {
            error = {
              message: "Certificate keyUsage or basicConstraints conflict or indicate that the certificate is not a CA. If the certificate is the only one in the chain or isn't the first then the certificate must be a valid CA.",
              error: pki.certificateError.bad_certificate
            };
          }
        }
        if (error === null && bcExt !== null && !bcExt.cA) {
          error = {
            message: "Certificate basicConstraints indicates the certificate is not a CA.",
            error: pki.certificateError.bad_certificate
          };
        }
        if (error === null && keyUsageExt !== null && "pathLenConstraint" in bcExt) {
          var pathLen = depth - 1;
          if (pathLen > bcExt.pathLenConstraint) {
            error = {
              message: "Certificate basicConstraints pathLenConstraint violated.",
              error: pki.certificateError.bad_certificate
            };
          }
        }
      }
      var vfd = error === null ? true : error.error;
      var ret = options.verify ? options.verify(vfd, depth, certs) : vfd;
      if (ret === true) {
        error = null;
      } else {
        if (vfd === true) {
          error = {
            message: "The application rejected the certificate.",
            error: pki.certificateError.bad_certificate
          };
        }
        if (ret || ret === 0) {
          if (typeof ret === "object" && !forge.util.isArray(ret)) {
            if (ret.message) {
              error.message = ret.message;
            }
            if (ret.error) {
              error.error = ret.error;
            }
          } else if (typeof ret === "string") {
            error.error = ret;
          }
        }
        throw error;
      }
      first = false;
      ++depth;
    } while (chain.length > 0);
    return true;
  };
});

// node_modules/node-forge/lib/pkcs7.js
var require_pkcs7 = __commonJS((exports2, module2) => {
  var forge = require_forge();
  require_aes();
  require_asn1();
  require_des();
  require_oids();
  require_pem();
  require_pkcs7asn1();
  require_random();
  require_util3();
  require_x509();
  var asn1 = forge.asn1;
  var p7 = module2.exports = forge.pkcs7 = forge.pkcs7 || {};
  p7.messageFromPem = function(pem) {
    var msg = forge.pem.decode(pem)[0];
    if (msg.type !== "PKCS7") {
      var error = new Error('Could not convert PKCS#7 message from PEM; PEM header type is not "PKCS#7".');
      error.headerType = msg.type;
      throw error;
    }
    if (msg.procType && msg.procType.type === "ENCRYPTED") {
      throw new Error("Could not convert PKCS#7 message from PEM; PEM is encrypted.");
    }
    var obj = asn1.fromDer(msg.body);
    return p7.messageFromAsn1(obj);
  };
  p7.messageToPem = function(msg, maxline) {
    var pemObj = {
      type: "PKCS7",
      body: asn1.toDer(msg.toAsn1()).getBytes()
    };
    return forge.pem.encode(pemObj, {maxline});
  };
  p7.messageFromAsn1 = function(obj) {
    var capture = {};
    var errors = [];
    if (!asn1.validate(obj, p7.asn1.contentInfoValidator, capture, errors)) {
      var error = new Error("Cannot read PKCS#7 message. ASN.1 object is not an PKCS#7 ContentInfo.");
      error.errors = errors;
      throw error;
    }
    var contentType = asn1.derToOid(capture.contentType);
    var msg;
    switch (contentType) {
      case forge.pki.oids.envelopedData:
        msg = p7.createEnvelopedData();
        break;
      case forge.pki.oids.encryptedData:
        msg = p7.createEncryptedData();
        break;
      case forge.pki.oids.signedData:
        msg = p7.createSignedData();
        break;
      default:
        throw new Error("Cannot read PKCS#7 message. ContentType with OID " + contentType + " is not (yet) supported.");
    }
    msg.fromAsn1(capture.content.value[0]);
    return msg;
  };
  p7.createSignedData = function() {
    var msg = null;
    msg = {
      type: forge.pki.oids.signedData,
      version: 1,
      certificates: [],
      crls: [],
      signers: [],
      digestAlgorithmIdentifiers: [],
      contentInfo: null,
      signerInfos: [],
      fromAsn1: function(obj) {
        _fromAsn1(msg, obj, p7.asn1.signedDataValidator);
        msg.certificates = [];
        msg.crls = [];
        msg.digestAlgorithmIdentifiers = [];
        msg.contentInfo = null;
        msg.signerInfos = [];
        if (msg.rawCapture.certificates) {
          var certs = msg.rawCapture.certificates.value;
          for (var i = 0; i < certs.length; ++i) {
            msg.certificates.push(forge.pki.certificateFromAsn1(certs[i]));
          }
        }
      },
      toAsn1: function() {
        if (!msg.contentInfo) {
          msg.sign();
        }
        var certs = [];
        for (var i = 0; i < msg.certificates.length; ++i) {
          certs.push(forge.pki.certificateToAsn1(msg.certificates[i]));
        }
        var crls = [];
        var signedData = asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, asn1.integerToDer(msg.version).getBytes()),
            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true, msg.digestAlgorithmIdentifiers),
            msg.contentInfo
          ])
        ]);
        if (certs.length > 0) {
          signedData.value[0].value.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, certs));
        }
        if (crls.length > 0) {
          signedData.value[0].value.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, 1, true, crls));
        }
        signedData.value[0].value.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true, msg.signerInfos));
        return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(msg.type).getBytes()),
          signedData
        ]);
      },
      addSigner: function(signer) {
        var issuer = signer.issuer;
        var serialNumber = signer.serialNumber;
        if (signer.certificate) {
          var cert = signer.certificate;
          if (typeof cert === "string") {
            cert = forge.pki.certificateFromPem(cert);
          }
          issuer = cert.issuer.attributes;
          serialNumber = cert.serialNumber;
        }
        var key = signer.key;
        if (!key) {
          throw new Error("Could not add PKCS#7 signer; no private key specified.");
        }
        if (typeof key === "string") {
          key = forge.pki.privateKeyFromPem(key);
        }
        var digestAlgorithm = signer.digestAlgorithm || forge.pki.oids.sha1;
        switch (digestAlgorithm) {
          case forge.pki.oids.sha1:
          case forge.pki.oids.sha256:
          case forge.pki.oids.sha384:
          case forge.pki.oids.sha512:
          case forge.pki.oids.md5:
            break;
          default:
            throw new Error("Could not add PKCS#7 signer; unknown message digest algorithm: " + digestAlgorithm);
        }
        var authenticatedAttributes = signer.authenticatedAttributes || [];
        if (authenticatedAttributes.length > 0) {
          var contentType = false;
          var messageDigest = false;
          for (var i = 0; i < authenticatedAttributes.length; ++i) {
            var attr = authenticatedAttributes[i];
            if (!contentType && attr.type === forge.pki.oids.contentType) {
              contentType = true;
              if (messageDigest) {
                break;
              }
              continue;
            }
            if (!messageDigest && attr.type === forge.pki.oids.messageDigest) {
              messageDigest = true;
              if (contentType) {
                break;
              }
              continue;
            }
          }
          if (!contentType || !messageDigest) {
            throw new Error("Invalid signer.authenticatedAttributes. If signer.authenticatedAttributes is specified, then it must contain at least two attributes, PKCS #9 content-type and PKCS #9 message-digest.");
          }
        }
        msg.signers.push({
          key,
          version: 1,
          issuer,
          serialNumber,
          digestAlgorithm,
          signatureAlgorithm: forge.pki.oids.rsaEncryption,
          signature: null,
          authenticatedAttributes,
          unauthenticatedAttributes: []
        });
      },
      sign: function(options) {
        options = options || {};
        if (typeof msg.content !== "object" || msg.contentInfo === null) {
          msg.contentInfo = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(forge.pki.oids.data).getBytes())
          ]);
          if ("content" in msg) {
            var content;
            if (msg.content instanceof forge.util.ByteBuffer) {
              content = msg.content.bytes();
            } else if (typeof msg.content === "string") {
              content = forge.util.encodeUtf8(msg.content);
            }
            if (options.detached) {
              msg.detachedContent = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, content);
            } else {
              msg.contentInfo.value.push(asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [
                asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, content)
              ]));
            }
          }
        }
        if (msg.signers.length === 0) {
          return;
        }
        var mds = addDigestAlgorithmIds();
        addSignerInfos(mds);
      },
      verify: function() {
        throw new Error("PKCS#7 signature verification not yet implemented.");
      },
      addCertificate: function(cert) {
        if (typeof cert === "string") {
          cert = forge.pki.certificateFromPem(cert);
        }
        msg.certificates.push(cert);
      },
      addCertificateRevokationList: function(crl) {
        throw new Error("PKCS#7 CRL support not yet implemented.");
      }
    };
    return msg;
    function addDigestAlgorithmIds() {
      var mds = {};
      for (var i = 0; i < msg.signers.length; ++i) {
        var signer = msg.signers[i];
        var oid = signer.digestAlgorithm;
        if (!(oid in mds)) {
          mds[oid] = forge.md[forge.pki.oids[oid]].create();
        }
        if (signer.authenticatedAttributes.length === 0) {
          signer.md = mds[oid];
        } else {
          signer.md = forge.md[forge.pki.oids[oid]].create();
        }
      }
      msg.digestAlgorithmIdentifiers = [];
      for (var oid in mds) {
        msg.digestAlgorithmIdentifiers.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(oid).getBytes()),
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, "")
        ]));
      }
      return mds;
    }
    function addSignerInfos(mds) {
      var content;
      if (msg.detachedContent) {
        content = msg.detachedContent;
      } else {
        content = msg.contentInfo.value[1];
        content = content.value[0];
      }
      if (!content) {
        throw new Error("Could not sign PKCS#7 message; there is no content to sign.");
      }
      var contentType = asn1.derToOid(msg.contentInfo.value[0].value);
      var bytes = asn1.toDer(content);
      bytes.getByte();
      asn1.getBerValueLength(bytes);
      bytes = bytes.getBytes();
      for (var oid in mds) {
        mds[oid].start().update(bytes);
      }
      var signingTime = new Date();
      for (var i = 0; i < msg.signers.length; ++i) {
        var signer = msg.signers[i];
        if (signer.authenticatedAttributes.length === 0) {
          if (contentType !== forge.pki.oids.data) {
            throw new Error("Invalid signer; authenticatedAttributes must be present when the ContentInfo content type is not PKCS#7 Data.");
          }
        } else {
          signer.authenticatedAttributesAsn1 = asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, []);
          var attrsAsn1 = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true, []);
          for (var ai = 0; ai < signer.authenticatedAttributes.length; ++ai) {
            var attr = signer.authenticatedAttributes[ai];
            if (attr.type === forge.pki.oids.messageDigest) {
              attr.value = mds[signer.digestAlgorithm].digest();
            } else if (attr.type === forge.pki.oids.signingTime) {
              if (!attr.value) {
                attr.value = signingTime;
              }
            }
            attrsAsn1.value.push(_attributeToAsn1(attr));
            signer.authenticatedAttributesAsn1.value.push(_attributeToAsn1(attr));
          }
          bytes = asn1.toDer(attrsAsn1).getBytes();
          signer.md.start().update(bytes);
        }
        signer.signature = signer.key.sign(signer.md, "RSASSA-PKCS1-V1_5");
      }
      msg.signerInfos = _signersToAsn1(msg.signers);
    }
  };
  p7.createEncryptedData = function() {
    var msg = null;
    msg = {
      type: forge.pki.oids.encryptedData,
      version: 0,
      encryptedContent: {
        algorithm: forge.pki.oids["aes256-CBC"]
      },
      fromAsn1: function(obj) {
        _fromAsn1(msg, obj, p7.asn1.encryptedDataValidator);
      },
      decrypt: function(key) {
        if (key !== void 0) {
          msg.encryptedContent.key = key;
        }
        _decryptContent(msg);
      }
    };
    return msg;
  };
  p7.createEnvelopedData = function() {
    var msg = null;
    msg = {
      type: forge.pki.oids.envelopedData,
      version: 0,
      recipients: [],
      encryptedContent: {
        algorithm: forge.pki.oids["aes256-CBC"]
      },
      fromAsn1: function(obj) {
        var capture = _fromAsn1(msg, obj, p7.asn1.envelopedDataValidator);
        msg.recipients = _recipientsFromAsn1(capture.recipientInfos.value);
      },
      toAsn1: function() {
        return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
          asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(msg.type).getBytes()),
          asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [
            asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
              asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, asn1.integerToDer(msg.version).getBytes()),
              asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true, _recipientsToAsn1(msg.recipients)),
              asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, _encryptedContentToAsn1(msg.encryptedContent))
            ])
          ])
        ]);
      },
      findRecipient: function(cert) {
        var sAttr = cert.issuer.attributes;
        for (var i = 0; i < msg.recipients.length; ++i) {
          var r = msg.recipients[i];
          var rAttr = r.issuer;
          if (r.serialNumber !== cert.serialNumber) {
            continue;
          }
          if (rAttr.length !== sAttr.length) {
            continue;
          }
          var match = true;
          for (var j = 0; j < sAttr.length; ++j) {
            if (rAttr[j].type !== sAttr[j].type || rAttr[j].value !== sAttr[j].value) {
              match = false;
              break;
            }
          }
          if (match) {
            return r;
          }
        }
        return null;
      },
      decrypt: function(recipient, privKey) {
        if (msg.encryptedContent.key === void 0 && recipient !== void 0 && privKey !== void 0) {
          switch (recipient.encryptedContent.algorithm) {
            case forge.pki.oids.rsaEncryption:
            case forge.pki.oids.desCBC:
              var key = privKey.decrypt(recipient.encryptedContent.content);
              msg.encryptedContent.key = forge.util.createBuffer(key);
              break;
            default:
              throw new Error("Unsupported asymmetric cipher, OID " + recipient.encryptedContent.algorithm);
          }
        }
        _decryptContent(msg);
      },
      addRecipient: function(cert) {
        msg.recipients.push({
          version: 0,
          issuer: cert.issuer.attributes,
          serialNumber: cert.serialNumber,
          encryptedContent: {
            algorithm: forge.pki.oids.rsaEncryption,
            key: cert.publicKey
          }
        });
      },
      encrypt: function(key, cipher) {
        if (msg.encryptedContent.content === void 0) {
          cipher = cipher || msg.encryptedContent.algorithm;
          key = key || msg.encryptedContent.key;
          var keyLen, ivLen, ciphFn;
          switch (cipher) {
            case forge.pki.oids["aes128-CBC"]:
              keyLen = 16;
              ivLen = 16;
              ciphFn = forge.aes.createEncryptionCipher;
              break;
            case forge.pki.oids["aes192-CBC"]:
              keyLen = 24;
              ivLen = 16;
              ciphFn = forge.aes.createEncryptionCipher;
              break;
            case forge.pki.oids["aes256-CBC"]:
              keyLen = 32;
              ivLen = 16;
              ciphFn = forge.aes.createEncryptionCipher;
              break;
            case forge.pki.oids["des-EDE3-CBC"]:
              keyLen = 24;
              ivLen = 8;
              ciphFn = forge.des.createEncryptionCipher;
              break;
            default:
              throw new Error("Unsupported symmetric cipher, OID " + cipher);
          }
          if (key === void 0) {
            key = forge.util.createBuffer(forge.random.getBytes(keyLen));
          } else if (key.length() != keyLen) {
            throw new Error("Symmetric key has wrong length; got " + key.length() + " bytes, expected " + keyLen + ".");
          }
          msg.encryptedContent.algorithm = cipher;
          msg.encryptedContent.key = key;
          msg.encryptedContent.parameter = forge.util.createBuffer(forge.random.getBytes(ivLen));
          var ciph = ciphFn(key);
          ciph.start(msg.encryptedContent.parameter.copy());
          ciph.update(msg.content);
          if (!ciph.finish()) {
            throw new Error("Symmetric encryption failed.");
          }
          msg.encryptedContent.content = ciph.output;
        }
        for (var i = 0; i < msg.recipients.length; ++i) {
          var recipient = msg.recipients[i];
          if (recipient.encryptedContent.content !== void 0) {
            continue;
          }
          switch (recipient.encryptedContent.algorithm) {
            case forge.pki.oids.rsaEncryption:
              recipient.encryptedContent.content = recipient.encryptedContent.key.encrypt(msg.encryptedContent.key.data);
              break;
            default:
              throw new Error("Unsupported asymmetric cipher, OID " + recipient.encryptedContent.algorithm);
          }
        }
      }
    };
    return msg;
  };
  function _recipientFromAsn1(obj) {
    var capture = {};
    var errors = [];
    if (!asn1.validate(obj, p7.asn1.recipientInfoValidator, capture, errors)) {
      var error = new Error("Cannot read PKCS#7 RecipientInfo. ASN.1 object is not an PKCS#7 RecipientInfo.");
      error.errors = errors;
      throw error;
    }
    return {
      version: capture.version.charCodeAt(0),
      issuer: forge.pki.RDNAttributesAsArray(capture.issuer),
      serialNumber: forge.util.createBuffer(capture.serial).toHex(),
      encryptedContent: {
        algorithm: asn1.derToOid(capture.encAlgorithm),
        parameter: capture.encParameter.value,
        content: capture.encKey
      }
    };
  }
  function _recipientToAsn1(obj) {
    return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, asn1.integerToDer(obj.version).getBytes()),
      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        forge.pki.distinguishedNameToAsn1({attributes: obj.issuer}),
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, forge.util.hexToBytes(obj.serialNumber))
      ]),
      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(obj.encryptedContent.algorithm).getBytes()),
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, "")
      ]),
      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, obj.encryptedContent.content)
    ]);
  }
  function _recipientsFromAsn1(infos) {
    var ret = [];
    for (var i = 0; i < infos.length; ++i) {
      ret.push(_recipientFromAsn1(infos[i]));
    }
    return ret;
  }
  function _recipientsToAsn1(recipients) {
    var ret = [];
    for (var i = 0; i < recipients.length; ++i) {
      ret.push(_recipientToAsn1(recipients[i]));
    }
    return ret;
  }
  function _signerToAsn1(obj) {
    var rval = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, asn1.integerToDer(obj.version).getBytes()),
      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        forge.pki.distinguishedNameToAsn1({attributes: obj.issuer}),
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.INTEGER, false, forge.util.hexToBytes(obj.serialNumber))
      ]),
      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(obj.digestAlgorithm).getBytes()),
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, "")
      ])
    ]);
    if (obj.authenticatedAttributesAsn1) {
      rval.value.push(obj.authenticatedAttributesAsn1);
    }
    rval.value.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(obj.signatureAlgorithm).getBytes()),
      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.NULL, false, "")
    ]));
    rval.value.push(asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, obj.signature));
    if (obj.unauthenticatedAttributes.length > 0) {
      var attrsAsn1 = asn1.create(asn1.Class.CONTEXT_SPECIFIC, 1, true, []);
      for (var i = 0; i < obj.unauthenticatedAttributes.length; ++i) {
        var attr = obj.unauthenticatedAttributes[i];
        attrsAsn1.values.push(_attributeToAsn1(attr));
      }
      rval.value.push(attrsAsn1);
    }
    return rval;
  }
  function _signersToAsn1(signers) {
    var ret = [];
    for (var i = 0; i < signers.length; ++i) {
      ret.push(_signerToAsn1(signers[i]));
    }
    return ret;
  }
  function _attributeToAsn1(attr) {
    var value;
    if (attr.type === forge.pki.oids.contentType) {
      value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(attr.value).getBytes());
    } else if (attr.type === forge.pki.oids.messageDigest) {
      value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, attr.value.bytes());
    } else if (attr.type === forge.pki.oids.signingTime) {
      var jan_1_1950 = new Date("1950-01-01T00:00:00Z");
      var jan_1_2050 = new Date("2050-01-01T00:00:00Z");
      var date = attr.value;
      if (typeof date === "string") {
        var timestamp = Date.parse(date);
        if (!isNaN(timestamp)) {
          date = new Date(timestamp);
        } else if (date.length === 13) {
          date = asn1.utcTimeToDate(date);
        } else {
          date = asn1.generalizedTimeToDate(date);
        }
      }
      if (date >= jan_1_1950 && date < jan_1_2050) {
        value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.UTCTIME, false, asn1.dateToUtcTime(date));
      } else {
        value = asn1.create(asn1.Class.UNIVERSAL, asn1.Type.GENERALIZEDTIME, false, asn1.dateToGeneralizedTime(date));
      }
    }
    return asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(attr.type).getBytes()),
      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SET, true, [
        value
      ])
    ]);
  }
  function _encryptedContentToAsn1(ec) {
    return [
      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(forge.pki.oids.data).getBytes()),
      asn1.create(asn1.Class.UNIVERSAL, asn1.Type.SEQUENCE, true, [
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OID, false, asn1.oidToDer(ec.algorithm).getBytes()),
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, ec.parameter.getBytes())
      ]),
      asn1.create(asn1.Class.CONTEXT_SPECIFIC, 0, true, [
        asn1.create(asn1.Class.UNIVERSAL, asn1.Type.OCTETSTRING, false, ec.content.getBytes())
      ])
    ];
  }
  function _fromAsn1(msg, obj, validator) {
    var capture = {};
    var errors = [];
    if (!asn1.validate(obj, validator, capture, errors)) {
      var error = new Error("Cannot read PKCS#7 message. ASN.1 object is not a supported PKCS#7 message.");
      error.errors = error;
      throw error;
    }
    var contentType = asn1.derToOid(capture.contentType);
    if (contentType !== forge.pki.oids.data) {
      throw new Error("Unsupported PKCS#7 message. Only wrapped ContentType Data supported.");
    }
    if (capture.encryptedContent) {
      var content = "";
      if (forge.util.isArray(capture.encryptedContent)) {
        for (var i = 0; i < capture.encryptedContent.length; ++i) {
          if (capture.encryptedContent[i].type !== asn1.Type.OCTETSTRING) {
            throw new Error("Malformed PKCS#7 message, expecting encrypted content constructed of only OCTET STRING objects.");
          }
          content += capture.encryptedContent[i].value;
        }
      } else {
        content = capture.encryptedContent;
      }
      msg.encryptedContent = {
        algorithm: asn1.derToOid(capture.encAlgorithm),
        parameter: forge.util.createBuffer(capture.encParameter.value),
        content: forge.util.createBuffer(content)
      };
    }
    if (capture.content) {
      var content = "";
      if (forge.util.isArray(capture.content)) {
        for (var i = 0; i < capture.content.length; ++i) {
          if (capture.content[i].type !== asn1.Type.OCTETSTRING) {
            throw new Error("Malformed PKCS#7 message, expecting content constructed of only OCTET STRING objects.");
          }
          content += capture.content[i].value;
        }
      } else {
        content = capture.content;
      }
      msg.content = forge.util.createBuffer(content);
    }
    msg.version = capture.version.charCodeAt(0);
    msg.rawCapture = capture;
    return capture;
  }
  function _decryptContent(msg) {
    if (msg.encryptedContent.key === void 0) {
      throw new Error("Symmetric key not available.");
    }
    if (msg.content === void 0) {
      var ciph;
      switch (msg.encryptedContent.algorithm) {
        case forge.pki.oids["aes128-CBC"]:
        case forge.pki.oids["aes192-CBC"]:
        case forge.pki.oids["aes256-CBC"]:
          ciph = forge.aes.createDecryptionCipher(msg.encryptedContent.key);
          break;
        case forge.pki.oids["desCBC"]:
        case forge.pki.oids["des-EDE3-CBC"]:
          ciph = forge.des.createDecryptionCipher(msg.encryptedContent.key);
          break;
        default:
          throw new Error("Unsupported symmetric cipher, OID " + msg.encryptedContent.algorithm);
      }
      ciph.start(msg.encryptedContent.parameter);
      ciph.update(msg.encryptedContent.content);
      if (!ciph.finish()) {
        throw new Error("Symmetric decryption failed.");
      }
      msg.content = ciph.output;
    }
  }
});

// node_modules/libp2p/src/keychain/util.js
var require_util13 = __commonJS((exports2, module2) => {
  "use strict";
  require_x509();
  var forge = require_forge();
  var pki = forge.pki;
  exports2 = module2.exports;
  exports2.certificateForKey = (key, privateKey) => {
    const publicKey = pki.setRsaPublicKey(privateKey.n, privateKey.e);
    const cert = pki.createCertificate();
    cert.publicKey = publicKey;
    cert.serialNumber = "01";
    cert.validity.notBefore = new Date();
    cert.validity.notAfter = new Date();
    cert.validity.notAfter.setFullYear(cert.validity.notBefore.getFullYear() + 10);
    const attrs = [{
      name: "organizationName",
      value: "ipfs"
    }, {
      shortName: "OU",
      value: "keystore"
    }, {
      name: "commonName",
      value: key.id
    }];
    cert.setSubject(attrs);
    cert.setIssuer(attrs);
    cert.setExtensions([{
      name: "basicConstraints",
      cA: true
    }, {
      name: "keyUsage",
      keyCertSign: true,
      digitalSignature: true,
      nonRepudiation: true,
      keyEncipherment: true,
      dataEncipherment: true
    }, {
      name: "extKeyUsage",
      serverAuth: true,
      clientAuth: true,
      codeSigning: true,
      emailProtection: true,
      timeStamping: true
    }, {
      name: "nsCertType",
      client: true,
      server: true,
      email: true,
      objsign: true,
      sslCA: true,
      emailCA: true,
      objCA: true
    }]);
    cert.sign(privateKey);
    return cert;
  };
  async function findAsync(array, asyncCompare) {
    const promises = array.map(asyncCompare);
    const results = await Promise.all(promises);
    const index = results.findIndex((result) => result);
    return array[index];
  }
  module2.exports.findAsync = findAsync;
});

// node_modules/libp2p/src/keychain/cms.js
var require_cms = __commonJS((exports2, module2) => {
  "use strict";
  require_pkcs7();
  require_pbe();
  var forge = require_forge();
  var {certificateForKey, findAsync} = require_util13();
  var errcode = require_err_code();
  var uint8ArrayFromString = require_from_string2();
  var uint8ArrayToString = require_to_string2();
  var privates = new WeakMap();
  var CMS = class {
    constructor(keychain, dek) {
      if (!keychain) {
        throw errcode(new Error("keychain is required"), "ERR_KEYCHAIN_REQUIRED");
      }
      this.keychain = keychain;
      privates.set(this, {dek});
    }
    async encrypt(name, plain) {
      if (!(plain instanceof Uint8Array)) {
        throw errcode(new Error("Plain data must be a Uint8Array"), "ERR_INVALID_PARAMS");
      }
      const key = await this.keychain.findKeyByName(name);
      const pem = await this.keychain._getPrivateKey(name);
      const dek = privates.get(this).dek;
      const privateKey = forge.pki.decryptRsaPrivateKey(pem, dek);
      const certificate = await certificateForKey(key, privateKey);
      const p7 = forge.pkcs7.createEnvelopedData();
      p7.addRecipient(certificate);
      p7.content = forge.util.createBuffer(plain);
      p7.encrypt();
      const der = forge.asn1.toDer(p7.toAsn1()).getBytes();
      return uint8ArrayFromString(der, "ascii");
    }
    async decrypt(cmsData) {
      if (!(cmsData instanceof Uint8Array)) {
        throw errcode(new Error("CMS data is required"), "ERR_INVALID_PARAMS");
      }
      let cms;
      try {
        const buf = forge.util.createBuffer(uint8ArrayToString(cmsData, "ascii"));
        const obj = forge.asn1.fromDer(buf);
        cms = forge.pkcs7.messageFromAsn1(obj);
      } catch (err) {
        throw errcode(new Error("Invalid CMS: " + err.message), "ERR_INVALID_CMS");
      }
      const recipients = cms.recipients.filter((r2) => r2.issuer.find((a) => a.shortName === "O" && a.value === "ipfs")).filter((r2) => r2.issuer.find((a) => a.shortName === "CN")).map((r2) => {
        return {
          recipient: r2,
          keyId: r2.issuer.find((a) => a.shortName === "CN").value
        };
      });
      const r = await findAsync(recipients, async (recipient) => {
        try {
          const key2 = await this.keychain.findKeyById(recipient.keyId);
          if (key2)
            return true;
        } catch (err) {
          return false;
        }
        return false;
      });
      if (!r) {
        const missingKeys = recipients.map((r2) => r2.keyId);
        throw errcode(new Error("Decryption needs one of the key(s): " + missingKeys.join(", ")), "ERR_MISSING_KEYS", {
          missingKeys
        });
      }
      const key = await this.keychain.findKeyById(r.keyId);
      if (!key) {
        throw errcode(new Error("No key available to decrypto"), "ERR_NO_KEY");
      }
      const pem = await this.keychain._getPrivateKey(key.name);
      const dek = privates.get(this).dek;
      const privateKey = forge.pki.decryptRsaPrivateKey(pem, dek);
      cms.decrypt(r.recipient, privateKey);
      return uint8ArrayFromString(cms.content.getBytes(), "ascii");
    }
  };
  module2.exports = CMS;
});

// node_modules/libp2p/src/keychain/index.js
var require_keychain = __commonJS((exports2, module2) => {
  "use strict";
  var sanitize = require_sanitize_filename();
  var mergeOptions = require_merge_options();
  var crypto2 = require_src10();
  var {Key} = require_src15();
  var CMS = require_cms();
  var errcode = require_err_code();
  var uint8ArrayToString = require_to_string2();
  var uint8ArrayFromString = require_from_string2();
  require_sha512();
  var keyPrefix = "/pkcs8/";
  var infoPrefix = "/info/";
  var privates = new WeakMap();
  var NIST = {
    minKeyLength: 112 / 8,
    minSaltLength: 128 / 8,
    minIterationCount: 1e3
  };
  var defaultOptions = {
    dek: {
      keyLength: 512 / 8,
      iterationCount: 1e4,
      salt: "you should override this value with a crypto secure random number",
      hash: "sha2-512"
    }
  };
  function validateKeyName(name) {
    if (!name)
      return false;
    if (typeof name !== "string")
      return false;
    return name === sanitize(name.trim());
  }
  async function throwDelayed(err) {
    const min = 200;
    const max = 1e3;
    const delay = Math.random() * (max - min) + min;
    await new Promise((resolve) => setTimeout(resolve, delay));
    throw err;
  }
  function DsName(name) {
    return new Key(keyPrefix + name);
  }
  function DsInfoName(name) {
    return new Key(infoPrefix + name);
  }
  var Keychain = class {
    constructor(store, options) {
      if (!store) {
        throw new Error("store is required");
      }
      this.store = store;
      this.opts = mergeOptions(defaultOptions, options);
      if (this.opts.passPhrase && this.opts.passPhrase.length < 20) {
        throw new Error("passPhrase must be least 20 characters");
      }
      if (this.opts.dek.keyLength < NIST.minKeyLength) {
        throw new Error(`dek.keyLength must be least ${NIST.minKeyLength} bytes`);
      }
      if (this.opts.dek.salt.length < NIST.minSaltLength) {
        throw new Error(`dek.saltLength must be least ${NIST.minSaltLength} bytes`);
      }
      if (this.opts.dek.iterationCount < NIST.minIterationCount) {
        throw new Error(`dek.iterationCount must be least ${NIST.minIterationCount}`);
      }
      const dek = this.opts.passPhrase ? crypto2.pbkdf2(this.opts.passPhrase, this.opts.dek.salt, this.opts.dek.iterationCount, this.opts.dek.keyLength, this.opts.dek.hash) : "";
      privates.set(this, {dek});
    }
    get cms() {
      return new CMS(this, privates.get(this).dek);
    }
    static generateOptions() {
      const options = Object.assign({}, defaultOptions);
      const saltLength = Math.ceil(NIST.minSaltLength / 3) * 3;
      options.dek.salt = uint8ArrayToString(crypto2.randomBytes(saltLength), "base64");
      return options;
    }
    static get options() {
      return defaultOptions;
    }
    async createKey(name, type, size = 2048) {
      const self2 = this;
      if (!validateKeyName(name) || name === "self") {
        return throwDelayed(errcode(new Error(`Invalid key name '${name}'`), "ERR_INVALID_KEY_NAME"));
      }
      if (typeof type !== "string") {
        return throwDelayed(errcode(new Error(`Invalid key type '${type}'`), "ERR_INVALID_KEY_TYPE"));
      }
      const dsname = DsName(name);
      const exists = await self2.store.has(dsname);
      if (exists)
        return throwDelayed(errcode(new Error(`Key '${name}' already exists`), "ERR_KEY_ALREADY_EXISTS"));
      switch (type.toLowerCase()) {
        case "rsa":
          if (!Number.isSafeInteger(size) || size < 2048) {
            return throwDelayed(errcode(new Error(`Invalid RSA key size ${size}`), "ERR_INVALID_KEY_SIZE"));
          }
          break;
        default:
          break;
      }
      let keyInfo;
      try {
        const keypair = await crypto2.keys.generateKeyPair(type, size);
        const kid = await keypair.id();
        const dek = privates.get(this).dek;
        const pem = await keypair.export(dek);
        keyInfo = {
          name,
          id: kid
        };
        const batch = self2.store.batch();
        batch.put(dsname, uint8ArrayFromString(pem));
        batch.put(DsInfoName(name), uint8ArrayFromString(JSON.stringify(keyInfo)));
        await batch.commit();
      } catch (err) {
        return throwDelayed(err);
      }
      return keyInfo;
    }
    async listKeys() {
      const self2 = this;
      const query = {
        prefix: infoPrefix
      };
      const info = [];
      for await (const value of self2.store.query(query)) {
        info.push(JSON.parse(uint8ArrayToString(value.value)));
      }
      return info;
    }
    async findKeyById(id) {
      try {
        const keys = await this.listKeys();
        return keys.find((k) => k.id === id);
      } catch (err) {
        return throwDelayed(err);
      }
    }
    async findKeyByName(name) {
      if (!validateKeyName(name)) {
        return throwDelayed(errcode(new Error(`Invalid key name '${name}'`), "ERR_INVALID_KEY_NAME"));
      }
      const dsname = DsInfoName(name);
      try {
        const res = await this.store.get(dsname);
        return JSON.parse(uint8ArrayToString(res));
      } catch (err) {
        return throwDelayed(errcode(new Error(`Key '${name}' does not exist. ${err.message}`), "ERR_KEY_NOT_FOUND"));
      }
    }
    async removeKey(name) {
      const self2 = this;
      if (!validateKeyName(name) || name === "self") {
        return throwDelayed(errcode(new Error(`Invalid key name '${name}'`), "ERR_INVALID_KEY_NAME"));
      }
      const dsname = DsName(name);
      const keyInfo = await self2.findKeyByName(name);
      const batch = self2.store.batch();
      batch.delete(dsname);
      batch.delete(DsInfoName(name));
      await batch.commit();
      return keyInfo;
    }
    async renameKey(oldName, newName) {
      const self2 = this;
      if (!validateKeyName(oldName) || oldName === "self") {
        return throwDelayed(errcode(new Error(`Invalid old key name '${oldName}'`), "ERR_OLD_KEY_NAME_INVALID"));
      }
      if (!validateKeyName(newName) || newName === "self") {
        return throwDelayed(errcode(new Error(`Invalid new key name '${newName}'`), "ERR_NEW_KEY_NAME_INVALID"));
      }
      const oldDsname = DsName(oldName);
      const newDsname = DsName(newName);
      const oldInfoName = DsInfoName(oldName);
      const newInfoName = DsInfoName(newName);
      const exists = await self2.store.has(newDsname);
      if (exists)
        return throwDelayed(errcode(new Error(`Key '${newName}' already exists`), "ERR_KEY_ALREADY_EXISTS"));
      try {
        const pem = await self2.store.get(oldDsname);
        const res = await self2.store.get(oldInfoName);
        const keyInfo = JSON.parse(uint8ArrayToString(res));
        keyInfo.name = newName;
        const batch = self2.store.batch();
        batch.put(newDsname, pem);
        batch.put(newInfoName, uint8ArrayFromString(JSON.stringify(keyInfo)));
        batch.delete(oldDsname);
        batch.delete(oldInfoName);
        await batch.commit();
        return keyInfo;
      } catch (err) {
        return throwDelayed(err);
      }
    }
    async exportKey(name, password) {
      if (!validateKeyName(name)) {
        return throwDelayed(errcode(new Error(`Invalid key name '${name}'`), "ERR_INVALID_KEY_NAME"));
      }
      if (!password) {
        return throwDelayed(errcode(new Error("Password is required"), "ERR_PASSWORD_REQUIRED"));
      }
      const dsname = DsName(name);
      try {
        const res = await this.store.get(dsname);
        const pem = uint8ArrayToString(res);
        const dek = privates.get(this).dek;
        const privateKey = await crypto2.keys.import(pem, dek);
        return privateKey.export(password);
      } catch (err) {
        return throwDelayed(err);
      }
    }
    async importKey(name, pem, password) {
      const self2 = this;
      if (!validateKeyName(name) || name === "self") {
        return throwDelayed(errcode(new Error(`Invalid key name '${name}'`), "ERR_INVALID_KEY_NAME"));
      }
      if (!pem) {
        return throwDelayed(errcode(new Error("PEM encoded key is required"), "ERR_PEM_REQUIRED"));
      }
      const dsname = DsName(name);
      const exists = await self2.store.has(dsname);
      if (exists)
        return throwDelayed(errcode(new Error(`Key '${name}' already exists`), "ERR_KEY_ALREADY_EXISTS"));
      let privateKey;
      try {
        privateKey = await crypto2.keys.import(pem, password);
      } catch (err) {
        return throwDelayed(errcode(new Error("Cannot read the key, most likely the password is wrong"), "ERR_CANNOT_READ_KEY"));
      }
      let kid;
      try {
        kid = await privateKey.id();
        const dek = privates.get(this).dek;
        pem = await privateKey.export(dek);
      } catch (err) {
        return throwDelayed(err);
      }
      const keyInfo = {
        name,
        id: kid
      };
      const batch = self2.store.batch();
      batch.put(dsname, uint8ArrayFromString(pem));
      batch.put(DsInfoName(name), uint8ArrayFromString(JSON.stringify(keyInfo)));
      await batch.commit();
      return keyInfo;
    }
    async importPeer(name, peer) {
      const self2 = this;
      if (!validateKeyName(name)) {
        return throwDelayed(errcode(new Error(`Invalid key name '${name}'`), "ERR_INVALID_KEY_NAME"));
      }
      if (!peer || !peer.privKey) {
        return throwDelayed(errcode(new Error("Peer.privKey is required"), "ERR_MISSING_PRIVATE_KEY"));
      }
      const privateKey = peer.privKey;
      const dsname = DsName(name);
      const exists = await self2.store.has(dsname);
      if (exists)
        return throwDelayed(errcode(new Error(`Key '${name}' already exists`), "ERR_KEY_ALREADY_EXISTS"));
      try {
        const kid = await privateKey.id();
        const dek = privates.get(this).dek;
        const pem = await privateKey.export(dek);
        const keyInfo = {
          name,
          id: kid
        };
        const batch = self2.store.batch();
        batch.put(dsname, uint8ArrayFromString(pem));
        batch.put(DsInfoName(name), uint8ArrayFromString(JSON.stringify(keyInfo)));
        await batch.commit();
        return keyInfo;
      } catch (err) {
        return throwDelayed(err);
      }
    }
    async _getPrivateKey(name) {
      if (!validateKeyName(name)) {
        return throwDelayed(errcode(new Error(`Invalid key name '${name}'`), "ERR_INVALID_KEY_NAME"));
      }
      try {
        const dsname = DsName(name);
        const res = await this.store.get(dsname);
        return uint8ArrayToString(res);
      } catch (err) {
        return throwDelayed(errcode(new Error(`Key '${name}' does not exist. ${err.message}`), "ERR_KEY_NOT_FOUND"));
      }
    }
  };
  module2.exports = Keychain;
});

// node_modules/libp2p/src/metrics/old-peers.js
var require_old_peers = __commonJS((exports2, module2) => {
  "use strict";
  var LRU = require_hashlru();
  module2.exports = (maxSize) => {
    const patched = LRU(maxSize);
    patched.delete = patched.remove;
    return patched;
  };
});

// node_modules/moving-average/index.js
var require_moving_average = __commonJS((exports2, module2) => {
  "use strict";
  var exp = Math.exp;
  exports2 = module2.exports = function MovingAverage(timespan) {
    if (typeof timespan !== "number") {
      throw new Error("must provide a timespan to the moving average constructor");
    }
    if (timespan <= 0) {
      throw new Error("must provide a timespan > 0 to the moving average constructor");
    }
    let ma;
    let v = 0;
    let d = 0;
    let f = 0;
    let previousTime;
    let ret = {};
    function alpha(t, pt) {
      return 1 - exp(-(t - pt) / timespan);
    }
    ret.push = function push(time, value) {
      if (previousTime) {
        const a = alpha(time, previousTime);
        const diff = value - ma;
        const incr = a * diff;
        ma = a * value + (1 - a) * ma;
        v = (1 - a) * (v + diff * incr);
        d = Math.sqrt(v);
        f = ma + a * diff;
      } else {
        ma = value;
      }
      previousTime = time;
    };
    ret.movingAverage = function movingAverage() {
      return ma;
    };
    ret.variance = function variance() {
      return v;
    };
    ret.deviation = function deviation() {
      return d;
    };
    ret.forecast = function forecast() {
      return f;
    };
    return ret;
  };
});

// node_modules/libp2p/src/metrics/stats.js
var require_stats2 = __commonJS((exports2, module2) => {
  "use strict";
  var EventEmitter = require_events();
  var Big = require_bignumber();
  var MovingAverage = require_moving_average();
  var retimer = require_retimer();
  var Stats = class extends EventEmitter {
    constructor(initialCounters, options) {
      super();
      this._options = options;
      this._queue = [];
      this._stats = {};
      this._frequencyLastTime = Date.now();
      this._frequencyAccumulators = {};
      this._movingAverages = {};
      this._update = this._update.bind(this);
      const intervals = this._options.movingAverageIntervals;
      for (var i = 0; i < initialCounters.length; i++) {
        var key = initialCounters[i];
        this._stats[key] = Big(0);
        this._movingAverages[key] = {};
        for (var k = 0; k < intervals.length; k++) {
          var interval = intervals[k];
          var ma = this._movingAverages[key][interval] = MovingAverage(interval);
          ma.push(this._frequencyLastTime, 0);
        }
      }
    }
    start() {
      if (this._queue.length) {
        this._resetComputeTimeout();
      }
    }
    stop() {
      if (this._timeout) {
        this._timeout.clear();
        this._timeout = null;
      }
    }
    get snapshot() {
      return Object.assign({}, this._stats);
    }
    get movingAverages() {
      return Object.assign({}, this._movingAverages);
    }
    toJSON() {
      const snapshot = this.snapshot;
      const movingAverages = this.movingAverages;
      const data = {
        dataReceived: snapshot.dataReceived.toString(),
        dataSent: snapshot.dataSent.toString(),
        movingAverages: {}
      };
      const counters = Object.keys(movingAverages);
      for (const key of counters) {
        data.movingAverages[key] = {};
        for (const interval of Object.keys(movingAverages[key])) {
          data.movingAverages[key][interval] = movingAverages[key][interval].movingAverage();
        }
      }
      return data;
    }
    push(counter, inc) {
      this._queue.push([counter, inc, Date.now()]);
      this._resetComputeTimeout();
    }
    _resetComputeTimeout() {
      this._timeout = retimer(this._update, this._nextTimeout());
    }
    _nextTimeout() {
      const urgency = this._queue.length / this._options.computeThrottleMaxQueueSize;
      const timeout = Math.max(this._options.computeThrottleTimeout * (1 - urgency), 0);
      return timeout;
    }
    _update() {
      this._timeout = null;
      if (this._queue.length) {
        let last;
        for (last of this._queue) {
          this._applyOp(last);
        }
        this._queue = [];
        this._updateFrequency(last[2]);
        this.emit("update", this._stats);
      }
    }
    _updateFrequency(latestTime) {
      const timeDiff = latestTime - this._frequencyLastTime;
      Object.keys(this._stats).forEach((key) => {
        this._updateFrequencyFor(key, timeDiff, latestTime);
      });
      this._frequencyLastTime = latestTime;
    }
    _updateFrequencyFor(key, timeDiffMS, latestTime) {
      const count = this._frequencyAccumulators[key] || 0;
      this._frequencyAccumulators[key] = 0;
      const safeTimeDiff = timeDiffMS || 1;
      const hz = count / safeTimeDiff * 1e3;
      let movingAverages = this._movingAverages[key];
      if (!movingAverages) {
        movingAverages = this._movingAverages[key] = {};
      }
      const intervals = this._options.movingAverageIntervals;
      for (var i = 0; i < intervals.length; i++) {
        var movingAverageInterval = intervals[i];
        var movingAverage = movingAverages[movingAverageInterval];
        if (!movingAverage) {
          movingAverage = movingAverages[movingAverageInterval] = MovingAverage(movingAverageInterval);
        }
        movingAverage.push(latestTime, hz);
      }
    }
    _applyOp(op) {
      const key = op[0];
      const inc = op[1];
      if (typeof inc !== "number") {
        throw new Error(`invalid increment number: ${inc}`);
      }
      let n;
      if (!Object.prototype.hasOwnProperty.call(this._stats, key)) {
        n = this._stats[key] = Big(0);
      } else {
        n = this._stats[key];
      }
      this._stats[key] = n.plus(inc);
      if (!this._frequencyAccumulators[key]) {
        this._frequencyAccumulators[key] = 0;
      }
      this._frequencyAccumulators[key] += inc;
    }
  };
  module2.exports = Stats;
});

// node_modules/libp2p/src/metrics/index.js
var require_metrics = __commonJS((exports2, module2) => {
  "use strict";
  var mergeOptions = require_merge_options();
  var {pipe} = require_it_pipe();
  var {tap} = require_dist2();
  var oldPeerLRU = require_old_peers();
  var {METRICS: defaultOptions} = require_constants10();
  var Stats = require_stats2();
  var initialCounters = [
    "dataReceived",
    "dataSent"
  ];
  var directionToEvent = {
    in: "dataReceived",
    out: "dataSent"
  };
  var Metrics = class {
    constructor(options) {
      this._options = mergeOptions(defaultOptions, options);
      this._globalStats = new Stats(initialCounters, this._options);
      this._peerStats = new Map();
      this._protocolStats = new Map();
      this._oldPeers = oldPeerLRU(this._options.maxOldPeersRetention);
      this._running = false;
      this._onMessage = this._onMessage.bind(this);
      this._connectionManager = options.connectionManager;
      this._connectionManager.on("peer:disconnect", (connection) => {
        this.onPeerDisconnected(connection.remotePeer);
      });
    }
    start() {
      this._running = true;
    }
    stop() {
      this._running = false;
      this._globalStats.stop();
      for (const stats of this._peerStats.values()) {
        stats.stop();
      }
      for (const stats of this._protocolStats.values()) {
        stats.stop();
      }
    }
    get global() {
      return this._globalStats;
    }
    get peers() {
      return Array.from(this._peerStats.keys());
    }
    forPeer(peerId) {
      const idString = peerId.toB58String();
      return this._peerStats.get(idString) || this._oldPeers.get(idString);
    }
    get protocols() {
      return Array.from(this._protocolStats.keys());
    }
    forProtocol(protocol) {
      return this._protocolStats.get(protocol);
    }
    onPeerDisconnected(peerId) {
      const idString = peerId.toB58String();
      const peerStats = this._peerStats.get(idString);
      if (peerStats) {
        peerStats.stop();
        this._peerStats.delete(idString);
        this._oldPeers.set(idString, peerStats);
      }
    }
    _onMessage({remotePeer, protocol, direction, dataLength}) {
      if (!this._running)
        return;
      const key = directionToEvent[direction];
      let peerStats = this.forPeer(remotePeer);
      if (!peerStats) {
        peerStats = new Stats(initialCounters, this._options);
        this._peerStats.set(remotePeer.toB58String(), peerStats);
      }
      peerStats.push(key, dataLength);
      this._globalStats.push(key, dataLength);
      if (protocol) {
        let protocolStats = this.forProtocol(protocol);
        if (!protocolStats) {
          protocolStats = new Stats(initialCounters, this._options);
          this._protocolStats.set(protocol, protocolStats);
        }
        protocolStats.push(key, dataLength);
      }
    }
    updatePlaceholder(placeholder, peerId) {
      if (!this._running)
        return;
      const placeholderStats = this.forPeer(placeholder);
      const peerIdString = peerId.toB58String();
      const existingStats = this.forPeer(peerId);
      let mergedStats = placeholderStats;
      if (existingStats) {
        mergedStats = Metrics.mergeStats(existingStats, mergedStats);
        this._oldPeers.delete(peerIdString);
      }
      this._peerStats.delete(placeholder.toB58String());
      this._peerStats.set(peerIdString, mergedStats);
      mergedStats.start();
    }
    trackStream({stream, remotePeer, protocol}) {
      const metrics = this;
      const _source = stream.source;
      stream.source = tap((chunk) => metrics._onMessage({
        remotePeer,
        protocol,
        direction: "in",
        dataLength: chunk.length
      }))(_source);
      const _sink = stream.sink;
      stream.sink = (source) => {
        return pipe(source, tap((chunk) => metrics._onMessage({
          remotePeer,
          protocol,
          direction: "out",
          dataLength: chunk.length
        })), _sink);
      };
      return stream;
    }
    static mergeStats(target, other) {
      target.stop();
      other.stop();
      target._queue = [...target._queue, ...other._queue];
      return target;
    }
  };
  module2.exports = Metrics;
});

// node_modules/multistream-select/src/multistream.js
var require_multistream = __commonJS((exports2) => {
  "use strict";
  var BufferList = require_BufferList();
  var lp = require_src37();
  var pipe = require_it_pipe();
  var errCode = require_err_code();
  var uint8ArrayFromString = require_from_string2();
  var NewLine = uint8ArrayFromString("\n");
  async function oneChunk(source) {
    for await (const chunk of source)
      return chunk;
  }
  exports2.encode = (buffer) => lp.encode.single(new BufferList([buffer, NewLine]));
  exports2.write = (writer, buffer) => writer.push(exports2.encode(buffer));
  exports2.writeAll = (writer, buffers) => {
    writer.push(buffers.reduce((bl, buffer) => bl.append(exports2.encode(buffer)), new BufferList()));
  };
  exports2.read = async (reader) => {
    let byteLength = 1;
    const varByteSource = {
      [Symbol.asyncIterator]() {
        return this;
      },
      next: () => reader.next(byteLength)
    };
    const onLength = (l) => {
      byteLength = l;
    };
    const buf = await pipe(varByteSource, lp.decode({onLength}), oneChunk);
    if (buf.get(buf.length - 1) !== NewLine[0]) {
      throw errCode(new Error("missing newline"), "ERR_INVALID_MULTISTREAM_SELECT_MESSAGE");
    }
    return buf.shallowSlice(0, -1);
  };
});

// node_modules/multistream-select/src/select.js
var require_select = __commonJS((exports2, module2) => {
  "use strict";
  var log = require_browser4()("mss:select");
  var errCode = require_err_code();
  var multistream = require_multistream();
  var handshake = require_src42();
  module2.exports = async (stream, protocols, protocolId) => {
    protocols = Array.isArray(protocols) ? [...protocols] : [protocols];
    const {reader, writer, rest, stream: shakeStream} = handshake(stream);
    const protocol = protocols.shift();
    if (protocolId) {
      log('select: write ["%s", "%s"]', protocolId, protocol);
      multistream.writeAll(writer, [protocolId, protocol]);
    } else {
      log('select: write "%s"', protocol);
      multistream.write(writer, protocol);
    }
    let response = (await multistream.read(reader)).toString();
    log('select: read "%s"', response);
    if (response === protocolId) {
      response = (await multistream.read(reader)).toString();
      log('select: read "%s"', response);
    }
    if (response === protocol) {
      rest();
      return {stream: shakeStream, protocol};
    }
    for (const protocol2 of protocols) {
      log('select: write "%s"', protocol2);
      multistream.write(writer, protocol2);
      const response2 = (await multistream.read(reader)).toString();
      log('select: read "%s" for "%s"', response2, protocol2);
      if (response2 === protocol2) {
        rest();
        return {stream: shakeStream, protocol: protocol2};
      }
    }
    rest();
    throw errCode(new Error("protocol selection failed"), "ERR_UNSUPPORTED_PROTOCOL");
  };
});

// node_modules/multistream-select/src/constants.js
var require_constants12 = __commonJS((exports2) => {
  "use strict";
  exports2.PROTOCOL_ID = "/multistream/1.0.0";
});

// node_modules/multistream-select/src/handle.js
var require_handle = __commonJS((exports2, module2) => {
  "use strict";
  var log = require_browser4()("mss:handle");
  var BufferList = require_BufferList();
  var multistream = require_multistream();
  var handshake = require_src42();
  var {PROTOCOL_ID} = require_constants12();
  module2.exports = async (stream, protocols) => {
    protocols = Array.isArray(protocols) ? protocols : [protocols];
    const {writer, reader, rest, stream: shakeStream} = handshake(stream);
    while (true) {
      const protocol = (await multistream.read(reader)).toString();
      log('read "%s"', protocol);
      if (protocol === PROTOCOL_ID) {
        log('respond with "%s" for "%s"', PROTOCOL_ID, protocol);
        multistream.write(writer, PROTOCOL_ID);
        continue;
      }
      if (protocols.includes(protocol)) {
        multistream.write(writer, protocol);
        log('respond with "%s" for "%s"', protocol, protocol);
        rest();
        return {stream: shakeStream, protocol};
      }
      if (protocol === "ls") {
        multistream.write(writer, new BufferList(protocols.map((p) => multistream.encode(p))));
        log('respond with "%s" for %s', protocols, protocol);
        continue;
      }
      multistream.write(writer, "na");
      log('respond with "na" for "%s"', protocol);
    }
  };
});

// node_modules/multistream-select/src/ls.js
var require_ls4 = __commonJS((exports2, module2) => {
  "use strict";
  var Reader = require_it_reader();
  var log = require_browser4()("it-multistream-select:ls");
  var multistream = require_multistream();
  var handshake = require_src42();
  var lp = require_src37();
  var pipe = require_it_pipe();
  module2.exports = async (stream) => {
    const {reader, writer, rest, stream: shakeStream} = handshake(stream);
    log('write "ls"');
    multistream.write(writer, "ls");
    rest();
    const res = await multistream.read(reader);
    const protocolsReader = Reader([res]);
    const protocols = [];
    await pipe(protocolsReader, lp.decode(), async (source) => {
      for await (const protocol of source) {
        protocols.push(protocol.shallowSlice(0, -1).toString());
      }
    });
    return {stream: shakeStream, protocols};
  };
});

// node_modules/multistream-select/src/index.js
var require_src43 = __commonJS((exports2) => {
  "use strict";
  var select = require_select();
  var handle = require_handle();
  var ls = require_ls4();
  var {PROTOCOL_ID} = require_constants12();
  exports2.PROTOCOL_ID = PROTOCOL_ID;
  var MultistreamSelect = class {
    constructor(stream) {
      this._stream = stream;
      this._shaken = false;
    }
    async _handshake() {
      if (this._shaken)
        return;
      const {stream} = await select(this._stream, PROTOCOL_ID);
      this._stream = stream;
      this._shaken = true;
    }
  };
  var Dialer = class extends MultistreamSelect {
    select(protocols) {
      return select(this._stream, protocols, this._shaken ? null : PROTOCOL_ID);
    }
    async ls() {
      await this._handshake();
      const {stream, protocols} = await ls(this._stream);
      this._stream = stream;
      return protocols;
    }
  };
  exports2.Dialer = Dialer;
  var Listener = class extends MultistreamSelect {
    handle(protocols) {
      return handle(this._stream, protocols);
    }
  };
  exports2.Listener = Listener;
});

// node_modules/libp2p-interfaces/src/connection/status.js
var require_status = __commonJS((exports2, module2) => {
  "use strict";
  var STATUS = {
    OPEN: "open",
    CLOSING: "closing",
    CLOSED: "closed"
  };
  module2.exports = STATUS;
});

// node_modules/libp2p-interfaces/src/connection/connection.js
var require_connection = __commonJS((exports2, module2) => {
  "use strict";
  var PeerId = require_src9();
  var multiaddr = require_src11();
  var errCode = require_err_code();
  var {OPEN, CLOSING, CLOSED} = require_status();
  var connectionSymbol = Symbol.for("@libp2p/interface-connection/connection");
  var Connection = class {
    constructor({localAddr, remoteAddr, localPeer, remotePeer, newStream, close, getStreams, stat}) {
      validateArgs(localAddr, localPeer, remotePeer, newStream, close, getStreams, stat);
      this.id = parseInt(String(Math.random() * 1e9)).toString(36) + Date.now();
      this.localAddr = localAddr;
      this.remoteAddr = remoteAddr;
      this.localPeer = localPeer;
      this.remotePeer = remotePeer;
      this._stat = {
        ...stat,
        status: OPEN
      };
      this._newStream = newStream;
      this._close = close;
      this._getStreams = getStreams;
      this.registry = new Map();
      this.tags = [];
    }
    get [Symbol.toStringTag]() {
      return "Connection";
    }
    get [connectionSymbol]() {
      return true;
    }
    static isConnection(other) {
      return Boolean(other && other[connectionSymbol]);
    }
    get stat() {
      return this._stat;
    }
    get streams() {
      return this._getStreams();
    }
    async newStream(protocols) {
      if (this.stat.status === CLOSING) {
        throw errCode(new Error("the connection is being closed"), "ERR_CONNECTION_BEING_CLOSED");
      }
      if (this.stat.status === CLOSED) {
        throw errCode(new Error("the connection is closed"), "ERR_CONNECTION_CLOSED");
      }
      if (!Array.isArray(protocols))
        protocols = [protocols];
      const {stream, protocol} = await this._newStream(protocols);
      this.addStream(stream, {protocol});
      return {
        stream,
        protocol
      };
    }
    addStream(muxedStream, {protocol, metadata = {}}) {
      this.registry.set(muxedStream.id, {
        protocol,
        ...metadata
      });
    }
    removeStream(id) {
      this.registry.delete(id);
    }
    async close() {
      if (this.stat.status === CLOSED) {
        return;
      }
      if (this._closing) {
        return this._closing;
      }
      this.stat.status = CLOSING;
      this._closing = await this._close();
      this._stat.timeline.close = Date.now();
      this.stat.status = CLOSED;
    }
  };
  module2.exports = Connection;
  function validateArgs(localAddr, localPeer, remotePeer, newStream, close, getStreams, stat) {
    if (localAddr && !multiaddr.isMultiaddr(localAddr)) {
      throw errCode(new Error("localAddr must be an instance of multiaddr"), "ERR_INVALID_PARAMETERS");
    }
    if (!PeerId.isPeerId(localPeer)) {
      throw errCode(new Error("localPeer must be an instance of peer-id"), "ERR_INVALID_PARAMETERS");
    }
    if (!PeerId.isPeerId(remotePeer)) {
      throw errCode(new Error("remotePeer must be an instance of peer-id"), "ERR_INVALID_PARAMETERS");
    }
    if (typeof newStream !== "function") {
      throw errCode(new Error("new stream must be a function"), "ERR_INVALID_PARAMETERS");
    }
    if (typeof close !== "function") {
      throw errCode(new Error("close must be a function"), "ERR_INVALID_PARAMETERS");
    }
    if (typeof getStreams !== "function") {
      throw errCode(new Error("getStreams must be a function"), "ERR_INVALID_PARAMETERS");
    }
    if (!stat) {
      throw errCode(new Error("connection metadata object must be provided"), "ERR_INVALID_PARAMETERS");
    }
    if (stat.direction !== "inbound" && stat.direction !== "outbound") {
      throw errCode(new Error('direction must be "inbound" or "outbound"'), "ERR_INVALID_PARAMETERS");
    }
    if (!stat.timeline) {
      throw errCode(new Error("connection timeline object must be provided in the stat object"), "ERR_INVALID_PARAMETERS");
    }
    if (!stat.timeline.open) {
      throw errCode(new Error("connection open timestamp must be provided"), "ERR_INVALID_PARAMETERS");
    }
    if (!stat.timeline.upgraded) {
      throw errCode(new Error("connection upgraded timestamp must be provided"), "ERR_INVALID_PARAMETERS");
    }
  }
});

// node_modules/libp2p-interfaces/src/connection/index.js
var require_connection2 = __commonJS((exports2) => {
  "use strict";
  exports2.Connection = require_connection();
});

// node_modules/mutable-proxy/build/index.js
var require_build2 = __commonJS((exports2, module2) => {
  "use strict";
  function _toConsumableArray(arr) {
    if (Array.isArray(arr)) {
      for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
        arr2[i] = arr[i];
      }
      return arr2;
    } else {
      return Array.from(arr);
    }
  }
  module2.exports = function mutableProxyFactory(defaultTarget) {
    var mutableHandler = void 0;
    var mutableTarget = void 0;
    function setTarget(target) {
      if (!(target instanceof Object)) {
        throw new Error('Target "' + target + '" is not an object');
      }
      mutableTarget = target;
    }
    function setHandler(handler2) {
      Object.keys(handler2).forEach(function(key) {
        var value = handler2[key];
        if (typeof value !== "function") {
          throw new Error('Trap "' + key + ": " + value + '" is not a function');
        }
        if (!Reflect[key]) {
          throw new Error('Trap "' + key + ": " + value + '" is not a valid trap');
        }
      });
      mutableHandler = handler2;
    }
    setTarget(function() {
    });
    if (defaultTarget) {
      setTarget(defaultTarget);
    }
    setHandler(Reflect);
    var handler = new Proxy({}, {
      get: function get(target, property) {
        return function() {
          for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }
          return mutableHandler[property].apply(null, [mutableTarget].concat(_toConsumableArray(args.slice(1))));
        };
      }
    });
    return {
      setTarget,
      setHandler,
      getTarget: function getTarget() {
        return mutableTarget;
      },
      getHandler: function getHandler() {
        return mutableHandler;
      },
      proxy: new Proxy(mutableTarget, handler)
    };
  };
});

// node_modules/libp2p/src/upgrader.js
var require_upgrader = __commonJS((exports2, module2) => {
  "use strict";
  var debug = require_browser4();
  var log = Object.assign(debug("libp2p:upgrader"), {
    error: debug("libp2p:upgrader:err")
  });
  var errCode = require_err_code();
  var Multistream = require_src43();
  var {Connection} = require_connection2();
  var PeerId = require_src9();
  var {pipe} = require_it_pipe();
  var mutableProxy = require_build2();
  var {codes} = require_errors12();
  var Upgrader = class {
    constructor({
      localPeer,
      metrics,
      cryptos = new Map(),
      muxers = new Map(),
      onConnectionEnd = () => {
      },
      onConnection = () => {
      }
    }) {
      this.localPeer = localPeer;
      this.metrics = metrics;
      this.cryptos = cryptos;
      this.muxers = muxers;
      this.protector = null;
      this.protocols = new Map();
      this.onConnection = onConnection;
      this.onConnectionEnd = onConnectionEnd;
    }
    async upgradeInbound(maConn) {
      let encryptedConn;
      let remotePeer;
      let upgradedConn;
      let Muxer;
      let cryptoProtocol;
      let setPeer;
      let proxyPeer;
      if (this.metrics) {
        ({setTarget: setPeer, proxy: proxyPeer} = mutableProxy());
        const idString = (Math.random() * 1e9).toString(36) + Date.now();
        setPeer({toB58String: () => idString});
        maConn = this.metrics.trackStream({stream: maConn, remotePeer: proxyPeer});
      }
      log("Starting the inbound connection upgrade");
      let protectedConn = maConn;
      if (this.protector) {
        protectedConn = await this.protector.protect(maConn);
      }
      try {
        ({
          conn: encryptedConn,
          remotePeer,
          protocol: cryptoProtocol
        } = await this._encryptInbound(this.localPeer, protectedConn, this.cryptos));
        if (this.muxers.size) {
          ({stream: upgradedConn, Muxer} = await this._multiplexInbound(encryptedConn, this.muxers));
        } else {
          upgradedConn = encryptedConn;
        }
      } catch (err) {
        log.error("Failed to upgrade inbound connection", err);
        await maConn.close(err);
        throw err;
      }
      if (this.metrics) {
        this.metrics.updatePlaceholder(proxyPeer, remotePeer);
        setPeer(remotePeer);
      }
      log("Successfully upgraded inbound connection");
      return this._createConnection({
        cryptoProtocol,
        direction: "inbound",
        maConn,
        upgradedConn,
        Muxer,
        remotePeer
      });
    }
    async upgradeOutbound(maConn) {
      const remotePeerId = PeerId.createFromB58String(maConn.remoteAddr.getPeerId());
      let encryptedConn;
      let remotePeer;
      let upgradedConn;
      let cryptoProtocol;
      let Muxer;
      let setPeer;
      let proxyPeer;
      if (this.metrics) {
        ({setTarget: setPeer, proxy: proxyPeer} = mutableProxy());
        const idString = (Math.random() * 1e9).toString(36) + Date.now();
        setPeer({toB58String: () => idString});
        maConn = this.metrics.trackStream({stream: maConn, remotePeer: proxyPeer});
      }
      log("Starting the outbound connection upgrade");
      let protectedConn = maConn;
      if (this.protector) {
        protectedConn = await this.protector.protect(maConn);
      }
      try {
        ({
          conn: encryptedConn,
          remotePeer,
          protocol: cryptoProtocol
        } = await this._encryptOutbound(this.localPeer, protectedConn, remotePeerId, this.cryptos));
        if (this.muxers.size) {
          ({stream: upgradedConn, Muxer} = await this._multiplexOutbound(encryptedConn, this.muxers));
        } else {
          upgradedConn = encryptedConn;
        }
      } catch (err) {
        log.error("Failed to upgrade outbound connection", err);
        await maConn.close(err);
        throw err;
      }
      if (this.metrics) {
        this.metrics.updatePlaceholder(proxyPeer, remotePeer);
        setPeer(remotePeer);
      }
      log("Successfully upgraded outbound connection");
      return this._createConnection({
        cryptoProtocol,
        direction: "outbound",
        maConn,
        upgradedConn,
        Muxer,
        remotePeer
      });
    }
    _createConnection({
      cryptoProtocol,
      direction,
      maConn,
      upgradedConn,
      Muxer,
      remotePeer
    }) {
      let muxer;
      let newStream;
      let connection;
      if (Muxer) {
        muxer = new Muxer({
          onStream: async (muxedStream) => {
            const mss = new Multistream.Listener(muxedStream);
            try {
              const {stream, protocol} = await mss.handle(Array.from(this.protocols.keys()));
              log("%s: incoming stream opened on %s", direction, protocol);
              if (this.metrics)
                this.metrics.trackStream({stream, remotePeer, protocol});
              connection.addStream(muxedStream, {protocol});
              this._onStream({connection, stream: {...muxedStream, ...stream}, protocol});
            } catch (err) {
              log.error(err);
            }
          },
          onStreamEnd: (muxedStream) => {
            connection.removeStream(muxedStream.id);
          }
        });
        newStream = async (protocols) => {
          log("%s: starting new stream on %s", direction, protocols);
          const muxedStream = muxer.newStream();
          const mss = new Multistream.Dialer(muxedStream);
          try {
            const {stream, protocol} = await mss.select(protocols);
            if (this.metrics)
              this.metrics.trackStream({stream, remotePeer, protocol});
            return {stream: {...muxedStream, ...stream}, protocol};
          } catch (err) {
            log.error("could not create new stream", err);
            throw errCode(err, codes.ERR_UNSUPPORTED_PROTOCOL);
          }
        };
        pipe(upgradedConn, muxer, upgradedConn).catch(log.error);
      }
      const _timeline = maConn.timeline;
      maConn.timeline = new Proxy(_timeline, {
        set: (...args) => {
          if (connection && args[1] === "close" && args[2] && !_timeline.close) {
            (async () => {
              try {
                if (connection.stat.status === "open") {
                  await connection.close();
                }
              } catch (err) {
                log.error(err);
              } finally {
                this.onConnectionEnd(connection);
              }
            })();
          }
          return Reflect.set(...args);
        }
      });
      maConn.timeline.upgraded = Date.now();
      const errConnectionNotMultiplexed = () => {
        throw errCode(new Error("connection is not multiplexed"), "ERR_CONNECTION_NOT_MULTIPLEXED");
      };
      connection = new Connection({
        localAddr: maConn.localAddr,
        remoteAddr: maConn.remoteAddr,
        localPeer: this.localPeer,
        remotePeer,
        stat: {
          direction,
          timeline: maConn.timeline,
          multiplexer: Muxer && Muxer.multicodec,
          encryption: cryptoProtocol
        },
        newStream: newStream || errConnectionNotMultiplexed,
        getStreams: () => muxer ? muxer.streams : errConnectionNotMultiplexed,
        close: async (err) => {
          await maConn.close(err);
          if (muxer) {
            muxer.streams.map((stream) => stream.abort(err));
          }
        }
      });
      this.onConnection(connection);
      return connection;
    }
    _onStream({connection, stream, protocol}) {
      const handler = this.protocols.get(protocol);
      handler({connection, stream, protocol});
    }
    async _encryptInbound(localPeer, connection, cryptos) {
      const mss = new Multistream.Listener(connection);
      const protocols = Array.from(cryptos.keys());
      log("handling inbound crypto protocol selection", protocols);
      try {
        const {stream, protocol} = await mss.handle(protocols);
        const crypto2 = cryptos.get(protocol);
        log("encrypting inbound connection...");
        if (!crypto2) {
          throw new Error(`no crypto module found for ${protocol}`);
        }
        return {
          ...await crypto2.secureInbound(localPeer, stream),
          protocol
        };
      } catch (err) {
        throw errCode(err, codes.ERR_ENCRYPTION_FAILED);
      }
    }
    async _encryptOutbound(localPeer, connection, remotePeerId, cryptos) {
      const mss = new Multistream.Dialer(connection);
      const protocols = Array.from(cryptos.keys());
      log("selecting outbound crypto protocol", protocols);
      try {
        const {stream, protocol} = await mss.select(protocols);
        const crypto2 = cryptos.get(protocol);
        log("encrypting outbound connection to %j", remotePeerId);
        if (!crypto2) {
          throw new Error(`no crypto module found for ${protocol}`);
        }
        return {
          ...await crypto2.secureOutbound(localPeer, stream, remotePeerId),
          protocol
        };
      } catch (err) {
        throw errCode(err, codes.ERR_ENCRYPTION_FAILED);
      }
    }
    async _multiplexOutbound(connection, muxers) {
      const dialer = new Multistream.Dialer(connection);
      const protocols = Array.from(muxers.keys());
      log("outbound selecting muxer %s", protocols);
      try {
        const {stream, protocol} = await dialer.select(protocols);
        log("%s selected as muxer protocol", protocol);
        const Muxer = muxers.get(protocol);
        return {stream, Muxer};
      } catch (err) {
        throw errCode(err, codes.ERR_MUXER_UNAVAILABLE);
      }
    }
    async _multiplexInbound(connection, muxers) {
      const listener = new Multistream.Listener(connection);
      const protocols = Array.from(muxers.keys());
      log("inbound handling muxers %s", protocols);
      try {
        const {stream, protocol} = await listener.handle(protocols);
        const Muxer = muxers.get(protocol);
        return {stream, Muxer};
      } catch (err) {
        throw errCode(err, codes.ERR_MUXER_UNAVAILABLE);
      }
    }
  };
  module2.exports = Upgrader;
});

// node_modules/libp2p/src/peer-store/book.js
var require_book = __commonJS((exports2, module2) => {
  "use strict";
  var errcode = require_err_code();
  var PeerId = require_src9();
  var {
    codes: {ERR_INVALID_PARAMETERS}
  } = require_errors12();
  var passthrough = (data) => data;
  var Book = class {
    constructor({peerStore, eventName, eventProperty, eventTransformer = passthrough}) {
      this._ps = peerStore;
      this.eventName = eventName;
      this.eventProperty = eventProperty;
      this.eventTransformer = eventTransformer;
      this.data = new Map();
    }
    set(peerId, data) {
      throw errcode(new Error("set must be implemented by the subclass"), "ERR_NOT_IMPLEMENTED");
    }
    _setData(peerId, data, {emit = true} = {}) {
      const b58key = peerId.toB58String();
      this.data.set(b58key, data);
      emit && this._emit(peerId, data);
    }
    _emit(peerId, data) {
      this._ps.emit(this.eventName, {
        peerId,
        [this.eventProperty]: this.eventTransformer(data)
      });
    }
    get(peerId) {
      if (!PeerId.isPeerId(peerId)) {
        throw errcode(new Error("peerId must be an instance of peer-id"), ERR_INVALID_PARAMETERS);
      }
      const rec = this.data.get(peerId.toB58String());
      return rec ? [...rec] : void 0;
    }
    delete(peerId) {
      if (!PeerId.isPeerId(peerId)) {
        throw errcode(new Error("peerId must be an instance of peer-id"), ERR_INVALID_PARAMETERS);
      }
      if (!this.data.delete(peerId.toB58String())) {
        return false;
      }
      this._emit(peerId, []);
      return true;
    }
  };
  module2.exports = Book;
});

// node_modules/libp2p/src/peer-store/address-book.js
var require_address_book = __commonJS((exports2, module2) => {
  "use strict";
  var debug = require_browser4();
  var log = Object.assign(debug("libp2p:peer-store:address-book"), {
    error: debug("libp2p:peer-store:address-book:err")
  });
  var errcode = require_err_code();
  var multiaddr = require_src11();
  var PeerId = require_src9();
  var Book = require_book();
  var PeerRecord = require_peer_record();
  var {
    codes: {ERR_INVALID_PARAMETERS}
  } = require_errors12();
  var Envelope = require_envelope();
  var AddressBook = class extends Book {
    constructor(peerStore) {
      super({
        peerStore,
        eventName: "change:multiaddrs",
        eventProperty: "multiaddrs",
        eventTransformer: (data) => {
          if (!data.addresses) {
            return [];
          }
          return data.addresses.map((address) => address.multiaddr);
        }
      });
      this.data = new Map();
    }
    consumePeerRecord(envelope) {
      let peerRecord;
      try {
        peerRecord = PeerRecord.createFromProtobuf(envelope.payload);
      } catch (err) {
        log.error("invalid peer record received");
        return false;
      }
      if (!peerRecord.peerId.equals(envelope.peerId)) {
        log("signing key does not match PeerId in the PeerRecord");
        return false;
      }
      if (!peerRecord.multiaddrs || !peerRecord.multiaddrs.length) {
        return false;
      }
      const peerId = peerRecord.peerId;
      const id = peerId.toB58String();
      const entry = this.data.get(id) || {record: void 0};
      const storedRecord = entry.record;
      if (storedRecord && storedRecord.seqNumber >= peerRecord.seqNumber) {
        return false;
      }
      const addresses = this._toAddresses(peerRecord.multiaddrs, true);
      this._setData(peerId, {
        addresses,
        record: {
          raw: envelope.marshal(),
          seqNumber: peerRecord.seqNumber
        }
      });
      log(`stored provided peer record for ${id}`);
      return true;
    }
    getRawEnvelope(peerId) {
      const entry = this.data.get(peerId.toB58String());
      if (!entry || !entry.record || !entry.record.raw) {
        return void 0;
      }
      return entry.record.raw;
    }
    getPeerRecord(peerId) {
      const raw = this.getRawEnvelope(peerId);
      if (!raw) {
        return void 0;
      }
      return Envelope.createFromProtobuf(raw);
    }
    set(peerId, multiaddrs) {
      if (!PeerId.isPeerId(peerId)) {
        log.error("peerId must be an instance of peer-id to store data");
        throw errcode(new Error("peerId must be an instance of peer-id"), ERR_INVALID_PARAMETERS);
      }
      const addresses = this._toAddresses(multiaddrs);
      if (!addresses.length) {
        return this;
      }
      const id = peerId.toB58String();
      const entry = this.data.get(id);
      if (entry && entry.addresses && entry.addresses.length === addresses.length) {
        const intersection = entry.addresses.filter((addr) => addresses.some((newAddr) => addr.multiaddr.equals(newAddr.multiaddr)));
        if (intersection.length === entry.addresses.length) {
          log(`the addresses provided to store are equal to the already stored for ${id}`);
          return this;
        }
      }
      this._setData(peerId, {
        addresses,
        record: entry && entry.record
      });
      log(`stored provided multiaddrs for ${id}`);
      if (!entry) {
        this._ps.emit("peer", peerId);
      }
      return this;
    }
    add(peerId, multiaddrs) {
      if (!PeerId.isPeerId(peerId)) {
        log.error("peerId must be an instance of peer-id to store data");
        throw errcode(new Error("peerId must be an instance of peer-id"), ERR_INVALID_PARAMETERS);
      }
      const addresses = this._toAddresses(multiaddrs);
      const id = peerId.toB58String();
      const entry = this.data.get(id);
      if (entry && entry.addresses) {
        entry.addresses.forEach((addr) => {
          if (!addresses.find((r) => r.multiaddr.equals(addr.multiaddr))) {
            addresses.push(addr);
          }
        });
        if (entry.addresses.length === addresses.length) {
          log(`the addresses provided to store are already stored for ${id}`);
          return this;
        }
      }
      this._setData(peerId, {
        addresses,
        record: entry && entry.record
      });
      log(`added provided multiaddrs for ${id}`);
      if (!(entry && entry.addresses)) {
        this._ps.emit("peer", peerId);
      }
      return this;
    }
    get(peerId) {
      if (!PeerId.isPeerId(peerId)) {
        throw errcode(new Error("peerId must be an instance of peer-id"), ERR_INVALID_PARAMETERS);
      }
      const entry = this.data.get(peerId.toB58String());
      return entry && entry.addresses ? [...entry.addresses] : void 0;
    }
    _toAddresses(multiaddrs, isCertified = false) {
      if (!multiaddrs) {
        log.error("multiaddrs must be provided to store data");
        throw errcode(new Error("multiaddrs must be provided"), ERR_INVALID_PARAMETERS);
      }
      const addresses = [];
      multiaddrs.forEach((addr) => {
        if (!multiaddr.isMultiaddr(addr)) {
          log.error(`multiaddr ${addr} must be an instance of multiaddr`);
          throw errcode(new Error(`multiaddr ${addr} must be an instance of multiaddr`), ERR_INVALID_PARAMETERS);
        }
        addresses.push({
          multiaddr: addr,
          isCertified
        });
      });
      return addresses;
    }
    getMultiaddrsForPeer(peerId, addressSorter = (ms) => ms) {
      if (!PeerId.isPeerId(peerId)) {
        throw errcode(new Error("peerId must be an instance of peer-id"), ERR_INVALID_PARAMETERS);
      }
      const entry = this.data.get(peerId.toB58String());
      if (!entry || !entry.addresses) {
        return void 0;
      }
      return addressSorter(entry.addresses || []).map((address) => {
        const multiaddr2 = address.multiaddr;
        const idString = multiaddr2.getPeerId();
        if (idString && idString === peerId.toB58String())
          return multiaddr2;
        return multiaddr2.encapsulate(`/p2p/${peerId.toB58String()}`);
      });
    }
  };
  module2.exports = AddressBook;
});

// node_modules/libp2p/src/peer-store/key-book.js
var require_key_book = __commonJS((exports2, module2) => {
  "use strict";
  var debug = require_browser4();
  var log = Object.assign(debug("libp2p:peer-store:key-book"), {
    error: debug("libp2p:peer-store:key-book:err")
  });
  var errcode = require_err_code();
  var PeerId = require_src9();
  var Book = require_book();
  var {
    codes: {ERR_INVALID_PARAMETERS}
  } = require_errors12();
  var KeyBook = class extends Book {
    constructor(peerStore) {
      super({
        peerStore,
        eventName: "change:pubkey",
        eventProperty: "pubkey",
        eventTransformer: (data) => data.pubKey
      });
      this.data = new Map();
    }
    set(peerId, publicKey) {
      if (!PeerId.isPeerId(peerId)) {
        log.error("peerId must be an instance of peer-id to store data");
        throw errcode(new Error("peerId must be an instance of peer-id"), ERR_INVALID_PARAMETERS);
      }
      const id = peerId.toB58String();
      const recPeerId = this.data.get(id);
      if (!recPeerId && publicKey) {
        peerId.pubKey = publicKey;
        this._setData(peerId, peerId);
        log(`stored provided public key for ${id}`);
      }
      return this;
    }
    get(peerId) {
      if (!PeerId.isPeerId(peerId)) {
        throw errcode(new Error("peerId must be an instance of peer-id"), ERR_INVALID_PARAMETERS);
      }
      const rec = this.data.get(peerId.toB58String());
      return rec ? rec.pubKey : void 0;
    }
  };
  module2.exports = KeyBook;
});

// node_modules/libp2p/src/peer-store/metadata-book.js
var require_metadata_book = __commonJS((exports2, module2) => {
  "use strict";
  var debug = require_browser4();
  var log = Object.assign(debug("libp2p:peer-store:proto-book"), {
    error: debug("libp2p:peer-store:proto-book:err")
  });
  var errcode = require_err_code();
  var uint8ArrayEquals = require_equals2();
  var PeerId = require_src9();
  var Book = require_book();
  var {
    codes: {ERR_INVALID_PARAMETERS}
  } = require_errors12();
  var MetadataBook = class extends Book {
    constructor(peerStore) {
      super({
        peerStore,
        eventName: "change:metadata",
        eventProperty: "metadata"
      });
      this.data = new Map();
    }
    set(peerId, key, value) {
      if (!PeerId.isPeerId(peerId)) {
        log.error("peerId must be an instance of peer-id to store data");
        throw errcode(new Error("peerId must be an instance of peer-id"), ERR_INVALID_PARAMETERS);
      }
      if (typeof key !== "string" || !(value instanceof Uint8Array)) {
        log.error("valid key and value must be provided to store data");
        throw errcode(new Error("valid key and value must be provided"), ERR_INVALID_PARAMETERS);
      }
      this._setValue(peerId, key, value);
      return this;
    }
    _setValue(peerId, key, value, {emit = true} = {}) {
      const id = peerId.toB58String();
      const rec = this.data.get(id) || new Map();
      const recMap = rec.get(key);
      if (recMap && uint8ArrayEquals(value, recMap)) {
        log(`the metadata provided to store is equal to the already stored for ${id} on ${key}`);
        return;
      }
      rec.set(key, value);
      this.data.set(id, rec);
      emit && this._emit(peerId, key);
    }
    get(peerId) {
      if (!PeerId.isPeerId(peerId)) {
        throw errcode(new Error("peerId must be an instance of peer-id"), ERR_INVALID_PARAMETERS);
      }
      return this.data.get(peerId.toB58String());
    }
    getValue(peerId, key) {
      if (!PeerId.isPeerId(peerId)) {
        throw errcode(new Error("peerId must be an instance of peer-id"), ERR_INVALID_PARAMETERS);
      }
      const rec = this.data.get(peerId.toB58String());
      return rec && rec.get(key);
    }
    delete(peerId) {
      if (!PeerId.isPeerId(peerId)) {
        throw errcode(new Error("peerId must be an instance of peer-id"), ERR_INVALID_PARAMETERS);
      }
      if (!this.data.delete(peerId.toB58String())) {
        return false;
      }
      this._emit(peerId);
      return true;
    }
    deleteValue(peerId, key) {
      if (!PeerId.isPeerId(peerId)) {
        throw errcode(new Error("peerId must be an instance of peer-id"), ERR_INVALID_PARAMETERS);
      }
      const rec = this.data.get(peerId.toB58String());
      if (!rec || !rec.delete(key)) {
        return false;
      }
      this._emit(peerId, key);
      return true;
    }
  };
  module2.exports = MetadataBook;
});

// node_modules/libp2p/src/peer-store/proto-book.js
var require_proto_book = __commonJS((exports2, module2) => {
  "use strict";
  var debug = require_browser4();
  var log = Object.assign(debug("libp2p:peer-store:proto-book"), {
    error: debug("libp2p:peer-store:proto-book:err")
  });
  var errcode = require_err_code();
  var PeerId = require_src9();
  var Book = require_book();
  var {
    codes: {ERR_INVALID_PARAMETERS}
  } = require_errors12();
  var ProtoBook = class extends Book {
    constructor(peerStore) {
      super({
        peerStore,
        eventName: "change:protocols",
        eventProperty: "protocols",
        eventTransformer: (data) => Array.from(data)
      });
      this.data = new Map();
    }
    set(peerId, protocols) {
      if (!PeerId.isPeerId(peerId)) {
        log.error("peerId must be an instance of peer-id to store data");
        throw errcode(new Error("peerId must be an instance of peer-id"), ERR_INVALID_PARAMETERS);
      }
      if (!protocols) {
        log.error("protocols must be provided to store data");
        throw errcode(new Error("protocols must be provided"), ERR_INVALID_PARAMETERS);
      }
      const id = peerId.toB58String();
      const recSet = this.data.get(id);
      const newSet = new Set(protocols);
      const isSetEqual = (a, b) => a.size === b.size && [...a].every((value) => b.has(value));
      if (recSet && isSetEqual(recSet, newSet)) {
        log(`the protocols provided to store are equal to the already stored for ${id}`);
        return this;
      }
      this._setData(peerId, newSet);
      log(`stored provided protocols for ${id}`);
      return this;
    }
    add(peerId, protocols) {
      if (!PeerId.isPeerId(peerId)) {
        log.error("peerId must be an instance of peer-id to store data");
        throw errcode(new Error("peerId must be an instance of peer-id"), ERR_INVALID_PARAMETERS);
      }
      if (!protocols) {
        log.error("protocols must be provided to store data");
        throw errcode(new Error("protocols must be provided"), ERR_INVALID_PARAMETERS);
      }
      const id = peerId.toB58String();
      const recSet = this.data.get(id) || new Set();
      const newSet = new Set([...recSet, ...protocols]);
      if (recSet.size === newSet.size) {
        log(`the protocols provided to store are already stored for ${id}`);
        return this;
      }
      this._setData(peerId, newSet);
      log(`added provided protocols for ${id}`);
      return this;
    }
    remove(peerId, protocols) {
      if (!PeerId.isPeerId(peerId)) {
        log.error("peerId must be an instance of peer-id to store data");
        throw errcode(new Error("peerId must be an instance of peer-id"), ERR_INVALID_PARAMETERS);
      }
      if (!protocols) {
        log.error("protocols must be provided to store data");
        throw errcode(new Error("protocols must be provided"), ERR_INVALID_PARAMETERS);
      }
      const id = peerId.toB58String();
      const recSet = this.data.get(id);
      if (recSet) {
        const newSet = new Set([
          ...recSet
        ].filter((p) => !protocols.includes(p)));
        if (recSet.size === newSet.size) {
          return this;
        }
        this._setData(peerId, newSet);
        log(`removed provided protocols for ${id}`);
      }
      return this;
    }
  };
  module2.exports = ProtoBook;
});

// node_modules/libp2p/src/peer-store/index.js
var require_peer_store = __commonJS((exports2, module2) => {
  "use strict";
  var errcode = require_err_code();
  var EventEmitter = require_events();
  var PeerId = require_src9();
  var AddressBook = require_address_book();
  var KeyBook = require_key_book();
  var MetadataBook = require_metadata_book();
  var ProtoBook = require_proto_book();
  var {
    codes: {ERR_INVALID_PARAMETERS}
  } = require_errors12();
  var PeerStore = class extends EventEmitter {
    constructor({peerId}) {
      super();
      this._peerId = peerId;
      this.addressBook = new AddressBook(this);
      this.keyBook = new KeyBook(this);
      this.metadataBook = new MetadataBook(this);
      this.protoBook = new ProtoBook(this);
    }
    start() {
    }
    stop() {
    }
    get peers() {
      const storedPeers = new Set([
        ...this.addressBook.data.keys(),
        ...this.keyBook.data.keys(),
        ...this.protoBook.data.keys(),
        ...this.metadataBook.data.keys()
      ]);
      this._peerId && storedPeers.delete(this._peerId.toB58String());
      const peersData = new Map();
      storedPeers.forEach((idStr) => {
        peersData.set(idStr, this.get(PeerId.createFromCID(idStr)));
      });
      return peersData;
    }
    delete(peerId) {
      const addressesDeleted = this.addressBook.delete(peerId);
      const keyDeleted = this.keyBook.delete(peerId);
      const protocolsDeleted = this.protoBook.delete(peerId);
      const metadataDeleted = this.metadataBook.delete(peerId);
      return addressesDeleted || keyDeleted || protocolsDeleted || metadataDeleted;
    }
    get(peerId) {
      if (!PeerId.isPeerId(peerId)) {
        throw errcode(new Error("peerId must be an instance of peer-id"), ERR_INVALID_PARAMETERS);
      }
      const id = this.keyBook.data.get(peerId.toB58String());
      const addresses = this.addressBook.get(peerId);
      const metadata = this.metadataBook.get(peerId);
      const protocols = this.protoBook.get(peerId);
      if (!id && !addresses && !metadata && !protocols) {
        return void 0;
      }
      return {
        id: id || peerId,
        addresses: addresses || [],
        protocols: protocols || [],
        metadata
      };
    }
  };
  module2.exports = PeerStore;
});

// node_modules/libp2p/src/pubsub-adapter.js
var require_pubsub_adapter = __commonJS((exports2, module2) => {
  "use strict";
  function pubsubAdapter(PubsubRouter, libp2p, options) {
    const pubsub = new PubsubRouter(libp2p, options);
    pubsub._subscribeAdapter = pubsub.subscribe;
    pubsub._unsubscribeAdapter = pubsub.unsubscribe;
    function subscribe(topic, handler) {
      handler && pubsub.on(topic, handler);
      pubsub._subscribeAdapter(topic);
    }
    function unsubscribe(topic, handler) {
      if (!handler) {
        pubsub.removeAllListeners(topic);
      } else {
        pubsub.removeListener(topic, handler);
      }
      if (pubsub.listenerCount(topic) === 0) {
        pubsub._unsubscribeAdapter(topic);
      }
    }
    pubsub.subscribe = subscribe;
    pubsub.unsubscribe = unsubscribe;
    return pubsub;
  }
  module2.exports = pubsubAdapter;
});

// node_modules/libp2p/src/peer-store/persistent/consts.js
var require_consts3 = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports.NAMESPACE_COMMON = "/peers/";
  module2.exports.NAMESPACE_ADDRESS = "/peers/addrs/";
  module2.exports.NAMESPACE_KEYS = "/peers/keys/";
  module2.exports.NAMESPACE_METADATA = "/peers/metadata/";
  module2.exports.NAMESPACE_PROTOCOL = "/peers/protos/";
});

// node_modules/libp2p/src/peer-store/persistent/pb/address-book.proto.js
var require_address_book_proto = __commonJS((exports2, module2) => {
  "use strict";
  var protons = require_src8();
  var message = `
message Addresses {
  // Address represents a single multiaddr.
  message Address {
    required bytes multiaddr = 1;

    // Flag to indicate if the address comes from a certified source.
    optional bool isCertified = 2;
  }

  // CertifiedRecord contains a serialized signed PeerRecord used to
  // populate the signedAddrs list.
  message CertifiedRecord {
    // The Seq counter from the signed PeerRecord envelope
    uint64 seq = 1;

    // The serialized bytes of the SignedEnvelope containing the PeerRecord.
    bytes raw = 2;
  }

  // The known multiaddrs.
  repeated Address addrs = 1;

  // The most recently received signed PeerRecord.
  CertifiedRecord certified_record = 2;
}
`;
  module2.exports = protons(message).Addresses;
});

// node_modules/libp2p/src/peer-store/persistent/pb/proto-book.proto.js
var require_proto_book_proto = __commonJS((exports2, module2) => {
  "use strict";
  var protons = require_src8();
  var message = `
message Protocols {
  repeated string protocols = 1;
}
`;
  module2.exports = protons(message).Protocols;
});

// node_modules/libp2p/src/peer-store/persistent/index.js
var require_persistent = __commonJS((exports2, module2) => {
  "use strict";
  var debug = require_browser4();
  var log = Object.assign(debug("libp2p:persistent-peer-store"), {
    error: debug("libp2p:persistent-peer-store:err")
  });
  var {Key} = require_src15();
  var multiaddr = require_src11();
  var PeerId = require_src9();
  var PeerStore = require_peer_store();
  var {
    NAMESPACE_ADDRESS,
    NAMESPACE_COMMON,
    NAMESPACE_KEYS,
    NAMESPACE_METADATA,
    NAMESPACE_PROTOCOL
  } = require_consts3();
  var Addresses = require_address_book_proto();
  var Protocols = require_proto_book_proto();
  var PersistentPeerStore = class extends PeerStore {
    constructor({peerId, datastore, threshold = 5}) {
      super({peerId});
      this._datastore = datastore;
      this._dirtyPeers = new Set();
      this._dirtyMetadata = new Map();
      this.threshold = threshold;
      this._addDirtyPeer = this._addDirtyPeer.bind(this);
    }
    async start() {
      log("PeerStore is starting");
      this.on("change:protocols", this._addDirtyPeer);
      this.on("change:multiaddrs", this._addDirtyPeer);
      this.on("change:pubkey", this._addDirtyPeerKey);
      this.on("change:metadata", this._addDirtyPeerMetadata);
      for await (const entry of this._datastore.query({prefix: NAMESPACE_COMMON})) {
        await this._processDatastoreEntry(entry);
      }
      log("PeerStore started");
    }
    async stop() {
      log("PeerStore is stopping");
      this.removeAllListeners();
      await this._commitData();
      log("PeerStore stopped");
    }
    _addDirtyPeer({peerId}) {
      const peerIdstr = peerId.toB58String();
      log("add dirty peer", peerIdstr);
      this._dirtyPeers.add(peerIdstr);
      if (this._dirtyPeers.size >= this.threshold) {
        this._commitData().catch((err) => {
          log.error("error committing data", err);
        });
      }
    }
    _addDirtyPeerKey({peerId}) {
      if (peerId.hasInlinePublicKey()) {
        return;
      }
      const peerIdstr = peerId.toB58String();
      log("add dirty peer key", peerIdstr);
      this._dirtyPeers.add(peerIdstr);
      if (this._dirtyPeers.size >= this.threshold) {
        this._commitData().catch((err) => {
          log.error("error committing data", err);
        });
      }
    }
    _addDirtyPeerMetadata({peerId, metadata}) {
      const peerIdstr = peerId.toB58String();
      log("add dirty metadata peer", peerIdstr);
      this._dirtyPeers.add(peerIdstr);
      const mData = this._dirtyMetadata.get(peerIdstr) || new Set();
      mData.add(metadata);
      this._dirtyMetadata.set(peerIdstr, mData);
      if (this._dirtyPeers.size >= this.threshold) {
        this._commitData().catch((err) => {
          log.error("error committing data", err);
        });
      }
    }
    async _commitData() {
      const commitPeers = Array.from(this._dirtyPeers);
      if (!commitPeers.length) {
        return;
      }
      this._dirtyPeers.clear();
      log("create batch commit");
      const batch = this._datastore.batch();
      for (const peerIdStr of commitPeers) {
        const peerId = this.keyBook.data.get(peerIdStr) || PeerId.createFromCID(peerIdStr);
        this._batchAddressBook(peerId, batch);
        !peerId.hasInlinePublicKey() && this._batchKeyBook(peerId, batch);
        this._batchMetadataBook(peerId, batch);
        this._batchProtoBook(peerId, batch);
      }
      await batch.commit();
      log("batch committed");
    }
    _batchAddressBook(peerId, batch) {
      const b32key = peerId.toString();
      const key = new Key(`${NAMESPACE_ADDRESS}${b32key}`);
      const entry = this.addressBook.data.get(peerId.toB58String());
      try {
        if (!entry) {
          batch.delete(key);
          return;
        }
        const encodedData = Addresses.encode({
          addrs: entry.addresses.map((address) => ({
            multiaddr: address.multiaddr.bytes,
            isCertified: address.isCertified
          })),
          certified_record: entry.record ? {
            seq: entry.record.seqNumber,
            raw: entry.record.raw
          } : void 0
        });
        batch.put(key, encodedData);
      } catch (err) {
        log.error(err);
      }
    }
    _batchKeyBook(peerId, batch) {
      const b32key = peerId.toString();
      const key = new Key(`${NAMESPACE_KEYS}${b32key}`);
      try {
        if (!peerId.pubKey) {
          batch.delete(key);
          return;
        }
        const encodedData = peerId.marshalPubKey();
        batch.put(key, encodedData);
      } catch (err) {
        log.error(err);
      }
    }
    _batchMetadataBook(peerId, batch) {
      const b32key = peerId.toString();
      const dirtyMetada = this._dirtyMetadata.get(peerId.toB58String()) || [];
      try {
        dirtyMetada.forEach((dirtyKey) => {
          const key = new Key(`${NAMESPACE_METADATA}${b32key}/${dirtyKey}`);
          const dirtyValue = this.metadataBook.getValue(peerId, dirtyKey);
          if (dirtyValue) {
            batch.put(key, dirtyValue);
          } else {
            batch.delete(key);
          }
        });
      } catch (err) {
        log.error(err);
      }
    }
    _batchProtoBook(peerId, batch) {
      const b32key = peerId.toString();
      const key = new Key(`${NAMESPACE_PROTOCOL}${b32key}`);
      const protocols = this.protoBook.get(peerId);
      try {
        if (!protocols) {
          batch.delete(key);
          return;
        }
        const encodedData = Protocols.encode({protocols});
        batch.put(key, encodedData);
      } catch (err) {
        log.error(err);
      }
    }
    async _processDatastoreEntry({key, value}) {
      try {
        const keyParts = key.toString().split("/");
        const peerId = PeerId.createFromCID(keyParts[3]);
        let decoded;
        switch (keyParts[2]) {
          case "addrs":
            decoded = Addresses.decode(value);
            this.addressBook._setData(peerId, {
              addresses: decoded.addrs.map((address) => ({
                multiaddr: multiaddr(address.multiaddr),
                isCertified: Boolean(address.isCertified)
              })),
              record: decoded.certified_record ? {
                raw: decoded.certified_record.raw,
                seqNumber: decoded.certified_record.seq
              } : void 0
            }, {emit: false});
            break;
          case "keys":
            decoded = await PeerId.createFromPubKey(value);
            this.keyBook._setData(decoded, decoded, {emit: false});
            break;
          case "metadata":
            this.metadataBook._setValue(peerId, keyParts[4], value, {emit: false});
            break;
          case "protos":
            decoded = Protocols.decode(value);
            this.protoBook._setData(peerId, new Set(decoded.protocols), {emit: false});
            break;
          default:
            log("invalid data persisted for: ", key.toString());
        }
      } catch (err) {
        log.error(err);
      }
    }
  };
  module2.exports = PersistentPeerStore;
});

// node_modules/libp2p/src/registrar.js
var require_registrar = __commonJS((exports2, module2) => {
  "use strict";
  var debug = require_browser4();
  var log = Object.assign(debug("libp2p:peer-store"), {
    error: debug("libp2p:peer-store:err")
  });
  var errcode = require_err_code();
  var {
    codes: {ERR_INVALID_PARAMETERS}
  } = require_errors12();
  var Topology = require_topology();
  var Registrar = class {
    constructor({peerStore, connectionManager}) {
      this.peerStore = peerStore;
      this.connectionManager = connectionManager;
      this.topologies = new Map();
      this._handle = void 0;
      this._onDisconnect = this._onDisconnect.bind(this);
      this.connectionManager.on("peer:disconnect", this._onDisconnect);
    }
    get handle() {
      return this._handle;
    }
    set handle(handle) {
      this._handle = handle;
    }
    getConnection(peerId) {
      return this.connectionManager.get(peerId);
    }
    register(topology) {
      if (!Topology.isTopology(topology)) {
        log.error("topology must be an instance of interfaces/topology");
        throw errcode(new Error("topology must be an instance of interfaces/topology"), ERR_INVALID_PARAMETERS);
      }
      const id = (Math.random() * 1e9).toString(36) + Date.now();
      this.topologies.set(id, topology);
      topology.registrar = this;
      return id;
    }
    unregister(id) {
      return this.topologies.delete(id);
    }
    _onDisconnect(connection, error) {
      for (const [, topology] of this.topologies) {
        topology.disconnect(connection.remotePeer, error);
      }
    }
  };
  module2.exports = Registrar;
});

// node_modules/it-buffer/index.js
var require_it_buffer = __commonJS((exports2, module2) => {
  "use strict";
  var {Buffer: Buffer2} = require_buffer();
  var BufferList = require_BufferList();
  module2.exports = async function* (source) {
    for await (const b of source) {
      if (Buffer2.isBuffer(b)) {
        yield b;
      } else if (BufferList.isBufferList(b)) {
        yield b.slice();
      } else {
        yield Buffer2.from(b);
      }
    }
  };
  module2.exports.toBuffer = module2.exports;
  module2.exports.toList = async function* (source) {
    for await (const b of source) {
      if (Buffer2.isBuffer(b)) {
        yield new BufferList().append(b);
      } else if (BufferList.isBufferList(b)) {
        yield b;
      } else {
        yield new BufferList().append(Buffer2.from(b));
      }
    }
  };
});

// node_modules/libp2p/src/ping/constants.js
var require_constants13 = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = {
    PROTOCOL: "/ipfs/ping/1.0.0",
    PING_LENGTH: 32
  };
});

// node_modules/libp2p/src/ping/index.js
var require_ping = __commonJS((exports2, module2) => {
  "use strict";
  var debug = require_browser4();
  var log = Object.assign(debug("libp2p:ping"), {
    error: debug("libp2p:ping:err")
  });
  var errCode = require_err_code();
  var crypto2 = require_src10();
  var {pipe} = require_it_pipe();
  var {toBuffer} = require_it_buffer();
  var {collect, take} = require_dist2();
  var equals = require_equals2();
  var {PROTOCOL, PING_LENGTH} = require_constants13();
  async function ping(node, peer) {
    log("dialing %s to %s", PROTOCOL, peer.toB58String ? peer.toB58String() : peer);
    const {stream} = await node.dialProtocol(peer, PROTOCOL);
    const start = Date.now();
    const data = crypto2.randomBytes(PING_LENGTH);
    const [result] = await pipe([data], stream, (stream2) => take(1, stream2), toBuffer, collect);
    const end = Date.now();
    if (!equals(data, result)) {
      throw errCode(new Error("Received wrong ping ack"), "ERR_WRONG_PING_ACK");
    }
    return end - start;
  }
  function mount(node) {
    node.handle(PROTOCOL, ({stream}) => pipe(stream, stream));
  }
  function unmount(node) {
    node.unhandle(PROTOCOL);
  }
  exports2 = module2.exports = ping;
  exports2.mount = mount;
  exports2.unmount = unmount;
});

// node_modules/it-protocol-buffers/it.js
var require_it = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports.encode = (proto) => {
    return (source) => async function* () {
      for await (const msg of source) {
        yield proto.encode(msg);
      }
    }();
  };
  module2.exports.decode = (proto) => {
    return (source) => async function* () {
      for await (const msg of source) {
        yield proto.decode(msg);
      }
    }();
  };
});

// node_modules/it-protocol-buffers/index.js
var require_it_protocol_buffers = __commonJS((exports2, module2) => {
  "use strict";
  var lp = require_src37();
  var it = require_it();
  var toBuffer = require_it_buffer();
  module2.exports.encode = (proto) => {
    return (source) => lp.encode()(it.encode(proto)(source));
  };
  module2.exports.decode = (proto) => {
    return (source) => it.decode(proto)(toBuffer(lp.decode()(source)));
  };
  module2.exports.it = it;
});

// node_modules/libp2p/src/identify/message.js
var require_message3 = __commonJS((exports2, module2) => {
  "use strict";
  var protons = require_src8();
  var schema = `
message Identify {
  // protocolVersion determines compatibility between peers
  optional string protocolVersion = 5; // e.g. ipfs/1.0.0

  // agentVersion is like a UserAgent string in browsers, or client version in bittorrent
  // includes the client name and client.
  optional string agentVersion = 6; // e.g. go-ipfs/0.1.0

  // publicKey is this node's public key (which also gives its node.ID)
  // - may not need to be sent, as secure channel implies it has been sent.
  // - then again, if we change / disable secure channel, may still want it.
  optional bytes publicKey = 1;

  // listenAddrs are the multiaddrs the sender node listens for open connections on
  repeated bytes listenAddrs = 2;

  // oservedAddr is the multiaddr of the remote endpoint that the sender node perceives
  // this is useful information to convey to the other side, as it helps the remote endpoint
  // determine whether its connection to the local peer goes through NAT.
  optional bytes observedAddr = 4;

  repeated string protocols = 3;

  // signedPeerRecord contains a serialized SignedEnvelope containing a PeerRecord,
  // signed by the sending node. It contains the same addresses as the listenAddrs field, but
  // in a form that lets us share authenticated addrs with other peers.
  optional bytes signedPeerRecord = 8;
}
`;
  module2.exports = protons(schema).Identify;
});

// node_modules/libp2p/src/identify/index.js
var require_identify = __commonJS((exports2, module2) => {
  "use strict";
  var debug = require_browser4();
  var log = Object.assign(debug("libp2p:identify"), {
    error: debug("libp2p:identify:err")
  });
  var errCode = require_err_code();
  var pb = require_it_protocol_buffers();
  var lp = require_src37();
  var {pipe} = require_it_pipe();
  var {collect, take, consume} = require_dist2();
  var uint8ArrayFromString = require_from_string2();
  var PeerId = require_src9();
  var multiaddr = require_src11();
  var {toBuffer} = require_it_buffer();
  var Message = require_message3();
  var Envelope = require_envelope();
  var PeerRecord = require_peer_record();
  var {
    MULTICODEC_IDENTIFY,
    MULTICODEC_IDENTIFY_PUSH,
    AGENT_VERSION,
    PROTOCOL_VERSION
  } = require_consts();
  var {codes} = require_errors12();
  var IdentifyService = class {
    constructor({libp2p}) {
      this._libp2p = libp2p;
      this.peerStore = libp2p.peerStore;
      this.addressManager = libp2p.addressManager;
      this.connectionManager = libp2p.connectionManager;
      this.peerId = libp2p.peerId;
      this.handleMessage = this.handleMessage.bind(this);
      this._host = {
        agentVersion: AGENT_VERSION,
        protocolVersion: PROTOCOL_VERSION,
        ...libp2p._options.host
      };
      this.peerStore.metadataBook.set(this.peerId, "AgentVersion", uint8ArrayFromString(this._host.agentVersion));
      this.peerStore.metadataBook.set(this.peerId, "ProtocolVersion", uint8ArrayFromString(this._host.protocolVersion));
      this.connectionManager.on("peer:connect", (connection) => {
        this.identify(connection).catch(log.error);
      });
      this.peerStore.on("change:multiaddrs", ({peerId}) => {
        if (peerId.toString() === this.peerId.toString()) {
          this.pushToPeerStore();
        }
      });
      this.peerStore.on("change:protocols", ({peerId}) => {
        if (peerId.toString() === this.peerId.toString()) {
          this.pushToPeerStore();
        }
      });
    }
    async push(connections) {
      const signedPeerRecord = await this.peerStore.addressBook.getRawEnvelope(this.peerId);
      const listenAddrs = this._libp2p.multiaddrs.map((ma) => ma.bytes);
      const protocols = this.peerStore.protoBook.get(this.peerId) || [];
      const pushes = connections.map(async (connection) => {
        try {
          const {stream} = await connection.newStream(MULTICODEC_IDENTIFY_PUSH);
          await pipe([{
            listenAddrs,
            signedPeerRecord,
            protocols
          }], pb.encode(Message), stream, consume);
        } catch (err) {
          log.error("could not push identify update to peer", err);
        }
      });
      return Promise.all(pushes);
    }
    pushToPeerStore() {
      if (!this._libp2p.isStarted()) {
        return;
      }
      const connections = [];
      let connection;
      for (const peer of this.peerStore.peers.values()) {
        if (peer.protocols.includes(MULTICODEC_IDENTIFY_PUSH) && (connection = this.connectionManager.get(peer.id))) {
          connections.push(connection);
        }
      }
      this.push(connections);
    }
    async identify(connection) {
      const {stream} = await connection.newStream(MULTICODEC_IDENTIFY);
      const [data] = await pipe([], stream, lp.decode(), take(1), toBuffer, collect);
      if (!data) {
        throw errCode(new Error("No data could be retrieved"), codes.ERR_CONNECTION_ENDED);
      }
      let message;
      try {
        message = Message.decode(data);
      } catch (err) {
        throw errCode(err, codes.ERR_INVALID_MESSAGE);
      }
      let {
        publicKey,
        listenAddrs,
        protocols,
        observedAddr,
        signedPeerRecord
      } = message;
      const id = await PeerId.createFromPubKey(publicKey);
      if (connection.remotePeer.toB58String() !== id.toB58String()) {
        throw errCode(new Error("identified peer does not match the expected peer"), codes.ERR_INVALID_PEER);
      }
      observedAddr = IdentifyService.getCleanMultiaddr(observedAddr);
      try {
        const envelope = await Envelope.openAndCertify(signedPeerRecord, PeerRecord.DOMAIN);
        if (this.peerStore.addressBook.consumePeerRecord(envelope)) {
          this.peerStore.protoBook.set(id, protocols);
          return;
        }
      } catch (err) {
        log("received invalid envelope, discard it and fallback to listenAddrs is available", err);
      }
      try {
        this.peerStore.addressBook.set(id, listenAddrs.map((addr) => multiaddr(addr)));
      } catch (err) {
        log.error("received invalid addrs", err);
      }
      this.peerStore.protoBook.set(id, protocols);
      this.peerStore.metadataBook.set(id, "AgentVersion", uint8ArrayFromString(message.agentVersion));
      log("received observed address of %s", observedAddr);
    }
    handleMessage({connection, stream, protocol}) {
      switch (protocol) {
        case MULTICODEC_IDENTIFY:
          return this._handleIdentify({connection, stream});
        case MULTICODEC_IDENTIFY_PUSH:
          return this._handlePush({connection, stream});
        default:
          log.error("cannot handle unknown protocol %s", protocol);
      }
    }
    async _handleIdentify({connection, stream}) {
      let publicKey = new Uint8Array(0);
      if (this.peerId.pubKey) {
        publicKey = this.peerId.pubKey.bytes;
      }
      const signedPeerRecord = await this.peerStore.addressBook.getRawEnvelope(this.peerId);
      const protocols = this.peerStore.protoBook.get(this.peerId) || [];
      const message = Message.encode({
        protocolVersion: this._host.protocolVersion,
        agentVersion: this._host.agentVersion,
        publicKey,
        listenAddrs: this._libp2p.multiaddrs.map((ma) => ma.bytes),
        signedPeerRecord,
        observedAddr: connection.remoteAddr.bytes,
        protocols
      });
      try {
        await pipe([message], lp.encode(), stream, consume);
      } catch (err) {
        log.error("could not respond to identify request", err);
      }
    }
    async _handlePush({connection, stream}) {
      let message;
      try {
        const [data] = await pipe([], stream, lp.decode(), take(1), toBuffer, collect);
        message = Message.decode(data);
      } catch (err) {
        return log.error("received invalid message", err);
      }
      const id = connection.remotePeer;
      try {
        const envelope = await Envelope.openAndCertify(message.signedPeerRecord, PeerRecord.DOMAIN);
        if (this.peerStore.addressBook.consumePeerRecord(envelope)) {
          this.peerStore.protoBook.set(id, message.protocols);
          return;
        }
      } catch (err) {
        log("received invalid envelope, discard it and fallback to listenAddrs is available", err);
      }
      try {
        this.peerStore.addressBook.set(id, message.listenAddrs.map((addr) => multiaddr(addr)));
      } catch (err) {
        log.error("received invalid addrs", err);
      }
      this.peerStore.protoBook.set(id, message.protocols);
    }
    static getCleanMultiaddr(addr) {
      if (addr && addr.length > 0) {
        try {
          return multiaddr(addr);
        } catch (_) {
          return null;
        }
      }
      return null;
    }
  };
  var multicodecs = {
    IDENTIFY: MULTICODEC_IDENTIFY,
    IDENTIFY_PUSH: MULTICODEC_IDENTIFY_PUSH
  };
  IdentifyService.multicodecs = multicodecs;
  IdentifyService.Messsage = Message;
  module2.exports = IdentifyService;
});

// empty:/Users/gozala/Projects/replicator/node_modules/@motrix/nat-api/index.js
var require_nat_api = __commonJS(() => {
});

// node_modules/promisify-es6/index.js
var require_promisify_es6 = __commonJS((exports2, module2) => {
  /** PROMISIFY CALLBACK-STYLE FUNCTIONS TO ES6 PROMISES
  *
  * EXAMPLE:
  * const fn = promisify( (callback) => callback(null, "Hello world!") );
  * fn((err, str) => console.log(str));
  * fn().then((str) => console.log(str));
  * //Both functions, will log 'Hello world!'
  *
  * Note: The function you pass, may have any arguments you want, but the latest
  * have to be the callback, which you will call with: next(err, value)
  *
  * @param method: Function/Array/Map = The function(s) to promisify
  * @param options: Map =
  *  "context" (default is function): The context which to apply the called function
  *  "replace" (default is falsy): When passed an array/map, if to replace the original object
  *
  * @return: A promise if passed a function, otherwise the object with the promises
  *
  * @license: MIT
  * @version: 1.0.3
  * @author: Manuel Di Iorio
  **/
  var createCallback = function(method, context) {
    return function() {
      var args = Array.prototype.slice.call(arguments);
      var lastIndex = args.length - 1;
      var lastArg = args && args.length > 0 ? args[lastIndex] : null;
      var cb = typeof lastArg === "function" ? lastArg : null;
      if (cb) {
        return method.apply(context, args);
      }
      return new Promise(function(resolve, reject) {
        args.push(function(err, val) {
          if (err)
            return reject(err);
          resolve(val);
        });
        method.apply(context, args);
      });
    };
  };
  if (typeof module2 === "undefined")
    module2 = {};
  module2.exports = function(methods, options) {
    options = options || {};
    var type = Object.prototype.toString.call(methods);
    if (type === "[object Object]" || type === "[object Array]") {
      var obj = options.replace ? methods : {};
      for (var key in methods) {
        if (methods.hasOwnProperty(key))
          obj[key] = createCallback(methods[key]);
      }
      return obj;
    }
    return createCallback(methods, options.context || methods);
  };
  if (typeof exports2 === "undefined") {
    exports2["promisify"] = module2.exports;
  }
});

// node_modules/retry/lib/retry_operation.js
var require_retry_operation = __commonJS((exports2, module2) => {
  function RetryOperation(timeouts, options) {
    if (typeof options === "boolean") {
      options = {forever: options};
    }
    this._originalTimeouts = JSON.parse(JSON.stringify(timeouts));
    this._timeouts = timeouts;
    this._options = options || {};
    this._maxRetryTime = options && options.maxRetryTime || Infinity;
    this._fn = null;
    this._errors = [];
    this._attempts = 1;
    this._operationTimeout = null;
    this._operationTimeoutCb = null;
    this._timeout = null;
    this._operationStart = null;
    if (this._options.forever) {
      this._cachedTimeouts = this._timeouts.slice(0);
    }
  }
  module2.exports = RetryOperation;
  RetryOperation.prototype.reset = function() {
    this._attempts = 1;
    this._timeouts = this._originalTimeouts;
  };
  RetryOperation.prototype.stop = function() {
    if (this._timeout) {
      clearTimeout(this._timeout);
    }
    this._timeouts = [];
    this._cachedTimeouts = null;
  };
  RetryOperation.prototype.retry = function(err) {
    if (this._timeout) {
      clearTimeout(this._timeout);
    }
    if (!err) {
      return false;
    }
    var currentTime = new Date().getTime();
    if (err && currentTime - this._operationStart >= this._maxRetryTime) {
      this._errors.unshift(new Error("RetryOperation timeout occurred"));
      return false;
    }
    this._errors.push(err);
    var timeout = this._timeouts.shift();
    if (timeout === void 0) {
      if (this._cachedTimeouts) {
        this._errors.splice(this._errors.length - 1, this._errors.length);
        this._timeouts = this._cachedTimeouts.slice(0);
        timeout = this._timeouts.shift();
      } else {
        return false;
      }
    }
    var self2 = this;
    var timer = setTimeout(function() {
      self2._attempts++;
      if (self2._operationTimeoutCb) {
        self2._timeout = setTimeout(function() {
          self2._operationTimeoutCb(self2._attempts);
        }, self2._operationTimeout);
        if (self2._options.unref) {
          self2._timeout.unref();
        }
      }
      self2._fn(self2._attempts);
    }, timeout);
    if (this._options.unref) {
      timer.unref();
    }
    return true;
  };
  RetryOperation.prototype.attempt = function(fn, timeoutOps) {
    this._fn = fn;
    if (timeoutOps) {
      if (timeoutOps.timeout) {
        this._operationTimeout = timeoutOps.timeout;
      }
      if (timeoutOps.cb) {
        this._operationTimeoutCb = timeoutOps.cb;
      }
    }
    var self2 = this;
    if (this._operationTimeoutCb) {
      this._timeout = setTimeout(function() {
        self2._operationTimeoutCb();
      }, self2._operationTimeout);
    }
    this._operationStart = new Date().getTime();
    this._fn(this._attempts);
  };
  RetryOperation.prototype.try = function(fn) {
    console.log("Using RetryOperation.try() is deprecated");
    this.attempt(fn);
  };
  RetryOperation.prototype.start = function(fn) {
    console.log("Using RetryOperation.start() is deprecated");
    this.attempt(fn);
  };
  RetryOperation.prototype.start = RetryOperation.prototype.try;
  RetryOperation.prototype.errors = function() {
    return this._errors;
  };
  RetryOperation.prototype.attempts = function() {
    return this._attempts;
  };
  RetryOperation.prototype.mainError = function() {
    if (this._errors.length === 0) {
      return null;
    }
    var counts = {};
    var mainError = null;
    var mainErrorCount = 0;
    for (var i = 0; i < this._errors.length; i++) {
      var error = this._errors[i];
      var message = error.message;
      var count = (counts[message] || 0) + 1;
      counts[message] = count;
      if (count >= mainErrorCount) {
        mainError = error;
        mainErrorCount = count;
      }
    }
    return mainError;
  };
});

// node_modules/retry/lib/retry.js
var require_retry = __commonJS((exports2) => {
  var RetryOperation = require_retry_operation();
  exports2.operation = function(options) {
    var timeouts = exports2.timeouts(options);
    return new RetryOperation(timeouts, {
      forever: options && options.forever,
      unref: options && options.unref,
      maxRetryTime: options && options.maxRetryTime
    });
  };
  exports2.timeouts = function(options) {
    if (options instanceof Array) {
      return [].concat(options);
    }
    var opts = {
      retries: 10,
      factor: 2,
      minTimeout: 1 * 1e3,
      maxTimeout: Infinity,
      randomize: false
    };
    for (var key in options) {
      opts[key] = options[key];
    }
    if (opts.minTimeout > opts.maxTimeout) {
      throw new Error("minTimeout is greater than maxTimeout");
    }
    var timeouts = [];
    for (var i = 0; i < opts.retries; i++) {
      timeouts.push(this.createTimeout(i, opts));
    }
    if (options && options.forever && !timeouts.length) {
      timeouts.push(this.createTimeout(i, opts));
    }
    timeouts.sort(function(a, b) {
      return a - b;
    });
    return timeouts;
  };
  exports2.createTimeout = function(attempt, opts) {
    var random = opts.randomize ? Math.random() + 1 : 1;
    var timeout = Math.round(random * opts.minTimeout * Math.pow(opts.factor, attempt));
    timeout = Math.min(timeout, opts.maxTimeout);
    return timeout;
  };
  exports2.wrap = function(obj, options, methods) {
    if (options instanceof Array) {
      methods = options;
      options = null;
    }
    if (!methods) {
      methods = [];
      for (var key in obj) {
        if (typeof obj[key] === "function") {
          methods.push(key);
        }
      }
    }
    for (var i = 0; i < methods.length; i++) {
      var method = methods[i];
      var original = obj[method];
      obj[method] = function retryWrapper(original2) {
        var op = exports2.operation(options);
        var args = Array.prototype.slice.call(arguments, 1);
        var callback = args.pop();
        args.push(function(err) {
          if (op.retry(err)) {
            return;
          }
          if (err) {
            arguments[0] = op.mainError();
          }
          callback.apply(this, arguments);
        });
        op.attempt(function() {
          original2.apply(obj, args);
        });
      }.bind(obj, original);
      obj[method].options = options;
    }
  };
});

// node_modules/retry/index.js
var require_retry2 = __commonJS((exports2, module2) => {
  module2.exports = require_retry();
});

// node_modules/p-retry/index.js
var require_p_retry = __commonJS((exports2, module2) => {
  "use strict";
  var retry = require_retry2();
  var AbortError = class extends Error {
    constructor(message) {
      super();
      if (message instanceof Error) {
        this.originalError = message;
        ({message} = message);
      } else {
        this.originalError = new Error(message);
        this.originalError.stack = this.stack;
      }
      this.name = "AbortError";
      this.message = message;
    }
  };
  var decorateErrorWithCounts = (error, attemptNumber, options) => {
    const retriesLeft = options.retries - (attemptNumber - 1);
    error.attemptNumber = attemptNumber;
    error.retriesLeft = retriesLeft;
    return error;
  };
  var pRetry = (input, options) => new Promise((resolve, reject) => {
    options = {
      onFailedAttempt: () => {
      },
      retries: 10,
      ...options
    };
    const operation = retry.operation(options);
    operation.attempt(async (attemptNumber) => {
      try {
        resolve(await input(attemptNumber));
      } catch (error) {
        if (!(error instanceof Error)) {
          reject(new TypeError(`Non-error was thrown: "${error}". You should only throw errors.`));
          return;
        }
        if (error instanceof AbortError) {
          operation.stop();
          reject(error.originalError);
        } else if (error instanceof TypeError && error.message !== "Failed to fetch") {
          operation.stop();
          reject(error);
        } else {
          decorateErrorWithCounts(error, attemptNumber, options);
          try {
            await options.onFailedAttempt(error);
          } catch (error2) {
            reject(error2);
            return;
          }
          if (!operation.retry(error)) {
            reject(operation.mainError());
          }
        }
      }
    });
  });
  module2.exports = pRetry;
  module2.exports.default = pRetry;
  module2.exports.AbortError = AbortError;
});

// node_modules/is-loopback-addr/index.js
var require_is_loopback_addr = __commonJS((exports2, module2) => {
  "use strict";
  function isLoopbackAddr(ip) {
    return /^127\.([0-9]{1,3})\.([0-9]{1,3})\.([0-9]{1,3})$/i.test(ip) || /^::1$/.test(ip);
  }
  module2.exports = isLoopbackAddr;
});

// node_modules/libp2p-utils/src/multiaddr/is-loopback.js
var require_is_loopback = __commonJS((exports2, module2) => {
  "use strict";
  var isLoopbackAddr = require_is_loopback_addr();
  function isLoopback(ma) {
    const {address} = ma.nodeAddress();
    return isLoopbackAddr(address);
  }
  module2.exports = isLoopback;
});

// node_modules/libp2p/src/nat-manager.js
var require_nat_manager = __commonJS((exports2, module2) => {
  "use strict";
  var NatAPI = require_nat_api();
  var debug = require_browser4();
  var promisify = require_promisify_es6();
  var Multiaddr = require_src11();
  var log = Object.assign(debug("libp2p:nat"), {
    error: debug("libp2p:nat:err")
  });
  var {isBrowser} = require_env();
  var retry = require_p_retry();
  var isPrivateIp = require_private_ip();
  var pkg = require_package4();
  var errcode = require_err_code();
  var {
    codes: {ERR_INVALID_PARAMETERS}
  } = require_errors12();
  var isLoopback = require_is_loopback();
  function highPort(min = 1024, max = 65535) {
    return Math.floor(Math.random() * (max - min + 1) + min);
  }
  var DEFAULT_TTL = 7200;
  var NatManager = class {
    constructor({peerId, addressManager, transportManager, ...options}) {
      this._peerId = peerId;
      this._addressManager = addressManager;
      this._transportManager = transportManager;
      this._enabled = options.enabled;
      this._externalIp = options.externalIp;
      this._options = {
        description: options.description || `${pkg.name}@${pkg.version} ${this._peerId}`,
        ttl: options.ttl || DEFAULT_TTL,
        autoUpdate: options.keepAlive || true,
        gateway: options.gateway,
        enablePMP: Boolean(options.pmp && options.pmp.enabled)
      };
      if (this._options.ttl < DEFAULT_TTL) {
        throw errcode(new Error(`NatManager ttl should be at least ${DEFAULT_TTL} seconds`), ERR_INVALID_PARAMETERS);
      }
    }
    start() {
      if (isBrowser || !this._enabled) {
        return;
      }
      this._start().catch((err) => {
        log.error(err);
      });
    }
    async _start() {
      const addrs = this._transportManager.getAddrs();
      for (const addr of addrs) {
        const {family, host, port, transport} = addr.toOptions();
        if (!addr.isThinWaistAddress() || transport !== "tcp") {
          continue;
        }
        if (isLoopback(addr)) {
          continue;
        }
        if (family !== "ipv4") {
          continue;
        }
        const client = this._getClient();
        const publicIp = this._externalIp || await client.externalIp();
        if (isPrivateIp(publicIp)) {
          throw new Error(`${publicIp} is private - please set config.nat.externalIp to an externally routable IP or ensure you are not behind a double NAT`);
        }
        const publicPort = highPort();
        log(`opening uPnP connection from ${publicIp}:${publicPort} to ${host}:${port}`);
        await client.map({
          publicPort,
          privatePort: port,
          protocol: transport.toUpperCase()
        });
        this._addressManager.addObservedAddr(Multiaddr.fromNodeAddress({
          family: "IPv4",
          address: publicIp,
          port: `${publicPort}`
        }, transport));
      }
    }
    _getClient() {
      if (this._client) {
        return this._client;
      }
      const client = new NatAPI(this._options);
      const map = promisify(client.map, {context: client});
      const destroy = promisify(client.destroy, {context: client});
      const externalIp = promisify(client.externalIp, {context: client});
      this._client = {
        map: (...args) => retry(() => map(...args), {onFailedAttempt: log.error, unref: true}),
        destroy: (...args) => retry(() => destroy(...args), {onFailedAttempt: log.error, unref: true}),
        externalIp: (...args) => retry(() => externalIp(...args), {onFailedAttempt: log.error, unref: true})
      };
      return this._client;
    }
    async stop() {
      if (isBrowser || !this._client) {
        return;
      }
      try {
        await this._client.destroy();
        this._client = null;
      } catch (err) {
        log.error(err);
      }
    }
  };
  module2.exports = NatManager;
});

// node_modules/libp2p/src/index.js
var require_src44 = __commonJS((exports2, module2) => {
  "use strict";
  var debug = require_browser4();
  var log = Object.assign(debug("libp2p"), {
    error: debug("libp2p:err")
  });
  var EventEmitter = require_events();
  var errCode = require_err_code();
  var PeerId = require_src9();
  var multiaddr = require_src11();
  var PeerRouting = require_peer_routing();
  var ContentRouting = require_content_routing();
  var getPeer = require_get_peer();
  var {validate: validateConfig} = require_config4();
  var {codes, messages} = require_errors12();
  var AddressManager = require_address_manager();
  var ConnectionManager = require_connection_manager();
  var Circuit = require_transport();
  var Relay = require_circuit();
  var Dialer = require_dialer();
  var Keychain = require_keychain();
  var Metrics = require_metrics();
  var TransportManager = require_transport_manager();
  var Upgrader = require_upgrader();
  var PeerStore = require_peer_store();
  var PubsubAdapter = require_pubsub_adapter();
  var PersistentPeerStore = require_persistent();
  var Registrar = require_registrar();
  var ping = require_ping();
  var IdentifyService = require_identify();
  var IDENTIFY_PROTOCOLS = IdentifyService.multicodecs;
  var NatManager = require_nat_manager();
  var {updateSelfPeerRecord} = require_utils27();
  var Libp2p = class extends EventEmitter {
    static async create(options) {
      if (options.peerId) {
        return new Libp2p(options);
      }
      const peerId = await PeerId.create();
      options.peerId = peerId;
      return new Libp2p(options);
    }
    constructor(_options) {
      super();
      this._options = validateConfig(_options);
      this.peerId = this._options.peerId;
      this.datastore = this._options.datastore;
      this.peerStore = this.datastore && this._options.peerStore.persistence ? new PersistentPeerStore({
        peerId: this.peerId,
        datastore: this.datastore,
        ...this._options.peerStore
      }) : new PeerStore({peerId: this.peerId});
      this.addresses = this._options.addresses;
      this.addressManager = new AddressManager(this.peerId, this._options.addresses);
      this.addressManager.on("change:addresses", () => {
        updateSelfPeerRecord(this).catch((err) => {
          log.error("Error updating self peer record", err);
        });
      });
      this._modules = this._options.modules;
      this._config = this._options.config;
      this._transport = [];
      this._discovery = new Map();
      if (this._options.connectionManager.minPeers) {
        this._options.connectionManager.minConnections = this._options.connectionManager.minPeers;
      }
      this.connectionManager = new ConnectionManager(this, {
        autoDial: this._config.peerDiscovery.autoDial,
        ...this._options.connectionManager
      });
      if (this._options.metrics.enabled) {
        this.metrics = new Metrics({
          ...this._options.metrics,
          connectionManager: this.connectionManager
        });
      }
      if (this._options.keychain && this._options.keychain.datastore) {
        log("creating keychain");
        const keychainOpts = Keychain.generateOptions();
        this.keychain = new Keychain(this._options.keychain.datastore, {
          passPhrase: this._options.keychain.pass,
          ...keychainOpts,
          ...this._options.keychain
        });
        log("keychain constructed");
      }
      this.upgrader = new Upgrader({
        localPeer: this.peerId,
        metrics: this.metrics,
        onConnection: (connection) => this.connectionManager.onConnect(connection),
        onConnectionEnd: (connection) => this.connectionManager.onDisconnect(connection)
      });
      this.transportManager = new TransportManager({
        libp2p: this,
        upgrader: this.upgrader,
        faultTolerance: this._options.transportManager.faultTolerance
      });
      this.natManager = new NatManager({
        peerId: this.peerId,
        addressManager: this.addressManager,
        transportManager: this.transportManager,
        ...this._options.config.nat
      });
      this.registrar = new Registrar({
        peerStore: this.peerStore,
        connectionManager: this.connectionManager
      });
      this.handle = this.handle.bind(this);
      this.registrar.handle = this.handle;
      if (!this._modules.connEncryption || !this._modules.connEncryption.length) {
        throw errCode(new Error(messages.CONN_ENCRYPTION_REQUIRED), codes.CONN_ENCRYPTION_REQUIRED);
      }
      const cryptos = this._modules.connEncryption;
      cryptos.forEach((crypto2) => {
        this.upgrader.cryptos.set(crypto2.protocol, crypto2);
      });
      this.dialer = new Dialer({
        transportManager: this.transportManager,
        peerStore: this.peerStore,
        concurrency: this._options.dialer.maxParallelDials,
        perPeerLimit: this._options.dialer.maxDialsPerPeer,
        timeout: this._options.dialer.dialTimeout,
        resolvers: this._options.dialer.resolvers,
        addressSorter: this._options.dialer.addressSorter
      });
      this._modules.transport.forEach((Transport) => {
        const key = Transport.prototype[Symbol.toStringTag];
        const transportOptions = this._config.transport[key];
        this.transportManager.add(key, Transport, transportOptions);
      });
      if (this._config.relay.enabled) {
        this.transportManager.add(Circuit.prototype[Symbol.toStringTag], Circuit);
        this.relay = new Relay(this);
      }
      if (this._modules.streamMuxer) {
        const muxers = this._modules.streamMuxer;
        muxers.forEach((muxer) => {
          this.upgrader.muxers.set(muxer.multicodec, muxer);
        });
        this.identifyService = new IdentifyService({libp2p: this});
        this.handle(Object.values(IDENTIFY_PROTOCOLS), this.identifyService.handleMessage);
      }
      if (this._modules.connProtector) {
        this.upgrader.protector = this._modules.connProtector;
      } else if (globalThis.process !== void 0 && globalThis.process.env && globalThis.process.env.LIBP2P_FORCE_PNET) {
        throw new Error("Private network is enforced, but no protector was provided");
      }
      if (this._modules.dht) {
        const DHT = this._modules.dht;
        this._dht = new DHT({
          libp2p: this,
          dialer: this.dialer,
          peerId: this.peerId,
          peerStore: this.peerStore,
          registrar: this.registrar,
          datastore: this.datastore,
          ...this._config.dht
        });
      }
      if (this._modules.pubsub) {
        const Pubsub = this._modules.pubsub;
        this.pubsub = PubsubAdapter(Pubsub, this, this._config.pubsub);
      }
      this.peerRouting = new PeerRouting(this);
      this.contentRouting = new ContentRouting(this);
      ping.mount(this);
      this._onDiscoveryPeer = this._onDiscoveryPeer.bind(this);
    }
    emit(eventName, ...args) {
      if (eventName === "error" && !this._events.error) {
        log.error(args);
        return false;
      } else {
        return super.emit(eventName, ...args);
      }
    }
    async start() {
      log("libp2p is starting");
      try {
        await this._onStarting();
        await this._onDidStart();
        log("libp2p has started");
      } catch (err) {
        this.emit("error", err);
        log.error("An error occurred starting libp2p", err);
        await this.stop();
        throw err;
      }
    }
    async stop() {
      log("libp2p is stopping");
      try {
        this._isStarted = false;
        this.relay && this.relay.stop();
        this.peerRouting.stop();
        for (const service of this._discovery.values()) {
          service.removeListener("peer", this._onDiscoveryPeer);
        }
        await Promise.all(Array.from(this._discovery.values(), (s) => s.stop()));
        this._discovery = new Map();
        await this.peerStore.stop();
        await this.connectionManager.stop();
        await Promise.all([
          this.pubsub && this.pubsub.stop(),
          this._dht && this._dht.stop(),
          this.metrics && this.metrics.stop()
        ]);
        await this.natManager.stop();
        await this.transportManager.close();
        ping.unmount(this);
        this.dialer.destroy();
      } catch (err) {
        if (err) {
          log.error(err);
          this.emit("error", err);
        }
      }
      log("libp2p has stopped");
    }
    async loadKeychain() {
      if (!this.keychain) {
        return;
      }
      try {
        await this.keychain.findKeyByName("self");
      } catch (err) {
        await this.keychain.importPeer("self", this.peerId);
      }
    }
    isStarted() {
      return this._isStarted;
    }
    get connections() {
      return this.connectionManager.connections;
    }
    dial(peer, options) {
      return this.dialProtocol(peer, [], options);
    }
    async dialProtocol(peer, protocols, options) {
      const {id, multiaddrs} = getPeer(peer);
      if (id.equals(this.peerId)) {
        throw errCode(new Error("Cannot dial self"), codes.ERR_DIALED_SELF);
      }
      let connection = this.connectionManager.get(id);
      if (!connection) {
        connection = await this.dialer.connectToPeer(peer, options);
      } else if (multiaddrs) {
        this.peerStore.addressBook.add(id, multiaddrs);
      }
      if (protocols && protocols.length) {
        return connection.newStream(protocols);
      }
      return connection;
    }
    get multiaddrs() {
      let addrs = this.addressManager.getAnnounceAddrs().map((ma) => ma.toString());
      if (!addrs.length) {
        addrs = this.transportManager.getAddrs().map((ma) => ma.toString());
      }
      addrs = addrs.concat(this.addressManager.getObservedAddrs().map((ma) => ma.toString()));
      const announceFilter = this._options.addresses.announceFilter || ((multiaddrs) => multiaddrs);
      const addrSet = new Set(addrs);
      return announceFilter(Array.from(addrSet).map((str) => multiaddr(str)));
    }
    async hangUp(peer) {
      const {id} = getPeer(peer);
      const connections = this.connectionManager.connections.get(id.toB58String());
      if (!connections) {
        return;
      }
      await Promise.all(connections.map((connection) => {
        return connection.close();
      }));
    }
    ping(peer) {
      const {id, multiaddrs} = getPeer(peer);
      if (multiaddrs) {
        return ping(this, multiaddrs[0]);
      }
      return ping(this, id);
    }
    handle(protocols, handler) {
      protocols = Array.isArray(protocols) ? protocols : [protocols];
      protocols.forEach((protocol) => {
        this.upgrader.protocols.set(protocol, handler);
      });
      this.peerStore.protoBook.add(this.peerId, protocols);
    }
    unhandle(protocols) {
      protocols = Array.isArray(protocols) ? protocols : [protocols];
      protocols.forEach((protocol) => {
        this.upgrader.protocols.delete(protocol);
      });
      this.peerStore.protoBook.remove(this.peerId, protocols);
    }
    async _onStarting() {
      const addrs = this.addressManager.getListenAddrs();
      await this.transportManager.listen(addrs);
      this.natManager.start();
      await this.peerStore.start();
      if (this._config.pubsub.enabled) {
        this.pubsub && this.pubsub.start();
      }
      if (this._config.dht.enabled) {
        this._dht && this._dht.start();
        this._dht.on("peer", this._onDiscoveryPeer);
      }
      this.metrics && this.metrics.start();
    }
    async _onDidStart() {
      this._isStarted = true;
      this.peerStore.on("peer", (peerId) => {
        this.emit("peer:discovery", peerId);
        this._maybeConnect(peerId);
      });
      for (const peer of this.peerStore.peers.values()) {
        this.emit("peer:discovery", peer.id);
      }
      this.connectionManager.start();
      await this._setupPeerDiscovery();
      this.relay && this.relay.start();
      this.peerRouting.start();
    }
    _onDiscoveryPeer(peer) {
      if (peer.id.toB58String() === this.peerId.toB58String()) {
        log.error(new Error(codes.ERR_DISCOVERED_SELF));
        return;
      }
      peer.multiaddrs && this.peerStore.addressBook.add(peer.id, peer.multiaddrs);
      peer.protocols && this.peerStore.protoBook.set(peer.id, peer.protocols);
    }
    async _maybeConnect(peerId) {
      if (this._config.peerDiscovery.autoDial === true && !this.connectionManager.get(peerId)) {
        const minConnections = this._options.connectionManager.minConnections || 0;
        if (minConnections > this.connectionManager.size) {
          log("connecting to discovered peer %s", peerId.toB58String());
          try {
            await this.dialer.connectToPeer(peerId);
          } catch (err) {
            log.error("could not connect to discovered peer", err);
          }
        }
      }
    }
    async _setupPeerDiscovery() {
      const setupService = (DiscoveryService) => {
        let config = {
          enabled: true
        };
        if (DiscoveryService.tag && this._config.peerDiscovery && this._config.peerDiscovery[DiscoveryService.tag]) {
          config = {...config, ...this._config.peerDiscovery[DiscoveryService.tag]};
        }
        if (config.enabled && !this._discovery.has(DiscoveryService.tag)) {
          let discoveryService;
          if (typeof DiscoveryService === "function") {
            discoveryService = new DiscoveryService(Object.assign({}, config, {
              peerId: this.peerId,
              libp2p: this
            }));
          } else {
            discoveryService = DiscoveryService;
          }
          discoveryService.on("peer", this._onDiscoveryPeer);
          this._discovery.set(DiscoveryService.tag, discoveryService);
        }
      };
      for (const DiscoveryService of this._modules.peerDiscovery || []) {
        setupService(DiscoveryService);
      }
      for (const Transport of this.transportManager.getTransports()) {
        if (Transport.discovery) {
          setupService(Transport.discovery);
        }
      }
      await Promise.all(Array.from(this._discovery.values(), (d) => d.start()));
    }
  };
  module2.exports = Libp2p;
});

// empty:/Users/gozala/Projects/replicator/node_modules/ws/browser.js
var require_browser10 = __commonJS(() => {
});

// node_modules/it-ws/web-socket.js
var require_web_socket = __commonJS((exports2, module2) => {
  module2.exports = typeof WebSocket === "undefined" ? require_browser10() : WebSocket;
});

// node_modules/event-iterator/lib/event-iterator.js
var require_event_iterator = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  var EventQueue = class {
    constructor() {
      this.pullQueue = [];
      this.pushQueue = [];
      this.eventHandlers = {};
      this.isPaused = false;
      this.isStopped = false;
    }
    push(value) {
      if (this.isStopped)
        return;
      const resolution = {value, done: false};
      if (this.pullQueue.length) {
        const placeholder = this.pullQueue.shift();
        if (placeholder)
          placeholder.resolve(resolution);
      } else {
        this.pushQueue.push(Promise.resolve(resolution));
        if (this.highWaterMark !== void 0 && this.pushQueue.length >= this.highWaterMark && !this.isPaused) {
          this.isPaused = true;
          if (this.eventHandlers.highWater) {
            this.eventHandlers.highWater();
          } else if (console) {
            console.warn(`EventIterator queue reached ${this.pushQueue.length} items`);
          }
        }
      }
    }
    stop() {
      if (this.isStopped)
        return;
      this.isStopped = true;
      this.remove();
      for (const placeholder of this.pullQueue) {
        placeholder.resolve({value: void 0, done: true});
      }
      this.pullQueue.length = 0;
    }
    fail(error) {
      if (this.isStopped)
        return;
      this.isStopped = true;
      this.remove();
      if (this.pullQueue.length) {
        for (const placeholder of this.pullQueue) {
          placeholder.reject(error);
        }
        this.pullQueue.length = 0;
      } else {
        const rejection = Promise.reject(error);
        rejection.catch(() => {
        });
        this.pushQueue.push(rejection);
      }
    }
    remove() {
      Promise.resolve().then(() => {
        if (this.removeCallback)
          this.removeCallback();
      });
    }
    [Symbol.asyncIterator]() {
      return {
        next: (value) => {
          const result = this.pushQueue.shift();
          if (result) {
            if (this.lowWaterMark !== void 0 && this.pushQueue.length <= this.lowWaterMark && this.isPaused) {
              this.isPaused = false;
              if (this.eventHandlers.lowWater) {
                this.eventHandlers.lowWater();
              }
            }
            return result;
          } else if (this.isStopped) {
            return Promise.resolve({value: void 0, done: true});
          } else {
            return new Promise((resolve, reject) => {
              this.pullQueue.push({resolve, reject});
            });
          }
        },
        return: () => {
          this.isStopped = true;
          this.pushQueue.length = 0;
          this.remove();
          return Promise.resolve({value: void 0, done: true});
        }
      };
    }
  };
  var EventIterator = class {
    constructor(listen, {highWaterMark = 100, lowWaterMark = 1} = {}) {
      const queue = new EventQueue();
      queue.highWaterMark = highWaterMark;
      queue.lowWaterMark = lowWaterMark;
      queue.removeCallback = listen({
        push: (value) => queue.push(value),
        stop: () => queue.stop(),
        fail: (error) => queue.fail(error),
        on: (event, fn) => {
          queue.eventHandlers[event] = fn;
        }
      }) || (() => {
      });
      this[Symbol.asyncIterator] = () => queue[Symbol.asyncIterator]();
      Object.freeze(this);
    }
  };
  exports2.EventIterator = EventIterator;
  exports2.default = EventIterator;
});

// node_modules/event-iterator/lib/dom.js
var require_dom = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  var event_iterator_1 = require_event_iterator();
  exports2.EventIterator = event_iterator_1.EventIterator;
  function subscribe(event, options, evOptions) {
    return new event_iterator_1.EventIterator(({push}) => {
      this.addEventListener(event, push, options);
      return () => this.removeEventListener(event, push, options);
    }, evOptions);
  }
  exports2.subscribe = subscribe;
  exports2.default = event_iterator_1.EventIterator;
});

// node_modules/it-ws/source.js
var require_source = __commonJS((exports2, module2) => {
  var {Buffer: Buffer2} = require_buffer();
  var {EventIterator} = require_dom();
  function isArrayBuffer(obj) {
    return obj instanceof ArrayBuffer || obj != null && obj.constructor != null && obj.constructor.name === "ArrayBuffer" && typeof obj.byteLength === "number";
  }
  module2.exports = (socket) => {
    const removeListener = socket.removeEventListener || socket.removeListener;
    const source = async function* () {
      const messages = new EventIterator(({push, stop, fail}) => {
        socket.addEventListener("message", push);
        socket.addEventListener("error", fail);
        socket.addEventListener("close", stop);
        return () => {
          removeListener.call(socket, "message", push);
          removeListener.call(socket, "error", fail);
          removeListener.call(socket, "close", stop);
        };
      }, {highWaterMark: Infinity});
      for await (const {data} of messages) {
        yield isArrayBuffer(data) ? Buffer2.from(data) : data;
      }
    }();
    let connected = socket.readyState === 1;
    let connError;
    socket.addEventListener("open", () => {
      connected = true;
      connError = null;
    });
    socket.addEventListener("close", () => {
      connected = false;
      connError = null;
    });
    socket.addEventListener("error", (err) => {
      if (!connected)
        connError = err;
    });
    source.connected = () => new Promise((resolve, reject) => {
      if (connected)
        return resolve();
      if (connError)
        return reject(connError);
      const cleanUp = (cont) => {
        removeListener.call(socket, "open", onOpen);
        removeListener.call(socket, "error", onError);
        cont();
      };
      const onOpen = () => cleanUp(resolve);
      const onError = (err) => cleanUp(() => reject(err));
      socket.addEventListener("open", onOpen);
      socket.addEventListener("error", onError);
    });
    return source;
  };
});

// node_modules/it-ws/ready.js
var require_ready = __commonJS((exports2, module2) => {
  module2.exports = async (socket) => {
    if (socket.readyState >= 2) {
      throw new Error("socket closed");
    }
    if (socket.readyState === 1) {
      return;
    }
    return new Promise((resolve, reject) => {
      const remove = socket && (socket.removeEventListener || socket.removeListener);
      function cleanup() {
        if (typeof remove === "function") {
          remove.call(socket, "open", handleOpen);
          remove.call(socket, "error", handleErr);
        }
      }
      function handleOpen() {
        cleanup();
        resolve();
      }
      function handleErr(evt) {
        cleanup();
        reject(evt);
      }
      socket.addEventListener("open", handleOpen);
      socket.addEventListener("error", handleErr);
    });
  };
});

// node_modules/it-ws/sink.js
var require_sink = __commonJS((exports2, module2) => {
  var ready = require_ready();
  module2.exports = (socket, options) => {
    options = options || {};
    options.closeOnEnd = options.closeOnEnd !== false;
    return async (source) => {
      for await (const data of source) {
        try {
          await ready(socket);
        } catch (err) {
          if (err.message === "socket closed")
            break;
          throw err;
        }
        socket.send(data);
      }
      if (options.closeOnEnd && socket.readyState <= 1) {
        return new Promise((resolve, reject) => {
          socket.addEventListener("close", (event) => {
            if (event.wasClean || event.code === 1006) {
              resolve();
            } else {
              const err = Object.assign(new Error("ws error"), {event});
              reject(err);
            }
          });
          setTimeout(() => socket.close());
        });
      }
    };
  };
});

// node_modules/it-ws/duplex.js
var require_duplex = __commonJS((exports2, module2) => {
  var source = require_source();
  var sink = require_sink();
  module2.exports = (socket, options) => {
    options = options || {};
    if (options.binaryType) {
      socket.binaryType = options.binaryType;
    } else if (options.binary) {
      socket.binaryType = "arraybuffer";
    }
    const duplex = {
      sink: sink(socket, options),
      source: source(socket, options),
      connected: () => duplex.source.connected()
    };
    return duplex;
  };
});

// node_modules/relative-url/index.js
var require_relative_url = __commonJS((exports2, module2) => {
  var URL2 = require_url();
  module2.exports = function(url, location2, protocolMap, defaultProtocol) {
    protocolMap = protocolMap || {};
    var url = URL2.parse(url, false, true);
    var proto;
    if (url.protocol)
      proto = url.protocol;
    else {
      proto = location2.protocol ? location2.protocol.replace(/:$/, "") : "http";
      proto = (protocolMap[proto] || defaultProtocol || proto) + ":";
    }
    if (url.host && url.host[0] === ":")
      url.host = null;
    if (url.hostname) {
      return URL2.format({
        protocol: proto,
        slashes: true,
        hostname: url.hostname,
        port: url.port,
        pathname: url.pathname,
        search: url.search
      });
    } else
      url.host = location2.host;
    if (url.port) {
      return URL2.format({
        protocol: proto,
        slashes: true,
        host: location2.hostname + ":" + url.port,
        port: url.port,
        pathname: url.pathname,
        search: url.search
      });
    }
    if (url.pathname) {
      return URL2.format({
        protocol: proto,
        slashes: true,
        host: url.host,
        pathname: url.pathname,
        search: url.search
      });
    } else
      url.pathname = location2.pathname;
    if (url.search) {
      return URL2.format({
        protocol: proto,
        slashes: true,
        host: url.host,
        pathname: url.pathname,
        search: url.search
      });
    } else
      url.search = location2.search;
    return url.format(url);
  };
});

// node_modules/it-ws/ws-url.js
var require_ws_url = __commonJS((exports2, module2) => {
  var rurl = require_relative_url();
  var map = {http: "ws", https: "wss"};
  var def = "ws";
  module2.exports = (url, location2) => rurl(url, location2, map, def);
});

// node_modules/it-ws/client.js
var require_client = __commonJS((exports2, module2) => {
  "use strict";
  var WebSocket2 = require_web_socket();
  var duplex = require_duplex();
  var wsurl = require_ws_url();
  module2.exports = function(addr, opts = {}) {
    const location2 = typeof window === "undefined" ? {} : window.location;
    const url = wsurl(addr, location2);
    const socket = new WebSocket2(url, opts.websocket);
    const stream = duplex(socket, opts);
    stream.remoteAddress = url;
    stream.close = () => new Promise((resolve, reject) => {
      socket.addEventListener("close", resolve);
      socket.close();
    });
    stream.destroy = () => {
      if (socket.terminate) {
        socket.terminate();
      } else {
        socket.close();
      }
    };
    stream.socket = socket;
    return stream;
  };
  module2.exports.connect = module2.exports;
});

// node_modules/libp2p-websockets/node_modules/ipfs-utils/src/env.js
var require_env2 = __commonJS((exports2, module2) => {
  "use strict";
  var isElectron = require_is_electron();
  var IS_ENV_WITH_DOM = typeof window === "object" && typeof document === "object" && document.nodeType === 9;
  var IS_ELECTRON = isElectron();
  var IS_BROWSER = IS_ENV_WITH_DOM && !IS_ELECTRON;
  var IS_ELECTRON_MAIN = IS_ELECTRON && !IS_ENV_WITH_DOM;
  var IS_ELECTRON_RENDERER = IS_ELECTRON && IS_ENV_WITH_DOM;
  var IS_NODE = typeof process !== "undefined" && typeof process.release !== "undefined" && process.release.name === "node" && !IS_ELECTRON;
  var IS_WEBWORKER = typeof importScripts === "function" && typeof self !== "undefined" && typeof WorkerGlobalScope !== "undefined" && self instanceof WorkerGlobalScope;
  var IS_TEST = typeof process !== "undefined" && typeof process.env !== "undefined" && process.env.NODE_ENV === "test";
  module2.exports = {
    isTest: IS_TEST,
    isElectron: IS_ELECTRON,
    isElectronMain: IS_ELECTRON_MAIN,
    isElectronRenderer: IS_ELECTRON_RENDERER,
    isNode: IS_NODE,
    isBrowser: IS_BROWSER,
    isWebWorker: IS_WEBWORKER,
    isEnvWithDom: IS_ENV_WITH_DOM
  };
});

// node_modules/libp2p-websockets/src/listener.browser.js
var require_listener_browser = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = function() {
    throw new Error("WebSocket Servers can not be created in the browser!");
  };
});

// node_modules/libp2p-websockets/src/constants.js
var require_constants14 = __commonJS((exports2) => {
  "use strict";
  exports2.CODE_P2P = 421;
  exports2.CODE_CIRCUIT = 290;
  exports2.CODE_TCP = 6;
  exports2.CODE_WS = 477;
  exports2.CODE_WSS = 478;
  exports2.CLOSE_TIMEOUT = 2e3;
});

// node_modules/ip-address/node_modules/jsbn/index.js
var require_jsbn2 = __commonJS((exports2, module2) => {
  (function() {
    var dbits;
    var canary = 244837814094590;
    var j_lm = (canary & 16777215) == 15715070;
    function BigInteger(a, b, c) {
      if (a != null)
        if (typeof a == "number")
          this.fromNumber(a, b, c);
        else if (b == null && typeof a != "string")
          this.fromString(a, 256);
        else
          this.fromString(a, b);
    }
    function nbi() {
      return new BigInteger(null);
    }
    function am1(i, x, w, j, c, n) {
      while (--n >= 0) {
        var v = x * this[i++] + w[j] + c;
        c = Math.floor(v / 67108864);
        w[j++] = v & 67108863;
      }
      return c;
    }
    function am2(i, x, w, j, c, n) {
      var xl = x & 32767, xh = x >> 15;
      while (--n >= 0) {
        var l = this[i] & 32767;
        var h = this[i++] >> 15;
        var m = xh * l + h * xl;
        l = xl * l + ((m & 32767) << 15) + w[j] + (c & 1073741823);
        c = (l >>> 30) + (m >>> 15) + xh * h + (c >>> 30);
        w[j++] = l & 1073741823;
      }
      return c;
    }
    function am3(i, x, w, j, c, n) {
      var xl = x & 16383, xh = x >> 14;
      while (--n >= 0) {
        var l = this[i] & 16383;
        var h = this[i++] >> 14;
        var m = xh * l + h * xl;
        l = xl * l + ((m & 16383) << 14) + w[j] + c;
        c = (l >> 28) + (m >> 14) + xh * h;
        w[j++] = l & 268435455;
      }
      return c;
    }
    var inBrowser = typeof navigator !== "undefined";
    if (inBrowser && j_lm && navigator.appName == "Microsoft Internet Explorer") {
      BigInteger.prototype.am = am2;
      dbits = 30;
    } else if (inBrowser && j_lm && navigator.appName != "Netscape") {
      BigInteger.prototype.am = am1;
      dbits = 26;
    } else {
      BigInteger.prototype.am = am3;
      dbits = 28;
    }
    BigInteger.prototype.DB = dbits;
    BigInteger.prototype.DM = (1 << dbits) - 1;
    BigInteger.prototype.DV = 1 << dbits;
    var BI_FP = 52;
    BigInteger.prototype.FV = Math.pow(2, BI_FP);
    BigInteger.prototype.F1 = BI_FP - dbits;
    BigInteger.prototype.F2 = 2 * dbits - BI_FP;
    var BI_RM = "0123456789abcdefghijklmnopqrstuvwxyz";
    var BI_RC = new Array();
    var rr, vv;
    rr = "0".charCodeAt(0);
    for (vv = 0; vv <= 9; ++vv)
      BI_RC[rr++] = vv;
    rr = "a".charCodeAt(0);
    for (vv = 10; vv < 36; ++vv)
      BI_RC[rr++] = vv;
    rr = "A".charCodeAt(0);
    for (vv = 10; vv < 36; ++vv)
      BI_RC[rr++] = vv;
    function int2char(n) {
      return BI_RM.charAt(n);
    }
    function intAt(s, i) {
      var c = BI_RC[s.charCodeAt(i)];
      return c == null ? -1 : c;
    }
    function bnpCopyTo(r) {
      for (var i = this.t - 1; i >= 0; --i)
        r[i] = this[i];
      r.t = this.t;
      r.s = this.s;
    }
    function bnpFromInt(x) {
      this.t = 1;
      this.s = x < 0 ? -1 : 0;
      if (x > 0)
        this[0] = x;
      else if (x < -1)
        this[0] = x + this.DV;
      else
        this.t = 0;
    }
    function nbv(i) {
      var r = nbi();
      r.fromInt(i);
      return r;
    }
    function bnpFromString(s, b) {
      var k;
      if (b == 16)
        k = 4;
      else if (b == 8)
        k = 3;
      else if (b == 256)
        k = 8;
      else if (b == 2)
        k = 1;
      else if (b == 32)
        k = 5;
      else if (b == 4)
        k = 2;
      else {
        this.fromRadix(s, b);
        return;
      }
      this.t = 0;
      this.s = 0;
      var i = s.length, mi = false, sh = 0;
      while (--i >= 0) {
        var x = k == 8 ? s[i] & 255 : intAt(s, i);
        if (x < 0) {
          if (s.charAt(i) == "-")
            mi = true;
          continue;
        }
        mi = false;
        if (sh == 0)
          this[this.t++] = x;
        else if (sh + k > this.DB) {
          this[this.t - 1] |= (x & (1 << this.DB - sh) - 1) << sh;
          this[this.t++] = x >> this.DB - sh;
        } else
          this[this.t - 1] |= x << sh;
        sh += k;
        if (sh >= this.DB)
          sh -= this.DB;
      }
      if (k == 8 && (s[0] & 128) != 0) {
        this.s = -1;
        if (sh > 0)
          this[this.t - 1] |= (1 << this.DB - sh) - 1 << sh;
      }
      this.clamp();
      if (mi)
        BigInteger.ZERO.subTo(this, this);
    }
    function bnpClamp() {
      var c = this.s & this.DM;
      while (this.t > 0 && this[this.t - 1] == c)
        --this.t;
    }
    function bnToString(b) {
      if (this.s < 0)
        return "-" + this.negate().toString(b);
      var k;
      if (b == 16)
        k = 4;
      else if (b == 8)
        k = 3;
      else if (b == 2)
        k = 1;
      else if (b == 32)
        k = 5;
      else if (b == 4)
        k = 2;
      else
        return this.toRadix(b);
      var km = (1 << k) - 1, d, m = false, r = "", i = this.t;
      var p = this.DB - i * this.DB % k;
      if (i-- > 0) {
        if (p < this.DB && (d = this[i] >> p) > 0) {
          m = true;
          r = int2char(d);
        }
        while (i >= 0) {
          if (p < k) {
            d = (this[i] & (1 << p) - 1) << k - p;
            d |= this[--i] >> (p += this.DB - k);
          } else {
            d = this[i] >> (p -= k) & km;
            if (p <= 0) {
              p += this.DB;
              --i;
            }
          }
          if (d > 0)
            m = true;
          if (m)
            r += int2char(d);
        }
      }
      return m ? r : "0";
    }
    function bnNegate() {
      var r = nbi();
      BigInteger.ZERO.subTo(this, r);
      return r;
    }
    function bnAbs() {
      return this.s < 0 ? this.negate() : this;
    }
    function bnCompareTo(a) {
      var r = this.s - a.s;
      if (r != 0)
        return r;
      var i = this.t;
      r = i - a.t;
      if (r != 0)
        return this.s < 0 ? -r : r;
      while (--i >= 0)
        if ((r = this[i] - a[i]) != 0)
          return r;
      return 0;
    }
    function nbits(x) {
      var r = 1, t2;
      if ((t2 = x >>> 16) != 0) {
        x = t2;
        r += 16;
      }
      if ((t2 = x >> 8) != 0) {
        x = t2;
        r += 8;
      }
      if ((t2 = x >> 4) != 0) {
        x = t2;
        r += 4;
      }
      if ((t2 = x >> 2) != 0) {
        x = t2;
        r += 2;
      }
      if ((t2 = x >> 1) != 0) {
        x = t2;
        r += 1;
      }
      return r;
    }
    function bnBitLength() {
      if (this.t <= 0)
        return 0;
      return this.DB * (this.t - 1) + nbits(this[this.t - 1] ^ this.s & this.DM);
    }
    function bnpDLShiftTo(n, r) {
      var i;
      for (i = this.t - 1; i >= 0; --i)
        r[i + n] = this[i];
      for (i = n - 1; i >= 0; --i)
        r[i] = 0;
      r.t = this.t + n;
      r.s = this.s;
    }
    function bnpDRShiftTo(n, r) {
      for (var i = n; i < this.t; ++i)
        r[i - n] = this[i];
      r.t = Math.max(this.t - n, 0);
      r.s = this.s;
    }
    function bnpLShiftTo(n, r) {
      var bs = n % this.DB;
      var cbs = this.DB - bs;
      var bm = (1 << cbs) - 1;
      var ds = Math.floor(n / this.DB), c = this.s << bs & this.DM, i;
      for (i = this.t - 1; i >= 0; --i) {
        r[i + ds + 1] = this[i] >> cbs | c;
        c = (this[i] & bm) << bs;
      }
      for (i = ds - 1; i >= 0; --i)
        r[i] = 0;
      r[ds] = c;
      r.t = this.t + ds + 1;
      r.s = this.s;
      r.clamp();
    }
    function bnpRShiftTo(n, r) {
      r.s = this.s;
      var ds = Math.floor(n / this.DB);
      if (ds >= this.t) {
        r.t = 0;
        return;
      }
      var bs = n % this.DB;
      var cbs = this.DB - bs;
      var bm = (1 << bs) - 1;
      r[0] = this[ds] >> bs;
      for (var i = ds + 1; i < this.t; ++i) {
        r[i - ds - 1] |= (this[i] & bm) << cbs;
        r[i - ds] = this[i] >> bs;
      }
      if (bs > 0)
        r[this.t - ds - 1] |= (this.s & bm) << cbs;
      r.t = this.t - ds;
      r.clamp();
    }
    function bnpSubTo(a, r) {
      var i = 0, c = 0, m = Math.min(a.t, this.t);
      while (i < m) {
        c += this[i] - a[i];
        r[i++] = c & this.DM;
        c >>= this.DB;
      }
      if (a.t < this.t) {
        c -= a.s;
        while (i < this.t) {
          c += this[i];
          r[i++] = c & this.DM;
          c >>= this.DB;
        }
        c += this.s;
      } else {
        c += this.s;
        while (i < a.t) {
          c -= a[i];
          r[i++] = c & this.DM;
          c >>= this.DB;
        }
        c -= a.s;
      }
      r.s = c < 0 ? -1 : 0;
      if (c < -1)
        r[i++] = this.DV + c;
      else if (c > 0)
        r[i++] = c;
      r.t = i;
      r.clamp();
    }
    function bnpMultiplyTo(a, r) {
      var x = this.abs(), y = a.abs();
      var i = x.t;
      r.t = i + y.t;
      while (--i >= 0)
        r[i] = 0;
      for (i = 0; i < y.t; ++i)
        r[i + x.t] = x.am(0, y[i], r, i, 0, x.t);
      r.s = 0;
      r.clamp();
      if (this.s != a.s)
        BigInteger.ZERO.subTo(r, r);
    }
    function bnpSquareTo(r) {
      var x = this.abs();
      var i = r.t = 2 * x.t;
      while (--i >= 0)
        r[i] = 0;
      for (i = 0; i < x.t - 1; ++i) {
        var c = x.am(i, x[i], r, 2 * i, 0, 1);
        if ((r[i + x.t] += x.am(i + 1, 2 * x[i], r, 2 * i + 1, c, x.t - i - 1)) >= x.DV) {
          r[i + x.t] -= x.DV;
          r[i + x.t + 1] = 1;
        }
      }
      if (r.t > 0)
        r[r.t - 1] += x.am(i, x[i], r, 2 * i, 0, 1);
      r.s = 0;
      r.clamp();
    }
    function bnpDivRemTo(m, q, r) {
      var pm = m.abs();
      if (pm.t <= 0)
        return;
      var pt = this.abs();
      if (pt.t < pm.t) {
        if (q != null)
          q.fromInt(0);
        if (r != null)
          this.copyTo(r);
        return;
      }
      if (r == null)
        r = nbi();
      var y = nbi(), ts = this.s, ms = m.s;
      var nsh = this.DB - nbits(pm[pm.t - 1]);
      if (nsh > 0) {
        pm.lShiftTo(nsh, y);
        pt.lShiftTo(nsh, r);
      } else {
        pm.copyTo(y);
        pt.copyTo(r);
      }
      var ys = y.t;
      var y0 = y[ys - 1];
      if (y0 == 0)
        return;
      var yt = y0 * (1 << this.F1) + (ys > 1 ? y[ys - 2] >> this.F2 : 0);
      var d1 = this.FV / yt, d2 = (1 << this.F1) / yt, e = 1 << this.F2;
      var i = r.t, j = i - ys, t2 = q == null ? nbi() : q;
      y.dlShiftTo(j, t2);
      if (r.compareTo(t2) >= 0) {
        r[r.t++] = 1;
        r.subTo(t2, r);
      }
      BigInteger.ONE.dlShiftTo(ys, t2);
      t2.subTo(y, y);
      while (y.t < ys)
        y[y.t++] = 0;
      while (--j >= 0) {
        var qd = r[--i] == y0 ? this.DM : Math.floor(r[i] * d1 + (r[i - 1] + e) * d2);
        if ((r[i] += y.am(0, qd, r, j, 0, ys)) < qd) {
          y.dlShiftTo(j, t2);
          r.subTo(t2, r);
          while (r[i] < --qd)
            r.subTo(t2, r);
        }
      }
      if (q != null) {
        r.drShiftTo(ys, q);
        if (ts != ms)
          BigInteger.ZERO.subTo(q, q);
      }
      r.t = ys;
      r.clamp();
      if (nsh > 0)
        r.rShiftTo(nsh, r);
      if (ts < 0)
        BigInteger.ZERO.subTo(r, r);
    }
    function bnMod(a) {
      var r = nbi();
      this.abs().divRemTo(a, null, r);
      if (this.s < 0 && r.compareTo(BigInteger.ZERO) > 0)
        a.subTo(r, r);
      return r;
    }
    function Classic(m) {
      this.m = m;
    }
    function cConvert(x) {
      if (x.s < 0 || x.compareTo(this.m) >= 0)
        return x.mod(this.m);
      else
        return x;
    }
    function cRevert(x) {
      return x;
    }
    function cReduce(x) {
      x.divRemTo(this.m, null, x);
    }
    function cMulTo(x, y, r) {
      x.multiplyTo(y, r);
      this.reduce(r);
    }
    function cSqrTo(x, r) {
      x.squareTo(r);
      this.reduce(r);
    }
    Classic.prototype.convert = cConvert;
    Classic.prototype.revert = cRevert;
    Classic.prototype.reduce = cReduce;
    Classic.prototype.mulTo = cMulTo;
    Classic.prototype.sqrTo = cSqrTo;
    function bnpInvDigit() {
      if (this.t < 1)
        return 0;
      var x = this[0];
      if ((x & 1) == 0)
        return 0;
      var y = x & 3;
      y = y * (2 - (x & 15) * y) & 15;
      y = y * (2 - (x & 255) * y) & 255;
      y = y * (2 - ((x & 65535) * y & 65535)) & 65535;
      y = y * (2 - x * y % this.DV) % this.DV;
      return y > 0 ? this.DV - y : -y;
    }
    function Montgomery(m) {
      this.m = m;
      this.mp = m.invDigit();
      this.mpl = this.mp & 32767;
      this.mph = this.mp >> 15;
      this.um = (1 << m.DB - 15) - 1;
      this.mt2 = 2 * m.t;
    }
    function montConvert(x) {
      var r = nbi();
      x.abs().dlShiftTo(this.m.t, r);
      r.divRemTo(this.m, null, r);
      if (x.s < 0 && r.compareTo(BigInteger.ZERO) > 0)
        this.m.subTo(r, r);
      return r;
    }
    function montRevert(x) {
      var r = nbi();
      x.copyTo(r);
      this.reduce(r);
      return r;
    }
    function montReduce(x) {
      while (x.t <= this.mt2)
        x[x.t++] = 0;
      for (var i = 0; i < this.m.t; ++i) {
        var j = x[i] & 32767;
        var u0 = j * this.mpl + ((j * this.mph + (x[i] >> 15) * this.mpl & this.um) << 15) & x.DM;
        j = i + this.m.t;
        x[j] += this.m.am(0, u0, x, i, 0, this.m.t);
        while (x[j] >= x.DV) {
          x[j] -= x.DV;
          x[++j]++;
        }
      }
      x.clamp();
      x.drShiftTo(this.m.t, x);
      if (x.compareTo(this.m) >= 0)
        x.subTo(this.m, x);
    }
    function montSqrTo(x, r) {
      x.squareTo(r);
      this.reduce(r);
    }
    function montMulTo(x, y, r) {
      x.multiplyTo(y, r);
      this.reduce(r);
    }
    Montgomery.prototype.convert = montConvert;
    Montgomery.prototype.revert = montRevert;
    Montgomery.prototype.reduce = montReduce;
    Montgomery.prototype.mulTo = montMulTo;
    Montgomery.prototype.sqrTo = montSqrTo;
    function bnpIsEven() {
      return (this.t > 0 ? this[0] & 1 : this.s) == 0;
    }
    function bnpExp(e, z2) {
      if (e > 4294967295 || e < 1)
        return BigInteger.ONE;
      var r = nbi(), r2 = nbi(), g = z2.convert(this), i = nbits(e) - 1;
      g.copyTo(r);
      while (--i >= 0) {
        z2.sqrTo(r, r2);
        if ((e & 1 << i) > 0)
          z2.mulTo(r2, g, r);
        else {
          var t2 = r;
          r = r2;
          r2 = t2;
        }
      }
      return z2.revert(r);
    }
    function bnModPowInt(e, m) {
      var z2;
      if (e < 256 || m.isEven())
        z2 = new Classic(m);
      else
        z2 = new Montgomery(m);
      return this.exp(e, z2);
    }
    BigInteger.prototype.copyTo = bnpCopyTo;
    BigInteger.prototype.fromInt = bnpFromInt;
    BigInteger.prototype.fromString = bnpFromString;
    BigInteger.prototype.clamp = bnpClamp;
    BigInteger.prototype.dlShiftTo = bnpDLShiftTo;
    BigInteger.prototype.drShiftTo = bnpDRShiftTo;
    BigInteger.prototype.lShiftTo = bnpLShiftTo;
    BigInteger.prototype.rShiftTo = bnpRShiftTo;
    BigInteger.prototype.subTo = bnpSubTo;
    BigInteger.prototype.multiplyTo = bnpMultiplyTo;
    BigInteger.prototype.squareTo = bnpSquareTo;
    BigInteger.prototype.divRemTo = bnpDivRemTo;
    BigInteger.prototype.invDigit = bnpInvDigit;
    BigInteger.prototype.isEven = bnpIsEven;
    BigInteger.prototype.exp = bnpExp;
    BigInteger.prototype.toString = bnToString;
    BigInteger.prototype.negate = bnNegate;
    BigInteger.prototype.abs = bnAbs;
    BigInteger.prototype.compareTo = bnCompareTo;
    BigInteger.prototype.bitLength = bnBitLength;
    BigInteger.prototype.mod = bnMod;
    BigInteger.prototype.modPowInt = bnModPowInt;
    BigInteger.ZERO = nbv(0);
    BigInteger.ONE = nbv(1);
    function bnClone() {
      var r = nbi();
      this.copyTo(r);
      return r;
    }
    function bnIntValue() {
      if (this.s < 0) {
        if (this.t == 1)
          return this[0] - this.DV;
        else if (this.t == 0)
          return -1;
      } else if (this.t == 1)
        return this[0];
      else if (this.t == 0)
        return 0;
      return (this[1] & (1 << 32 - this.DB) - 1) << this.DB | this[0];
    }
    function bnByteValue() {
      return this.t == 0 ? this.s : this[0] << 24 >> 24;
    }
    function bnShortValue() {
      return this.t == 0 ? this.s : this[0] << 16 >> 16;
    }
    function bnpChunkSize(r) {
      return Math.floor(Math.LN2 * this.DB / Math.log(r));
    }
    function bnSigNum() {
      if (this.s < 0)
        return -1;
      else if (this.t <= 0 || this.t == 1 && this[0] <= 0)
        return 0;
      else
        return 1;
    }
    function bnpToRadix(b) {
      if (b == null)
        b = 10;
      if (this.signum() == 0 || b < 2 || b > 36)
        return "0";
      var cs = this.chunkSize(b);
      var a = Math.pow(b, cs);
      var d = nbv(a), y = nbi(), z2 = nbi(), r = "";
      this.divRemTo(d, y, z2);
      while (y.signum() > 0) {
        r = (a + z2.intValue()).toString(b).substr(1) + r;
        y.divRemTo(d, y, z2);
      }
      return z2.intValue().toString(b) + r;
    }
    function bnpFromRadix(s, b) {
      this.fromInt(0);
      if (b == null)
        b = 10;
      var cs = this.chunkSize(b);
      var d = Math.pow(b, cs), mi = false, j = 0, w = 0;
      for (var i = 0; i < s.length; ++i) {
        var x = intAt(s, i);
        if (x < 0) {
          if (s.charAt(i) == "-" && this.signum() == 0)
            mi = true;
          continue;
        }
        w = b * w + x;
        if (++j >= cs) {
          this.dMultiply(d);
          this.dAddOffset(w, 0);
          j = 0;
          w = 0;
        }
      }
      if (j > 0) {
        this.dMultiply(Math.pow(b, j));
        this.dAddOffset(w, 0);
      }
      if (mi)
        BigInteger.ZERO.subTo(this, this);
    }
    function bnpFromNumber(a, b, c) {
      if (typeof b == "number") {
        if (a < 2)
          this.fromInt(1);
        else {
          this.fromNumber(a, c);
          if (!this.testBit(a - 1))
            this.bitwiseTo(BigInteger.ONE.shiftLeft(a - 1), op_or, this);
          if (this.isEven())
            this.dAddOffset(1, 0);
          while (!this.isProbablePrime(b)) {
            this.dAddOffset(2, 0);
            if (this.bitLength() > a)
              this.subTo(BigInteger.ONE.shiftLeft(a - 1), this);
          }
        }
      } else {
        var x = new Array(), t2 = a & 7;
        x.length = (a >> 3) + 1;
        b.nextBytes(x);
        if (t2 > 0)
          x[0] &= (1 << t2) - 1;
        else
          x[0] = 0;
        this.fromString(x, 256);
      }
    }
    function bnToByteArray() {
      var i = this.t, r = new Array();
      r[0] = this.s;
      var p = this.DB - i * this.DB % 8, d, k = 0;
      if (i-- > 0) {
        if (p < this.DB && (d = this[i] >> p) != (this.s & this.DM) >> p)
          r[k++] = d | this.s << this.DB - p;
        while (i >= 0) {
          if (p < 8) {
            d = (this[i] & (1 << p) - 1) << 8 - p;
            d |= this[--i] >> (p += this.DB - 8);
          } else {
            d = this[i] >> (p -= 8) & 255;
            if (p <= 0) {
              p += this.DB;
              --i;
            }
          }
          if ((d & 128) != 0)
            d |= -256;
          if (k == 0 && (this.s & 128) != (d & 128))
            ++k;
          if (k > 0 || d != this.s)
            r[k++] = d;
        }
      }
      return r;
    }
    function bnEquals(a) {
      return this.compareTo(a) == 0;
    }
    function bnMin(a) {
      return this.compareTo(a) < 0 ? this : a;
    }
    function bnMax(a) {
      return this.compareTo(a) > 0 ? this : a;
    }
    function bnpBitwiseTo(a, op, r) {
      var i, f, m = Math.min(a.t, this.t);
      for (i = 0; i < m; ++i)
        r[i] = op(this[i], a[i]);
      if (a.t < this.t) {
        f = a.s & this.DM;
        for (i = m; i < this.t; ++i)
          r[i] = op(this[i], f);
        r.t = this.t;
      } else {
        f = this.s & this.DM;
        for (i = m; i < a.t; ++i)
          r[i] = op(f, a[i]);
        r.t = a.t;
      }
      r.s = op(this.s, a.s);
      r.clamp();
    }
    function op_and(x, y) {
      return x & y;
    }
    function bnAnd(a) {
      var r = nbi();
      this.bitwiseTo(a, op_and, r);
      return r;
    }
    function op_or(x, y) {
      return x | y;
    }
    function bnOr(a) {
      var r = nbi();
      this.bitwiseTo(a, op_or, r);
      return r;
    }
    function op_xor(x, y) {
      return x ^ y;
    }
    function bnXor(a) {
      var r = nbi();
      this.bitwiseTo(a, op_xor, r);
      return r;
    }
    function op_andnot(x, y) {
      return x & ~y;
    }
    function bnAndNot(a) {
      var r = nbi();
      this.bitwiseTo(a, op_andnot, r);
      return r;
    }
    function bnNot() {
      var r = nbi();
      for (var i = 0; i < this.t; ++i)
        r[i] = this.DM & ~this[i];
      r.t = this.t;
      r.s = ~this.s;
      return r;
    }
    function bnShiftLeft(n) {
      var r = nbi();
      if (n < 0)
        this.rShiftTo(-n, r);
      else
        this.lShiftTo(n, r);
      return r;
    }
    function bnShiftRight(n) {
      var r = nbi();
      if (n < 0)
        this.lShiftTo(-n, r);
      else
        this.rShiftTo(n, r);
      return r;
    }
    function lbit(x) {
      if (x == 0)
        return -1;
      var r = 0;
      if ((x & 65535) == 0) {
        x >>= 16;
        r += 16;
      }
      if ((x & 255) == 0) {
        x >>= 8;
        r += 8;
      }
      if ((x & 15) == 0) {
        x >>= 4;
        r += 4;
      }
      if ((x & 3) == 0) {
        x >>= 2;
        r += 2;
      }
      if ((x & 1) == 0)
        ++r;
      return r;
    }
    function bnGetLowestSetBit() {
      for (var i = 0; i < this.t; ++i)
        if (this[i] != 0)
          return i * this.DB + lbit(this[i]);
      if (this.s < 0)
        return this.t * this.DB;
      return -1;
    }
    function cbit(x) {
      var r = 0;
      while (x != 0) {
        x &= x - 1;
        ++r;
      }
      return r;
    }
    function bnBitCount() {
      var r = 0, x = this.s & this.DM;
      for (var i = 0; i < this.t; ++i)
        r += cbit(this[i] ^ x);
      return r;
    }
    function bnTestBit(n) {
      var j = Math.floor(n / this.DB);
      if (j >= this.t)
        return this.s != 0;
      return (this[j] & 1 << n % this.DB) != 0;
    }
    function bnpChangeBit(n, op) {
      var r = BigInteger.ONE.shiftLeft(n);
      this.bitwiseTo(r, op, r);
      return r;
    }
    function bnSetBit(n) {
      return this.changeBit(n, op_or);
    }
    function bnClearBit(n) {
      return this.changeBit(n, op_andnot);
    }
    function bnFlipBit(n) {
      return this.changeBit(n, op_xor);
    }
    function bnpAddTo(a, r) {
      var i = 0, c = 0, m = Math.min(a.t, this.t);
      while (i < m) {
        c += this[i] + a[i];
        r[i++] = c & this.DM;
        c >>= this.DB;
      }
      if (a.t < this.t) {
        c += a.s;
        while (i < this.t) {
          c += this[i];
          r[i++] = c & this.DM;
          c >>= this.DB;
        }
        c += this.s;
      } else {
        c += this.s;
        while (i < a.t) {
          c += a[i];
          r[i++] = c & this.DM;
          c >>= this.DB;
        }
        c += a.s;
      }
      r.s = c < 0 ? -1 : 0;
      if (c > 0)
        r[i++] = c;
      else if (c < -1)
        r[i++] = this.DV + c;
      r.t = i;
      r.clamp();
    }
    function bnAdd(a) {
      var r = nbi();
      this.addTo(a, r);
      return r;
    }
    function bnSubtract(a) {
      var r = nbi();
      this.subTo(a, r);
      return r;
    }
    function bnMultiply(a) {
      var r = nbi();
      this.multiplyTo(a, r);
      return r;
    }
    function bnSquare() {
      var r = nbi();
      this.squareTo(r);
      return r;
    }
    function bnDivide(a) {
      var r = nbi();
      this.divRemTo(a, r, null);
      return r;
    }
    function bnRemainder(a) {
      var r = nbi();
      this.divRemTo(a, null, r);
      return r;
    }
    function bnDivideAndRemainder(a) {
      var q = nbi(), r = nbi();
      this.divRemTo(a, q, r);
      return new Array(q, r);
    }
    function bnpDMultiply(n) {
      this[this.t] = this.am(0, n - 1, this, 0, 0, this.t);
      ++this.t;
      this.clamp();
    }
    function bnpDAddOffset(n, w) {
      if (n == 0)
        return;
      while (this.t <= w)
        this[this.t++] = 0;
      this[w] += n;
      while (this[w] >= this.DV) {
        this[w] -= this.DV;
        if (++w >= this.t)
          this[this.t++] = 0;
        ++this[w];
      }
    }
    function NullExp() {
    }
    function nNop(x) {
      return x;
    }
    function nMulTo(x, y, r) {
      x.multiplyTo(y, r);
    }
    function nSqrTo(x, r) {
      x.squareTo(r);
    }
    NullExp.prototype.convert = nNop;
    NullExp.prototype.revert = nNop;
    NullExp.prototype.mulTo = nMulTo;
    NullExp.prototype.sqrTo = nSqrTo;
    function bnPow(e) {
      return this.exp(e, new NullExp());
    }
    function bnpMultiplyLowerTo(a, n, r) {
      var i = Math.min(this.t + a.t, n);
      r.s = 0;
      r.t = i;
      while (i > 0)
        r[--i] = 0;
      var j;
      for (j = r.t - this.t; i < j; ++i)
        r[i + this.t] = this.am(0, a[i], r, i, 0, this.t);
      for (j = Math.min(a.t, n); i < j; ++i)
        this.am(0, a[i], r, i, 0, n - i);
      r.clamp();
    }
    function bnpMultiplyUpperTo(a, n, r) {
      --n;
      var i = r.t = this.t + a.t - n;
      r.s = 0;
      while (--i >= 0)
        r[i] = 0;
      for (i = Math.max(n - this.t, 0); i < a.t; ++i)
        r[this.t + i - n] = this.am(n - i, a[i], r, 0, 0, this.t + i - n);
      r.clamp();
      r.drShiftTo(1, r);
    }
    function Barrett(m) {
      this.r2 = nbi();
      this.q3 = nbi();
      BigInteger.ONE.dlShiftTo(2 * m.t, this.r2);
      this.mu = this.r2.divide(m);
      this.m = m;
    }
    function barrettConvert(x) {
      if (x.s < 0 || x.t > 2 * this.m.t)
        return x.mod(this.m);
      else if (x.compareTo(this.m) < 0)
        return x;
      else {
        var r = nbi();
        x.copyTo(r);
        this.reduce(r);
        return r;
      }
    }
    function barrettRevert(x) {
      return x;
    }
    function barrettReduce(x) {
      x.drShiftTo(this.m.t - 1, this.r2);
      if (x.t > this.m.t + 1) {
        x.t = this.m.t + 1;
        x.clamp();
      }
      this.mu.multiplyUpperTo(this.r2, this.m.t + 1, this.q3);
      this.m.multiplyLowerTo(this.q3, this.m.t + 1, this.r2);
      while (x.compareTo(this.r2) < 0)
        x.dAddOffset(1, this.m.t + 1);
      x.subTo(this.r2, x);
      while (x.compareTo(this.m) >= 0)
        x.subTo(this.m, x);
    }
    function barrettSqrTo(x, r) {
      x.squareTo(r);
      this.reduce(r);
    }
    function barrettMulTo(x, y, r) {
      x.multiplyTo(y, r);
      this.reduce(r);
    }
    Barrett.prototype.convert = barrettConvert;
    Barrett.prototype.revert = barrettRevert;
    Barrett.prototype.reduce = barrettReduce;
    Barrett.prototype.mulTo = barrettMulTo;
    Barrett.prototype.sqrTo = barrettSqrTo;
    function bnModPow(e, m) {
      var i = e.bitLength(), k, r = nbv(1), z2;
      if (i <= 0)
        return r;
      else if (i < 18)
        k = 1;
      else if (i < 48)
        k = 3;
      else if (i < 144)
        k = 4;
      else if (i < 768)
        k = 5;
      else
        k = 6;
      if (i < 8)
        z2 = new Classic(m);
      else if (m.isEven())
        z2 = new Barrett(m);
      else
        z2 = new Montgomery(m);
      var g = new Array(), n = 3, k1 = k - 1, km = (1 << k) - 1;
      g[1] = z2.convert(this);
      if (k > 1) {
        var g2 = nbi();
        z2.sqrTo(g[1], g2);
        while (n <= km) {
          g[n] = nbi();
          z2.mulTo(g2, g[n - 2], g[n]);
          n += 2;
        }
      }
      var j = e.t - 1, w, is1 = true, r2 = nbi(), t2;
      i = nbits(e[j]) - 1;
      while (j >= 0) {
        if (i >= k1)
          w = e[j] >> i - k1 & km;
        else {
          w = (e[j] & (1 << i + 1) - 1) << k1 - i;
          if (j > 0)
            w |= e[j - 1] >> this.DB + i - k1;
        }
        n = k;
        while ((w & 1) == 0) {
          w >>= 1;
          --n;
        }
        if ((i -= n) < 0) {
          i += this.DB;
          --j;
        }
        if (is1) {
          g[w].copyTo(r);
          is1 = false;
        } else {
          while (n > 1) {
            z2.sqrTo(r, r2);
            z2.sqrTo(r2, r);
            n -= 2;
          }
          if (n > 0)
            z2.sqrTo(r, r2);
          else {
            t2 = r;
            r = r2;
            r2 = t2;
          }
          z2.mulTo(r2, g[w], r);
        }
        while (j >= 0 && (e[j] & 1 << i) == 0) {
          z2.sqrTo(r, r2);
          t2 = r;
          r = r2;
          r2 = t2;
          if (--i < 0) {
            i = this.DB - 1;
            --j;
          }
        }
      }
      return z2.revert(r);
    }
    function bnGCD(a) {
      var x = this.s < 0 ? this.negate() : this.clone();
      var y = a.s < 0 ? a.negate() : a.clone();
      if (x.compareTo(y) < 0) {
        var t2 = x;
        x = y;
        y = t2;
      }
      var i = x.getLowestSetBit(), g = y.getLowestSetBit();
      if (g < 0)
        return x;
      if (i < g)
        g = i;
      if (g > 0) {
        x.rShiftTo(g, x);
        y.rShiftTo(g, y);
      }
      while (x.signum() > 0) {
        if ((i = x.getLowestSetBit()) > 0)
          x.rShiftTo(i, x);
        if ((i = y.getLowestSetBit()) > 0)
          y.rShiftTo(i, y);
        if (x.compareTo(y) >= 0) {
          x.subTo(y, x);
          x.rShiftTo(1, x);
        } else {
          y.subTo(x, y);
          y.rShiftTo(1, y);
        }
      }
      if (g > 0)
        y.lShiftTo(g, y);
      return y;
    }
    function bnpModInt(n) {
      if (n <= 0)
        return 0;
      var d = this.DV % n, r = this.s < 0 ? n - 1 : 0;
      if (this.t > 0)
        if (d == 0)
          r = this[0] % n;
        else
          for (var i = this.t - 1; i >= 0; --i)
            r = (d * r + this[i]) % n;
      return r;
    }
    function bnModInverse(m) {
      var ac = m.isEven();
      if (this.isEven() && ac || m.signum() == 0)
        return BigInteger.ZERO;
      var u = m.clone(), v = this.clone();
      var a = nbv(1), b = nbv(0), c = nbv(0), d = nbv(1);
      while (u.signum() != 0) {
        while (u.isEven()) {
          u.rShiftTo(1, u);
          if (ac) {
            if (!a.isEven() || !b.isEven()) {
              a.addTo(this, a);
              b.subTo(m, b);
            }
            a.rShiftTo(1, a);
          } else if (!b.isEven())
            b.subTo(m, b);
          b.rShiftTo(1, b);
        }
        while (v.isEven()) {
          v.rShiftTo(1, v);
          if (ac) {
            if (!c.isEven() || !d.isEven()) {
              c.addTo(this, c);
              d.subTo(m, d);
            }
            c.rShiftTo(1, c);
          } else if (!d.isEven())
            d.subTo(m, d);
          d.rShiftTo(1, d);
        }
        if (u.compareTo(v) >= 0) {
          u.subTo(v, u);
          if (ac)
            a.subTo(c, a);
          b.subTo(d, b);
        } else {
          v.subTo(u, v);
          if (ac)
            c.subTo(a, c);
          d.subTo(b, d);
        }
      }
      if (v.compareTo(BigInteger.ONE) != 0)
        return BigInteger.ZERO;
      if (d.compareTo(m) >= 0)
        return d.subtract(m);
      if (d.signum() < 0)
        d.addTo(m, d);
      else
        return d;
      if (d.signum() < 0)
        return d.add(m);
      else
        return d;
    }
    var lowprimes = [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97, 101, 103, 107, 109, 113, 127, 131, 137, 139, 149, 151, 157, 163, 167, 173, 179, 181, 191, 193, 197, 199, 211, 223, 227, 229, 233, 239, 241, 251, 257, 263, 269, 271, 277, 281, 283, 293, 307, 311, 313, 317, 331, 337, 347, 349, 353, 359, 367, 373, 379, 383, 389, 397, 401, 409, 419, 421, 431, 433, 439, 443, 449, 457, 461, 463, 467, 479, 487, 491, 499, 503, 509, 521, 523, 541, 547, 557, 563, 569, 571, 577, 587, 593, 599, 601, 607, 613, 617, 619, 631, 641, 643, 647, 653, 659, 661, 673, 677, 683, 691, 701, 709, 719, 727, 733, 739, 743, 751, 757, 761, 769, 773, 787, 797, 809, 811, 821, 823, 827, 829, 839, 853, 857, 859, 863, 877, 881, 883, 887, 907, 911, 919, 929, 937, 941, 947, 953, 967, 971, 977, 983, 991, 997];
    var lplim = (1 << 26) / lowprimes[lowprimes.length - 1];
    function bnIsProbablePrime(t2) {
      var i, x = this.abs();
      if (x.t == 1 && x[0] <= lowprimes[lowprimes.length - 1]) {
        for (i = 0; i < lowprimes.length; ++i)
          if (x[0] == lowprimes[i])
            return true;
        return false;
      }
      if (x.isEven())
        return false;
      i = 1;
      while (i < lowprimes.length) {
        var m = lowprimes[i], j = i + 1;
        while (j < lowprimes.length && m < lplim)
          m *= lowprimes[j++];
        m = x.modInt(m);
        while (i < j)
          if (m % lowprimes[i++] == 0)
            return false;
      }
      return x.millerRabin(t2);
    }
    function bnpMillerRabin(t2) {
      var n1 = this.subtract(BigInteger.ONE);
      var k = n1.getLowestSetBit();
      if (k <= 0)
        return false;
      var r = n1.shiftRight(k);
      t2 = t2 + 1 >> 1;
      if (t2 > lowprimes.length)
        t2 = lowprimes.length;
      var a = nbi();
      for (var i = 0; i < t2; ++i) {
        a.fromInt(lowprimes[Math.floor(Math.random() * lowprimes.length)]);
        var y = a.modPow(r, this);
        if (y.compareTo(BigInteger.ONE) != 0 && y.compareTo(n1) != 0) {
          var j = 1;
          while (j++ < k && y.compareTo(n1) != 0) {
            y = y.modPowInt(2, this);
            if (y.compareTo(BigInteger.ONE) == 0)
              return false;
          }
          if (y.compareTo(n1) != 0)
            return false;
        }
      }
      return true;
    }
    BigInteger.prototype.chunkSize = bnpChunkSize;
    BigInteger.prototype.toRadix = bnpToRadix;
    BigInteger.prototype.fromRadix = bnpFromRadix;
    BigInteger.prototype.fromNumber = bnpFromNumber;
    BigInteger.prototype.bitwiseTo = bnpBitwiseTo;
    BigInteger.prototype.changeBit = bnpChangeBit;
    BigInteger.prototype.addTo = bnpAddTo;
    BigInteger.prototype.dMultiply = bnpDMultiply;
    BigInteger.prototype.dAddOffset = bnpDAddOffset;
    BigInteger.prototype.multiplyLowerTo = bnpMultiplyLowerTo;
    BigInteger.prototype.multiplyUpperTo = bnpMultiplyUpperTo;
    BigInteger.prototype.modInt = bnpModInt;
    BigInteger.prototype.millerRabin = bnpMillerRabin;
    BigInteger.prototype.clone = bnClone;
    BigInteger.prototype.intValue = bnIntValue;
    BigInteger.prototype.byteValue = bnByteValue;
    BigInteger.prototype.shortValue = bnShortValue;
    BigInteger.prototype.signum = bnSigNum;
    BigInteger.prototype.toByteArray = bnToByteArray;
    BigInteger.prototype.equals = bnEquals;
    BigInteger.prototype.min = bnMin;
    BigInteger.prototype.max = bnMax;
    BigInteger.prototype.and = bnAnd;
    BigInteger.prototype.or = bnOr;
    BigInteger.prototype.xor = bnXor;
    BigInteger.prototype.andNot = bnAndNot;
    BigInteger.prototype.not = bnNot;
    BigInteger.prototype.shiftLeft = bnShiftLeft;
    BigInteger.prototype.shiftRight = bnShiftRight;
    BigInteger.prototype.getLowestSetBit = bnGetLowestSetBit;
    BigInteger.prototype.bitCount = bnBitCount;
    BigInteger.prototype.testBit = bnTestBit;
    BigInteger.prototype.setBit = bnSetBit;
    BigInteger.prototype.clearBit = bnClearBit;
    BigInteger.prototype.flipBit = bnFlipBit;
    BigInteger.prototype.add = bnAdd;
    BigInteger.prototype.subtract = bnSubtract;
    BigInteger.prototype.multiply = bnMultiply;
    BigInteger.prototype.divide = bnDivide;
    BigInteger.prototype.remainder = bnRemainder;
    BigInteger.prototype.divideAndRemainder = bnDivideAndRemainder;
    BigInteger.prototype.modPow = bnModPow;
    BigInteger.prototype.modInverse = bnModInverse;
    BigInteger.prototype.pow = bnPow;
    BigInteger.prototype.gcd = bnGCD;
    BigInteger.prototype.isProbablePrime = bnIsProbablePrime;
    BigInteger.prototype.square = bnSquare;
    BigInteger.prototype.Barrett = Barrett;
    var rng_state;
    var rng_pool;
    var rng_pptr;
    function rng_seed_int(x) {
      rng_pool[rng_pptr++] ^= x & 255;
      rng_pool[rng_pptr++] ^= x >> 8 & 255;
      rng_pool[rng_pptr++] ^= x >> 16 & 255;
      rng_pool[rng_pptr++] ^= x >> 24 & 255;
      if (rng_pptr >= rng_psize)
        rng_pptr -= rng_psize;
    }
    function rng_seed_time() {
      rng_seed_int(new Date().getTime());
    }
    if (rng_pool == null) {
      rng_pool = new Array();
      rng_pptr = 0;
      var t;
      if (typeof window !== "undefined" && window.crypto) {
        if (window.crypto.getRandomValues) {
          var ua = new Uint8Array(32);
          window.crypto.getRandomValues(ua);
          for (t = 0; t < 32; ++t)
            rng_pool[rng_pptr++] = ua[t];
        } else if (navigator.appName == "Netscape" && navigator.appVersion < "5") {
          var z = window.crypto.random(32);
          for (t = 0; t < z.length; ++t)
            rng_pool[rng_pptr++] = z.charCodeAt(t) & 255;
        }
      }
      while (rng_pptr < rng_psize) {
        t = Math.floor(65536 * Math.random());
        rng_pool[rng_pptr++] = t >>> 8;
        rng_pool[rng_pptr++] = t & 255;
      }
      rng_pptr = 0;
      rng_seed_time();
    }
    function rng_get_byte() {
      if (rng_state == null) {
        rng_seed_time();
        rng_state = prng_newstate();
        rng_state.init(rng_pool);
        for (rng_pptr = 0; rng_pptr < rng_pool.length; ++rng_pptr)
          rng_pool[rng_pptr] = 0;
        rng_pptr = 0;
      }
      return rng_state.next();
    }
    function rng_get_bytes(ba) {
      var i;
      for (i = 0; i < ba.length; ++i)
        ba[i] = rng_get_byte();
    }
    function SecureRandom() {
    }
    SecureRandom.prototype.nextBytes = rng_get_bytes;
    function Arcfour() {
      this.i = 0;
      this.j = 0;
      this.S = new Array();
    }
    function ARC4init(key) {
      var i, j, t2;
      for (i = 0; i < 256; ++i)
        this.S[i] = i;
      j = 0;
      for (i = 0; i < 256; ++i) {
        j = j + this.S[i] + key[i % key.length] & 255;
        t2 = this.S[i];
        this.S[i] = this.S[j];
        this.S[j] = t2;
      }
      this.i = 0;
      this.j = 0;
    }
    function ARC4next() {
      var t2;
      this.i = this.i + 1 & 255;
      this.j = this.j + this.S[this.i] & 255;
      t2 = this.S[this.i];
      this.S[this.i] = this.S[this.j];
      this.S[this.j] = t2;
      return this.S[t2 + this.S[this.i] & 255];
    }
    Arcfour.prototype.init = ARC4init;
    Arcfour.prototype.next = ARC4next;
    function prng_newstate() {
      return new Arcfour();
    }
    var rng_psize = 256;
    if (typeof exports2 !== "undefined") {
      exports2 = module2.exports = {
        default: BigInteger,
        BigInteger,
        SecureRandom
      };
    } else {
      this.jsbn = {
        BigInteger,
        SecureRandom
      };
    }
  }).call(exports2);
});

// node_modules/ip-address/lib/common.js
var require_common5 = __commonJS((exports2) => {
  "use strict";
  var falseIfInvalid = exports2.falseIfInvalid = function(fn) {
    return function() {
      if (!this.valid) {
        return false;
      }
      return fn.apply(this, arguments);
    };
  };
  exports2.isInSubnet = falseIfInvalid(function(address) {
    if (this.subnetMask < address.subnetMask) {
      return false;
    }
    if (this.mask(address.subnetMask) === address.mask()) {
      return true;
    }
    return false;
  });
  exports2.isCorrect = function(defaultBits) {
    return falseIfInvalid(function() {
      if (this.addressMinusSuffix !== this.correctForm()) {
        return false;
      }
      if (this.subnetMask === defaultBits && !this.parsedSubnet) {
        return true;
      }
      return this.parsedSubnet === String(this.subnetMask);
    });
  };
});

// node_modules/sprintf-js/src/sprintf.js
var require_sprintf = __commonJS((exports2) => {
  !function() {
    "use strict";
    var re = {
      not_string: /[^s]/,
      not_bool: /[^t]/,
      not_type: /[^T]/,
      not_primitive: /[^v]/,
      number: /[diefg]/,
      numeric_arg: /[bcdiefguxX]/,
      json: /[j]/,
      not_json: /[^j]/,
      text: /^[^\x25]+/,
      modulo: /^\x25{2}/,
      placeholder: /^\x25(?:([1-9]\d*)\$|\(([^)]+)\))?(\+)?(0|'[^$])?(-)?(\d+)?(?:\.(\d+))?([b-gijostTuvxX])/,
      key: /^([a-z_][a-z_\d]*)/i,
      key_access: /^\.([a-z_][a-z_\d]*)/i,
      index_access: /^\[(\d+)\]/,
      sign: /^[+-]/
    };
    function sprintf(key) {
      return sprintf_format(sprintf_parse(key), arguments);
    }
    function vsprintf(fmt, argv) {
      return sprintf.apply(null, [fmt].concat(argv || []));
    }
    function sprintf_format(parse_tree, argv) {
      var cursor = 1, tree_length = parse_tree.length, arg, output = "", i, k, ph, pad, pad_character, pad_length, is_positive, sign;
      for (i = 0; i < tree_length; i++) {
        if (typeof parse_tree[i] === "string") {
          output += parse_tree[i];
        } else if (typeof parse_tree[i] === "object") {
          ph = parse_tree[i];
          if (ph.keys) {
            arg = argv[cursor];
            for (k = 0; k < ph.keys.length; k++) {
              if (arg == void 0) {
                throw new Error(sprintf('[sprintf] Cannot access property "%s" of undefined value "%s"', ph.keys[k], ph.keys[k - 1]));
              }
              arg = arg[ph.keys[k]];
            }
          } else if (ph.param_no) {
            arg = argv[ph.param_no];
          } else {
            arg = argv[cursor++];
          }
          if (re.not_type.test(ph.type) && re.not_primitive.test(ph.type) && arg instanceof Function) {
            arg = arg();
          }
          if (re.numeric_arg.test(ph.type) && (typeof arg !== "number" && isNaN(arg))) {
            throw new TypeError(sprintf("[sprintf] expecting number but found %T", arg));
          }
          if (re.number.test(ph.type)) {
            is_positive = arg >= 0;
          }
          switch (ph.type) {
            case "b":
              arg = parseInt(arg, 10).toString(2);
              break;
            case "c":
              arg = String.fromCharCode(parseInt(arg, 10));
              break;
            case "d":
            case "i":
              arg = parseInt(arg, 10);
              break;
            case "j":
              arg = JSON.stringify(arg, null, ph.width ? parseInt(ph.width) : 0);
              break;
            case "e":
              arg = ph.precision ? parseFloat(arg).toExponential(ph.precision) : parseFloat(arg).toExponential();
              break;
            case "f":
              arg = ph.precision ? parseFloat(arg).toFixed(ph.precision) : parseFloat(arg);
              break;
            case "g":
              arg = ph.precision ? String(Number(arg.toPrecision(ph.precision))) : parseFloat(arg);
              break;
            case "o":
              arg = (parseInt(arg, 10) >>> 0).toString(8);
              break;
            case "s":
              arg = String(arg);
              arg = ph.precision ? arg.substring(0, ph.precision) : arg;
              break;
            case "t":
              arg = String(!!arg);
              arg = ph.precision ? arg.substring(0, ph.precision) : arg;
              break;
            case "T":
              arg = Object.prototype.toString.call(arg).slice(8, -1).toLowerCase();
              arg = ph.precision ? arg.substring(0, ph.precision) : arg;
              break;
            case "u":
              arg = parseInt(arg, 10) >>> 0;
              break;
            case "v":
              arg = arg.valueOf();
              arg = ph.precision ? arg.substring(0, ph.precision) : arg;
              break;
            case "x":
              arg = (parseInt(arg, 10) >>> 0).toString(16);
              break;
            case "X":
              arg = (parseInt(arg, 10) >>> 0).toString(16).toUpperCase();
              break;
          }
          if (re.json.test(ph.type)) {
            output += arg;
          } else {
            if (re.number.test(ph.type) && (!is_positive || ph.sign)) {
              sign = is_positive ? "+" : "-";
              arg = arg.toString().replace(re.sign, "");
            } else {
              sign = "";
            }
            pad_character = ph.pad_char ? ph.pad_char === "0" ? "0" : ph.pad_char.charAt(1) : " ";
            pad_length = ph.width - (sign + arg).length;
            pad = ph.width ? pad_length > 0 ? pad_character.repeat(pad_length) : "" : "";
            output += ph.align ? sign + arg + pad : pad_character === "0" ? sign + pad + arg : pad + sign + arg;
          }
        }
      }
      return output;
    }
    var sprintf_cache = Object.create(null);
    function sprintf_parse(fmt) {
      if (sprintf_cache[fmt]) {
        return sprintf_cache[fmt];
      }
      var _fmt = fmt, match, parse_tree = [], arg_names = 0;
      while (_fmt) {
        if ((match = re.text.exec(_fmt)) !== null) {
          parse_tree.push(match[0]);
        } else if ((match = re.modulo.exec(_fmt)) !== null) {
          parse_tree.push("%");
        } else if ((match = re.placeholder.exec(_fmt)) !== null) {
          if (match[2]) {
            arg_names |= 1;
            var field_list = [], replacement_field = match[2], field_match = [];
            if ((field_match = re.key.exec(replacement_field)) !== null) {
              field_list.push(field_match[1]);
              while ((replacement_field = replacement_field.substring(field_match[0].length)) !== "") {
                if ((field_match = re.key_access.exec(replacement_field)) !== null) {
                  field_list.push(field_match[1]);
                } else if ((field_match = re.index_access.exec(replacement_field)) !== null) {
                  field_list.push(field_match[1]);
                } else {
                  throw new SyntaxError("[sprintf] failed to parse named argument key");
                }
              }
            } else {
              throw new SyntaxError("[sprintf] failed to parse named argument key");
            }
            match[2] = field_list;
          } else {
            arg_names |= 2;
          }
          if (arg_names === 3) {
            throw new Error("[sprintf] mixing positional and named placeholders is not (yet) supported");
          }
          parse_tree.push({
            placeholder: match[0],
            param_no: match[1],
            keys: match[2],
            sign: match[3],
            pad_char: match[4],
            align: match[5],
            width: match[6],
            precision: match[7],
            type: match[8]
          });
        } else {
          throw new SyntaxError("[sprintf] unexpected placeholder");
        }
        _fmt = _fmt.substring(match[0].length);
      }
      return sprintf_cache[fmt] = parse_tree;
    }
    if (typeof exports2 !== "undefined") {
      exports2["sprintf"] = sprintf;
      exports2["vsprintf"] = vsprintf;
    }
    if (typeof window !== "undefined") {
      window["sprintf"] = sprintf;
      window["vsprintf"] = vsprintf;
      if (typeof define === "function" && define["amd"]) {
        define(function() {
          return {
            sprintf,
            vsprintf
          };
        });
      }
    }
  }();
});

// node_modules/lodash.padstart/index.js
var require_lodash2 = __commonJS((exports2, module2) => {
  var INFINITY = 1 / 0;
  var MAX_SAFE_INTEGER = 9007199254740991;
  var MAX_INTEGER = 17976931348623157e292;
  var NAN = 0 / 0;
  var symbolTag = "[object Symbol]";
  var reTrim = /^\s+|\s+$/g;
  var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
  var reIsBinary = /^0b[01]+$/i;
  var reIsOctal = /^0o[0-7]+$/i;
  var rsAstralRange = "\\ud800-\\udfff";
  var rsComboMarksRange = "\\u0300-\\u036f\\ufe20-\\ufe23";
  var rsComboSymbolsRange = "\\u20d0-\\u20f0";
  var rsVarRange = "\\ufe0e\\ufe0f";
  var rsAstral = "[" + rsAstralRange + "]";
  var rsCombo = "[" + rsComboMarksRange + rsComboSymbolsRange + "]";
  var rsFitz = "\\ud83c[\\udffb-\\udfff]";
  var rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")";
  var rsNonAstral = "[^" + rsAstralRange + "]";
  var rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}";
  var rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]";
  var rsZWJ = "\\u200d";
  var reOptMod = rsModifier + "?";
  var rsOptVar = "[" + rsVarRange + "]?";
  var rsOptJoin = "(?:" + rsZWJ + "(?:" + [rsNonAstral, rsRegional, rsSurrPair].join("|") + ")" + rsOptVar + reOptMod + ")*";
  var rsSeq = rsOptVar + reOptMod + rsOptJoin;
  var rsSymbol = "(?:" + [rsNonAstral + rsCombo + "?", rsCombo, rsRegional, rsSurrPair, rsAstral].join("|") + ")";
  var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
  var reHasUnicode = RegExp("[" + rsZWJ + rsAstralRange + rsComboMarksRange + rsComboSymbolsRange + rsVarRange + "]");
  var freeParseInt = parseInt;
  var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
  var freeSelf = typeof self == "object" && self && self.Object === Object && self;
  var root = freeGlobal || freeSelf || Function("return this")();
  var asciiSize = baseProperty("length");
  function asciiToArray(string) {
    return string.split("");
  }
  function baseProperty(key) {
    return function(object) {
      return object == null ? void 0 : object[key];
    };
  }
  function hasUnicode(string) {
    return reHasUnicode.test(string);
  }
  function stringSize(string) {
    return hasUnicode(string) ? unicodeSize(string) : asciiSize(string);
  }
  function stringToArray(string) {
    return hasUnicode(string) ? unicodeToArray(string) : asciiToArray(string);
  }
  function unicodeSize(string) {
    var result = reUnicode.lastIndex = 0;
    while (reUnicode.test(string)) {
      result++;
    }
    return result;
  }
  function unicodeToArray(string) {
    return string.match(reUnicode) || [];
  }
  var objectProto = Object.prototype;
  var objectToString = objectProto.toString;
  var Symbol2 = root.Symbol;
  var nativeCeil = Math.ceil;
  var nativeFloor = Math.floor;
  var symbolProto = Symbol2 ? Symbol2.prototype : void 0;
  var symbolToString = symbolProto ? symbolProto.toString : void 0;
  function baseRepeat(string, n) {
    var result = "";
    if (!string || n < 1 || n > MAX_SAFE_INTEGER) {
      return result;
    }
    do {
      if (n % 2) {
        result += string;
      }
      n = nativeFloor(n / 2);
      if (n) {
        string += string;
      }
    } while (n);
    return result;
  }
  function baseSlice(array, start, end) {
    var index = -1, length = array.length;
    if (start < 0) {
      start = -start > length ? 0 : length + start;
    }
    end = end > length ? length : end;
    if (end < 0) {
      end += length;
    }
    length = start > end ? 0 : end - start >>> 0;
    start >>>= 0;
    var result = Array(length);
    while (++index < length) {
      result[index] = array[index + start];
    }
    return result;
  }
  function baseToString(value) {
    if (typeof value == "string") {
      return value;
    }
    if (isSymbol(value)) {
      return symbolToString ? symbolToString.call(value) : "";
    }
    var result = value + "";
    return result == "0" && 1 / value == -INFINITY ? "-0" : result;
  }
  function castSlice(array, start, end) {
    var length = array.length;
    end = end === void 0 ? length : end;
    return !start && end >= length ? array : baseSlice(array, start, end);
  }
  function createPadding(length, chars) {
    chars = chars === void 0 ? " " : baseToString(chars);
    var charsLength = chars.length;
    if (charsLength < 2) {
      return charsLength ? baseRepeat(chars, length) : chars;
    }
    var result = baseRepeat(chars, nativeCeil(length / stringSize(chars)));
    return hasUnicode(chars) ? castSlice(stringToArray(result), 0, length).join("") : result.slice(0, length);
  }
  function isObject(value) {
    var type = typeof value;
    return !!value && (type == "object" || type == "function");
  }
  function isObjectLike(value) {
    return !!value && typeof value == "object";
  }
  function isSymbol(value) {
    return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
  }
  function toFinite(value) {
    if (!value) {
      return value === 0 ? value : 0;
    }
    value = toNumber(value);
    if (value === INFINITY || value === -INFINITY) {
      var sign = value < 0 ? -1 : 1;
      return sign * MAX_INTEGER;
    }
    return value === value ? value : 0;
  }
  function toInteger(value) {
    var result = toFinite(value), remainder = result % 1;
    return result === result ? remainder ? result - remainder : result : 0;
  }
  function toNumber(value) {
    if (typeof value == "number") {
      return value;
    }
    if (isSymbol(value)) {
      return NAN;
    }
    if (isObject(value)) {
      var other = typeof value.valueOf == "function" ? value.valueOf() : value;
      value = isObject(other) ? other + "" : other;
    }
    if (typeof value != "string") {
      return value === 0 ? value : +value;
    }
    value = value.replace(reTrim, "");
    var isBinary = reIsBinary.test(value);
    return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
  }
  function toString(value) {
    return value == null ? "" : baseToString(value);
  }
  function padStart(string, length, chars) {
    string = toString(string);
    length = toInteger(length);
    var strLength = length ? stringSize(string) : 0;
    return length && strLength < length ? createPadding(length - strLength, chars) + string : string;
  }
  module2.exports = padStart;
});

// node_modules/lodash.repeat/index.js
var require_lodash3 = __commonJS((exports2, module2) => {
  var INFINITY = 1 / 0;
  var MAX_SAFE_INTEGER = 9007199254740991;
  var MAX_INTEGER = 17976931348623157e292;
  var NAN = 0 / 0;
  var funcTag = "[object Function]";
  var genTag = "[object GeneratorFunction]";
  var symbolTag = "[object Symbol]";
  var reTrim = /^\s+|\s+$/g;
  var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
  var reIsBinary = /^0b[01]+$/i;
  var reIsOctal = /^0o[0-7]+$/i;
  var reIsUint = /^(?:0|[1-9]\d*)$/;
  var freeParseInt = parseInt;
  var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
  var freeSelf = typeof self == "object" && self && self.Object === Object && self;
  var root = freeGlobal || freeSelf || Function("return this")();
  var objectProto = Object.prototype;
  var objectToString = objectProto.toString;
  var Symbol2 = root.Symbol;
  var nativeFloor = Math.floor;
  var symbolProto = Symbol2 ? Symbol2.prototype : void 0;
  var symbolToString = symbolProto ? symbolProto.toString : void 0;
  function baseRepeat(string, n) {
    var result = "";
    if (!string || n < 1 || n > MAX_SAFE_INTEGER) {
      return result;
    }
    do {
      if (n % 2) {
        result += string;
      }
      n = nativeFloor(n / 2);
      if (n) {
        string += string;
      }
    } while (n);
    return result;
  }
  function baseToString(value) {
    if (typeof value == "string") {
      return value;
    }
    if (isSymbol(value)) {
      return symbolToString ? symbolToString.call(value) : "";
    }
    var result = value + "";
    return result == "0" && 1 / value == -INFINITY ? "-0" : result;
  }
  function isIndex(value, length) {
    length = length == null ? MAX_SAFE_INTEGER : length;
    return !!length && (typeof value == "number" || reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
  }
  function isIterateeCall(value, index, object) {
    if (!isObject(object)) {
      return false;
    }
    var type = typeof index;
    if (type == "number" ? isArrayLike(object) && isIndex(index, object.length) : type == "string" && index in object) {
      return eq(object[index], value);
    }
    return false;
  }
  function eq(value, other) {
    return value === other || value !== value && other !== other;
  }
  function isArrayLike(value) {
    return value != null && isLength(value.length) && !isFunction(value);
  }
  function isFunction(value) {
    var tag = isObject(value) ? objectToString.call(value) : "";
    return tag == funcTag || tag == genTag;
  }
  function isLength(value) {
    return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
  }
  function isObject(value) {
    var type = typeof value;
    return !!value && (type == "object" || type == "function");
  }
  function isObjectLike(value) {
    return !!value && typeof value == "object";
  }
  function isSymbol(value) {
    return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
  }
  function toFinite(value) {
    if (!value) {
      return value === 0 ? value : 0;
    }
    value = toNumber(value);
    if (value === INFINITY || value === -INFINITY) {
      var sign = value < 0 ? -1 : 1;
      return sign * MAX_INTEGER;
    }
    return value === value ? value : 0;
  }
  function toInteger(value) {
    var result = toFinite(value), remainder = result % 1;
    return result === result ? remainder ? result - remainder : result : 0;
  }
  function toNumber(value) {
    if (typeof value == "number") {
      return value;
    }
    if (isSymbol(value)) {
      return NAN;
    }
    if (isObject(value)) {
      var other = typeof value.valueOf == "function" ? value.valueOf() : value;
      value = isObject(other) ? other + "" : other;
    }
    if (typeof value != "string") {
      return value === 0 ? value : +value;
    }
    value = value.replace(reTrim, "");
    var isBinary = reIsBinary.test(value);
    return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
  }
  function toString(value) {
    return value == null ? "" : baseToString(value);
  }
  function repeat(string, n, guard) {
    if (guard ? isIterateeCall(string, n, guard) : n === void 0) {
      n = 1;
    } else {
      n = toInteger(n);
    }
    return baseRepeat(toString(string), n);
  }
  module2.exports = repeat;
});

// node_modules/ip-address/lib/v4/constants.js
var require_constants15 = __commonJS((exports2) => {
  exports2.BITS = 32;
  exports2.GROUPS = 4;
  exports2.RE_ADDRESS = /^(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/g;
  exports2.RE_SUBNET_STRING = /\/\d{1,2}$/;
});

// node_modules/ip-address/lib/ipv4.js
var require_ipv4 = __commonJS((exports2, module2) => {
  "use strict";
  var BigInteger = require_jsbn2().BigInteger;
  var common = require_common5();
  var sprintf = require_sprintf().sprintf;
  var padStart = require_lodash2();
  var repeat = require_lodash3();
  var constants = require_constants15();
  function Address4(address) {
    this.valid = false;
    this.address = address;
    this.groups = constants.GROUPS;
    this.v4 = true;
    this.subnet = "/32";
    this.subnetMask = 32;
    var subnet = constants.RE_SUBNET_STRING.exec(address);
    if (subnet) {
      this.parsedSubnet = subnet[0].replace("/", "");
      this.subnetMask = parseInt(this.parsedSubnet, 10);
      this.subnet = "/" + this.subnetMask;
      if (this.subnetMask < 0 || this.subnetMask > constants.BITS) {
        this.valid = false;
        this.error = "Invalid subnet mask.";
        return;
      }
      address = address.replace(constants.RE_SUBNET_STRING, "");
    }
    this.addressMinusSuffix = address;
    this.parsedAddress = this.parse(address);
  }
  Address4.prototype.parse = function(address) {
    var groups = address.split(".");
    if (address.match(constants.RE_ADDRESS)) {
      this.valid = true;
    } else {
      this.error = "Invalid IPv4 address.";
    }
    return groups;
  };
  Address4.prototype.isValid = function() {
    return this.valid;
  };
  Address4.prototype.correctForm = function() {
    return this.parsedAddress.map(function(part) {
      return parseInt(part, 10);
    }).join(".");
  };
  Address4.prototype.isCorrect = common.isCorrect(constants.BITS);
  Address4.fromHex = function(hex) {
    var padded = padStart(hex.replace(/:/g, ""), 8, "0");
    var groups = [];
    var i;
    for (i = 0; i < 8; i += 2) {
      var h = padded.slice(i, i + 2);
      groups.push(parseInt(h, 16));
    }
    return new Address4(groups.join("."));
  };
  Address4.fromInteger = function(integer) {
    return Address4.fromHex(integer.toString(16));
  };
  Address4.prototype.toHex = function() {
    return this.parsedAddress.map(function(part) {
      return sprintf("%02x", parseInt(part, 10));
    }).join(":");
  };
  Address4.prototype.toArray = function() {
    return this.parsedAddress.map(function(part) {
      return parseInt(part, 10);
    });
  };
  Address4.prototype.toGroup6 = function() {
    var output = [];
    var i;
    for (i = 0; i < constants.GROUPS; i += 2) {
      var hex = sprintf("%02x%02x", parseInt(this.parsedAddress[i], 10), parseInt(this.parsedAddress[i + 1], 10));
      output.push(sprintf("%x", parseInt(hex, 16)));
    }
    return output.join(":");
  };
  Address4.prototype.bigInteger = function() {
    if (!this.valid) {
      return null;
    }
    return new BigInteger(this.parsedAddress.map(function(n) {
      return sprintf("%02x", parseInt(n, 10));
    }).join(""), 16);
  };
  Address4.prototype._startAddress = function() {
    return new BigInteger(this.mask() + repeat("0", constants.BITS - this.subnetMask), 2);
  };
  Address4.prototype.startAddress = function() {
    return Address4.fromBigInteger(this._startAddress());
  };
  Address4.prototype.startAddressExclusive = function() {
    var adjust = new BigInteger("1");
    return Address4.fromBigInteger(this._startAddress().add(adjust));
  };
  Address4.prototype._endAddress = function() {
    return new BigInteger(this.mask() + repeat("1", constants.BITS - this.subnetMask), 2);
  };
  Address4.prototype.endAddress = function() {
    return Address4.fromBigInteger(this._endAddress());
  };
  Address4.prototype.endAddressExclusive = function() {
    var adjust = new BigInteger("1");
    return Address4.fromBigInteger(this._endAddress().subtract(adjust));
  };
  Address4.fromBigInteger = function(bigInteger) {
    return Address4.fromInteger(parseInt(bigInteger.toString(), 10));
  };
  Address4.prototype.mask = function(optionalMask) {
    if (optionalMask === void 0) {
      optionalMask = this.subnetMask;
    }
    return this.getBitsBase2(0, optionalMask);
  };
  Address4.prototype.getBitsBase2 = function(start, end) {
    return this.binaryZeroPad().slice(start, end);
  };
  Address4.prototype.isInSubnet = common.isInSubnet;
  Address4.prototype.isMulticast = function() {
    return this.isInSubnet(new Address4("224.0.0.0/4"));
  };
  Address4.prototype.binaryZeroPad = function() {
    return padStart(this.bigInteger().toString(2), constants.BITS, "0");
  };
  module2.exports = Address4;
});

// node_modules/lodash.merge/index.js
var require_lodash4 = __commonJS((exports2, module2) => {
  var LARGE_ARRAY_SIZE = 200;
  var HASH_UNDEFINED = "__lodash_hash_undefined__";
  var HOT_COUNT = 800;
  var HOT_SPAN = 16;
  var MAX_SAFE_INTEGER = 9007199254740991;
  var argsTag = "[object Arguments]";
  var arrayTag = "[object Array]";
  var asyncTag = "[object AsyncFunction]";
  var boolTag = "[object Boolean]";
  var dateTag = "[object Date]";
  var errorTag = "[object Error]";
  var funcTag = "[object Function]";
  var genTag = "[object GeneratorFunction]";
  var mapTag = "[object Map]";
  var numberTag = "[object Number]";
  var nullTag = "[object Null]";
  var objectTag = "[object Object]";
  var proxyTag = "[object Proxy]";
  var regexpTag = "[object RegExp]";
  var setTag = "[object Set]";
  var stringTag = "[object String]";
  var undefinedTag = "[object Undefined]";
  var weakMapTag = "[object WeakMap]";
  var arrayBufferTag = "[object ArrayBuffer]";
  var dataViewTag = "[object DataView]";
  var float32Tag = "[object Float32Array]";
  var float64Tag = "[object Float64Array]";
  var int8Tag = "[object Int8Array]";
  var int16Tag = "[object Int16Array]";
  var int32Tag = "[object Int32Array]";
  var uint8Tag = "[object Uint8Array]";
  var uint8ClampedTag = "[object Uint8ClampedArray]";
  var uint16Tag = "[object Uint16Array]";
  var uint32Tag = "[object Uint32Array]";
  var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
  var reIsHostCtor = /^\[object .+?Constructor\]$/;
  var reIsUint = /^(?:0|[1-9]\d*)$/;
  var typedArrayTags = {};
  typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
  typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
  var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
  var freeSelf = typeof self == "object" && self && self.Object === Object && self;
  var root = freeGlobal || freeSelf || Function("return this")();
  var freeExports = typeof exports2 == "object" && exports2 && !exports2.nodeType && exports2;
  var freeModule = freeExports && typeof module2 == "object" && module2 && !module2.nodeType && module2;
  var moduleExports = freeModule && freeModule.exports === freeExports;
  var freeProcess = moduleExports && freeGlobal.process;
  var nodeUtil = function() {
    try {
      var types = freeModule && freeModule.require && freeModule.require("util").types;
      if (types) {
        return types;
      }
      return freeProcess && freeProcess.binding && freeProcess.binding("util");
    } catch (e) {
    }
  }();
  var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
  function apply(func, thisArg, args) {
    switch (args.length) {
      case 0:
        return func.call(thisArg);
      case 1:
        return func.call(thisArg, args[0]);
      case 2:
        return func.call(thisArg, args[0], args[1]);
      case 3:
        return func.call(thisArg, args[0], args[1], args[2]);
    }
    return func.apply(thisArg, args);
  }
  function baseTimes(n, iteratee) {
    var index = -1, result = Array(n);
    while (++index < n) {
      result[index] = iteratee(index);
    }
    return result;
  }
  function baseUnary(func) {
    return function(value) {
      return func(value);
    };
  }
  function getValue(object, key) {
    return object == null ? void 0 : object[key];
  }
  function overArg(func, transform) {
    return function(arg) {
      return func(transform(arg));
    };
  }
  var arrayProto = Array.prototype;
  var funcProto = Function.prototype;
  var objectProto = Object.prototype;
  var coreJsData = root["__core-js_shared__"];
  var funcToString = funcProto.toString;
  var hasOwnProperty = objectProto.hasOwnProperty;
  var maskSrcKey = function() {
    var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
    return uid ? "Symbol(src)_1." + uid : "";
  }();
  var nativeObjectToString = objectProto.toString;
  var objectCtorString = funcToString.call(Object);
  var reIsNative = RegExp("^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
  var Buffer2 = moduleExports ? root.Buffer : void 0;
  var Symbol2 = root.Symbol;
  var Uint8Array2 = root.Uint8Array;
  var allocUnsafe = Buffer2 ? Buffer2.allocUnsafe : void 0;
  var getPrototype = overArg(Object.getPrototypeOf, Object);
  var objectCreate = Object.create;
  var propertyIsEnumerable = objectProto.propertyIsEnumerable;
  var splice = arrayProto.splice;
  var symToStringTag = Symbol2 ? Symbol2.toStringTag : void 0;
  var defineProperty = function() {
    try {
      var func = getNative(Object, "defineProperty");
      func({}, "", {});
      return func;
    } catch (e) {
    }
  }();
  var nativeIsBuffer = Buffer2 ? Buffer2.isBuffer : void 0;
  var nativeMax = Math.max;
  var nativeNow = Date.now;
  var Map2 = getNative(root, "Map");
  var nativeCreate = getNative(Object, "create");
  var baseCreate = function() {
    function object() {
    }
    return function(proto) {
      if (!isObject(proto)) {
        return {};
      }
      if (objectCreate) {
        return objectCreate(proto);
      }
      object.prototype = proto;
      var result = new object();
      object.prototype = void 0;
      return result;
    };
  }();
  function Hash(entries) {
    var index = -1, length = entries == null ? 0 : entries.length;
    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }
  function hashClear() {
    this.__data__ = nativeCreate ? nativeCreate(null) : {};
    this.size = 0;
  }
  function hashDelete(key) {
    var result = this.has(key) && delete this.__data__[key];
    this.size -= result ? 1 : 0;
    return result;
  }
  function hashGet(key) {
    var data = this.__data__;
    if (nativeCreate) {
      var result = data[key];
      return result === HASH_UNDEFINED ? void 0 : result;
    }
    return hasOwnProperty.call(data, key) ? data[key] : void 0;
  }
  function hashHas(key) {
    var data = this.__data__;
    return nativeCreate ? data[key] !== void 0 : hasOwnProperty.call(data, key);
  }
  function hashSet(key, value) {
    var data = this.__data__;
    this.size += this.has(key) ? 0 : 1;
    data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
    return this;
  }
  Hash.prototype.clear = hashClear;
  Hash.prototype["delete"] = hashDelete;
  Hash.prototype.get = hashGet;
  Hash.prototype.has = hashHas;
  Hash.prototype.set = hashSet;
  function ListCache(entries) {
    var index = -1, length = entries == null ? 0 : entries.length;
    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }
  function listCacheClear() {
    this.__data__ = [];
    this.size = 0;
  }
  function listCacheDelete(key) {
    var data = this.__data__, index = assocIndexOf(data, key);
    if (index < 0) {
      return false;
    }
    var lastIndex = data.length - 1;
    if (index == lastIndex) {
      data.pop();
    } else {
      splice.call(data, index, 1);
    }
    --this.size;
    return true;
  }
  function listCacheGet(key) {
    var data = this.__data__, index = assocIndexOf(data, key);
    return index < 0 ? void 0 : data[index][1];
  }
  function listCacheHas(key) {
    return assocIndexOf(this.__data__, key) > -1;
  }
  function listCacheSet(key, value) {
    var data = this.__data__, index = assocIndexOf(data, key);
    if (index < 0) {
      ++this.size;
      data.push([key, value]);
    } else {
      data[index][1] = value;
    }
    return this;
  }
  ListCache.prototype.clear = listCacheClear;
  ListCache.prototype["delete"] = listCacheDelete;
  ListCache.prototype.get = listCacheGet;
  ListCache.prototype.has = listCacheHas;
  ListCache.prototype.set = listCacheSet;
  function MapCache(entries) {
    var index = -1, length = entries == null ? 0 : entries.length;
    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }
  function mapCacheClear() {
    this.size = 0;
    this.__data__ = {
      hash: new Hash(),
      map: new (Map2 || ListCache)(),
      string: new Hash()
    };
  }
  function mapCacheDelete(key) {
    var result = getMapData(this, key)["delete"](key);
    this.size -= result ? 1 : 0;
    return result;
  }
  function mapCacheGet(key) {
    return getMapData(this, key).get(key);
  }
  function mapCacheHas(key) {
    return getMapData(this, key).has(key);
  }
  function mapCacheSet(key, value) {
    var data = getMapData(this, key), size = data.size;
    data.set(key, value);
    this.size += data.size == size ? 0 : 1;
    return this;
  }
  MapCache.prototype.clear = mapCacheClear;
  MapCache.prototype["delete"] = mapCacheDelete;
  MapCache.prototype.get = mapCacheGet;
  MapCache.prototype.has = mapCacheHas;
  MapCache.prototype.set = mapCacheSet;
  function Stack(entries) {
    var data = this.__data__ = new ListCache(entries);
    this.size = data.size;
  }
  function stackClear() {
    this.__data__ = new ListCache();
    this.size = 0;
  }
  function stackDelete(key) {
    var data = this.__data__, result = data["delete"](key);
    this.size = data.size;
    return result;
  }
  function stackGet(key) {
    return this.__data__.get(key);
  }
  function stackHas(key) {
    return this.__data__.has(key);
  }
  function stackSet(key, value) {
    var data = this.__data__;
    if (data instanceof ListCache) {
      var pairs = data.__data__;
      if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
        pairs.push([key, value]);
        this.size = ++data.size;
        return this;
      }
      data = this.__data__ = new MapCache(pairs);
    }
    data.set(key, value);
    this.size = data.size;
    return this;
  }
  Stack.prototype.clear = stackClear;
  Stack.prototype["delete"] = stackDelete;
  Stack.prototype.get = stackGet;
  Stack.prototype.has = stackHas;
  Stack.prototype.set = stackSet;
  function arrayLikeKeys(value, inherited) {
    var isArr = isArray(value), isArg = !isArr && isArguments(value), isBuff = !isArr && !isArg && isBuffer(value), isType = !isArr && !isArg && !isBuff && isTypedArray(value), skipIndexes = isArr || isArg || isBuff || isType, result = skipIndexes ? baseTimes(value.length, String) : [], length = result.length;
    for (var key in value) {
      if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && (key == "length" || isBuff && (key == "offset" || key == "parent") || isType && (key == "buffer" || key == "byteLength" || key == "byteOffset") || isIndex(key, length)))) {
        result.push(key);
      }
    }
    return result;
  }
  function assignMergeValue(object, key, value) {
    if (value !== void 0 && !eq(object[key], value) || value === void 0 && !(key in object)) {
      baseAssignValue(object, key, value);
    }
  }
  function assignValue(object, key, value) {
    var objValue = object[key];
    if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) || value === void 0 && !(key in object)) {
      baseAssignValue(object, key, value);
    }
  }
  function assocIndexOf(array, key) {
    var length = array.length;
    while (length--) {
      if (eq(array[length][0], key)) {
        return length;
      }
    }
    return -1;
  }
  function baseAssignValue(object, key, value) {
    if (key == "__proto__" && defineProperty) {
      defineProperty(object, key, {
        configurable: true,
        enumerable: true,
        value,
        writable: true
      });
    } else {
      object[key] = value;
    }
  }
  var baseFor = createBaseFor();
  function baseGetTag(value) {
    if (value == null) {
      return value === void 0 ? undefinedTag : nullTag;
    }
    return symToStringTag && symToStringTag in Object(value) ? getRawTag(value) : objectToString(value);
  }
  function baseIsArguments(value) {
    return isObjectLike(value) && baseGetTag(value) == argsTag;
  }
  function baseIsNative(value) {
    if (!isObject(value) || isMasked(value)) {
      return false;
    }
    var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
    return pattern.test(toSource(value));
  }
  function baseIsTypedArray(value) {
    return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
  }
  function baseKeysIn(object) {
    if (!isObject(object)) {
      return nativeKeysIn(object);
    }
    var isProto = isPrototype(object), result = [];
    for (var key in object) {
      if (!(key == "constructor" && (isProto || !hasOwnProperty.call(object, key)))) {
        result.push(key);
      }
    }
    return result;
  }
  function baseMerge(object, source, srcIndex, customizer, stack) {
    if (object === source) {
      return;
    }
    baseFor(source, function(srcValue, key) {
      stack || (stack = new Stack());
      if (isObject(srcValue)) {
        baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
      } else {
        var newValue = customizer ? customizer(safeGet(object, key), srcValue, key + "", object, source, stack) : void 0;
        if (newValue === void 0) {
          newValue = srcValue;
        }
        assignMergeValue(object, key, newValue);
      }
    }, keysIn);
  }
  function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
    var objValue = safeGet(object, key), srcValue = safeGet(source, key), stacked = stack.get(srcValue);
    if (stacked) {
      assignMergeValue(object, key, stacked);
      return;
    }
    var newValue = customizer ? customizer(objValue, srcValue, key + "", object, source, stack) : void 0;
    var isCommon = newValue === void 0;
    if (isCommon) {
      var isArr = isArray(srcValue), isBuff = !isArr && isBuffer(srcValue), isTyped = !isArr && !isBuff && isTypedArray(srcValue);
      newValue = srcValue;
      if (isArr || isBuff || isTyped) {
        if (isArray(objValue)) {
          newValue = objValue;
        } else if (isArrayLikeObject(objValue)) {
          newValue = copyArray(objValue);
        } else if (isBuff) {
          isCommon = false;
          newValue = cloneBuffer(srcValue, true);
        } else if (isTyped) {
          isCommon = false;
          newValue = cloneTypedArray(srcValue, true);
        } else {
          newValue = [];
        }
      } else if (isPlainObject(srcValue) || isArguments(srcValue)) {
        newValue = objValue;
        if (isArguments(objValue)) {
          newValue = toPlainObject(objValue);
        } else if (!isObject(objValue) || isFunction(objValue)) {
          newValue = initCloneObject(srcValue);
        }
      } else {
        isCommon = false;
      }
    }
    if (isCommon) {
      stack.set(srcValue, newValue);
      mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
      stack["delete"](srcValue);
    }
    assignMergeValue(object, key, newValue);
  }
  function baseRest(func, start) {
    return setToString(overRest(func, start, identity), func + "");
  }
  var baseSetToString = !defineProperty ? identity : function(func, string) {
    return defineProperty(func, "toString", {
      configurable: true,
      enumerable: false,
      value: constant(string),
      writable: true
    });
  };
  function cloneBuffer(buffer, isDeep) {
    if (isDeep) {
      return buffer.slice();
    }
    var length = buffer.length, result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);
    buffer.copy(result);
    return result;
  }
  function cloneArrayBuffer(arrayBuffer) {
    var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
    new Uint8Array2(result).set(new Uint8Array2(arrayBuffer));
    return result;
  }
  function cloneTypedArray(typedArray, isDeep) {
    var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
    return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
  }
  function copyArray(source, array) {
    var index = -1, length = source.length;
    array || (array = Array(length));
    while (++index < length) {
      array[index] = source[index];
    }
    return array;
  }
  function copyObject(source, props, object, customizer) {
    var isNew = !object;
    object || (object = {});
    var index = -1, length = props.length;
    while (++index < length) {
      var key = props[index];
      var newValue = customizer ? customizer(object[key], source[key], key, object, source) : void 0;
      if (newValue === void 0) {
        newValue = source[key];
      }
      if (isNew) {
        baseAssignValue(object, key, newValue);
      } else {
        assignValue(object, key, newValue);
      }
    }
    return object;
  }
  function createAssigner(assigner) {
    return baseRest(function(object, sources) {
      var index = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : void 0, guard = length > 2 ? sources[2] : void 0;
      customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : void 0;
      if (guard && isIterateeCall(sources[0], sources[1], guard)) {
        customizer = length < 3 ? void 0 : customizer;
        length = 1;
      }
      object = Object(object);
      while (++index < length) {
        var source = sources[index];
        if (source) {
          assigner(object, source, index, customizer);
        }
      }
      return object;
    });
  }
  function createBaseFor(fromRight) {
    return function(object, iteratee, keysFunc) {
      var index = -1, iterable = Object(object), props = keysFunc(object), length = props.length;
      while (length--) {
        var key = props[fromRight ? length : ++index];
        if (iteratee(iterable[key], key, iterable) === false) {
          break;
        }
      }
      return object;
    };
  }
  function getMapData(map, key) {
    var data = map.__data__;
    return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
  }
  function getNative(object, key) {
    var value = getValue(object, key);
    return baseIsNative(value) ? value : void 0;
  }
  function getRawTag(value) {
    var isOwn = hasOwnProperty.call(value, symToStringTag), tag = value[symToStringTag];
    try {
      value[symToStringTag] = void 0;
      var unmasked = true;
    } catch (e) {
    }
    var result = nativeObjectToString.call(value);
    if (unmasked) {
      if (isOwn) {
        value[symToStringTag] = tag;
      } else {
        delete value[symToStringTag];
      }
    }
    return result;
  }
  function initCloneObject(object) {
    return typeof object.constructor == "function" && !isPrototype(object) ? baseCreate(getPrototype(object)) : {};
  }
  function isIndex(value, length) {
    var type = typeof value;
    length = length == null ? MAX_SAFE_INTEGER : length;
    return !!length && (type == "number" || type != "symbol" && reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
  }
  function isIterateeCall(value, index, object) {
    if (!isObject(object)) {
      return false;
    }
    var type = typeof index;
    if (type == "number" ? isArrayLike(object) && isIndex(index, object.length) : type == "string" && index in object) {
      return eq(object[index], value);
    }
    return false;
  }
  function isKeyable(value) {
    var type = typeof value;
    return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
  }
  function isMasked(func) {
    return !!maskSrcKey && maskSrcKey in func;
  }
  function isPrototype(value) {
    var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
    return value === proto;
  }
  function nativeKeysIn(object) {
    var result = [];
    if (object != null) {
      for (var key in Object(object)) {
        result.push(key);
      }
    }
    return result;
  }
  function objectToString(value) {
    return nativeObjectToString.call(value);
  }
  function overRest(func, start, transform) {
    start = nativeMax(start === void 0 ? func.length - 1 : start, 0);
    return function() {
      var args = arguments, index = -1, length = nativeMax(args.length - start, 0), array = Array(length);
      while (++index < length) {
        array[index] = args[start + index];
      }
      index = -1;
      var otherArgs = Array(start + 1);
      while (++index < start) {
        otherArgs[index] = args[index];
      }
      otherArgs[start] = transform(array);
      return apply(func, this, otherArgs);
    };
  }
  function safeGet(object, key) {
    if (key === "constructor" && typeof object[key] === "function") {
      return;
    }
    if (key == "__proto__") {
      return;
    }
    return object[key];
  }
  var setToString = shortOut(baseSetToString);
  function shortOut(func) {
    var count = 0, lastCalled = 0;
    return function() {
      var stamp = nativeNow(), remaining = HOT_SPAN - (stamp - lastCalled);
      lastCalled = stamp;
      if (remaining > 0) {
        if (++count >= HOT_COUNT) {
          return arguments[0];
        }
      } else {
        count = 0;
      }
      return func.apply(void 0, arguments);
    };
  }
  function toSource(func) {
    if (func != null) {
      try {
        return funcToString.call(func);
      } catch (e) {
      }
      try {
        return func + "";
      } catch (e) {
      }
    }
    return "";
  }
  function eq(value, other) {
    return value === other || value !== value && other !== other;
  }
  var isArguments = baseIsArguments(function() {
    return arguments;
  }()) ? baseIsArguments : function(value) {
    return isObjectLike(value) && hasOwnProperty.call(value, "callee") && !propertyIsEnumerable.call(value, "callee");
  };
  var isArray = Array.isArray;
  function isArrayLike(value) {
    return value != null && isLength(value.length) && !isFunction(value);
  }
  function isArrayLikeObject(value) {
    return isObjectLike(value) && isArrayLike(value);
  }
  var isBuffer = nativeIsBuffer || stubFalse;
  function isFunction(value) {
    if (!isObject(value)) {
      return false;
    }
    var tag = baseGetTag(value);
    return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
  }
  function isLength(value) {
    return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
  }
  function isObject(value) {
    var type = typeof value;
    return value != null && (type == "object" || type == "function");
  }
  function isObjectLike(value) {
    return value != null && typeof value == "object";
  }
  function isPlainObject(value) {
    if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
      return false;
    }
    var proto = getPrototype(value);
    if (proto === null) {
      return true;
    }
    var Ctor = hasOwnProperty.call(proto, "constructor") && proto.constructor;
    return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
  }
  var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
  function toPlainObject(value) {
    return copyObject(value, keysIn(value));
  }
  function keysIn(object) {
    return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
  }
  var merge = createAssigner(function(object, source, srcIndex) {
    baseMerge(object, source, srcIndex);
  });
  function constant(value) {
    return function() {
      return value;
    };
  }
  function identity(value) {
    return value;
  }
  function stubFalse() {
    return false;
  }
  module2.exports = merge;
});

// node_modules/lodash.find/index.js
var require_lodash5 = __commonJS((exports2, module2) => {
  var LARGE_ARRAY_SIZE = 200;
  var FUNC_ERROR_TEXT = "Expected a function";
  var HASH_UNDEFINED = "__lodash_hash_undefined__";
  var UNORDERED_COMPARE_FLAG = 1;
  var PARTIAL_COMPARE_FLAG = 2;
  var INFINITY = 1 / 0;
  var MAX_SAFE_INTEGER = 9007199254740991;
  var MAX_INTEGER = 17976931348623157e292;
  var NAN = 0 / 0;
  var argsTag = "[object Arguments]";
  var arrayTag = "[object Array]";
  var boolTag = "[object Boolean]";
  var dateTag = "[object Date]";
  var errorTag = "[object Error]";
  var funcTag = "[object Function]";
  var genTag = "[object GeneratorFunction]";
  var mapTag = "[object Map]";
  var numberTag = "[object Number]";
  var objectTag = "[object Object]";
  var promiseTag = "[object Promise]";
  var regexpTag = "[object RegExp]";
  var setTag = "[object Set]";
  var stringTag = "[object String]";
  var symbolTag = "[object Symbol]";
  var weakMapTag = "[object WeakMap]";
  var arrayBufferTag = "[object ArrayBuffer]";
  var dataViewTag = "[object DataView]";
  var float32Tag = "[object Float32Array]";
  var float64Tag = "[object Float64Array]";
  var int8Tag = "[object Int8Array]";
  var int16Tag = "[object Int16Array]";
  var int32Tag = "[object Int32Array]";
  var uint8Tag = "[object Uint8Array]";
  var uint8ClampedTag = "[object Uint8ClampedArray]";
  var uint16Tag = "[object Uint16Array]";
  var uint32Tag = "[object Uint32Array]";
  var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/;
  var reIsPlainProp = /^\w*$/;
  var reLeadingDot = /^\./;
  var rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;
  var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;
  var reTrim = /^\s+|\s+$/g;
  var reEscapeChar = /\\(\\)?/g;
  var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
  var reIsBinary = /^0b[01]+$/i;
  var reIsHostCtor = /^\[object .+?Constructor\]$/;
  var reIsOctal = /^0o[0-7]+$/i;
  var reIsUint = /^(?:0|[1-9]\d*)$/;
  var typedArrayTags = {};
  typedArrayTags[float32Tag] = typedArrayTags[float64Tag] = typedArrayTags[int8Tag] = typedArrayTags[int16Tag] = typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] = typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] = typedArrayTags[uint32Tag] = true;
  typedArrayTags[argsTag] = typedArrayTags[arrayTag] = typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] = typedArrayTags[dataViewTag] = typedArrayTags[dateTag] = typedArrayTags[errorTag] = typedArrayTags[funcTag] = typedArrayTags[mapTag] = typedArrayTags[numberTag] = typedArrayTags[objectTag] = typedArrayTags[regexpTag] = typedArrayTags[setTag] = typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;
  var freeParseInt = parseInt;
  var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
  var freeSelf = typeof self == "object" && self && self.Object === Object && self;
  var root = freeGlobal || freeSelf || Function("return this")();
  var freeExports = typeof exports2 == "object" && exports2 && !exports2.nodeType && exports2;
  var freeModule = freeExports && typeof module2 == "object" && module2 && !module2.nodeType && module2;
  var moduleExports = freeModule && freeModule.exports === freeExports;
  var freeProcess = moduleExports && freeGlobal.process;
  var nodeUtil = function() {
    try {
      return freeProcess && freeProcess.binding("util");
    } catch (e) {
    }
  }();
  var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;
  function arraySome(array, predicate) {
    var index = -1, length = array ? array.length : 0;
    while (++index < length) {
      if (predicate(array[index], index, array)) {
        return true;
      }
    }
    return false;
  }
  function baseFindIndex(array, predicate, fromIndex, fromRight) {
    var length = array.length, index = fromIndex + (fromRight ? 1 : -1);
    while (fromRight ? index-- : ++index < length) {
      if (predicate(array[index], index, array)) {
        return index;
      }
    }
    return -1;
  }
  function baseProperty(key) {
    return function(object) {
      return object == null ? void 0 : object[key];
    };
  }
  function baseTimes(n, iteratee) {
    var index = -1, result = Array(n);
    while (++index < n) {
      result[index] = iteratee(index);
    }
    return result;
  }
  function baseUnary(func) {
    return function(value) {
      return func(value);
    };
  }
  function getValue(object, key) {
    return object == null ? void 0 : object[key];
  }
  function isHostObject(value) {
    var result = false;
    if (value != null && typeof value.toString != "function") {
      try {
        result = !!(value + "");
      } catch (e) {
      }
    }
    return result;
  }
  function mapToArray(map) {
    var index = -1, result = Array(map.size);
    map.forEach(function(value, key) {
      result[++index] = [key, value];
    });
    return result;
  }
  function overArg(func, transform) {
    return function(arg) {
      return func(transform(arg));
    };
  }
  function setToArray(set) {
    var index = -1, result = Array(set.size);
    set.forEach(function(value) {
      result[++index] = value;
    });
    return result;
  }
  var arrayProto = Array.prototype;
  var funcProto = Function.prototype;
  var objectProto = Object.prototype;
  var coreJsData = root["__core-js_shared__"];
  var maskSrcKey = function() {
    var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || "");
    return uid ? "Symbol(src)_1." + uid : "";
  }();
  var funcToString = funcProto.toString;
  var hasOwnProperty = objectProto.hasOwnProperty;
  var objectToString = objectProto.toString;
  var reIsNative = RegExp("^" + funcToString.call(hasOwnProperty).replace(reRegExpChar, "\\$&").replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, "$1.*?") + "$");
  var Symbol2 = root.Symbol;
  var Uint8Array2 = root.Uint8Array;
  var propertyIsEnumerable = objectProto.propertyIsEnumerable;
  var splice = arrayProto.splice;
  var nativeKeys = overArg(Object.keys, Object);
  var nativeMax = Math.max;
  var DataView2 = getNative(root, "DataView");
  var Map2 = getNative(root, "Map");
  var Promise2 = getNative(root, "Promise");
  var Set2 = getNative(root, "Set");
  var WeakMap2 = getNative(root, "WeakMap");
  var nativeCreate = getNative(Object, "create");
  var dataViewCtorString = toSource(DataView2);
  var mapCtorString = toSource(Map2);
  var promiseCtorString = toSource(Promise2);
  var setCtorString = toSource(Set2);
  var weakMapCtorString = toSource(WeakMap2);
  var symbolProto = Symbol2 ? Symbol2.prototype : void 0;
  var symbolValueOf = symbolProto ? symbolProto.valueOf : void 0;
  var symbolToString = symbolProto ? symbolProto.toString : void 0;
  function Hash(entries) {
    var index = -1, length = entries ? entries.length : 0;
    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }
  function hashClear() {
    this.__data__ = nativeCreate ? nativeCreate(null) : {};
  }
  function hashDelete(key) {
    return this.has(key) && delete this.__data__[key];
  }
  function hashGet(key) {
    var data = this.__data__;
    if (nativeCreate) {
      var result = data[key];
      return result === HASH_UNDEFINED ? void 0 : result;
    }
    return hasOwnProperty.call(data, key) ? data[key] : void 0;
  }
  function hashHas(key) {
    var data = this.__data__;
    return nativeCreate ? data[key] !== void 0 : hasOwnProperty.call(data, key);
  }
  function hashSet(key, value) {
    var data = this.__data__;
    data[key] = nativeCreate && value === void 0 ? HASH_UNDEFINED : value;
    return this;
  }
  Hash.prototype.clear = hashClear;
  Hash.prototype["delete"] = hashDelete;
  Hash.prototype.get = hashGet;
  Hash.prototype.has = hashHas;
  Hash.prototype.set = hashSet;
  function ListCache(entries) {
    var index = -1, length = entries ? entries.length : 0;
    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }
  function listCacheClear() {
    this.__data__ = [];
  }
  function listCacheDelete(key) {
    var data = this.__data__, index = assocIndexOf(data, key);
    if (index < 0) {
      return false;
    }
    var lastIndex = data.length - 1;
    if (index == lastIndex) {
      data.pop();
    } else {
      splice.call(data, index, 1);
    }
    return true;
  }
  function listCacheGet(key) {
    var data = this.__data__, index = assocIndexOf(data, key);
    return index < 0 ? void 0 : data[index][1];
  }
  function listCacheHas(key) {
    return assocIndexOf(this.__data__, key) > -1;
  }
  function listCacheSet(key, value) {
    var data = this.__data__, index = assocIndexOf(data, key);
    if (index < 0) {
      data.push([key, value]);
    } else {
      data[index][1] = value;
    }
    return this;
  }
  ListCache.prototype.clear = listCacheClear;
  ListCache.prototype["delete"] = listCacheDelete;
  ListCache.prototype.get = listCacheGet;
  ListCache.prototype.has = listCacheHas;
  ListCache.prototype.set = listCacheSet;
  function MapCache(entries) {
    var index = -1, length = entries ? entries.length : 0;
    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }
  function mapCacheClear() {
    this.__data__ = {
      hash: new Hash(),
      map: new (Map2 || ListCache)(),
      string: new Hash()
    };
  }
  function mapCacheDelete(key) {
    return getMapData(this, key)["delete"](key);
  }
  function mapCacheGet(key) {
    return getMapData(this, key).get(key);
  }
  function mapCacheHas(key) {
    return getMapData(this, key).has(key);
  }
  function mapCacheSet(key, value) {
    getMapData(this, key).set(key, value);
    return this;
  }
  MapCache.prototype.clear = mapCacheClear;
  MapCache.prototype["delete"] = mapCacheDelete;
  MapCache.prototype.get = mapCacheGet;
  MapCache.prototype.has = mapCacheHas;
  MapCache.prototype.set = mapCacheSet;
  function SetCache(values) {
    var index = -1, length = values ? values.length : 0;
    this.__data__ = new MapCache();
    while (++index < length) {
      this.add(values[index]);
    }
  }
  function setCacheAdd(value) {
    this.__data__.set(value, HASH_UNDEFINED);
    return this;
  }
  function setCacheHas(value) {
    return this.__data__.has(value);
  }
  SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
  SetCache.prototype.has = setCacheHas;
  function Stack(entries) {
    this.__data__ = new ListCache(entries);
  }
  function stackClear() {
    this.__data__ = new ListCache();
  }
  function stackDelete(key) {
    return this.__data__["delete"](key);
  }
  function stackGet(key) {
    return this.__data__.get(key);
  }
  function stackHas(key) {
    return this.__data__.has(key);
  }
  function stackSet(key, value) {
    var cache = this.__data__;
    if (cache instanceof ListCache) {
      var pairs = cache.__data__;
      if (!Map2 || pairs.length < LARGE_ARRAY_SIZE - 1) {
        pairs.push([key, value]);
        return this;
      }
      cache = this.__data__ = new MapCache(pairs);
    }
    cache.set(key, value);
    return this;
  }
  Stack.prototype.clear = stackClear;
  Stack.prototype["delete"] = stackDelete;
  Stack.prototype.get = stackGet;
  Stack.prototype.has = stackHas;
  Stack.prototype.set = stackSet;
  function arrayLikeKeys(value, inherited) {
    var result = isArray(value) || isArguments(value) ? baseTimes(value.length, String) : [];
    var length = result.length, skipIndexes = !!length;
    for (var key in value) {
      if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && (key == "length" || isIndex(key, length)))) {
        result.push(key);
      }
    }
    return result;
  }
  function assocIndexOf(array, key) {
    var length = array.length;
    while (length--) {
      if (eq(array[length][0], key)) {
        return length;
      }
    }
    return -1;
  }
  function baseGet(object, path) {
    path = isKey(path, object) ? [path] : castPath(path);
    var index = 0, length = path.length;
    while (object != null && index < length) {
      object = object[toKey(path[index++])];
    }
    return index && index == length ? object : void 0;
  }
  function baseGetTag(value) {
    return objectToString.call(value);
  }
  function baseHasIn(object, key) {
    return object != null && key in Object(object);
  }
  function baseIsEqual(value, other, customizer, bitmask, stack) {
    if (value === other) {
      return true;
    }
    if (value == null || other == null || !isObject(value) && !isObjectLike(other)) {
      return value !== value && other !== other;
    }
    return baseIsEqualDeep(value, other, baseIsEqual, customizer, bitmask, stack);
  }
  function baseIsEqualDeep(object, other, equalFunc, customizer, bitmask, stack) {
    var objIsArr = isArray(object), othIsArr = isArray(other), objTag = arrayTag, othTag = arrayTag;
    if (!objIsArr) {
      objTag = getTag(object);
      objTag = objTag == argsTag ? objectTag : objTag;
    }
    if (!othIsArr) {
      othTag = getTag(other);
      othTag = othTag == argsTag ? objectTag : othTag;
    }
    var objIsObj = objTag == objectTag && !isHostObject(object), othIsObj = othTag == objectTag && !isHostObject(other), isSameTag = objTag == othTag;
    if (isSameTag && !objIsObj) {
      stack || (stack = new Stack());
      return objIsArr || isTypedArray(object) ? equalArrays(object, other, equalFunc, customizer, bitmask, stack) : equalByTag(object, other, objTag, equalFunc, customizer, bitmask, stack);
    }
    if (!(bitmask & PARTIAL_COMPARE_FLAG)) {
      var objIsWrapped = objIsObj && hasOwnProperty.call(object, "__wrapped__"), othIsWrapped = othIsObj && hasOwnProperty.call(other, "__wrapped__");
      if (objIsWrapped || othIsWrapped) {
        var objUnwrapped = objIsWrapped ? object.value() : object, othUnwrapped = othIsWrapped ? other.value() : other;
        stack || (stack = new Stack());
        return equalFunc(objUnwrapped, othUnwrapped, customizer, bitmask, stack);
      }
    }
    if (!isSameTag) {
      return false;
    }
    stack || (stack = new Stack());
    return equalObjects(object, other, equalFunc, customizer, bitmask, stack);
  }
  function baseIsMatch(object, source, matchData, customizer) {
    var index = matchData.length, length = index, noCustomizer = !customizer;
    if (object == null) {
      return !length;
    }
    object = Object(object);
    while (index--) {
      var data = matchData[index];
      if (noCustomizer && data[2] ? data[1] !== object[data[0]] : !(data[0] in object)) {
        return false;
      }
    }
    while (++index < length) {
      data = matchData[index];
      var key = data[0], objValue = object[key], srcValue = data[1];
      if (noCustomizer && data[2]) {
        if (objValue === void 0 && !(key in object)) {
          return false;
        }
      } else {
        var stack = new Stack();
        if (customizer) {
          var result = customizer(objValue, srcValue, key, object, source, stack);
        }
        if (!(result === void 0 ? baseIsEqual(srcValue, objValue, customizer, UNORDERED_COMPARE_FLAG | PARTIAL_COMPARE_FLAG, stack) : result)) {
          return false;
        }
      }
    }
    return true;
  }
  function baseIsNative(value) {
    if (!isObject(value) || isMasked(value)) {
      return false;
    }
    var pattern = isFunction(value) || isHostObject(value) ? reIsNative : reIsHostCtor;
    return pattern.test(toSource(value));
  }
  function baseIsTypedArray(value) {
    return isObjectLike(value) && isLength(value.length) && !!typedArrayTags[objectToString.call(value)];
  }
  function baseIteratee(value) {
    if (typeof value == "function") {
      return value;
    }
    if (value == null) {
      return identity;
    }
    if (typeof value == "object") {
      return isArray(value) ? baseMatchesProperty(value[0], value[1]) : baseMatches(value);
    }
    return property(value);
  }
  function baseKeys(object) {
    if (!isPrototype(object)) {
      return nativeKeys(object);
    }
    var result = [];
    for (var key in Object(object)) {
      if (hasOwnProperty.call(object, key) && key != "constructor") {
        result.push(key);
      }
    }
    return result;
  }
  function baseMatches(source) {
    var matchData = getMatchData(source);
    if (matchData.length == 1 && matchData[0][2]) {
      return matchesStrictComparable(matchData[0][0], matchData[0][1]);
    }
    return function(object) {
      return object === source || baseIsMatch(object, source, matchData);
    };
  }
  function baseMatchesProperty(path, srcValue) {
    if (isKey(path) && isStrictComparable(srcValue)) {
      return matchesStrictComparable(toKey(path), srcValue);
    }
    return function(object) {
      var objValue = get(object, path);
      return objValue === void 0 && objValue === srcValue ? hasIn(object, path) : baseIsEqual(srcValue, objValue, void 0, UNORDERED_COMPARE_FLAG | PARTIAL_COMPARE_FLAG);
    };
  }
  function basePropertyDeep(path) {
    return function(object) {
      return baseGet(object, path);
    };
  }
  function baseToString(value) {
    if (typeof value == "string") {
      return value;
    }
    if (isSymbol(value)) {
      return symbolToString ? symbolToString.call(value) : "";
    }
    var result = value + "";
    return result == "0" && 1 / value == -INFINITY ? "-0" : result;
  }
  function castPath(value) {
    return isArray(value) ? value : stringToPath(value);
  }
  function createFind(findIndexFunc) {
    return function(collection, predicate, fromIndex) {
      var iterable = Object(collection);
      if (!isArrayLike(collection)) {
        var iteratee = baseIteratee(predicate, 3);
        collection = keys(collection);
        predicate = function(key) {
          return iteratee(iterable[key], key, iterable);
        };
      }
      var index = findIndexFunc(collection, predicate, fromIndex);
      return index > -1 ? iterable[iteratee ? collection[index] : index] : void 0;
    };
  }
  function equalArrays(array, other, equalFunc, customizer, bitmask, stack) {
    var isPartial = bitmask & PARTIAL_COMPARE_FLAG, arrLength = array.length, othLength = other.length;
    if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
      return false;
    }
    var stacked = stack.get(array);
    if (stacked && stack.get(other)) {
      return stacked == other;
    }
    var index = -1, result = true, seen = bitmask & UNORDERED_COMPARE_FLAG ? new SetCache() : void 0;
    stack.set(array, other);
    stack.set(other, array);
    while (++index < arrLength) {
      var arrValue = array[index], othValue = other[index];
      if (customizer) {
        var compared = isPartial ? customizer(othValue, arrValue, index, other, array, stack) : customizer(arrValue, othValue, index, array, other, stack);
      }
      if (compared !== void 0) {
        if (compared) {
          continue;
        }
        result = false;
        break;
      }
      if (seen) {
        if (!arraySome(other, function(othValue2, othIndex) {
          if (!seen.has(othIndex) && (arrValue === othValue2 || equalFunc(arrValue, othValue2, customizer, bitmask, stack))) {
            return seen.add(othIndex);
          }
        })) {
          result = false;
          break;
        }
      } else if (!(arrValue === othValue || equalFunc(arrValue, othValue, customizer, bitmask, stack))) {
        result = false;
        break;
      }
    }
    stack["delete"](array);
    stack["delete"](other);
    return result;
  }
  function equalByTag(object, other, tag, equalFunc, customizer, bitmask, stack) {
    switch (tag) {
      case dataViewTag:
        if (object.byteLength != other.byteLength || object.byteOffset != other.byteOffset) {
          return false;
        }
        object = object.buffer;
        other = other.buffer;
      case arrayBufferTag:
        if (object.byteLength != other.byteLength || !equalFunc(new Uint8Array2(object), new Uint8Array2(other))) {
          return false;
        }
        return true;
      case boolTag:
      case dateTag:
      case numberTag:
        return eq(+object, +other);
      case errorTag:
        return object.name == other.name && object.message == other.message;
      case regexpTag:
      case stringTag:
        return object == other + "";
      case mapTag:
        var convert = mapToArray;
      case setTag:
        var isPartial = bitmask & PARTIAL_COMPARE_FLAG;
        convert || (convert = setToArray);
        if (object.size != other.size && !isPartial) {
          return false;
        }
        var stacked = stack.get(object);
        if (stacked) {
          return stacked == other;
        }
        bitmask |= UNORDERED_COMPARE_FLAG;
        stack.set(object, other);
        var result = equalArrays(convert(object), convert(other), equalFunc, customizer, bitmask, stack);
        stack["delete"](object);
        return result;
      case symbolTag:
        if (symbolValueOf) {
          return symbolValueOf.call(object) == symbolValueOf.call(other);
        }
    }
    return false;
  }
  function equalObjects(object, other, equalFunc, customizer, bitmask, stack) {
    var isPartial = bitmask & PARTIAL_COMPARE_FLAG, objProps = keys(object), objLength = objProps.length, othProps = keys(other), othLength = othProps.length;
    if (objLength != othLength && !isPartial) {
      return false;
    }
    var index = objLength;
    while (index--) {
      var key = objProps[index];
      if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
        return false;
      }
    }
    var stacked = stack.get(object);
    if (stacked && stack.get(other)) {
      return stacked == other;
    }
    var result = true;
    stack.set(object, other);
    stack.set(other, object);
    var skipCtor = isPartial;
    while (++index < objLength) {
      key = objProps[index];
      var objValue = object[key], othValue = other[key];
      if (customizer) {
        var compared = isPartial ? customizer(othValue, objValue, key, other, object, stack) : customizer(objValue, othValue, key, object, other, stack);
      }
      if (!(compared === void 0 ? objValue === othValue || equalFunc(objValue, othValue, customizer, bitmask, stack) : compared)) {
        result = false;
        break;
      }
      skipCtor || (skipCtor = key == "constructor");
    }
    if (result && !skipCtor) {
      var objCtor = object.constructor, othCtor = other.constructor;
      if (objCtor != othCtor && ("constructor" in object && "constructor" in other) && !(typeof objCtor == "function" && objCtor instanceof objCtor && typeof othCtor == "function" && othCtor instanceof othCtor)) {
        result = false;
      }
    }
    stack["delete"](object);
    stack["delete"](other);
    return result;
  }
  function getMapData(map, key) {
    var data = map.__data__;
    return isKeyable(key) ? data[typeof key == "string" ? "string" : "hash"] : data.map;
  }
  function getMatchData(object) {
    var result = keys(object), length = result.length;
    while (length--) {
      var key = result[length], value = object[key];
      result[length] = [key, value, isStrictComparable(value)];
    }
    return result;
  }
  function getNative(object, key) {
    var value = getValue(object, key);
    return baseIsNative(value) ? value : void 0;
  }
  var getTag = baseGetTag;
  if (DataView2 && getTag(new DataView2(new ArrayBuffer(1))) != dataViewTag || Map2 && getTag(new Map2()) != mapTag || Promise2 && getTag(Promise2.resolve()) != promiseTag || Set2 && getTag(new Set2()) != setTag || WeakMap2 && getTag(new WeakMap2()) != weakMapTag) {
    getTag = function(value) {
      var result = objectToString.call(value), Ctor = result == objectTag ? value.constructor : void 0, ctorString = Ctor ? toSource(Ctor) : void 0;
      if (ctorString) {
        switch (ctorString) {
          case dataViewCtorString:
            return dataViewTag;
          case mapCtorString:
            return mapTag;
          case promiseCtorString:
            return promiseTag;
          case setCtorString:
            return setTag;
          case weakMapCtorString:
            return weakMapTag;
        }
      }
      return result;
    };
  }
  function hasPath(object, path, hasFunc) {
    path = isKey(path, object) ? [path] : castPath(path);
    var result, index = -1, length = path.length;
    while (++index < length) {
      var key = toKey(path[index]);
      if (!(result = object != null && hasFunc(object, key))) {
        break;
      }
      object = object[key];
    }
    if (result) {
      return result;
    }
    var length = object ? object.length : 0;
    return !!length && isLength(length) && isIndex(key, length) && (isArray(object) || isArguments(object));
  }
  function isIndex(value, length) {
    length = length == null ? MAX_SAFE_INTEGER : length;
    return !!length && (typeof value == "number" || reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
  }
  function isKey(value, object) {
    if (isArray(value)) {
      return false;
    }
    var type = typeof value;
    if (type == "number" || type == "symbol" || type == "boolean" || value == null || isSymbol(value)) {
      return true;
    }
    return reIsPlainProp.test(value) || !reIsDeepProp.test(value) || object != null && value in Object(object);
  }
  function isKeyable(value) {
    var type = typeof value;
    return type == "string" || type == "number" || type == "symbol" || type == "boolean" ? value !== "__proto__" : value === null;
  }
  function isMasked(func) {
    return !!maskSrcKey && maskSrcKey in func;
  }
  function isPrototype(value) {
    var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
    return value === proto;
  }
  function isStrictComparable(value) {
    return value === value && !isObject(value);
  }
  function matchesStrictComparable(key, srcValue) {
    return function(object) {
      if (object == null) {
        return false;
      }
      return object[key] === srcValue && (srcValue !== void 0 || key in Object(object));
    };
  }
  var stringToPath = memoize(function(string) {
    string = toString(string);
    var result = [];
    if (reLeadingDot.test(string)) {
      result.push("");
    }
    string.replace(rePropName, function(match, number, quote, string2) {
      result.push(quote ? string2.replace(reEscapeChar, "$1") : number || match);
    });
    return result;
  });
  function toKey(value) {
    if (typeof value == "string" || isSymbol(value)) {
      return value;
    }
    var result = value + "";
    return result == "0" && 1 / value == -INFINITY ? "-0" : result;
  }
  function toSource(func) {
    if (func != null) {
      try {
        return funcToString.call(func);
      } catch (e) {
      }
      try {
        return func + "";
      } catch (e) {
      }
    }
    return "";
  }
  function findIndex(array, predicate, fromIndex) {
    var length = array ? array.length : 0;
    if (!length) {
      return -1;
    }
    var index = fromIndex == null ? 0 : toInteger(fromIndex);
    if (index < 0) {
      index = nativeMax(length + index, 0);
    }
    return baseFindIndex(array, baseIteratee(predicate, 3), index);
  }
  var find = createFind(findIndex);
  function memoize(func, resolver) {
    if (typeof func != "function" || resolver && typeof resolver != "function") {
      throw new TypeError(FUNC_ERROR_TEXT);
    }
    var memoized = function() {
      var args = arguments, key = resolver ? resolver.apply(this, args) : args[0], cache = memoized.cache;
      if (cache.has(key)) {
        return cache.get(key);
      }
      var result = func.apply(this, args);
      memoized.cache = cache.set(key, result);
      return result;
    };
    memoized.cache = new (memoize.Cache || MapCache)();
    return memoized;
  }
  memoize.Cache = MapCache;
  function eq(value, other) {
    return value === other || value !== value && other !== other;
  }
  function isArguments(value) {
    return isArrayLikeObject(value) && hasOwnProperty.call(value, "callee") && (!propertyIsEnumerable.call(value, "callee") || objectToString.call(value) == argsTag);
  }
  var isArray = Array.isArray;
  function isArrayLike(value) {
    return value != null && isLength(value.length) && !isFunction(value);
  }
  function isArrayLikeObject(value) {
    return isObjectLike(value) && isArrayLike(value);
  }
  function isFunction(value) {
    var tag = isObject(value) ? objectToString.call(value) : "";
    return tag == funcTag || tag == genTag;
  }
  function isLength(value) {
    return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
  }
  function isObject(value) {
    var type = typeof value;
    return !!value && (type == "object" || type == "function");
  }
  function isObjectLike(value) {
    return !!value && typeof value == "object";
  }
  function isSymbol(value) {
    return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
  }
  var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;
  function toFinite(value) {
    if (!value) {
      return value === 0 ? value : 0;
    }
    value = toNumber(value);
    if (value === INFINITY || value === -INFINITY) {
      var sign = value < 0 ? -1 : 1;
      return sign * MAX_INTEGER;
    }
    return value === value ? value : 0;
  }
  function toInteger(value) {
    var result = toFinite(value), remainder = result % 1;
    return result === result ? remainder ? result - remainder : result : 0;
  }
  function toNumber(value) {
    if (typeof value == "number") {
      return value;
    }
    if (isSymbol(value)) {
      return NAN;
    }
    if (isObject(value)) {
      var other = typeof value.valueOf == "function" ? value.valueOf() : value;
      value = isObject(other) ? other + "" : other;
    }
    if (typeof value != "string") {
      return value === 0 ? value : +value;
    }
    value = value.replace(reTrim, "");
    var isBinary = reIsBinary.test(value);
    return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
  }
  function toString(value) {
    return value == null ? "" : baseToString(value);
  }
  function get(object, path, defaultValue) {
    var result = object == null ? void 0 : baseGet(object, path);
    return result === void 0 ? defaultValue : result;
  }
  function hasIn(object, path) {
    return object != null && hasPath(object, path, baseHasIn);
  }
  function keys(object) {
    return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
  }
  function identity(value) {
    return value;
  }
  function property(path) {
    return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
  }
  module2.exports = find;
});

// node_modules/lodash.max/index.js
var require_lodash6 = __commonJS((exports2, module2) => {
  var symbolTag = "[object Symbol]";
  var objectProto = Object.prototype;
  var objectToString = objectProto.toString;
  function baseExtremum(array, iteratee, comparator) {
    var index = -1, length = array.length;
    while (++index < length) {
      var value = array[index], current = iteratee(value);
      if (current != null && (computed === void 0 ? current === current && !isSymbol(current) : comparator(current, computed))) {
        var computed = current, result = value;
      }
    }
    return result;
  }
  function baseGt(value, other) {
    return value > other;
  }
  function isObjectLike(value) {
    return !!value && typeof value == "object";
  }
  function isSymbol(value) {
    return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
  }
  function identity(value) {
    return value;
  }
  function max(array) {
    return array && array.length ? baseExtremum(array, identity, baseGt) : void 0;
  }
  module2.exports = max;
});

// node_modules/ip-address/lib/v6/constants.js
var require_constants16 = __commonJS((exports2) => {
  exports2.BITS = 128;
  exports2.GROUPS = 8;
  exports2.SCOPES = {
    0: "Reserved",
    1: "Interface local",
    2: "Link local",
    4: "Admin local",
    5: "Site local",
    8: "Organization local",
    14: "Global",
    15: "Reserved"
  };
  exports2.TYPES = {
    "ff01::1/128": "Multicast (All nodes on this interface)",
    "ff01::2/128": "Multicast (All routers on this interface)",
    "ff02::1/128": "Multicast (All nodes on this link)",
    "ff02::2/128": "Multicast (All routers on this link)",
    "ff05::2/128": "Multicast (All routers in this site)",
    "ff02::5/128": "Multicast (OSPFv3 AllSPF routers)",
    "ff02::6/128": "Multicast (OSPFv3 AllDR routers)",
    "ff02::9/128": "Multicast (RIP routers)",
    "ff02::a/128": "Multicast (EIGRP routers)",
    "ff02::d/128": "Multicast (PIM routers)",
    "ff02::16/128": "Multicast (MLDv2 reports)",
    "ff01::fb/128": "Multicast (mDNSv6)",
    "ff02::fb/128": "Multicast (mDNSv6)",
    "ff05::fb/128": "Multicast (mDNSv6)",
    "ff02::1:2/128": "Multicast (All DHCP servers and relay agents on this link)",
    "ff05::1:2/128": "Multicast (All DHCP servers and relay agents in this site)",
    "ff02::1:3/128": "Multicast (All DHCP servers on this link)",
    "ff05::1:3/128": "Multicast (All DHCP servers in this site)",
    "::/128": "Unspecified",
    "::1/128": "Loopback",
    "ff00::/8": "Multicast",
    "fe80::/10": "Link-local unicast"
  };
  exports2.RE_BAD_CHARACTERS = /([^0-9a-f:\/%])/ig;
  exports2.RE_BAD_ADDRESS = /([0-9a-f]{5,}|:{3,}|[^:]:$|^:[^:]|\/$)/ig;
  exports2.RE_SUBNET_STRING = /\/\d{1,3}(?=%|$)/;
  exports2.RE_ZONE_STRING = /%.*$/;
  exports2.RE_URL = new RegExp(/^\[{0,1}([0-9a-f:]+)\]{0,1}/);
  exports2.RE_URL_WITH_PORT = new RegExp(/\[([0-9a-f:]+)\]:([0-9]{1,5})/);
});

// node_modules/ip-address/lib/v6/attributes.js
var require_attributes = __commonJS((exports2) => {
  "use strict";
  var common = require_common5();
  var v6 = require_constants16();
  exports2.isValid = function() {
    return this.valid;
  };
  exports2.isInSubnet = common.isInSubnet;
  exports2.isCorrect = common.isCorrect(v6.BITS);
  exports2.isCanonical = common.falseIfInvalid(function() {
    return this.addressMinusSuffix === this.canonicalForm();
  });
  exports2.isLinkLocal = common.falseIfInvalid(function() {
    if (this.getBitsBase2(0, 64) === "1111111010000000000000000000000000000000000000000000000000000000") {
      return true;
    }
    return false;
  });
  exports2.isMulticast = common.falseIfInvalid(function() {
    return this.getType() === "Multicast";
  });
  exports2.is4 = common.falseIfInvalid(function() {
    return this.v4;
  });
  exports2.isTeredo = common.falseIfInvalid(function() {
    return this.isInSubnet(new this.constructor("2001::/32"));
  });
  exports2.is6to4 = common.falseIfInvalid(function() {
    return this.isInSubnet(new this.constructor("2002::/16"));
  });
  exports2.isLoopback = common.falseIfInvalid(function() {
    return this.getType() === "Loopback";
  });
});

// node_modules/ip-address/lib/v6/helpers.js
var require_helpers = __commonJS((exports2) => {
  "use strict";
  var sprintf = require_sprintf().sprintf;
  var spanAllZeroes = exports2.spanAllZeroes = function(s) {
    return s.replace(/(0+)/g, '<span class="zero">$1</span>');
  };
  exports2.spanAll = function(s, optionalOffset) {
    if (optionalOffset === void 0) {
      optionalOffset = 0;
    }
    var letters = s.split("");
    return letters.map(function(n, i) {
      return sprintf('<span class="digit value-%s position-%d">%s</span>', n, i + optionalOffset, spanAllZeroes(n));
    }).join("");
  };
  function spanLeadingZeroesSimple(group) {
    return group.replace(/^(0+)/, '<span class="zero">$1</span>');
  }
  exports2.spanLeadingZeroes = function(address) {
    var groups = address.split(":");
    return groups.map(function(g) {
      return spanLeadingZeroesSimple(g);
    }).join(":");
  };
  exports2.simpleGroup = function(addressString, offset) {
    var groups = addressString.split(":");
    if (!offset) {
      offset = 0;
    }
    return groups.map(function(g, i) {
      if (/group-v4/.test(g)) {
        return g;
      }
      return sprintf('<span class="hover-group group-%d">%s</span>', i + offset, spanLeadingZeroesSimple(g));
    }).join(":");
  };
});

// node_modules/ip-address/lib/v6/html.js
var require_html = __commonJS((exports2) => {
  "use strict";
  var constants4 = require_constants15();
  var helpers = require_helpers();
  var sprintf = require_sprintf().sprintf;
  exports2.href = function(optionalPort) {
    if (optionalPort === void 0) {
      optionalPort = "";
    } else {
      optionalPort = sprintf(":%s", optionalPort);
    }
    return sprintf("http://[%s]%s/", this.correctForm(), optionalPort);
  };
  exports2.link = function(options) {
    if (!options) {
      options = {};
    }
    if (options.className === void 0) {
      options.className = "";
    }
    if (options.prefix === void 0) {
      options.prefix = "/#address=";
    }
    if (options.v4 === void 0) {
      options.v4 = false;
    }
    var formFunction = this.correctForm;
    if (options.v4) {
      formFunction = this.to4in6;
    }
    if (options.className) {
      return sprintf('<a href="%1$s%2$s" class="%3$s">%2$s</a>', options.prefix, formFunction.call(this), options.className);
    }
    return sprintf('<a href="%1$s%2$s">%2$s</a>', options.prefix, formFunction.call(this));
  };
  exports2.group = function() {
    var address4 = this.address.match(constants4.RE_ADDRESS);
    var i;
    if (address4) {
      var segments = address4[0].split(".");
      this.address = this.address.replace(constants4.RE_ADDRESS, sprintf('<span class="hover-group group-v4 group-6">%s</span>.<span class="hover-group group-v4 group-7">%s</span>', segments.slice(0, 2).join("."), segments.slice(2, 4).join(".")));
    }
    if (this.elidedGroups === 0) {
      return helpers.simpleGroup(this.address);
    }
    var output = [];
    var halves = this.address.split("::");
    if (halves[0].length) {
      output.push(helpers.simpleGroup(halves[0]));
    } else {
      output.push("");
    }
    var classes = ["hover-group"];
    for (i = this.elisionBegin; i < this.elisionBegin + this.elidedGroups; i++) {
      classes.push(sprintf("group-%d", i));
    }
    output.push(sprintf('<span class="%s"></span>', classes.join(" ")));
    if (halves[1].length) {
      output.push(helpers.simpleGroup(halves[1], this.elisionEnd));
    } else {
      output.push("");
    }
    return output.join(":");
  };
});

// node_modules/ip-address/lib/v6/regular-expressions.js
var require_regular_expressions = __commonJS((exports2) => {
  "use strict";
  var sprintf = require_sprintf().sprintf;
  var v6 = require_constants16();
  function groupPossibilities(possibilities) {
    return sprintf("(%s)", possibilities.join("|"));
  }
  function padGroup(group) {
    if (group.length < 4) {
      return sprintf("0{0,%d}%s", 4 - group.length, group);
    }
    return group;
  }
  var ADDRESS_BOUNDARY = "[^A-Fa-f0-9:]";
  function simpleRegularExpression(groups) {
    var zeroIndexes = [];
    groups.forEach(function(group, i) {
      var groupInteger = parseInt(group, 16);
      if (groupInteger === 0) {
        zeroIndexes.push(i);
      }
    });
    var possibilities = zeroIndexes.map(function(zeroIndex) {
      return groups.map(function(group, i) {
        if (i === zeroIndex) {
          var elision = i === 0 || i === v6.GROUPS - 1 ? ":" : "";
          return groupPossibilities([padGroup(group), elision]);
        }
        return padGroup(group);
      }).join(":");
    });
    possibilities.push(groups.map(padGroup).join(":"));
    return groupPossibilities(possibilities);
  }
  function possibleElisions(elidedGroups, moreLeft, moreRight) {
    var left = moreLeft ? "" : ":";
    var right = moreRight ? "" : ":";
    var possibilities = [];
    if (!moreLeft && !moreRight) {
      possibilities.push("::");
    }
    if (moreLeft && moreRight) {
      possibilities.push("");
    }
    if (moreRight && !moreLeft || !moreRight && moreLeft) {
      possibilities.push(":");
    }
    possibilities.push(sprintf("%s(:0{1,4}){1,%d}", left, elidedGroups - 1));
    possibilities.push(sprintf("(0{1,4}:){1,%d}%s", elidedGroups - 1, right));
    possibilities.push(sprintf("(0{1,4}:){%d}0{1,4}", elidedGroups - 1));
    for (var groups = 1; groups < elidedGroups - 1; groups++) {
      for (var position = 1; position < elidedGroups - groups; position++) {
        possibilities.push(sprintf("(0{1,4}:){%d}:(0{1,4}:){%d}0{1,4}", position, elidedGroups - position - groups - 1));
      }
    }
    return groupPossibilities(possibilities);
  }
  exports2.regularExpressionString = function(optionalSubString) {
    if (optionalSubString === void 0) {
      optionalSubString = false;
    }
    var output = [];
    var address6 = new this.constructor(this.correctForm());
    if (address6.elidedGroups === 0) {
      output.push(simpleRegularExpression(address6.parsedAddress));
    } else if (address6.elidedGroups === v6.GROUPS) {
      output.push(possibleElisions(v6.GROUPS));
    } else {
      var halves = address6.address.split("::");
      if (halves[0].length) {
        output.push(simpleRegularExpression(halves[0].split(":")));
      }
      output.push(possibleElisions(address6.elidedGroups, halves[0].length !== 0, halves[1].length !== 0));
      if (halves[1].length) {
        output.push(simpleRegularExpression(halves[1].split(":")));
      }
      output = [output.join(":")];
    }
    if (!optionalSubString) {
      output = [].concat("(?=^|", ADDRESS_BOUNDARY, "|[^\\w\\:])(", output, ")(?=[^\\w\\:]|", ADDRESS_BOUNDARY, "|$)");
    }
    return output.join("");
  };
  exports2.regularExpression = function(optionalSubstring) {
    return new RegExp(this.regularExpressionString(optionalSubstring), "i");
  };
});

// node_modules/ip-address/lib/ipv6.js
var require_ipv6 = __commonJS((exports2, module2) => {
  "use strict";
  var BigInteger = require_jsbn2().BigInteger;
  var sprintf = require_sprintf().sprintf;
  var merge = require_lodash4();
  var padStart = require_lodash2();
  var repeat = require_lodash3();
  var find = require_lodash5();
  var max = require_lodash6();
  var constants4 = require_constants15();
  var constants6 = require_constants16();
  var Address4 = require_ipv4();
  function addCommas(number) {
    var r = /(\d+)(\d{3})/;
    while (r.test(number)) {
      number = number.replace(r, "$1,$2");
    }
    return number;
  }
  function spanLeadingZeroes4(n) {
    n = n.replace(/^(0{1,})([1-9]+)$/, '<span class="parse-error">$1</span>$2');
    n = n.replace(/^(0{1,})(0)$/, '<span class="parse-error">$1</span>$2');
    return n;
  }
  function Address6(address, optionalGroups) {
    if (optionalGroups === void 0) {
      this.groups = constants6.GROUPS;
    } else {
      this.groups = optionalGroups;
    }
    this.v4 = false;
    this.subnet = "/128";
    this.subnetMask = 128;
    this.zone = "";
    this.address = address;
    var subnet = constants6.RE_SUBNET_STRING.exec(address);
    if (subnet) {
      this.parsedSubnet = subnet[0].replace("/", "");
      this.subnetMask = parseInt(this.parsedSubnet, 10);
      this.subnet = "/" + this.subnetMask;
      if (isNaN(this.subnetMask) || this.subnetMask < 0 || this.subnetMask > constants6.BITS) {
        this.valid = false;
        this.error = "Invalid subnet mask.";
        return;
      }
      address = address.replace(constants6.RE_SUBNET_STRING, "");
    } else if (/\//.test(address)) {
      this.valid = false;
      this.error = "Invalid subnet mask.";
      return;
    }
    var zone = constants6.RE_ZONE_STRING.exec(address);
    if (zone) {
      this.zone = zone[0];
      address = address.replace(constants6.RE_ZONE_STRING, "");
    }
    this.addressMinusSuffix = address;
    this.parsedAddress = this.parse(this.addressMinusSuffix);
  }
  merge(Address6.prototype, require_attributes());
  merge(Address6.prototype, require_html());
  merge(Address6.prototype, require_regular_expressions());
  Address6.fromBigInteger = function(bigInteger) {
    var hex = padStart(bigInteger.toString(16), 32, "0");
    var groups = [];
    var i;
    for (i = 0; i < constants6.GROUPS; i++) {
      groups.push(hex.slice(i * 4, (i + 1) * 4));
    }
    return new Address6(groups.join(":"));
  };
  Address6.fromURL = function(url) {
    var host;
    var port;
    var result;
    if (url.indexOf("[") !== -1 && url.indexOf("]:") !== -1) {
      result = constants6.RE_URL_WITH_PORT.exec(url);
      if (result === null) {
        return {
          error: "failed to parse address with port",
          address: null,
          port: null
        };
      }
      host = result[1];
      port = result[2];
    } else if (url.indexOf("/") !== -1) {
      url = url.replace(/^[a-z0-9]+:\/\//, "");
      result = constants6.RE_URL.exec(url);
      if (result === null) {
        return {
          error: "failed to parse address from URL",
          address: null,
          port: null
        };
      }
      host = result[1];
    } else {
      host = url;
    }
    if (port) {
      port = parseInt(port, 10);
      if (port < 0 || port > 65536) {
        port = null;
      }
    } else {
      port = null;
    }
    return {
      address: new Address6(host),
      port
    };
  };
  Address6.fromAddress4 = function(address4) {
    var address4 = new Address4(address4);
    var mask6 = constants6.BITS - (constants4.BITS - address4.subnetMask);
    return new Address6("::ffff:" + address4.correctForm() + "/" + mask6);
  };
  Address6.fromArpa = function(arpaFormAddress) {
    var address = arpaFormAddress.replace(/(\.ip6\.arpa)?\.$/, "");
    var semicolonAmount = 7;
    if (address.length !== 63) {
      address = {
        error: "Not Valid 'ip6.arpa' form",
        address: null
      };
      return address;
    }
    address = address.split(".").reverse();
    for (var i = semicolonAmount; i > 0; i--) {
      var insertIndex = i * 4;
      address.splice(insertIndex, 0, ":");
    }
    address = address.join("");
    return new Address6(address);
  };
  function compact(address, slice) {
    var s1 = [];
    var s2 = [];
    var i;
    for (i = 0; i < address.length; i++) {
      if (i < slice[0]) {
        s1.push(address[i]);
      } else if (i > slice[1]) {
        s2.push(address[i]);
      }
    }
    return s1.concat(["compact"]).concat(s2);
  }
  Address6.prototype.microsoftTranscription = function() {
    return sprintf("%s.ipv6-literal.net", this.correctForm().replace(/:/g, "-"));
  };
  Address6.prototype.mask = function(optionalMask) {
    if (optionalMask === void 0) {
      optionalMask = this.subnetMask;
    }
    return this.getBitsBase2(0, optionalMask);
  };
  Address6.prototype.possibleSubnets = function(optionalSubnetSize) {
    if (optionalSubnetSize === void 0) {
      optionalSubnetSize = 128;
    }
    var availableBits = constants6.BITS - this.subnetMask;
    var subnetBits = Math.abs(optionalSubnetSize - constants6.BITS);
    var subnetPowers = availableBits - subnetBits;
    if (subnetPowers < 0) {
      return "0";
    }
    return addCommas(new BigInteger("2", 10).pow(subnetPowers).toString(10));
  };
  Address6.prototype._startAddress = function() {
    return new BigInteger(this.mask() + repeat("0", constants6.BITS - this.subnetMask), 2);
  };
  Address6.prototype.startAddress = function() {
    return Address6.fromBigInteger(this._startAddress());
  };
  Address6.prototype.startAddressExclusive = function() {
    var adjust = new BigInteger("1");
    return Address6.fromBigInteger(this._startAddress().add(adjust));
  };
  Address6.prototype._endAddress = function() {
    return new BigInteger(this.mask() + repeat("1", constants6.BITS - this.subnetMask), 2);
  };
  Address6.prototype.endAddress = function() {
    return Address6.fromBigInteger(this._endAddress());
  };
  Address6.prototype.endAddressExclusive = function() {
    var adjust = new BigInteger("1");
    return Address6.fromBigInteger(this._endAddress().subtract(adjust));
  };
  Address6.prototype.getScope = function() {
    var scope = constants6.SCOPES[this.getBits(12, 16)];
    if (this.getType() === "Global unicast" && scope !== "Link local") {
      scope = "Global";
    }
    return scope;
  };
  Address6.prototype.getType = function() {
    var self2 = this;
    function isType(name, type) {
      return self2.isInSubnet(new Address6(type));
    }
    return find(constants6.TYPES, isType) || "Global unicast";
  };
  Address6.prototype.getBits = function(start, end) {
    return new BigInteger(this.getBitsBase2(start, end), 2);
  };
  Address6.prototype.getBitsBase2 = function(start, end) {
    return this.binaryZeroPad().slice(start, end);
  };
  Address6.prototype.getBitsBase16 = function(start, end) {
    var length = end - start;
    if (length % 4 !== 0) {
      return null;
    }
    return padStart(this.getBits(start, end).toString(16), length / 4, "0");
  };
  Address6.prototype.getBitsPastSubnet = function() {
    return this.getBitsBase2(this.subnetMask, constants6.BITS);
  };
  Address6.prototype.reverseForm = function(options) {
    if (!options) {
      options = {};
    }
    var characters = Math.floor(this.subnetMask / 4);
    var reversed = this.canonicalForm().replace(/:/g, "").split("").slice(0, characters).reverse().join(".");
    if (characters > 0) {
      if (options.omitSuffix) {
        return reversed;
      }
      return sprintf("%s.ip6.arpa.", reversed);
    }
    if (options.omitSuffix) {
      return "";
    }
    return "ip6.arpa.";
  };
  Address6.prototype.correctForm = function() {
    if (!this.parsedAddress) {
      return null;
    }
    var i;
    var groups = [];
    var zeroCounter = 0;
    var zeroes = [];
    for (i = 0; i < this.parsedAddress.length; i++) {
      var value = parseInt(this.parsedAddress[i], 16);
      if (value === 0) {
        zeroCounter++;
      }
      if (value !== 0 && zeroCounter > 0) {
        if (zeroCounter > 1) {
          zeroes.push([i - zeroCounter, i - 1]);
        }
        zeroCounter = 0;
      }
    }
    if (zeroCounter > 1) {
      zeroes.push([
        this.parsedAddress.length - zeroCounter,
        this.parsedAddress.length - 1
      ]);
    }
    var zeroLengths = zeroes.map(function(n) {
      return n[1] - n[0] + 1;
    });
    if (zeroes.length > 0) {
      var index = zeroLengths.indexOf(max(zeroLengths));
      groups = compact(this.parsedAddress, zeroes[index]);
    } else {
      groups = this.parsedAddress;
    }
    for (i = 0; i < groups.length; i++) {
      if (groups[i] !== "compact") {
        groups[i] = parseInt(groups[i], 16).toString(16);
      }
    }
    var correct = groups.join(":");
    correct = correct.replace(/^compact$/, "::");
    correct = correct.replace(/^compact|compact$/, ":");
    correct = correct.replace(/compact/, "");
    return correct;
  };
  Address6.prototype.binaryZeroPad = function() {
    return padStart(this.bigInteger().toString(2), constants6.BITS, "0");
  };
  Address6.prototype.parse4in6 = function(address) {
    var groups = address.split(":");
    var lastGroup = groups.slice(-1)[0];
    var address4 = lastGroup.match(constants4.RE_ADDRESS);
    if (address4) {
      var temp4 = new Address4(address4[0]);
      for (var i = 0; i < temp4.groups; i++) {
        if (/^0[0-9]+/.test(temp4.parsedAddress[i])) {
          this.valid = false;
          this.error = "IPv4 addresses can not have leading zeroes.";
          this.parseError = address.replace(constants4.RE_ADDRESS, temp4.parsedAddress.map(spanLeadingZeroes4).join("."));
          return null;
        }
      }
      this.v4 = true;
      groups[groups.length - 1] = temp4.toGroup6();
      address = groups.join(":");
    }
    return address;
  };
  Address6.prototype.parse = function(address) {
    address = this.parse4in6(address);
    if (this.error) {
      return null;
    }
    var badCharacters = address.match(constants6.RE_BAD_CHARACTERS);
    if (badCharacters) {
      this.valid = false;
      this.error = sprintf("Bad character%s detected in address: %s", badCharacters.length > 1 ? "s" : "", badCharacters.join(""));
      this.parseError = address.replace(constants6.RE_BAD_CHARACTERS, '<span class="parse-error">$1</span>');
      return null;
    }
    var badAddress = address.match(constants6.RE_BAD_ADDRESS);
    if (badAddress) {
      this.valid = false;
      this.error = sprintf("Address failed regex: %s", badAddress.join(""));
      this.parseError = address.replace(constants6.RE_BAD_ADDRESS, '<span class="parse-error">$1</span>');
      return null;
    }
    var groups = [];
    var halves = address.split("::");
    if (halves.length === 2) {
      var first = halves[0].split(":");
      var last = halves[1].split(":");
      if (first.length === 1 && first[0] === "") {
        first = [];
      }
      if (last.length === 1 && last[0] === "") {
        last = [];
      }
      var remaining = this.groups - (first.length + last.length);
      if (!remaining) {
        this.valid = false;
        this.error = "Error parsing groups";
        return null;
      }
      this.elidedGroups = remaining;
      this.elisionBegin = first.length;
      this.elisionEnd = first.length + this.elidedGroups;
      first.forEach(function(group) {
        groups.push(group);
      });
      for (var i = 0; i < remaining; i++) {
        groups.push(0);
      }
      last.forEach(function(group) {
        groups.push(group);
      });
    } else if (halves.length === 1) {
      groups = address.split(":");
      this.elidedGroups = 0;
    } else {
      this.valid = false;
      this.error = "Too many :: groups found";
      return null;
    }
    groups = groups.map(function(g) {
      return sprintf("%x", parseInt(g, 16));
    });
    if (groups.length !== this.groups) {
      this.valid = false;
      this.error = "Incorrect number of groups found";
      return null;
    }
    this.valid = true;
    return groups;
  };
  function paddedHex(octet) {
    return sprintf("%04x", parseInt(octet, 16));
  }
  Address6.prototype.canonicalForm = function() {
    if (!this.valid) {
      return null;
    }
    return this.parsedAddress.map(paddedHex).join(":");
  };
  Address6.prototype.decimal = function() {
    if (!this.valid) {
      return null;
    }
    return this.parsedAddress.map(function(n) {
      return sprintf("%05d", parseInt(n, 16));
    }).join(":");
  };
  Address6.prototype.bigInteger = function() {
    if (!this.valid) {
      return null;
    }
    return new BigInteger(this.parsedAddress.map(paddedHex).join(""), 16);
  };
  Address6.prototype.to4 = function() {
    var binary = this.binaryZeroPad().split("");
    return Address4.fromHex(new BigInteger(binary.slice(96, 128).join(""), 2).toString(16));
  };
  Address6.prototype.to4in6 = function() {
    var address4 = this.to4();
    var address6 = new Address6(this.parsedAddress.slice(0, 6).join(":"), 6);
    var correct = address6.correctForm();
    var infix = "";
    if (!/:$/.test(correct)) {
      infix = ":";
    }
    return address6.correctForm() + infix + address4.address;
  };
  Address6.prototype.inspectTeredo = function() {
    var prefix = this.getBitsBase16(0, 32);
    var udpPort = this.getBits(80, 96).xor(new BigInteger("ffff", 16)).toString();
    var server4 = Address4.fromHex(this.getBitsBase16(32, 64));
    var client4 = Address4.fromHex(this.getBits(96, 128).xor(new BigInteger("ffffffff", 16)).toString(16));
    var flags = this.getBits(64, 80);
    var flagsBase2 = this.getBitsBase2(64, 80);
    var coneNat = flags.testBit(15);
    var reserved = flags.testBit(14);
    var groupIndividual = flags.testBit(8);
    var universalLocal = flags.testBit(9);
    var nonce = new BigInteger(flagsBase2.slice(2, 6) + flagsBase2.slice(8, 16), 2).toString(10);
    return {
      prefix: sprintf("%s:%s", prefix.slice(0, 4), prefix.slice(4, 8)),
      server4: server4.address,
      client4: client4.address,
      flags: flagsBase2,
      coneNat,
      microsoft: {
        reserved,
        universalLocal,
        groupIndividual,
        nonce
      },
      udpPort
    };
  };
  Address6.prototype.inspect6to4 = function() {
    var prefix = this.getBitsBase16(0, 16);
    var gateway = Address4.fromHex(this.getBitsBase16(16, 48));
    return {
      prefix: sprintf("%s", prefix.slice(0, 4)),
      gateway: gateway.address
    };
  };
  Address6.prototype.to6to4 = function() {
    if (!this.is4()) {
      return null;
    }
    var addr6to4 = [
      "2002",
      this.getBitsBase16(96, 112),
      this.getBitsBase16(112, 128),
      "",
      "/16"
    ].join(":");
    return new Address6(addr6to4);
  };
  Address6.prototype.toByteArray = function() {
    var byteArray = this.bigInteger().toByteArray();
    if (byteArray.length === 17 && byteArray[0] === 0) {
      return byteArray.slice(1);
    }
    return byteArray;
  };
  function unsignByte(b) {
    return b & 255;
  }
  Address6.prototype.toUnsignedByteArray = function() {
    return this.toByteArray().map(unsignByte);
  };
  Address6.fromByteArray = function(bytes) {
    return this.fromUnsignedByteArray(bytes.map(unsignByte));
  };
  Address6.fromUnsignedByteArray = function(bytes) {
    var BYTE_MAX = new BigInteger("256", 10);
    var result = new BigInteger("0", 10);
    var multiplier = new BigInteger("1", 10);
    for (var i = bytes.length - 1; i >= 0; i--) {
      result = result.add(multiplier.multiply(new BigInteger(bytes[i].toString(10), 10)));
      multiplier = multiplier.multiply(BYTE_MAX);
    }
    return Address6.fromBigInteger(result);
  };
  module2.exports = Address6;
});

// node_modules/ip-address/ip-address.js
var require_ip_address = __commonJS((exports2) => {
  "use strict";
  exports2.Address4 = require_ipv4();
  exports2.Address6 = require_ipv6();
  exports2.v6 = {
    helpers: require_helpers()
  };
});

// node_modules/libp2p-utils/src/ip-port-to-multiaddr.js
var require_ip_port_to_multiaddr = __commonJS((exports2, module2) => {
  "use strict";
  var multiaddr = require_src11();
  var errCode = require_err_code();
  var {Address4, Address6} = require_ip_address();
  var errors = {
    ERR_INVALID_IP_PARAMETER: "ERR_INVALID_IP_PARAMETER",
    ERR_INVALID_PORT_PARAMETER: "ERR_INVALID_PORT_PARAMETER",
    ERR_INVALID_IP: "ERR_INVALID_IP"
  };
  function ipPortToMultiaddr(ip, port) {
    if (typeof ip !== "string") {
      throw errCode(new Error(`invalid ip provided: ${ip}`), errors.ERR_INVALID_IP_PARAMETER);
    }
    port = parseInt(port);
    if (isNaN(port)) {
      throw errCode(new Error(`invalid port provided: ${port}`), errors.ERR_INVALID_PORT_PARAMETER);
    }
    if (new Address4(ip).isValid()) {
      return multiaddr(`/ip4/${ip}/tcp/${port}`);
    }
    const ip6 = new Address6(ip);
    if (ip6.isValid()) {
      return ip6.is4() ? multiaddr(`/ip4/${ip6.to4().correctForm()}/tcp/${port}`) : multiaddr(`/ip6/${ip}/tcp/${port}`);
    }
    throw errCode(new Error(`invalid ip:port for creating a multiaddr: ${ip}:${port}`), errors.ERR_INVALID_IP);
  }
  module2.exports = ipPortToMultiaddr;
  module2.exports.Errors = errors;
});

// node_modules/libp2p-websockets/src/socket-to-conn.js
var require_socket_to_conn = __commonJS((exports2, module2) => {
  "use strict";
  var abortable = require_abortable_iterator();
  var {CLOSE_TIMEOUT} = require_constants14();
  var toMultiaddr = require_ip_port_to_multiaddr();
  var pTimeout = require_p_timeout();
  var debug = require_browser4();
  var log = debug("libp2p:websockets:socket");
  log.error = debug("libp2p:websockets:socket:error");
  module2.exports = (stream, options = {}) => {
    const maConn = {
      async sink(source) {
        if (options.signal) {
          source = abortable(source, options.signal);
        }
        try {
          await stream.sink(async function* () {
            for await (const chunk of source) {
              yield chunk instanceof Uint8Array ? chunk : chunk.slice();
            }
          }());
        } catch (err) {
          if (err.type !== "aborted") {
            log.error(err);
          }
        }
      },
      source: options.signal ? abortable(stream.source, options.signal) : stream.source,
      conn: stream,
      localAddr: options.localAddr || (stream.localAddress && stream.localPort ? toMultiaddr(stream.localAddress, stream.localPort) : void 0),
      remoteAddr: options.remoteAddr || toMultiaddr(stream.remoteAddress, stream.remotePort),
      timeline: {open: Date.now()},
      async close() {
        const start = Date.now();
        try {
          await pTimeout(stream.close(), CLOSE_TIMEOUT);
        } catch (err) {
          const {host, port} = maConn.remoteAddr.toOptions();
          log("timeout closing stream to %s:%s after %dms, destroying it manually", host, port, Date.now() - start);
          stream.destroy();
        } finally {
          maConn.timeline.close = Date.now();
        }
      }
    };
    stream.socket.once && stream.socket.once("close", () => {
      if (!maConn.timeline.close) {
        maConn.timeline.close = Date.now();
      }
    });
    return maConn;
  };
});

// node_modules/libp2p-websockets/src/filters.js
var require_filters = __commonJS((exports2, module2) => {
  "use strict";
  var mafmt = require_src12();
  var {
    CODE_CIRCUIT,
    CODE_P2P,
    CODE_TCP,
    CODE_WS,
    CODE_WSS
  } = require_constants14();
  module2.exports = {
    all: (multiaddrs) => multiaddrs.filter((ma) => {
      if (ma.protoCodes().includes(CODE_CIRCUIT)) {
        return false;
      }
      const testMa = ma.decapsulateCode(CODE_P2P);
      return mafmt.WebSockets.matches(testMa) || mafmt.WebSocketsSecure.matches(testMa);
    }),
    dnsWss: (multiaddrs) => multiaddrs.filter((ma) => {
      if (ma.protoCodes().includes(CODE_CIRCUIT)) {
        return false;
      }
      const testMa = ma.decapsulateCode(CODE_P2P);
      return mafmt.WebSocketsSecure.matches(testMa) && mafmt.DNS.matches(testMa.decapsulateCode(CODE_TCP).decapsulateCode(CODE_WSS));
    }),
    dnsWsOrWss: (multiaddrs) => multiaddrs.filter((ma) => {
      if (ma.protoCodes().includes(CODE_CIRCUIT)) {
        return false;
      }
      const testMa = ma.decapsulateCode(CODE_P2P);
      if (mafmt.WebSockets.matches(testMa)) {
        return mafmt.DNS.matches(testMa.decapsulateCode(CODE_TCP).decapsulateCode(CODE_WS));
      }
      return mafmt.WebSocketsSecure.matches(testMa) && mafmt.DNS.matches(testMa.decapsulateCode(CODE_TCP).decapsulateCode(CODE_WSS));
    })
  };
});

// node_modules/libp2p-websockets/src/index.js
var require_src45 = __commonJS((exports2, module2) => {
  "use strict";
  var connect = require_client();
  var withIs = require_class_is();
  var toUri = require_multiaddr_to_uri();
  var {AbortError} = require_abortable_iterator();
  var log = require_browser4()("libp2p:websockets");
  var env = require_env2();
  var createListener = require_listener_browser();
  var toConnection = require_socket_to_conn();
  var filters = require_filters();
  var WebSockets = class {
    constructor({upgrader, filter}) {
      if (!upgrader) {
        throw new Error("An upgrader must be provided. See https://github.com/libp2p/interface-transport#upgrader.");
      }
      this._upgrader = upgrader;
      this._filter = filter;
    }
    async dial(ma, options = {}) {
      log("dialing %s", ma);
      const socket = await this._connect(ma, options);
      const maConn = toConnection(socket, {remoteAddr: ma, signal: options.signal});
      log("new outbound connection %s", maConn.remoteAddr);
      const conn = await this._upgrader.upgradeOutbound(maConn);
      log("outbound connection %s upgraded", maConn.remoteAddr);
      return conn;
    }
    async _connect(ma, options = {}) {
      if (options.signal && options.signal.aborted) {
        throw new AbortError();
      }
      const cOpts = ma.toOptions();
      log("dialing %s:%s", cOpts.host, cOpts.port);
      const rawSocket = connect(toUri(ma), Object.assign({binary: true}, options));
      if (!options.signal) {
        await rawSocket.connected();
        log("connected %s", ma);
        return rawSocket;
      }
      let onAbort;
      const abort = new Promise((resolve, reject) => {
        onAbort = () => {
          reject(new AbortError());
          rawSocket.close();
        };
        if (options.signal.aborted)
          return onAbort();
        options.signal.addEventListener("abort", onAbort);
      });
      try {
        await Promise.race([abort, rawSocket.connected()]);
      } finally {
        options.signal.removeEventListener("abort", onAbort);
      }
      log("connected %s", ma);
      return rawSocket;
    }
    createListener(options = {}, handler) {
      if (typeof options === "function") {
        handler = options;
        options = {};
      }
      return createListener({handler, upgrader: this._upgrader}, options);
    }
    filter(multiaddrs) {
      multiaddrs = Array.isArray(multiaddrs) ? multiaddrs : [multiaddrs];
      if (this._filter) {
        return this._filter(multiaddrs);
      }
      if (env.isBrowser || env.isWebWorker) {
        return filters.dnsWss(multiaddrs);
      }
      return filters.all(multiaddrs);
    }
  };
  module2.exports = withIs(WebSockets, {
    className: "WebSockets",
    symbolName: "@libp2p/js-libp2p-websockets/websockets"
  });
});

// node_modules/get-browser-rtc/index.js
var require_get_browser_rtc = __commonJS((exports2, module2) => {
  module2.exports = function getBrowserRTC() {
    if (typeof globalThis === "undefined")
      return null;
    var wrtc = {
      RTCPeerConnection: globalThis.RTCPeerConnection || globalThis.mozRTCPeerConnection || globalThis.webkitRTCPeerConnection,
      RTCSessionDescription: globalThis.RTCSessionDescription || globalThis.mozRTCSessionDescription || globalThis.webkitRTCSessionDescription,
      RTCIceCandidate: globalThis.RTCIceCandidate || globalThis.mozRTCIceCandidate || globalThis.webkitRTCIceCandidate
    };
    if (!wrtc.RTCPeerConnection)
      return null;
    return wrtc;
  };
});

// node_modules/randombytes/browser.js
var require_browser11 = __commonJS((exports2, module2) => {
  "use strict";
  var MAX_BYTES = 65536;
  var MAX_UINT32 = 4294967295;
  function oldBrowser() {
    throw new Error("Secure random number generation is not supported by this browser.\nUse Chrome, Firefox or Internet Explorer 11");
  }
  var Buffer2 = require_safe_buffer().Buffer;
  var crypto2 = global.crypto || global.msCrypto;
  if (crypto2 && crypto2.getRandomValues) {
    module2.exports = randomBytes;
  } else {
    module2.exports = oldBrowser;
  }
  function randomBytes(size, cb) {
    if (size > MAX_UINT32)
      throw new RangeError("requested too many random bytes");
    var bytes = Buffer2.allocUnsafe(size);
    if (size > 0) {
      if (size > MAX_BYTES) {
        for (var generated = 0; generated < size; generated += MAX_BYTES) {
          crypto2.getRandomValues(bytes.slice(generated, generated + MAX_BYTES));
        }
      } else {
        crypto2.getRandomValues(bytes);
      }
    }
    if (typeof cb === "function") {
      return process.nextTick(function() {
        cb(null, bytes);
      });
    }
    return bytes;
  }
});

// node_modules/queue-microtask/index.js
var require_queue_microtask = __commonJS((exports2, module2) => {
  /*! queue-microtask. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
  var promise;
  module2.exports = typeof queueMicrotask === "function" ? queueMicrotask.bind(globalThis) : (cb) => (promise || (promise = Promise.resolve())).then(cb).catch((err) => setTimeout(() => {
    throw err;
  }, 0));
});

// node_modules/libp2p-webrtc-peer/index.js
var require_libp2p_webrtc_peer = __commonJS((exports2, module2) => {
  /*! simple-peer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
  var debug = require_browser4()("simple-peer");
  var getBrowserRTC = require_get_browser_rtc();
  var randombytes = require_browser11();
  var stream = require_readable_browser();
  var queueMicrotask2 = require_queue_microtask();
  var errCode = require_err_code();
  var MAX_BUFFERED_AMOUNT = 64 * 1024;
  var ICECOMPLETE_TIMEOUT = 5 * 1e3;
  var CHANNEL_CLOSING_TIMEOUT = 5 * 1e3;
  function filterTrickle(sdp) {
    return sdp.replace(/a=ice-options:trickle\s\n/g, "");
  }
  function warn(message) {
    console.warn(message);
  }
  var Peer = class extends stream.Duplex {
    constructor(opts) {
      opts = Object.assign({
        allowHalfOpen: false
      }, opts);
      super(opts);
      this._id = randombytes(4).toString("hex").slice(0, 7);
      this._debug("new peer %o", opts);
      this.channelName = opts.initiator ? opts.channelName || randombytes(20).toString("hex") : null;
      this.initiator = opts.initiator || false;
      this.channelConfig = opts.channelConfig || Peer.channelConfig;
      this.negotiated = this.channelConfig.negotiated;
      this.config = Object.assign({}, Peer.config, opts.config);
      this.offerOptions = opts.offerOptions || {};
      this.answerOptions = opts.answerOptions || {};
      this.sdpTransform = opts.sdpTransform || ((sdp) => sdp);
      this.streams = opts.streams || (opts.stream ? [opts.stream] : []);
      this.trickle = opts.trickle !== void 0 ? opts.trickle : true;
      this.allowHalfTrickle = opts.allowHalfTrickle !== void 0 ? opts.allowHalfTrickle : false;
      this.iceCompleteTimeout = opts.iceCompleteTimeout || ICECOMPLETE_TIMEOUT;
      this._connected = false;
      this.remoteAddress = void 0;
      this.remoteFamily = void 0;
      this.remotePort = void 0;
      this.localAddress = void 0;
      this.localFamily = void 0;
      this.localPort = void 0;
      this._wrtc = opts.wrtc && typeof opts.wrtc === "object" ? opts.wrtc : getBrowserRTC();
      if (!this._wrtc) {
        if (typeof window === "undefined") {
          throw errCode(new Error("No WebRTC support: Specify `opts.wrtc` option in this environment"), "ERR_WEBRTC_SUPPORT");
        } else {
          throw errCode(new Error("No WebRTC support: Not a supported browser"), "ERR_WEBRTC_SUPPORT");
        }
      }
      this._pcReady = false;
      this._channelReady = false;
      this._iceComplete = false;
      this._iceCompleteTimer = null;
      this._channel = null;
      this._pendingCandidates = [];
      this._isNegotiating = this.negotiated ? false : !this.initiator;
      this._batchedNegotiation = false;
      this._queuedNegotiation = false;
      this._sendersAwaitingStable = [];
      this._senderMap = new Map();
      this._firstStable = true;
      this._closingInterval = null;
      this._remoteTracks = [];
      this._remoteStreams = [];
      this._chunk = null;
      this._cb = null;
      this._interval = null;
      try {
        this._pc = new this._wrtc.RTCPeerConnection(this.config);
      } catch (err) {
        queueMicrotask2(() => this.destroy(errCode(err, "ERR_PC_CONSTRUCTOR")));
        return;
      }
      this._isReactNativeWebrtc = typeof this._pc._peerConnectionId === "number";
      this._pc.oniceconnectionstatechange = () => {
        this._onIceStateChange();
      };
      this._pc.onicegatheringstatechange = () => {
        this._onIceStateChange();
      };
      this._pc.onconnectionstatechange = () => {
        this._onConnectionStateChange();
      };
      this._pc.onsignalingstatechange = () => {
        this._onSignalingStateChange();
      };
      this._pc.onicecandidate = (event) => {
        this._onIceCandidate(event);
      };
      if (this.initiator || this.negotiated) {
        this._setupData({
          channel: this._pc.createDataChannel(this.channelName, this.channelConfig)
        });
      } else {
        this._pc.ondatachannel = (event) => {
          this._setupData(event);
        };
      }
      if (this.streams) {
        this.streams.forEach((stream2) => {
          this.addStream(stream2);
        });
      }
      this._pc.ontrack = (event) => {
        this._onTrack(event);
      };
      if (this.initiator) {
        this._needsNegotiation();
      }
      this._onFinishBound = () => {
        this._onFinish();
      };
      this.once("finish", this._onFinishBound);
    }
    get bufferSize() {
      return this._channel && this._channel.bufferedAmount || 0;
    }
    get connected() {
      return this._connected && this._channel.readyState === "open";
    }
    address() {
      return {port: this.localPort, family: this.localFamily, address: this.localAddress};
    }
    signal(data) {
      if (this.destroyed)
        throw errCode(new Error("cannot signal after peer is destroyed"), "ERR_SIGNALING");
      if (typeof data === "string") {
        try {
          data = JSON.parse(data);
        } catch (err) {
          data = {};
        }
      }
      this._debug("signal()");
      if (data.renegotiate && this.initiator) {
        this._debug("got request to renegotiate");
        this._needsNegotiation();
      }
      if (data.transceiverRequest && this.initiator) {
        this._debug("got request for transceiver");
        this.addTransceiver(data.transceiverRequest.kind, data.transceiverRequest.init);
      }
      if (data.candidate) {
        if (this._pc.remoteDescription && this._pc.remoteDescription.type) {
          this._addIceCandidate(data.candidate);
        } else {
          this._pendingCandidates.push(data.candidate);
        }
      }
      if (data.sdp) {
        this._pc.setRemoteDescription(new this._wrtc.RTCSessionDescription(data)).then(() => {
          if (this.destroyed)
            return;
          this._pendingCandidates.forEach((candidate) => {
            this._addIceCandidate(candidate);
          });
          this._pendingCandidates = [];
          if (this._pc.remoteDescription.type === "offer")
            this._createAnswer();
        }).catch((err) => {
          this.destroy(errCode(err, "ERR_SET_REMOTE_DESCRIPTION"));
        });
      }
      if (!data.sdp && !data.candidate && !data.renegotiate && !data.transceiverRequest) {
        this.destroy(errCode(new Error("signal() called with invalid signal data"), "ERR_SIGNALING"));
      }
    }
    _addIceCandidate(candidate) {
      var iceCandidateObj = new this._wrtc.RTCIceCandidate(candidate);
      this._pc.addIceCandidate(iceCandidateObj).catch((err) => {
        if (!iceCandidateObj.address || iceCandidateObj.address.endsWith(".local")) {
          warn("Ignoring unsupported ICE candidate.");
        } else {
          this.destroy(errCode(err, "ERR_ADD_ICE_CANDIDATE"));
        }
      });
    }
    send(chunk) {
      this._channel.send(chunk);
    }
    addTransceiver(kind, init) {
      this._debug("addTransceiver()");
      if (this.initiator) {
        try {
          this._pc.addTransceiver(kind, init);
          this._needsNegotiation();
        } catch (err) {
          this.destroy(errCode(err, "ERR_ADD_TRANSCEIVER"));
        }
      } else {
        this.emit("signal", {
          transceiverRequest: {kind, init}
        });
      }
    }
    addStream(stream2) {
      this._debug("addStream()");
      stream2.getTracks().forEach((track) => {
        this.addTrack(track, stream2);
      });
    }
    addTrack(track, stream2) {
      this._debug("addTrack()");
      var submap = this._senderMap.get(track) || new Map();
      var sender = submap.get(stream2);
      if (!sender) {
        sender = this._pc.addTrack(track, stream2);
        submap.set(stream2, sender);
        this._senderMap.set(track, submap);
        this._needsNegotiation();
      } else if (sender.removed) {
        throw errCode(new Error("Track has been removed. You should enable/disable tracks that you want to re-add."), "ERR_SENDER_REMOVED");
      } else {
        throw errCode(new Error("Track has already been added to that stream."), "ERR_SENDER_ALREADY_ADDED");
      }
    }
    replaceTrack(oldTrack, newTrack, stream2) {
      this._debug("replaceTrack()");
      var submap = this._senderMap.get(oldTrack);
      var sender = submap ? submap.get(stream2) : null;
      if (!sender) {
        throw errCode(new Error("Cannot replace track that was never added."), "ERR_TRACK_NOT_ADDED");
      }
      if (newTrack)
        this._senderMap.set(newTrack, submap);
      if (sender.replaceTrack != null) {
        sender.replaceTrack(newTrack);
      } else {
        this.destroy(errCode(new Error("replaceTrack is not supported in this browser"), "ERR_UNSUPPORTED_REPLACETRACK"));
      }
    }
    removeTrack(track, stream2) {
      this._debug("removeSender()");
      var submap = this._senderMap.get(track);
      var sender = submap ? submap.get(stream2) : null;
      if (!sender) {
        throw errCode(new Error("Cannot remove track that was never added."), "ERR_TRACK_NOT_ADDED");
      }
      try {
        sender.removed = true;
        this._pc.removeTrack(sender);
      } catch (err) {
        if (err.name === "NS_ERROR_UNEXPECTED") {
          this._sendersAwaitingStable.push(sender);
        } else {
          this.destroy(errCode(err, "ERR_REMOVE_TRACK"));
        }
      }
      this._needsNegotiation();
    }
    removeStream(stream2) {
      this._debug("removeSenders()");
      stream2.getTracks().forEach((track) => {
        this.removeTrack(track, stream2);
      });
    }
    _needsNegotiation() {
      this._debug("_needsNegotiation");
      if (this._batchedNegotiation)
        return;
      this._batchedNegotiation = true;
      queueMicrotask2(() => {
        this._batchedNegotiation = false;
        this._debug("starting batched negotiation");
        this.negotiate();
      });
    }
    negotiate() {
      if (this.initiator) {
        if (this._isNegotiating) {
          this._queuedNegotiation = true;
          this._debug("already negotiating, queueing");
        } else {
          this._debug("start negotiation");
          setTimeout(() => {
            this._createOffer();
          }, 0);
        }
      } else {
        if (this._isNegotiating) {
          this._queuedNegotiation = true;
          this._debug("already negotiating, queueing");
        } else {
          this._debug("requesting negotiation from initiator");
          this.emit("signal", {
            renegotiate: true
          });
        }
      }
      this._isNegotiating = true;
    }
    _destroy(err, cb) {
      this._debug("destroy (error: %s)", err && (err.message || err));
      this.readable = this.writable = false;
      if (!this._readableState.ended)
        this.push(null);
      if (!this._writableState.finished)
        this.end();
      this._connected = false;
      this._pcReady = false;
      this._channelReady = false;
      this._remoteTracks = null;
      this._remoteStreams = null;
      this._senderMap = null;
      clearInterval(this._closingInterval);
      this._closingInterval = null;
      clearInterval(this._interval);
      this._interval = null;
      this._chunk = null;
      this._cb = null;
      if (this._onFinishBound)
        this.removeListener("finish", this._onFinishBound);
      this._onFinishBound = null;
      if (this._channel) {
        try {
          this._channel.close();
        } catch (err2) {
        }
        this._channel.onmessage = null;
        this._channel.onopen = null;
        this._channel.onclose = null;
        this._channel.onerror = null;
      }
      if (this._pc) {
        try {
          this._pc.close();
        } catch (err2) {
        }
        this._pc.oniceconnectionstatechange = null;
        this._pc.onicegatheringstatechange = null;
        this._pc.onsignalingstatechange = null;
        this._pc.onicecandidate = null;
        this._pc.ontrack = null;
        this._pc.ondatachannel = null;
      }
      this._pc = null;
      this._channel = null;
      cb(err);
    }
    _setupData(event) {
      if (!event.channel) {
        return this.destroy(errCode(new Error("Data channel event is missing `channel` property"), "ERR_DATA_CHANNEL"));
      }
      this._channel = event.channel;
      this._channel.binaryType = "arraybuffer";
      if (typeof this._channel.bufferedAmountLowThreshold === "number") {
        this._channel.bufferedAmountLowThreshold = MAX_BUFFERED_AMOUNT;
      }
      this.channelName = this._channel.label;
      this._channel.onmessage = (event2) => {
        this._onChannelMessage(event2);
      };
      this._channel.onbufferedamountlow = () => {
        this._onChannelBufferedAmountLow();
      };
      this._channel.onopen = () => {
        this._onChannelOpen();
      };
      this._channel.onclose = () => {
        this._onChannelClose();
      };
      this._channel.onerror = (err) => {
        this.destroy(errCode(err, "ERR_DATA_CHANNEL"));
      };
      var isClosing = false;
      this._closingInterval = setInterval(() => {
        if (this._channel && this._channel.readyState === "closing") {
          if (isClosing)
            this._onChannelClose();
          isClosing = true;
        } else {
          isClosing = false;
        }
      }, CHANNEL_CLOSING_TIMEOUT);
    }
    _read() {
    }
    _write(chunk, encoding, cb) {
      if (this.destroyed)
        return cb(errCode(new Error("cannot write after peer is destroyed"), "ERR_DATA_CHANNEL"));
      if (this._connected) {
        try {
          this.send(chunk);
        } catch (err) {
          return this.destroy(errCode(err, "ERR_DATA_CHANNEL"));
        }
        if (this._channel.bufferedAmount > MAX_BUFFERED_AMOUNT) {
          this._debug("start backpressure: bufferedAmount %d", this._channel.bufferedAmount);
          this._cb = cb;
        } else {
          cb(null);
        }
      } else {
        this._debug("write before connect");
        this._chunk = chunk;
        this._cb = cb;
      }
    }
    _onFinish() {
      if (this.destroyed)
        return;
      const destroySoon = () => {
        setTimeout(() => this.destroy(), 1e3);
      };
      if (this._connected) {
        destroySoon();
      } else {
        this.once("connect", destroySoon);
      }
    }
    _startIceCompleteTimeout() {
      if (this.destroyed)
        return;
      if (this._iceCompleteTimer)
        return;
      this._debug("started iceComplete timeout");
      this._iceCompleteTimer = setTimeout(() => {
        if (!this._iceComplete) {
          this._iceComplete = true;
          this._debug("iceComplete timeout completed");
          this.emit("iceTimeout");
          this.emit("_iceComplete");
        }
      }, this.iceCompleteTimeout);
    }
    _createOffer() {
      if (this.destroyed)
        return;
      this._pc.createOffer(this.offerOptions).then((offer) => {
        if (this.destroyed)
          return;
        if (!this.trickle && !this.allowHalfTrickle)
          offer.sdp = filterTrickle(offer.sdp);
        offer.sdp = this.sdpTransform(offer.sdp);
        const sendOffer = () => {
          if (this.destroyed)
            return;
          var signal = this._pc.localDescription || offer;
          this._debug("signal");
          this.emit("signal", {
            type: signal.type,
            sdp: signal.sdp
          });
        };
        const onSuccess = () => {
          this._debug("createOffer success");
          if (this.destroyed)
            return;
          if (this.trickle || this._iceComplete)
            sendOffer();
          else
            this.once("_iceComplete", sendOffer);
        };
        const onError = (err) => {
          this.destroy(errCode(err, "ERR_SET_LOCAL_DESCRIPTION"));
        };
        this._pc.setLocalDescription(offer).then(onSuccess).catch(onError);
      }).catch((err) => {
        this.destroy(errCode(err, "ERR_CREATE_OFFER"));
      });
    }
    _requestMissingTransceivers() {
      if (this._pc.getTransceivers) {
        this._pc.getTransceivers().forEach((transceiver) => {
          if (!transceiver.mid && transceiver.sender.track && !transceiver.requested) {
            transceiver.requested = true;
            this.addTransceiver(transceiver.sender.track.kind);
          }
        });
      }
    }
    _createAnswer() {
      if (this.destroyed)
        return;
      this._pc.createAnswer(this.answerOptions).then((answer) => {
        if (this.destroyed)
          return;
        if (!this.trickle && !this.allowHalfTrickle)
          answer.sdp = filterTrickle(answer.sdp);
        answer.sdp = this.sdpTransform(answer.sdp);
        const sendAnswer = () => {
          if (this.destroyed)
            return;
          var signal = this._pc.localDescription || answer;
          this._debug("signal");
          this.emit("signal", {
            type: signal.type,
            sdp: signal.sdp
          });
          if (!this.initiator)
            this._requestMissingTransceivers();
        };
        const onSuccess = () => {
          if (this.destroyed)
            return;
          if (this.trickle || this._iceComplete)
            sendAnswer();
          else
            this.once("_iceComplete", sendAnswer);
        };
        const onError = (err) => {
          this.destroy(errCode(err, "ERR_SET_LOCAL_DESCRIPTION"));
        };
        this._pc.setLocalDescription(answer).then(onSuccess).catch(onError);
      }).catch((err) => {
        this.destroy(errCode(err, "ERR_CREATE_ANSWER"));
      });
    }
    _onConnectionStateChange() {
      if (this.destroyed)
        return;
      if (this._pc.connectionState === "failed") {
        this.destroy(errCode(new Error("Connection failed."), "ERR_CONNECTION_FAILURE"));
      }
    }
    _onIceStateChange() {
      if (this.destroyed)
        return;
      var iceConnectionState = this._pc.iceConnectionState;
      var iceGatheringState = this._pc.iceGatheringState;
      this._debug("iceStateChange (connection: %s) (gathering: %s)", iceConnectionState, iceGatheringState);
      this.emit("iceStateChange", iceConnectionState, iceGatheringState);
      if (iceConnectionState === "connected" || iceConnectionState === "completed") {
        this._pcReady = true;
        this._maybeReady();
      }
      if (iceConnectionState === "failed") {
        this.destroy(errCode(new Error("Ice connection failed."), "ERR_ICE_CONNECTION_FAILURE"));
      }
      if (iceConnectionState === "closed") {
        this.destroy(errCode(new Error("Ice connection closed."), "ERR_ICE_CONNECTION_CLOSED"));
      }
    }
    getStats(cb) {
      const flattenValues = (report) => {
        if (Object.prototype.toString.call(report.values) === "[object Array]") {
          report.values.forEach((value) => {
            Object.assign(report, value);
          });
        }
        return report;
      };
      if (this._pc.getStats.length === 0 || this._isReactNativeWebrtc) {
        this._pc.getStats().then((res) => {
          var reports = [];
          res.forEach((report) => {
            reports.push(flattenValues(report));
          });
          cb(null, reports);
        }, (err) => cb(err));
      } else if (this._pc.getStats.length > 0) {
        this._pc.getStats((res) => {
          if (this.destroyed)
            return;
          var reports = [];
          res.result().forEach((result) => {
            var report = {};
            result.names().forEach((name) => {
              report[name] = result.stat(name);
            });
            report.id = result.id;
            report.type = result.type;
            report.timestamp = result.timestamp;
            reports.push(flattenValues(report));
          });
          cb(null, reports);
        }, (err) => cb(err));
      } else {
        cb(null, []);
      }
    }
    _maybeReady() {
      this._debug("maybeReady pc %s channel %s", this._pcReady, this._channelReady);
      if (this._connected || this._connecting || !this._pcReady || !this._channelReady)
        return;
      this._connecting = true;
      const findCandidatePair = () => {
        if (this.destroyed)
          return;
        this.getStats((err, items) => {
          if (this.destroyed)
            return;
          if (err)
            items = [];
          var remoteCandidates = {};
          var localCandidates = {};
          var candidatePairs = {};
          var foundSelectedCandidatePair = false;
          items.forEach((item) => {
            if (item.type === "remotecandidate" || item.type === "remote-candidate") {
              remoteCandidates[item.id] = item;
            }
            if (item.type === "localcandidate" || item.type === "local-candidate") {
              localCandidates[item.id] = item;
            }
            if (item.type === "candidatepair" || item.type === "candidate-pair") {
              candidatePairs[item.id] = item;
            }
          });
          const setSelectedCandidatePair = (selectedCandidatePair) => {
            foundSelectedCandidatePair = true;
            var local = localCandidates[selectedCandidatePair.localCandidateId];
            if (local && (local.ip || local.address)) {
              this.localAddress = local.ip || local.address;
              this.localPort = Number(local.port);
            } else if (local && local.ipAddress) {
              this.localAddress = local.ipAddress;
              this.localPort = Number(local.portNumber);
            } else if (typeof selectedCandidatePair.googLocalAddress === "string") {
              local = selectedCandidatePair.googLocalAddress.split(":");
              this.localAddress = local[0];
              this.localPort = Number(local[1]);
            }
            if (this.localAddress) {
              this.localFamily = this.localAddress.includes(":") ? "IPv6" : "IPv4";
            }
            var remote = remoteCandidates[selectedCandidatePair.remoteCandidateId];
            if (remote && (remote.ip || remote.address)) {
              this.remoteAddress = remote.ip || remote.address;
              this.remotePort = Number(remote.port);
            } else if (remote && remote.ipAddress) {
              this.remoteAddress = remote.ipAddress;
              this.remotePort = Number(remote.portNumber);
            } else if (typeof selectedCandidatePair.googRemoteAddress === "string") {
              remote = selectedCandidatePair.googRemoteAddress.split(":");
              this.remoteAddress = remote[0];
              this.remotePort = Number(remote[1]);
            }
            if (this.remoteAddress) {
              this.remoteFamily = this.remoteAddress.includes(":") ? "IPv6" : "IPv4";
            }
            this._debug("connect local: %s:%s remote: %s:%s", this.localAddress, this.localPort, this.remoteAddress, this.remotePort);
          };
          items.forEach((item) => {
            if (item.type === "transport" && item.selectedCandidatePairId) {
              setSelectedCandidatePair(candidatePairs[item.selectedCandidatePairId]);
            }
            if (item.type === "googCandidatePair" && item.googActiveConnection === "true" || (item.type === "candidatepair" || item.type === "candidate-pair") && item.selected) {
              setSelectedCandidatePair(item);
            }
          });
          if (!foundSelectedCandidatePair && (!Object.keys(candidatePairs).length || Object.keys(localCandidates).length)) {
            setTimeout(findCandidatePair, 100);
            return;
          } else {
            this._connecting = false;
            this._connected = true;
          }
          if (this._chunk) {
            try {
              this.send(this._chunk);
            } catch (err2) {
              return this.destroy(errCode(err2, "ERR_DATA_CHANNEL"));
            }
            this._chunk = null;
            this._debug('sent chunk from "write before connect"');
            var cb = this._cb;
            this._cb = null;
            cb(null);
          }
          if (typeof this._channel.bufferedAmountLowThreshold !== "number") {
            this._interval = setInterval(() => this._onInterval(), 150);
            if (this._interval.unref)
              this._interval.unref();
          }
          this._debug("connect");
          this.emit("connect");
        });
      };
      findCandidatePair();
    }
    _onInterval() {
      if (!this._cb || !this._channel || this._channel.bufferedAmount > MAX_BUFFERED_AMOUNT) {
        return;
      }
      this._onChannelBufferedAmountLow();
    }
    _onSignalingStateChange() {
      if (this.destroyed)
        return;
      if (this._pc.signalingState === "stable" && !this._firstStable) {
        this._isNegotiating = false;
        this._debug("flushing sender queue", this._sendersAwaitingStable);
        this._sendersAwaitingStable.forEach((sender) => {
          this._pc.removeTrack(sender);
          this._queuedNegotiation = true;
        });
        this._sendersAwaitingStable = [];
        if (this._queuedNegotiation) {
          this._debug("flushing negotiation queue");
          this._queuedNegotiation = false;
          this._needsNegotiation();
        }
        this._debug("negotiate");
        this.emit("negotiate");
      }
      this._firstStable = false;
      this._debug("signalingStateChange %s", this._pc.signalingState);
      this.emit("signalingStateChange", this._pc.signalingState);
    }
    _onIceCandidate(event) {
      if (this.destroyed)
        return;
      if (event.candidate && this.trickle) {
        this.emit("signal", {
          candidate: {
            candidate: event.candidate.candidate,
            sdpMLineIndex: event.candidate.sdpMLineIndex,
            sdpMid: event.candidate.sdpMid
          }
        });
      } else if (!event.candidate && !this._iceComplete) {
        this._iceComplete = true;
        this.emit("_iceComplete");
      }
      if (event.candidate) {
        this._startIceCompleteTimeout();
      }
    }
    _onChannelMessage(event) {
      if (this.destroyed)
        return;
      var data = event.data;
      if (data instanceof ArrayBuffer)
        data = new Uint8Array(data);
      this.push(data);
    }
    _onChannelBufferedAmountLow() {
      if (this.destroyed || !this._cb)
        return;
      this._debug("ending backpressure: bufferedAmount %d", this._channel.bufferedAmount);
      var cb = this._cb;
      this._cb = null;
      cb(null);
    }
    _onChannelOpen() {
      if (this._connected || this.destroyed)
        return;
      this._debug("on channel open");
      this._channelReady = true;
      this._maybeReady();
    }
    _onChannelClose() {
      if (this.destroyed)
        return;
      this._debug("on channel close");
      this.destroy();
    }
    _onTrack(event) {
      if (this.destroyed)
        return;
      event.streams.forEach((eventStream) => {
        this._debug("on track");
        this.emit("track", event.track, eventStream);
        this._remoteTracks.push({
          track: event.track,
          stream: eventStream
        });
        if (this._remoteStreams.some((remoteStream) => {
          return remoteStream.id === eventStream.id;
        }))
          return;
        this._remoteStreams.push(eventStream);
        queueMicrotask2(() => {
          this.emit("stream", eventStream);
        });
      });
    }
    _debug() {
      var args = [].slice.call(arguments);
      args[0] = "[" + this._id + "] " + args[0];
      debug.apply(null, args);
    }
  };
  Peer.WEBRTC_SUPPORT = !!getBrowserRTC();
  Peer.config = {
    iceServers: [
      {
        urls: [
          "stun:stun.l.google.com:19302",
          "stun:global.stun.twilio.com:3478"
        ]
      }
    ],
    sdpSemantics: "unified-plan"
  };
  Peer.channelConfig = {};
  module2.exports = Peer;
});

// node_modules/ipfs-utils/src/supports.js
var require_supports = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = {
    supportsFileReader: typeof self !== "undefined" && "FileReader" in self,
    supportsWebRTC: "RTCPeerConnection" in globalThis && (typeof navigator !== "undefined" && typeof navigator.mediaDevices !== "undefined" && "getUserMedia" in navigator.mediaDevices),
    supportsWebRTCDataChannels: "RTCPeerConnection" in globalThis
  };
});

// node_modules/libp2p-webrtc-star/src/constants.js
var require_constants17 = __commonJS((exports2) => {
  "use strict";
  exports2.CODE_P2P = 421;
  exports2.CODE_CIRCUIT = 290;
  exports2.CLOSE_TIMEOUT = 2e3;
});

// node_modules/parseuri/index.js
var require_parseuri = __commonJS((exports2, module2) => {
  var re = /^(?:(?![^:@]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/;
  var parts = [
    "source",
    "protocol",
    "authority",
    "userInfo",
    "user",
    "password",
    "host",
    "port",
    "relative",
    "path",
    "directory",
    "file",
    "query",
    "anchor"
  ];
  module2.exports = function parseuri(str) {
    var src = str, b = str.indexOf("["), e = str.indexOf("]");
    if (b != -1 && e != -1) {
      str = str.substring(0, b) + str.substring(b, e).replace(/:/g, ";") + str.substring(e, str.length);
    }
    var m = re.exec(str || ""), uri = {}, i = 14;
    while (i--) {
      uri[parts[i]] = m[i] || "";
    }
    if (b != -1 && e != -1) {
      uri.source = src;
      uri.host = uri.host.substring(1, uri.host.length - 1).replace(/;/g, ":");
      uri.authority = uri.authority.replace("[", "").replace("]", "").replace(/;/g, ":");
      uri.ipv6uri = true;
    }
    uri.pathNames = pathNames(uri, uri["path"]);
    uri.queryKey = queryKey(uri, uri["query"]);
    return uri;
  };
  function pathNames(obj, path) {
    var regx = /\/{2,9}/g, names = path.replace(regx, "/").split("/");
    if (path.substr(0, 1) == "/" || path.length === 0) {
      names.splice(0, 1);
    }
    if (path.substr(path.length - 1, 1) == "/") {
      names.splice(names.length - 1, 1);
    }
    return names;
  }
  function queryKey(uri, query) {
    var data = {};
    query.replace(/(?:^|&)([^&=]*)=?([^&]*)/g, function($0, $1, $2) {
      if ($1) {
        data[$1] = $2;
      }
    });
    return data;
  }
});

// node_modules/socket.io-client-next/build/url.js
var require_url2 = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.url = void 0;
  var parseuri = require_parseuri();
  var debug = require_browser4()("socket.io-client:url");
  function url(uri, loc) {
    let obj = uri;
    loc = loc || typeof location !== "undefined" && location;
    if (uri == null)
      uri = loc.protocol + "//" + loc.host;
    if (typeof uri === "string") {
      if (uri.charAt(0) === "/") {
        if (uri.charAt(1) === "/") {
          uri = loc.protocol + uri;
        } else {
          uri = loc.host + uri;
        }
      }
      if (!/^(https?|wss?):\/\//.test(uri)) {
        debug("protocol-less url %s", uri);
        if (typeof loc !== "undefined") {
          uri = loc.protocol + "//" + uri;
        } else {
          uri = "https://" + uri;
        }
      }
      debug("parse %s", uri);
      obj = parseuri(uri);
    }
    if (!obj.port) {
      if (/^(http|ws)$/.test(obj.protocol)) {
        obj.port = "80";
      } else if (/^(http|ws)s$/.test(obj.protocol)) {
        obj.port = "443";
      }
    }
    obj.path = obj.path || "/";
    const ipv6 = obj.host.indexOf(":") !== -1;
    const host = ipv6 ? "[" + obj.host + "]" : obj.host;
    obj.id = obj.protocol + "://" + host + ":" + obj.port;
    obj.href = obj.protocol + "://" + host + (loc && loc.port === obj.port ? "" : ":" + obj.port);
    return obj;
  }
  exports2.url = url;
});

// node_modules/has-cors/index.js
var require_has_cors = __commonJS((exports2, module2) => {
  try {
    module2.exports = typeof XMLHttpRequest !== "undefined" && "withCredentials" in new XMLHttpRequest();
  } catch (err) {
    module2.exports = false;
  }
});

// node_modules/engine.io-client/lib/globalThis.browser.js
var require_globalThis_browser = __commonJS((exports2, module2) => {
  module2.exports = (() => {
    if (typeof self !== "undefined") {
      return self;
    } else if (typeof window !== "undefined") {
      return window;
    } else {
      return Function("return this")();
    }
  })();
});

// node_modules/engine.io-client/lib/xmlhttprequest.js
var require_xmlhttprequest = __commonJS((exports2, module2) => {
  var hasCORS = require_has_cors();
  var globalThis2 = require_globalThis_browser();
  module2.exports = function(opts) {
    const xdomain = opts.xdomain;
    const xscheme = opts.xscheme;
    const enablesXDR = opts.enablesXDR;
    try {
      if (typeof XMLHttpRequest !== "undefined" && (!xdomain || hasCORS)) {
        return new XMLHttpRequest();
      }
    } catch (e) {
    }
    try {
      if (typeof XDomainRequest !== "undefined" && !xscheme && enablesXDR) {
        return new XDomainRequest();
      }
    } catch (e) {
    }
    if (!xdomain) {
      try {
        return new globalThis2[["Active"].concat("Object").join("X")]("Microsoft.XMLHTTP");
      } catch (e) {
      }
    }
  };
});

// node_modules/engine.io-client/node_modules/engine.io-parser/lib/commons.js
var require_commons = __commonJS((exports2, module2) => {
  var PACKET_TYPES = Object.create(null);
  PACKET_TYPES["open"] = "0";
  PACKET_TYPES["close"] = "1";
  PACKET_TYPES["ping"] = "2";
  PACKET_TYPES["pong"] = "3";
  PACKET_TYPES["message"] = "4";
  PACKET_TYPES["upgrade"] = "5";
  PACKET_TYPES["noop"] = "6";
  var PACKET_TYPES_REVERSE = Object.create(null);
  Object.keys(PACKET_TYPES).forEach((key) => {
    PACKET_TYPES_REVERSE[PACKET_TYPES[key]] = key;
  });
  var ERROR_PACKET = {type: "error", data: "parser error"};
  module2.exports = {
    PACKET_TYPES,
    PACKET_TYPES_REVERSE,
    ERROR_PACKET
  };
});

// node_modules/engine.io-client/node_modules/engine.io-parser/lib/encodePacket.browser.js
var require_encodePacket_browser = __commonJS((exports2, module2) => {
  var {PACKET_TYPES} = require_commons();
  var withNativeBlob = typeof Blob === "function" || typeof Blob !== "undefined" && Object.prototype.toString.call(Blob) === "[object BlobConstructor]";
  var withNativeArrayBuffer = typeof ArrayBuffer === "function";
  var isView = (obj) => {
    return typeof ArrayBuffer.isView === "function" ? ArrayBuffer.isView(obj) : obj && obj.buffer instanceof ArrayBuffer;
  };
  var encodePacket = ({type, data}, supportsBinary, callback) => {
    if (withNativeBlob && data instanceof Blob) {
      if (supportsBinary) {
        return callback(data);
      } else {
        return encodeBlobAsBase64(data, callback);
      }
    } else if (withNativeArrayBuffer && (data instanceof ArrayBuffer || isView(data))) {
      if (supportsBinary) {
        return callback(data instanceof ArrayBuffer ? data : data.buffer);
      } else {
        return encodeBlobAsBase64(new Blob([data]), callback);
      }
    }
    return callback(PACKET_TYPES[type] + (data || ""));
  };
  var encodeBlobAsBase64 = (data, callback) => {
    const fileReader = new FileReader();
    fileReader.onload = function() {
      const content = fileReader.result.split(",")[1];
      callback("b" + content);
    };
    return fileReader.readAsDataURL(data);
  };
  module2.exports = encodePacket;
});

// node_modules/base64-arraybuffer/lib/base64-arraybuffer.js
var require_base64_arraybuffer = __commonJS((exports2) => {
  (function(chars) {
    "use strict";
    exports2.encode = function(arraybuffer) {
      var bytes = new Uint8Array(arraybuffer), i, len = bytes.length, base64 = "";
      for (i = 0; i < len; i += 3) {
        base64 += chars[bytes[i] >> 2];
        base64 += chars[(bytes[i] & 3) << 4 | bytes[i + 1] >> 4];
        base64 += chars[(bytes[i + 1] & 15) << 2 | bytes[i + 2] >> 6];
        base64 += chars[bytes[i + 2] & 63];
      }
      if (len % 3 === 2) {
        base64 = base64.substring(0, base64.length - 1) + "=";
      } else if (len % 3 === 1) {
        base64 = base64.substring(0, base64.length - 2) + "==";
      }
      return base64;
    };
    exports2.decode = function(base64) {
      var bufferLength = base64.length * 0.75, len = base64.length, i, p = 0, encoded1, encoded2, encoded3, encoded4;
      if (base64[base64.length - 1] === "=") {
        bufferLength--;
        if (base64[base64.length - 2] === "=") {
          bufferLength--;
        }
      }
      var arraybuffer = new ArrayBuffer(bufferLength), bytes = new Uint8Array(arraybuffer);
      for (i = 0; i < len; i += 4) {
        encoded1 = chars.indexOf(base64[i]);
        encoded2 = chars.indexOf(base64[i + 1]);
        encoded3 = chars.indexOf(base64[i + 2]);
        encoded4 = chars.indexOf(base64[i + 3]);
        bytes[p++] = encoded1 << 2 | encoded2 >> 4;
        bytes[p++] = (encoded2 & 15) << 4 | encoded3 >> 2;
        bytes[p++] = (encoded3 & 3) << 6 | encoded4 & 63;
      }
      return arraybuffer;
    };
  })("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/");
});

// node_modules/engine.io-client/node_modules/engine.io-parser/lib/decodePacket.browser.js
var require_decodePacket_browser = __commonJS((exports2, module2) => {
  var {PACKET_TYPES_REVERSE, ERROR_PACKET} = require_commons();
  var withNativeArrayBuffer = typeof ArrayBuffer === "function";
  var base64decoder;
  if (withNativeArrayBuffer) {
    base64decoder = require_base64_arraybuffer();
  }
  var decodePacket = (encodedPacket, binaryType) => {
    if (typeof encodedPacket !== "string") {
      return {
        type: "message",
        data: mapBinary(encodedPacket, binaryType)
      };
    }
    const type = encodedPacket.charAt(0);
    if (type === "b") {
      return {
        type: "message",
        data: decodeBase64Packet(encodedPacket.substring(1), binaryType)
      };
    }
    const packetType = PACKET_TYPES_REVERSE[type];
    if (!packetType) {
      return ERROR_PACKET;
    }
    return encodedPacket.length > 1 ? {
      type: PACKET_TYPES_REVERSE[type],
      data: encodedPacket.substring(1)
    } : {
      type: PACKET_TYPES_REVERSE[type]
    };
  };
  var decodeBase64Packet = (data, binaryType) => {
    if (base64decoder) {
      const decoded = base64decoder.decode(data);
      return mapBinary(decoded, binaryType);
    } else {
      return {base64: true, data};
    }
  };
  var mapBinary = (data, binaryType) => {
    switch (binaryType) {
      case "blob":
        return data instanceof ArrayBuffer ? new Blob([data]) : data;
      case "arraybuffer":
      default:
        return data;
    }
  };
  module2.exports = decodePacket;
});

// node_modules/engine.io-client/node_modules/engine.io-parser/lib/index.js
var require_lib8 = __commonJS((exports2, module2) => {
  var encodePacket = require_encodePacket_browser();
  var decodePacket = require_decodePacket_browser();
  var SEPARATOR = String.fromCharCode(30);
  var encodePayload = (packets, callback) => {
    const length = packets.length;
    const encodedPackets = new Array(length);
    let count = 0;
    packets.forEach((packet, i) => {
      encodePacket(packet, false, (encodedPacket) => {
        encodedPackets[i] = encodedPacket;
        if (++count === length) {
          callback(encodedPackets.join(SEPARATOR));
        }
      });
    });
  };
  var decodePayload = (encodedPayload, binaryType) => {
    const encodedPackets = encodedPayload.split(SEPARATOR);
    const packets = [];
    for (let i = 0; i < encodedPackets.length; i++) {
      const decodedPacket = decodePacket(encodedPackets[i], binaryType);
      packets.push(decodedPacket);
      if (decodedPacket.type === "error") {
        break;
      }
    }
    return packets;
  };
  module2.exports = {
    protocol: 4,
    encodePacket,
    encodePayload,
    decodePacket,
    decodePayload
  };
});

// node_modules/component-emitter/index.js
var require_component_emitter = __commonJS((exports2, module2) => {
  if (typeof module2 !== "undefined") {
    module2.exports = Emitter;
  }
  function Emitter(obj) {
    if (obj)
      return mixin(obj);
  }
  function mixin(obj) {
    for (var key in Emitter.prototype) {
      obj[key] = Emitter.prototype[key];
    }
    return obj;
  }
  Emitter.prototype.on = Emitter.prototype.addEventListener = function(event, fn) {
    this._callbacks = this._callbacks || {};
    (this._callbacks["$" + event] = this._callbacks["$" + event] || []).push(fn);
    return this;
  };
  Emitter.prototype.once = function(event, fn) {
    function on() {
      this.off(event, on);
      fn.apply(this, arguments);
    }
    on.fn = fn;
    this.on(event, on);
    return this;
  };
  Emitter.prototype.off = Emitter.prototype.removeListener = Emitter.prototype.removeAllListeners = Emitter.prototype.removeEventListener = function(event, fn) {
    this._callbacks = this._callbacks || {};
    if (arguments.length == 0) {
      this._callbacks = {};
      return this;
    }
    var callbacks = this._callbacks["$" + event];
    if (!callbacks)
      return this;
    if (arguments.length == 1) {
      delete this._callbacks["$" + event];
      return this;
    }
    var cb;
    for (var i = 0; i < callbacks.length; i++) {
      cb = callbacks[i];
      if (cb === fn || cb.fn === fn) {
        callbacks.splice(i, 1);
        break;
      }
    }
    if (callbacks.length === 0) {
      delete this._callbacks["$" + event];
    }
    return this;
  };
  Emitter.prototype.emit = function(event) {
    this._callbacks = this._callbacks || {};
    var args = new Array(arguments.length - 1), callbacks = this._callbacks["$" + event];
    for (var i = 1; i < arguments.length; i++) {
      args[i - 1] = arguments[i];
    }
    if (callbacks) {
      callbacks = callbacks.slice(0);
      for (var i = 0, len = callbacks.length; i < len; ++i) {
        callbacks[i].apply(this, args);
      }
    }
    return this;
  };
  Emitter.prototype.listeners = function(event) {
    this._callbacks = this._callbacks || {};
    return this._callbacks["$" + event] || [];
  };
  Emitter.prototype.hasListeners = function(event) {
    return !!this.listeners(event).length;
  };
});

// node_modules/engine.io-client/lib/transport.js
var require_transport2 = __commonJS((exports2, module2) => {
  var parser = require_lib8();
  var Emitter = require_component_emitter();
  var Transport = class extends Emitter {
    constructor(opts) {
      super();
      this.opts = opts;
      this.query = opts.query;
      this.readyState = "";
      this.socket = opts.socket;
    }
    onError(msg, desc) {
      const err = new Error(msg);
      err.type = "TransportError";
      err.description = desc;
      this.emit("error", err);
      return this;
    }
    open() {
      if (this.readyState === "closed" || this.readyState === "") {
        this.readyState = "opening";
        this.doOpen();
      }
      return this;
    }
    close() {
      if (this.readyState === "opening" || this.readyState === "open") {
        this.doClose();
        this.onClose();
      }
      return this;
    }
    send(packets) {
      if (this.readyState === "open") {
        this.write(packets);
      } else {
        throw new Error("Transport not open");
      }
    }
    onOpen() {
      this.readyState = "open";
      this.writable = true;
      this.emit("open");
    }
    onData(data) {
      const packet = parser.decodePacket(data, this.socket.binaryType);
      this.onPacket(packet);
    }
    onPacket(packet) {
      this.emit("packet", packet);
    }
    onClose() {
      this.readyState = "closed";
      this.emit("close");
    }
  };
  module2.exports = Transport;
});

// node_modules/parseqs/index.js
var require_parseqs = __commonJS((exports2) => {
  exports2.encode = function(obj) {
    var str = "";
    for (var i in obj) {
      if (obj.hasOwnProperty(i)) {
        if (str.length)
          str += "&";
        str += encodeURIComponent(i) + "=" + encodeURIComponent(obj[i]);
      }
    }
    return str;
  };
  exports2.decode = function(qs) {
    var qry = {};
    var pairs = qs.split("&");
    for (var i = 0, l = pairs.length; i < l; i++) {
      var pair = pairs[i].split("=");
      qry[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1]);
    }
    return qry;
  };
});

// node_modules/yeast/index.js
var require_yeast = __commonJS((exports2, module2) => {
  "use strict";
  var alphabet = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_".split("");
  var length = 64;
  var map = {};
  var seed = 0;
  var i = 0;
  var prev;
  function encode(num) {
    var encoded = "";
    do {
      encoded = alphabet[num % length] + encoded;
      num = Math.floor(num / length);
    } while (num > 0);
    return encoded;
  }
  function decode(str) {
    var decoded = 0;
    for (i = 0; i < str.length; i++) {
      decoded = decoded * length + map[str.charAt(i)];
    }
    return decoded;
  }
  function yeast() {
    var now = encode(+new Date());
    if (now !== prev)
      return seed = 0, prev = now;
    return now + "." + encode(seed++);
  }
  for (; i < length; i++)
    map[alphabet[i]] = i;
  yeast.encode = encode;
  yeast.decode = decode;
  module2.exports = yeast;
});

// node_modules/engine.io-client/lib/transports/polling.js
var require_polling = __commonJS((exports2, module2) => {
  var Transport = require_transport2();
  var parseqs = require_parseqs();
  var parser = require_lib8();
  var yeast = require_yeast();
  var debug = require_browser4()("engine.io-client:polling");
  var Polling = class extends Transport {
    get name() {
      return "polling";
    }
    doOpen() {
      this.poll();
    }
    pause(onPause) {
      const self2 = this;
      this.readyState = "pausing";
      function pause() {
        debug("paused");
        self2.readyState = "paused";
        onPause();
      }
      if (this.polling || !this.writable) {
        let total = 0;
        if (this.polling) {
          debug("we are currently polling - waiting to pause");
          total++;
          this.once("pollComplete", function() {
            debug("pre-pause polling complete");
            --total || pause();
          });
        }
        if (!this.writable) {
          debug("we are currently writing - waiting to pause");
          total++;
          this.once("drain", function() {
            debug("pre-pause writing complete");
            --total || pause();
          });
        }
      } else {
        pause();
      }
    }
    poll() {
      debug("polling");
      this.polling = true;
      this.doPoll();
      this.emit("poll");
    }
    onData(data) {
      const self2 = this;
      debug("polling got data %s", data);
      const callback = function(packet, index, total) {
        if (self2.readyState === "opening" && packet.type === "open") {
          self2.onOpen();
        }
        if (packet.type === "close") {
          self2.onClose();
          return false;
        }
        self2.onPacket(packet);
      };
      parser.decodePayload(data, this.socket.binaryType).forEach(callback);
      if (this.readyState !== "closed") {
        this.polling = false;
        this.emit("pollComplete");
        if (this.readyState === "open") {
          this.poll();
        } else {
          debug('ignoring poll - transport state "%s"', this.readyState);
        }
      }
    }
    doClose() {
      const self2 = this;
      function close() {
        debug("writing close packet");
        self2.write([{type: "close"}]);
      }
      if (this.readyState === "open") {
        debug("transport open - closing");
        close();
      } else {
        debug("transport not open - deferring close");
        this.once("open", close);
      }
    }
    write(packets) {
      this.writable = false;
      parser.encodePayload(packets, (data) => {
        this.doWrite(data, () => {
          this.writable = true;
          this.emit("drain");
        });
      });
    }
    uri() {
      let query = this.query || {};
      const schema = this.opts.secure ? "https" : "http";
      let port = "";
      if (this.opts.timestampRequests !== false) {
        query[this.opts.timestampParam] = yeast();
      }
      if (!this.supportsBinary && !query.sid) {
        query.b64 = 1;
      }
      query = parseqs.encode(query);
      if (this.opts.port && (schema === "https" && Number(this.opts.port) !== 443 || schema === "http" && Number(this.opts.port) !== 80)) {
        port = ":" + this.opts.port;
      }
      if (query.length) {
        query = "?" + query;
      }
      const ipv6 = this.opts.hostname.indexOf(":") !== -1;
      return schema + "://" + (ipv6 ? "[" + this.opts.hostname + "]" : this.opts.hostname) + port + this.opts.path + query;
    }
  };
  module2.exports = Polling;
});

// node_modules/engine.io-client/lib/util.js
var require_util14 = __commonJS((exports2, module2) => {
  module2.exports.pick = (obj, ...attr) => {
    return attr.reduce((acc, k) => {
      if (obj.hasOwnProperty(k)) {
        acc[k] = obj[k];
      }
      return acc;
    }, {});
  };
});

// node_modules/engine.io-client/lib/transports/polling-xhr.js
var require_polling_xhr = __commonJS((exports2, module2) => {
  var XMLHttpRequest2 = require_xmlhttprequest();
  var Polling = require_polling();
  var Emitter = require_component_emitter();
  var {pick} = require_util14();
  var globalThis2 = require_globalThis_browser();
  var debug = require_browser4()("engine.io-client:polling-xhr");
  function empty() {
  }
  var hasXHR2 = function() {
    const xhr = new XMLHttpRequest2({xdomain: false});
    return xhr.responseType != null;
  }();
  var XHR = class extends Polling {
    constructor(opts) {
      super(opts);
      if (typeof location !== "undefined") {
        const isSSL = location.protocol === "https:";
        let port = location.port;
        if (!port) {
          port = isSSL ? 443 : 80;
        }
        this.xd = typeof location !== "undefined" && opts.hostname !== location.hostname || port !== opts.port;
        this.xs = opts.secure !== isSSL;
      }
      const forceBase64 = opts && opts.forceBase64;
      this.supportsBinary = hasXHR2 && !forceBase64;
    }
    request(opts = {}) {
      Object.assign(opts, {xd: this.xd, xs: this.xs}, this.opts);
      return new Request(this.uri(), opts);
    }
    doWrite(data, fn) {
      const req = this.request({
        method: "POST",
        data
      });
      const self2 = this;
      req.on("success", fn);
      req.on("error", function(err) {
        self2.onError("xhr post error", err);
      });
    }
    doPoll() {
      debug("xhr poll");
      const req = this.request();
      const self2 = this;
      req.on("data", function(data) {
        self2.onData(data);
      });
      req.on("error", function(err) {
        self2.onError("xhr poll error", err);
      });
      this.pollXhr = req;
    }
  };
  var Request = class extends Emitter {
    constructor(uri, opts) {
      super();
      this.opts = opts;
      this.method = opts.method || "GET";
      this.uri = uri;
      this.async = opts.async !== false;
      this.data = opts.data !== void 0 ? opts.data : null;
      this.create();
    }
    create() {
      const opts = pick(this.opts, "agent", "enablesXDR", "pfx", "key", "passphrase", "cert", "ca", "ciphers", "rejectUnauthorized");
      opts.xdomain = !!this.opts.xd;
      opts.xscheme = !!this.opts.xs;
      const xhr = this.xhr = new XMLHttpRequest2(opts);
      const self2 = this;
      try {
        debug("xhr open %s: %s", this.method, this.uri);
        xhr.open(this.method, this.uri, this.async);
        try {
          if (this.opts.extraHeaders) {
            xhr.setDisableHeaderCheck && xhr.setDisableHeaderCheck(true);
            for (let i in this.opts.extraHeaders) {
              if (this.opts.extraHeaders.hasOwnProperty(i)) {
                xhr.setRequestHeader(i, this.opts.extraHeaders[i]);
              }
            }
          }
        } catch (e) {
        }
        if (this.method === "POST") {
          try {
            xhr.setRequestHeader("Content-type", "text/plain;charset=UTF-8");
          } catch (e) {
          }
        }
        try {
          xhr.setRequestHeader("Accept", "*/*");
        } catch (e) {
        }
        if ("withCredentials" in xhr) {
          xhr.withCredentials = this.opts.withCredentials;
        }
        if (this.opts.requestTimeout) {
          xhr.timeout = this.opts.requestTimeout;
        }
        if (this.hasXDR()) {
          xhr.onload = function() {
            self2.onLoad();
          };
          xhr.onerror = function() {
            self2.onError(xhr.responseText);
          };
        } else {
          xhr.onreadystatechange = function() {
            if (xhr.readyState !== 4)
              return;
            if (xhr.status === 200 || xhr.status === 1223) {
              self2.onLoad();
            } else {
              setTimeout(function() {
                self2.onError(typeof xhr.status === "number" ? xhr.status : 0);
              }, 0);
            }
          };
        }
        debug("xhr data %s", this.data);
        xhr.send(this.data);
      } catch (e) {
        setTimeout(function() {
          self2.onError(e);
        }, 0);
        return;
      }
      if (typeof document !== "undefined") {
        this.index = Request.requestsCount++;
        Request.requests[this.index] = this;
      }
    }
    onSuccess() {
      this.emit("success");
      this.cleanup();
    }
    onData(data) {
      this.emit("data", data);
      this.onSuccess();
    }
    onError(err) {
      this.emit("error", err);
      this.cleanup(true);
    }
    cleanup(fromError) {
      if (typeof this.xhr === "undefined" || this.xhr === null) {
        return;
      }
      if (this.hasXDR()) {
        this.xhr.onload = this.xhr.onerror = empty;
      } else {
        this.xhr.onreadystatechange = empty;
      }
      if (fromError) {
        try {
          this.xhr.abort();
        } catch (e) {
        }
      }
      if (typeof document !== "undefined") {
        delete Request.requests[this.index];
      }
      this.xhr = null;
    }
    onLoad() {
      const data = this.xhr.responseText;
      if (data !== null) {
        this.onData(data);
      }
    }
    hasXDR() {
      return typeof XDomainRequest !== "undefined" && !this.xs && this.enablesXDR;
    }
    abort() {
      this.cleanup();
    }
  };
  Request.requestsCount = 0;
  Request.requests = {};
  if (typeof document !== "undefined") {
    if (typeof attachEvent === "function") {
      attachEvent("onunload", unloadHandler);
    } else if (typeof addEventListener === "function") {
      const terminationEvent = "onpagehide" in globalThis2 ? "pagehide" : "unload";
      addEventListener(terminationEvent, unloadHandler, false);
    }
  }
  function unloadHandler() {
    for (let i in Request.requests) {
      if (Request.requests.hasOwnProperty(i)) {
        Request.requests[i].abort();
      }
    }
  }
  module2.exports = XHR;
  module2.exports.Request = Request;
});

// node_modules/engine.io-client/lib/transports/polling-jsonp.js
var require_polling_jsonp = __commonJS((exports2, module2) => {
  var Polling = require_polling();
  var globalThis2 = require_globalThis_browser();
  var rNewline = /\n/g;
  var rEscapedNewline = /\\n/g;
  var callbacks;
  function empty() {
  }
  var JSONPPolling = class extends Polling {
    constructor(opts) {
      super(opts);
      this.query = this.query || {};
      if (!callbacks) {
        callbacks = globalThis2.___eio = globalThis2.___eio || [];
      }
      this.index = callbacks.length;
      const self2 = this;
      callbacks.push(function(msg) {
        self2.onData(msg);
      });
      this.query.j = this.index;
      if (typeof addEventListener === "function") {
        addEventListener("beforeunload", function() {
          if (self2.script)
            self2.script.onerror = empty;
        }, false);
      }
    }
    get supportsBinary() {
      return false;
    }
    doClose() {
      if (this.script) {
        this.script.parentNode.removeChild(this.script);
        this.script = null;
      }
      if (this.form) {
        this.form.parentNode.removeChild(this.form);
        this.form = null;
        this.iframe = null;
      }
      super.doClose();
    }
    doPoll() {
      const self2 = this;
      const script = document.createElement("script");
      if (this.script) {
        this.script.parentNode.removeChild(this.script);
        this.script = null;
      }
      script.async = true;
      script.src = this.uri();
      script.onerror = function(e) {
        self2.onError("jsonp poll error", e);
      };
      const insertAt = document.getElementsByTagName("script")[0];
      if (insertAt) {
        insertAt.parentNode.insertBefore(script, insertAt);
      } else {
        (document.head || document.body).appendChild(script);
      }
      this.script = script;
      const isUAgecko = typeof navigator !== "undefined" && /gecko/i.test(navigator.userAgent);
      if (isUAgecko) {
        setTimeout(function() {
          const iframe = document.createElement("iframe");
          document.body.appendChild(iframe);
          document.body.removeChild(iframe);
        }, 100);
      }
    }
    doWrite(data, fn) {
      const self2 = this;
      let iframe;
      if (!this.form) {
        const form = document.createElement("form");
        const area = document.createElement("textarea");
        const id = this.iframeId = "eio_iframe_" + this.index;
        form.className = "socketio";
        form.style.position = "absolute";
        form.style.top = "-1000px";
        form.style.left = "-1000px";
        form.target = id;
        form.method = "POST";
        form.setAttribute("accept-charset", "utf-8");
        area.name = "d";
        form.appendChild(area);
        document.body.appendChild(form);
        this.form = form;
        this.area = area;
      }
      this.form.action = this.uri();
      function complete() {
        initIframe();
        fn();
      }
      function initIframe() {
        if (self2.iframe) {
          try {
            self2.form.removeChild(self2.iframe);
          } catch (e) {
            self2.onError("jsonp polling iframe removal error", e);
          }
        }
        try {
          const html = '<iframe src="javascript:0" name="' + self2.iframeId + '">';
          iframe = document.createElement(html);
        } catch (e) {
          iframe = document.createElement("iframe");
          iframe.name = self2.iframeId;
          iframe.src = "javascript:0";
        }
        iframe.id = self2.iframeId;
        self2.form.appendChild(iframe);
        self2.iframe = iframe;
      }
      initIframe();
      data = data.replace(rEscapedNewline, "\\\n");
      this.area.value = data.replace(rNewline, "\\n");
      try {
        this.form.submit();
      } catch (e) {
      }
      if (this.iframe.attachEvent) {
        this.iframe.onreadystatechange = function() {
          if (self2.iframe.readyState === "complete") {
            complete();
          }
        };
      } else {
        this.iframe.onload = complete;
      }
    }
  };
  module2.exports = JSONPPolling;
});

// node_modules/engine.io-client/lib/transports/websocket-constructor.browser.js
var require_websocket_constructor_browser = __commonJS((exports2, module2) => {
  var globalThis2 = require_globalThis_browser();
  module2.exports = {
    WebSocket: globalThis2.WebSocket || globalThis2.MozWebSocket,
    usingBrowserWebSocket: true,
    defaultBinaryType: "arraybuffer"
  };
});

// node_modules/engine.io-client/lib/transports/websocket.js
var require_websocket = __commonJS((exports2, module2) => {
  var Transport = require_transport2();
  var parser = require_lib8();
  var parseqs = require_parseqs();
  var yeast = require_yeast();
  var {pick} = require_util14();
  var {
    WebSocket: WebSocket2,
    usingBrowserWebSocket,
    defaultBinaryType
  } = require_websocket_constructor_browser();
  var debug = require_browser4()("engine.io-client:websocket");
  var isReactNative = typeof navigator !== "undefined" && typeof navigator.product === "string" && navigator.product.toLowerCase() === "reactnative";
  var WS = class extends Transport {
    constructor(opts) {
      super(opts);
      this.supportsBinary = !opts.forceBase64;
    }
    get name() {
      return "websocket";
    }
    doOpen() {
      if (!this.check()) {
        return;
      }
      const uri = this.uri();
      const protocols = this.opts.protocols;
      const opts = isReactNative ? {} : pick(this.opts, "agent", "perMessageDeflate", "pfx", "key", "passphrase", "cert", "ca", "ciphers", "rejectUnauthorized", "localAddress", "protocolVersion", "origin", "maxPayload", "family", "checkServerIdentity");
      if (this.opts.extraHeaders) {
        opts.headers = this.opts.extraHeaders;
      }
      try {
        this.ws = usingBrowserWebSocket && !isReactNative ? protocols ? new WebSocket2(uri, protocols) : new WebSocket2(uri) : new WebSocket2(uri, protocols, opts);
      } catch (err) {
        return this.emit("error", err);
      }
      this.ws.binaryType = this.socket.binaryType || defaultBinaryType;
      this.addEventListeners();
    }
    addEventListeners() {
      const self2 = this;
      this.ws.onopen = function() {
        self2.onOpen();
      };
      this.ws.onclose = function() {
        self2.onClose();
      };
      this.ws.onmessage = function(ev) {
        self2.onData(ev.data);
      };
      this.ws.onerror = function(e) {
        self2.onError("websocket error", e);
      };
    }
    write(packets) {
      const self2 = this;
      this.writable = false;
      let total = packets.length;
      let i = 0;
      const l = total;
      for (; i < l; i++) {
        (function(packet) {
          parser.encodePacket(packet, self2.supportsBinary, function(data) {
            const opts = {};
            if (!usingBrowserWebSocket) {
              if (packet.options) {
                opts.compress = packet.options.compress;
              }
              if (self2.opts.perMessageDeflate) {
                const len = typeof data === "string" ? Buffer.byteLength(data) : data.length;
                if (len < self2.opts.perMessageDeflate.threshold) {
                  opts.compress = false;
                }
              }
            }
            try {
              if (usingBrowserWebSocket) {
                self2.ws.send(data);
              } else {
                self2.ws.send(data, opts);
              }
            } catch (e) {
              debug("websocket closed before onclose event");
            }
            --total || done();
          });
        })(packets[i]);
      }
      function done() {
        self2.emit("flush");
        setTimeout(function() {
          self2.writable = true;
          self2.emit("drain");
        }, 0);
      }
    }
    onClose() {
      Transport.prototype.onClose.call(this);
    }
    doClose() {
      if (typeof this.ws !== "undefined") {
        this.ws.close();
      }
    }
    uri() {
      let query = this.query || {};
      const schema = this.opts.secure ? "wss" : "ws";
      let port = "";
      if (this.opts.port && (schema === "wss" && Number(this.opts.port) !== 443 || schema === "ws" && Number(this.opts.port) !== 80)) {
        port = ":" + this.opts.port;
      }
      if (this.opts.timestampRequests) {
        query[this.opts.timestampParam] = yeast();
      }
      if (!this.supportsBinary) {
        query.b64 = 1;
      }
      query = parseqs.encode(query);
      if (query.length) {
        query = "?" + query;
      }
      const ipv6 = this.opts.hostname.indexOf(":") !== -1;
      return schema + "://" + (ipv6 ? "[" + this.opts.hostname + "]" : this.opts.hostname) + port + this.opts.path + query;
    }
    check() {
      return !!WebSocket2 && !("__initialize" in WebSocket2 && this.name === WS.prototype.name);
    }
  };
  module2.exports = WS;
});

// node_modules/engine.io-client/lib/transports/index.js
var require_transports = __commonJS((exports2) => {
  var XMLHttpRequest2 = require_xmlhttprequest();
  var XHR = require_polling_xhr();
  var JSONP = require_polling_jsonp();
  var websocket = require_websocket();
  exports2.polling = polling;
  exports2.websocket = websocket;
  function polling(opts) {
    let xhr;
    let xd = false;
    let xs = false;
    const jsonp = opts.jsonp !== false;
    if (typeof location !== "undefined") {
      const isSSL = location.protocol === "https:";
      let port = location.port;
      if (!port) {
        port = isSSL ? 443 : 80;
      }
      xd = opts.hostname !== location.hostname || port !== opts.port;
      xs = opts.secure !== isSSL;
    }
    opts.xdomain = xd;
    opts.xscheme = xs;
    xhr = new XMLHttpRequest2(opts);
    if ("open" in xhr && !opts.forceJSONP) {
      return new XHR(opts);
    } else {
      if (!jsonp)
        throw new Error("JSONP disabled");
      return new JSONP(opts);
    }
  }
});

// node_modules/engine.io-client/lib/socket.js
var require_socket = __commonJS((exports2, module2) => {
  var transports = require_transports();
  var Emitter = require_component_emitter();
  var debug = require_browser4()("engine.io-client:socket");
  var parser = require_lib8();
  var parseuri = require_parseuri();
  var parseqs = require_parseqs();
  var Socket = class extends Emitter {
    constructor(uri, opts = {}) {
      super();
      if (uri && typeof uri === "object") {
        opts = uri;
        uri = null;
      }
      if (uri) {
        uri = parseuri(uri);
        opts.hostname = uri.host;
        opts.secure = uri.protocol === "https" || uri.protocol === "wss";
        opts.port = uri.port;
        if (uri.query)
          opts.query = uri.query;
      } else if (opts.host) {
        opts.hostname = parseuri(opts.host).host;
      }
      this.secure = opts.secure != null ? opts.secure : typeof location !== "undefined" && location.protocol === "https:";
      if (opts.hostname && !opts.port) {
        opts.port = this.secure ? "443" : "80";
      }
      this.hostname = opts.hostname || (typeof location !== "undefined" ? location.hostname : "localhost");
      this.port = opts.port || (typeof location !== "undefined" && location.port ? location.port : this.secure ? 443 : 80);
      this.transports = opts.transports || ["polling", "websocket"];
      this.readyState = "";
      this.writeBuffer = [];
      this.prevBufferLen = 0;
      this.opts = Object.assign({
        path: "/engine.io",
        agent: false,
        withCredentials: false,
        upgrade: true,
        jsonp: true,
        timestampParam: "t",
        rememberUpgrade: false,
        rejectUnauthorized: true,
        perMessageDeflate: {
          threshold: 1024
        },
        transportOptions: {}
      }, opts);
      this.opts.path = this.opts.path.replace(/\/$/, "") + "/";
      if (typeof this.opts.query === "string") {
        this.opts.query = parseqs.decode(this.opts.query);
      }
      this.id = null;
      this.upgrades = null;
      this.pingInterval = null;
      this.pingTimeout = null;
      this.pingTimeoutTimer = null;
      this.open();
    }
    createTransport(name) {
      debug('creating transport "%s"', name);
      const query = clone(this.opts.query);
      query.EIO = parser.protocol;
      query.transport = name;
      if (this.id)
        query.sid = this.id;
      const opts = Object.assign({}, this.opts.transportOptions[name], this.opts, {
        query,
        socket: this,
        hostname: this.hostname,
        secure: this.secure,
        port: this.port
      });
      debug("options: %j", opts);
      return new transports[name](opts);
    }
    open() {
      let transport;
      if (this.opts.rememberUpgrade && Socket.priorWebsocketSuccess && this.transports.indexOf("websocket") !== -1) {
        transport = "websocket";
      } else if (this.transports.length === 0) {
        const self2 = this;
        setTimeout(function() {
          self2.emit("error", "No transports available");
        }, 0);
        return;
      } else {
        transport = this.transports[0];
      }
      this.readyState = "opening";
      try {
        transport = this.createTransport(transport);
      } catch (e) {
        debug("error while creating transport: %s", e);
        this.transports.shift();
        this.open();
        return;
      }
      transport.open();
      this.setTransport(transport);
    }
    setTransport(transport) {
      debug("setting transport %s", transport.name);
      const self2 = this;
      if (this.transport) {
        debug("clearing existing transport %s", this.transport.name);
        this.transport.removeAllListeners();
      }
      this.transport = transport;
      transport.on("drain", function() {
        self2.onDrain();
      }).on("packet", function(packet) {
        self2.onPacket(packet);
      }).on("error", function(e) {
        self2.onError(e);
      }).on("close", function() {
        self2.onClose("transport close");
      });
    }
    probe(name) {
      debug('probing transport "%s"', name);
      let transport = this.createTransport(name, {probe: 1});
      let failed = false;
      const self2 = this;
      Socket.priorWebsocketSuccess = false;
      function onTransportOpen() {
        if (self2.onlyBinaryUpgrades) {
          const upgradeLosesBinary = !this.supportsBinary && self2.transport.supportsBinary;
          failed = failed || upgradeLosesBinary;
        }
        if (failed)
          return;
        debug('probe transport "%s" opened', name);
        transport.send([{type: "ping", data: "probe"}]);
        transport.once("packet", function(msg) {
          if (failed)
            return;
          if (msg.type === "pong" && msg.data === "probe") {
            debug('probe transport "%s" pong', name);
            self2.upgrading = true;
            self2.emit("upgrading", transport);
            if (!transport)
              return;
            Socket.priorWebsocketSuccess = transport.name === "websocket";
            debug('pausing current transport "%s"', self2.transport.name);
            self2.transport.pause(function() {
              if (failed)
                return;
              if (self2.readyState === "closed")
                return;
              debug("changing transport and sending upgrade packet");
              cleanup();
              self2.setTransport(transport);
              transport.send([{type: "upgrade"}]);
              self2.emit("upgrade", transport);
              transport = null;
              self2.upgrading = false;
              self2.flush();
            });
          } else {
            debug('probe transport "%s" failed', name);
            const err = new Error("probe error");
            err.transport = transport.name;
            self2.emit("upgradeError", err);
          }
        });
      }
      function freezeTransport() {
        if (failed)
          return;
        failed = true;
        cleanup();
        transport.close();
        transport = null;
      }
      function onerror(err) {
        const error = new Error("probe error: " + err);
        error.transport = transport.name;
        freezeTransport();
        debug('probe transport "%s" failed because of error: %s', name, err);
        self2.emit("upgradeError", error);
      }
      function onTransportClose() {
        onerror("transport closed");
      }
      function onclose() {
        onerror("socket closed");
      }
      function onupgrade(to) {
        if (transport && to.name !== transport.name) {
          debug('"%s" works - aborting "%s"', to.name, transport.name);
          freezeTransport();
        }
      }
      function cleanup() {
        transport.removeListener("open", onTransportOpen);
        transport.removeListener("error", onerror);
        transport.removeListener("close", onTransportClose);
        self2.removeListener("close", onclose);
        self2.removeListener("upgrading", onupgrade);
      }
      transport.once("open", onTransportOpen);
      transport.once("error", onerror);
      transport.once("close", onTransportClose);
      this.once("close", onclose);
      this.once("upgrading", onupgrade);
      transport.open();
    }
    onOpen() {
      debug("socket open");
      this.readyState = "open";
      Socket.priorWebsocketSuccess = this.transport.name === "websocket";
      this.emit("open");
      this.flush();
      if (this.readyState === "open" && this.opts.upgrade && this.transport.pause) {
        debug("starting upgrade probes");
        let i = 0;
        const l = this.upgrades.length;
        for (; i < l; i++) {
          this.probe(this.upgrades[i]);
        }
      }
    }
    onPacket(packet) {
      if (this.readyState === "opening" || this.readyState === "open" || this.readyState === "closing") {
        debug('socket receive: type "%s", data "%s"', packet.type, packet.data);
        this.emit("packet", packet);
        this.emit("heartbeat");
        switch (packet.type) {
          case "open":
            this.onHandshake(JSON.parse(packet.data));
            break;
          case "ping":
            this.resetPingTimeout();
            this.sendPacket("pong");
            this.emit("pong");
            break;
          case "error":
            const err = new Error("server error");
            err.code = packet.data;
            this.onError(err);
            break;
          case "message":
            this.emit("data", packet.data);
            this.emit("message", packet.data);
            break;
        }
      } else {
        debug('packet received with socket readyState "%s"', this.readyState);
      }
    }
    onHandshake(data) {
      this.emit("handshake", data);
      this.id = data.sid;
      this.transport.query.sid = data.sid;
      this.upgrades = this.filterUpgrades(data.upgrades);
      this.pingInterval = data.pingInterval;
      this.pingTimeout = data.pingTimeout;
      this.onOpen();
      if (this.readyState === "closed")
        return;
      this.resetPingTimeout();
    }
    resetPingTimeout() {
      clearTimeout(this.pingTimeoutTimer);
      this.pingTimeoutTimer = setTimeout(() => {
        this.onClose("ping timeout");
      }, this.pingInterval + this.pingTimeout);
    }
    onDrain() {
      this.writeBuffer.splice(0, this.prevBufferLen);
      this.prevBufferLen = 0;
      if (this.writeBuffer.length === 0) {
        this.emit("drain");
      } else {
        this.flush();
      }
    }
    flush() {
      if (this.readyState !== "closed" && this.transport.writable && !this.upgrading && this.writeBuffer.length) {
        debug("flushing %d packets in socket", this.writeBuffer.length);
        this.transport.send(this.writeBuffer);
        this.prevBufferLen = this.writeBuffer.length;
        this.emit("flush");
      }
    }
    write(msg, options, fn) {
      this.sendPacket("message", msg, options, fn);
      return this;
    }
    send(msg, options, fn) {
      this.sendPacket("message", msg, options, fn);
      return this;
    }
    sendPacket(type, data, options, fn) {
      if (typeof data === "function") {
        fn = data;
        data = void 0;
      }
      if (typeof options === "function") {
        fn = options;
        options = null;
      }
      if (this.readyState === "closing" || this.readyState === "closed") {
        return;
      }
      options = options || {};
      options.compress = options.compress !== false;
      const packet = {
        type,
        data,
        options
      };
      this.emit("packetCreate", packet);
      this.writeBuffer.push(packet);
      if (fn)
        this.once("flush", fn);
      this.flush();
    }
    close() {
      const self2 = this;
      if (this.readyState === "opening" || this.readyState === "open") {
        this.readyState = "closing";
        if (this.writeBuffer.length) {
          this.once("drain", function() {
            if (this.upgrading) {
              waitForUpgrade();
            } else {
              close();
            }
          });
        } else if (this.upgrading) {
          waitForUpgrade();
        } else {
          close();
        }
      }
      function close() {
        self2.onClose("forced close");
        debug("socket closing - telling transport to close");
        self2.transport.close();
      }
      function cleanupAndClose() {
        self2.removeListener("upgrade", cleanupAndClose);
        self2.removeListener("upgradeError", cleanupAndClose);
        close();
      }
      function waitForUpgrade() {
        self2.once("upgrade", cleanupAndClose);
        self2.once("upgradeError", cleanupAndClose);
      }
      return this;
    }
    onError(err) {
      debug("socket error %j", err);
      Socket.priorWebsocketSuccess = false;
      this.emit("error", err);
      this.onClose("transport error", err);
    }
    onClose(reason, desc) {
      if (this.readyState === "opening" || this.readyState === "open" || this.readyState === "closing") {
        debug('socket close with reason: "%s"', reason);
        const self2 = this;
        clearTimeout(this.pingIntervalTimer);
        clearTimeout(this.pingTimeoutTimer);
        this.transport.removeAllListeners("close");
        this.transport.close();
        this.transport.removeAllListeners();
        this.readyState = "closed";
        this.id = null;
        this.emit("close", reason, desc);
        self2.writeBuffer = [];
        self2.prevBufferLen = 0;
      }
    }
    filterUpgrades(upgrades) {
      const filteredUpgrades = [];
      let i = 0;
      const j = upgrades.length;
      for (; i < j; i++) {
        if (~this.transports.indexOf(upgrades[i]))
          filteredUpgrades.push(upgrades[i]);
      }
      return filteredUpgrades;
    }
  };
  Socket.priorWebsocketSuccess = false;
  Socket.protocol = parser.protocol;
  function clone(obj) {
    const o = {};
    for (let i in obj) {
      if (obj.hasOwnProperty(i)) {
        o[i] = obj[i];
      }
    }
    return o;
  }
  module2.exports = Socket;
});

// node_modules/engine.io-client/lib/index.js
var require_lib9 = __commonJS((exports2, module2) => {
  var Socket = require_socket();
  module2.exports = (uri, opts) => new Socket(uri, opts);
  module2.exports.Socket = Socket;
  module2.exports.protocol = Socket.protocol;
  module2.exports.Transport = require_transport2();
  module2.exports.transports = require_transports();
  module2.exports.parser = require_lib8();
});

// node_modules/socket.io-parser/dist/is-binary.js
var require_is_binary = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.hasBinary = exports2.isBinary = void 0;
  var withNativeArrayBuffer = typeof ArrayBuffer === "function";
  var isView = (obj) => {
    return typeof ArrayBuffer.isView === "function" ? ArrayBuffer.isView(obj) : obj.buffer instanceof ArrayBuffer;
  };
  var toString = Object.prototype.toString;
  var withNativeBlob = typeof Blob === "function" || typeof Blob !== "undefined" && toString.call(Blob) === "[object BlobConstructor]";
  var withNativeFile = typeof File === "function" || typeof File !== "undefined" && toString.call(File) === "[object FileConstructor]";
  function isBinary(obj) {
    return withNativeArrayBuffer && (obj instanceof ArrayBuffer || isView(obj)) || withNativeBlob && obj instanceof Blob || withNativeFile && obj instanceof File;
  }
  exports2.isBinary = isBinary;
  function hasBinary(obj, toJSON) {
    if (!obj || typeof obj !== "object") {
      return false;
    }
    if (Array.isArray(obj)) {
      for (let i = 0, l = obj.length; i < l; i++) {
        if (hasBinary(obj[i])) {
          return true;
        }
      }
      return false;
    }
    if (isBinary(obj)) {
      return true;
    }
    if (obj.toJSON && typeof obj.toJSON === "function" && arguments.length === 1) {
      return hasBinary(obj.toJSON(), true);
    }
    for (const key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key) && hasBinary(obj[key])) {
        return true;
      }
    }
    return false;
  }
  exports2.hasBinary = hasBinary;
});

// node_modules/socket.io-parser/dist/binary.js
var require_binary = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.reconstructPacket = exports2.deconstructPacket = void 0;
  var is_binary_1 = require_is_binary();
  function deconstructPacket(packet) {
    const buffers = [];
    const packetData = packet.data;
    const pack = packet;
    pack.data = _deconstructPacket(packetData, buffers);
    pack.attachments = buffers.length;
    return {packet: pack, buffers};
  }
  exports2.deconstructPacket = deconstructPacket;
  function _deconstructPacket(data, buffers) {
    if (!data)
      return data;
    if (is_binary_1.isBinary(data)) {
      const placeholder = {_placeholder: true, num: buffers.length};
      buffers.push(data);
      return placeholder;
    } else if (Array.isArray(data)) {
      const newData = new Array(data.length);
      for (let i = 0; i < data.length; i++) {
        newData[i] = _deconstructPacket(data[i], buffers);
      }
      return newData;
    } else if (typeof data === "object" && !(data instanceof Date)) {
      const newData = {};
      for (const key in data) {
        if (data.hasOwnProperty(key)) {
          newData[key] = _deconstructPacket(data[key], buffers);
        }
      }
      return newData;
    }
    return data;
  }
  function reconstructPacket(packet, buffers) {
    packet.data = _reconstructPacket(packet.data, buffers);
    packet.attachments = void 0;
    return packet;
  }
  exports2.reconstructPacket = reconstructPacket;
  function _reconstructPacket(data, buffers) {
    if (!data)
      return data;
    if (data && data._placeholder) {
      return buffers[data.num];
    } else if (Array.isArray(data)) {
      for (let i = 0; i < data.length; i++) {
        data[i] = _reconstructPacket(data[i], buffers);
      }
    } else if (typeof data === "object") {
      for (const key in data) {
        if (data.hasOwnProperty(key)) {
          data[key] = _reconstructPacket(data[key], buffers);
        }
      }
    }
    return data;
  }
});

// node_modules/socket.io-parser/dist/index.js
var require_dist3 = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.Decoder = exports2.Encoder = exports2.PacketType = exports2.protocol = void 0;
  var Emitter = require_component_emitter();
  var binary_1 = require_binary();
  var is_binary_1 = require_is_binary();
  var debug = require_browser4()("socket.io-parser");
  exports2.protocol = 5;
  var PacketType;
  (function(PacketType2) {
    PacketType2[PacketType2["CONNECT"] = 0] = "CONNECT";
    PacketType2[PacketType2["DISCONNECT"] = 1] = "DISCONNECT";
    PacketType2[PacketType2["EVENT"] = 2] = "EVENT";
    PacketType2[PacketType2["ACK"] = 3] = "ACK";
    PacketType2[PacketType2["CONNECT_ERROR"] = 4] = "CONNECT_ERROR";
    PacketType2[PacketType2["BINARY_EVENT"] = 5] = "BINARY_EVENT";
    PacketType2[PacketType2["BINARY_ACK"] = 6] = "BINARY_ACK";
  })(PacketType = exports2.PacketType || (exports2.PacketType = {}));
  var Encoder = class {
    encode(obj) {
      debug("encoding packet %j", obj);
      if (obj.type === PacketType.EVENT || obj.type === PacketType.ACK) {
        if (is_binary_1.hasBinary(obj)) {
          obj.type = obj.type === PacketType.EVENT ? PacketType.BINARY_EVENT : PacketType.BINARY_ACK;
          return this.encodeAsBinary(obj);
        }
      }
      return [this.encodeAsString(obj)];
    }
    encodeAsString(obj) {
      let str = "" + obj.type;
      if (obj.type === PacketType.BINARY_EVENT || obj.type === PacketType.BINARY_ACK) {
        str += obj.attachments + "-";
      }
      if (obj.nsp && obj.nsp !== "/") {
        str += obj.nsp + ",";
      }
      if (obj.id != null) {
        str += obj.id;
      }
      if (obj.data != null) {
        str += JSON.stringify(obj.data);
      }
      debug("encoded %j as %s", obj, str);
      return str;
    }
    encodeAsBinary(obj) {
      const deconstruction = binary_1.deconstructPacket(obj);
      const pack = this.encodeAsString(deconstruction.packet);
      const buffers = deconstruction.buffers;
      buffers.unshift(pack);
      return buffers;
    }
  };
  exports2.Encoder = Encoder;
  var Decoder = class extends Emitter {
    constructor() {
      super();
    }
    add(obj) {
      let packet;
      if (typeof obj === "string") {
        packet = this.decodeString(obj);
        if (packet.type === PacketType.BINARY_EVENT || packet.type === PacketType.BINARY_ACK) {
          this.reconstructor = new BinaryReconstructor(packet);
          if (packet.attachments === 0) {
            super.emit("decoded", packet);
          }
        } else {
          super.emit("decoded", packet);
        }
      } else if (is_binary_1.isBinary(obj) || obj.base64) {
        if (!this.reconstructor) {
          throw new Error("got binary data when not reconstructing a packet");
        } else {
          packet = this.reconstructor.takeBinaryData(obj);
          if (packet) {
            this.reconstructor = null;
            super.emit("decoded", packet);
          }
        }
      } else {
        throw new Error("Unknown type: " + obj);
      }
    }
    decodeString(str) {
      let i = 0;
      const p = {
        type: Number(str.charAt(0))
      };
      if (PacketType[p.type] === void 0) {
        throw new Error("unknown packet type " + p.type);
      }
      if (p.type === PacketType.BINARY_EVENT || p.type === PacketType.BINARY_ACK) {
        const start = i + 1;
        while (str.charAt(++i) !== "-" && i != str.length) {
        }
        const buf = str.substring(start, i);
        if (buf != Number(buf) || str.charAt(i) !== "-") {
          throw new Error("Illegal attachments");
        }
        p.attachments = Number(buf);
      }
      if (str.charAt(i + 1) === "/") {
        const start = i + 1;
        while (++i) {
          const c = str.charAt(i);
          if (c === ",")
            break;
          if (i === str.length)
            break;
        }
        p.nsp = str.substring(start, i);
      } else {
        p.nsp = "/";
      }
      const next = str.charAt(i + 1);
      if (next !== "" && Number(next) == next) {
        const start = i + 1;
        while (++i) {
          const c = str.charAt(i);
          if (c == null || Number(c) != c) {
            --i;
            break;
          }
          if (i === str.length)
            break;
        }
        p.id = Number(str.substring(start, i + 1));
      }
      if (str.charAt(++i)) {
        const payload = tryParse(str.substr(i));
        if (Decoder.isPayloadValid(p.type, payload)) {
          p.data = payload;
        } else {
          throw new Error("invalid payload");
        }
      }
      debug("decoded %s as %j", str, p);
      return p;
    }
    static isPayloadValid(type, payload) {
      switch (type) {
        case PacketType.CONNECT:
          return typeof payload === "object";
        case PacketType.DISCONNECT:
          return payload === void 0;
        case PacketType.CONNECT_ERROR:
          return typeof payload === "string" || typeof payload === "object";
        case PacketType.EVENT:
        case PacketType.BINARY_EVENT:
          return Array.isArray(payload) && payload.length > 0;
        case PacketType.ACK:
        case PacketType.BINARY_ACK:
          return Array.isArray(payload);
      }
    }
    destroy() {
      if (this.reconstructor) {
        this.reconstructor.finishedReconstruction();
      }
    }
  };
  exports2.Decoder = Decoder;
  function tryParse(str) {
    try {
      return JSON.parse(str);
    } catch (e) {
      return false;
    }
  }
  var BinaryReconstructor = class {
    constructor(packet) {
      this.packet = packet;
      this.buffers = [];
      this.reconPack = packet;
    }
    takeBinaryData(binData) {
      this.buffers.push(binData);
      if (this.buffers.length === this.reconPack.attachments) {
        const packet = binary_1.reconstructPacket(this.reconPack, this.buffers);
        this.finishedReconstruction();
        return packet;
      }
      return null;
    }
    finishedReconstruction() {
      this.reconPack = null;
      this.buffers = [];
    }
  };
});

// node_modules/socket.io-client-next/build/on.js
var require_on = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.on = void 0;
  function on(obj, ev, fn) {
    obj.on(ev, fn);
    return function subDestroy() {
      obj.off(ev, fn);
    };
  }
  exports2.on = on;
});

// node_modules/socket.io-client-next/build/socket.js
var require_socket2 = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.Socket = void 0;
  var socket_io_parser_1 = require_dist3();
  var Emitter = require_component_emitter();
  var on_1 = require_on();
  var debug = require_browser4()("socket.io-client:socket");
  var RESERVED_EVENTS = Object.freeze({
    connect: 1,
    connect_error: 1,
    disconnect: 1,
    disconnecting: 1,
    newListener: 1,
    removeListener: 1
  });
  var Socket = class extends Emitter {
    constructor(io, nsp, opts) {
      super();
      this.receiveBuffer = [];
      this.sendBuffer = [];
      this.ids = 0;
      this.acks = {};
      this.flags = {};
      this.io = io;
      this.nsp = nsp;
      this.ids = 0;
      this.acks = {};
      this.receiveBuffer = [];
      this.sendBuffer = [];
      this.connected = false;
      this.disconnected = true;
      this.flags = {};
      if (opts && opts.auth) {
        this.auth = opts.auth;
      }
      if (this.io._autoConnect)
        this.open();
    }
    subEvents() {
      if (this.subs)
        return;
      const io = this.io;
      this.subs = [
        on_1.on(io, "open", this.onopen.bind(this)),
        on_1.on(io, "packet", this.onpacket.bind(this)),
        on_1.on(io, "error", this.onerror.bind(this)),
        on_1.on(io, "close", this.onclose.bind(this))
      ];
    }
    get active() {
      return !!this.subs;
    }
    connect() {
      if (this.connected)
        return this;
      this.subEvents();
      if (!this.io["_reconnecting"])
        this.io.open();
      if (this.io._readyState === "open")
        this.onopen();
      return this;
    }
    open() {
      return this.connect();
    }
    send(...args) {
      args.unshift("message");
      this.emit.apply(this, args);
      return this;
    }
    emit(ev, ...args) {
      if (RESERVED_EVENTS.hasOwnProperty(ev)) {
        throw new Error('"' + ev + '" is a reserved event name');
      }
      args.unshift(ev);
      const packet = {
        type: socket_io_parser_1.PacketType.EVENT,
        data: args
      };
      packet.options = {};
      packet.options.compress = this.flags.compress !== false;
      if (typeof args[args.length - 1] === "function") {
        debug("emitting packet with ack id %d", this.ids);
        this.acks[this.ids] = args.pop();
        packet.id = this.ids++;
      }
      const isTransportWritable = this.io.engine && this.io.engine.transport && this.io.engine.transport.writable;
      const discardPacket = this.flags.volatile && (!isTransportWritable || !this.connected);
      if (discardPacket) {
        debug("discard packet as the transport is not currently writable");
      } else if (this.connected) {
        this.packet(packet);
      } else {
        this.sendBuffer.push(packet);
      }
      this.flags = {};
      return this;
    }
    packet(packet) {
      packet.nsp = this.nsp;
      this.io._packet(packet);
    }
    onopen() {
      debug("transport is open - connecting");
      if (typeof this.auth == "function") {
        this.auth((data) => {
          this.packet({type: socket_io_parser_1.PacketType.CONNECT, data});
        });
      } else {
        this.packet({type: socket_io_parser_1.PacketType.CONNECT, data: this.auth});
      }
    }
    onerror(err) {
      if (!this.connected) {
        super.emit("connect_error", err);
      }
    }
    onclose(reason) {
      debug("close (%s)", reason);
      this.connected = false;
      this.disconnected = true;
      delete this.id;
      super.emit("disconnect", reason);
    }
    onpacket(packet) {
      const sameNamespace = packet.nsp === this.nsp;
      if (!sameNamespace)
        return;
      switch (packet.type) {
        case socket_io_parser_1.PacketType.CONNECT:
          if (packet.data && packet.data.sid) {
            const id = packet.data.sid;
            this.onconnect(id);
          } else {
            super.emit("connect_error", new Error("It seems you are trying to reach a Socket.IO server in v2.x with a v3.x client, but they are not compatible (more information here: https://socket.io/docs/v3/migrating-from-2-x-to-3-0/)"));
          }
          break;
        case socket_io_parser_1.PacketType.EVENT:
          this.onevent(packet);
          break;
        case socket_io_parser_1.PacketType.BINARY_EVENT:
          this.onevent(packet);
          break;
        case socket_io_parser_1.PacketType.ACK:
          this.onack(packet);
          break;
        case socket_io_parser_1.PacketType.BINARY_ACK:
          this.onack(packet);
          break;
        case socket_io_parser_1.PacketType.DISCONNECT:
          this.ondisconnect();
          break;
        case socket_io_parser_1.PacketType.CONNECT_ERROR:
          const err = new Error(packet.data.message);
          err.data = packet.data.data;
          super.emit("connect_error", err);
          break;
      }
    }
    onevent(packet) {
      const args = packet.data || [];
      debug("emitting event %j", args);
      if (packet.id != null) {
        debug("attaching ack callback to event");
        args.push(this.ack(packet.id));
      }
      if (this.connected) {
        this.emitEvent(args);
      } else {
        this.receiveBuffer.push(Object.freeze(args));
      }
    }
    emitEvent(args) {
      if (this._anyListeners && this._anyListeners.length) {
        const listeners = this._anyListeners.slice();
        for (const listener of listeners) {
          listener.apply(this, args);
        }
      }
      super.emit.apply(this, args);
    }
    ack(id) {
      const self2 = this;
      let sent = false;
      return function(...args) {
        if (sent)
          return;
        sent = true;
        debug("sending ack %j", args);
        self2.packet({
          type: socket_io_parser_1.PacketType.ACK,
          id,
          data: args
        });
      };
    }
    onack(packet) {
      const ack = this.acks[packet.id];
      if (typeof ack === "function") {
        debug("calling ack %s with %j", packet.id, packet.data);
        ack.apply(this, packet.data);
        delete this.acks[packet.id];
      } else {
        debug("bad ack %s", packet.id);
      }
    }
    onconnect(id) {
      debug("socket connected with id %s", id);
      this.id = id;
      this.connected = true;
      this.disconnected = false;
      super.emit("connect");
      this.emitBuffered();
    }
    emitBuffered() {
      this.receiveBuffer.forEach((args) => this.emitEvent(args));
      this.receiveBuffer = [];
      this.sendBuffer.forEach((packet) => this.packet(packet));
      this.sendBuffer = [];
    }
    ondisconnect() {
      debug("server disconnect (%s)", this.nsp);
      this.destroy();
      this.onclose("io server disconnect");
    }
    destroy() {
      if (this.subs) {
        this.subs.forEach((subDestroy) => subDestroy());
        this.subs = void 0;
      }
      this.io["_destroy"](this);
    }
    disconnect() {
      if (this.connected) {
        debug("performing disconnect (%s)", this.nsp);
        this.packet({type: socket_io_parser_1.PacketType.DISCONNECT});
      }
      this.destroy();
      if (this.connected) {
        this.onclose("io client disconnect");
      }
      return this;
    }
    close() {
      return this.disconnect();
    }
    compress(compress) {
      this.flags.compress = compress;
      return this;
    }
    get volatile() {
      this.flags.volatile = true;
      return this;
    }
    onAny(listener) {
      this._anyListeners = this._anyListeners || [];
      this._anyListeners.push(listener);
      return this;
    }
    prependAny(listener) {
      this._anyListeners = this._anyListeners || [];
      this._anyListeners.unshift(listener);
      return this;
    }
    offAny(listener) {
      if (!this._anyListeners) {
        return this;
      }
      if (listener) {
        const listeners = this._anyListeners;
        for (let i = 0; i < listeners.length; i++) {
          if (listener === listeners[i]) {
            listeners.splice(i, 1);
            return this;
          }
        }
      } else {
        this._anyListeners = [];
      }
      return this;
    }
    listenersAny() {
      return this._anyListeners || [];
    }
  };
  exports2.Socket = Socket;
});

// node_modules/backo2/index.js
var require_backo2 = __commonJS((exports2, module2) => {
  module2.exports = Backoff;
  function Backoff(opts) {
    opts = opts || {};
    this.ms = opts.min || 100;
    this.max = opts.max || 1e4;
    this.factor = opts.factor || 2;
    this.jitter = opts.jitter > 0 && opts.jitter <= 1 ? opts.jitter : 0;
    this.attempts = 0;
  }
  Backoff.prototype.duration = function() {
    var ms = this.ms * Math.pow(this.factor, this.attempts++);
    if (this.jitter) {
      var rand = Math.random();
      var deviation = Math.floor(rand * this.jitter * ms);
      ms = (Math.floor(rand * 10) & 1) == 0 ? ms - deviation : ms + deviation;
    }
    return Math.min(ms, this.max) | 0;
  };
  Backoff.prototype.reset = function() {
    this.attempts = 0;
  };
  Backoff.prototype.setMin = function(min) {
    this.ms = min;
  };
  Backoff.prototype.setMax = function(max) {
    this.max = max;
  };
  Backoff.prototype.setJitter = function(jitter) {
    this.jitter = jitter;
  };
});

// node_modules/socket.io-client-next/build/manager.js
var require_manager = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.Manager = void 0;
  var eio = require_lib9();
  var socket_1 = require_socket2();
  var Emitter = require_component_emitter();
  var parser = require_dist3();
  var on_1 = require_on();
  var Backoff = require_backo2();
  var debug = require_browser4()("socket.io-client:manager");
  var Manager = class extends Emitter {
    constructor(uri, opts) {
      super();
      this.nsps = {};
      this.subs = [];
      if (uri && typeof uri === "object") {
        opts = uri;
        uri = void 0;
      }
      opts = opts || {};
      opts.path = opts.path || "/socket.io";
      this.opts = opts;
      this.reconnection(opts.reconnection !== false);
      this.reconnectionAttempts(opts.reconnectionAttempts || Infinity);
      this.reconnectionDelay(opts.reconnectionDelay || 1e3);
      this.reconnectionDelayMax(opts.reconnectionDelayMax || 5e3);
      this.randomizationFactor(opts.randomizationFactor || 0.5);
      this.backoff = new Backoff({
        min: this.reconnectionDelay(),
        max: this.reconnectionDelayMax(),
        jitter: this.randomizationFactor()
      });
      this.timeout(opts.timeout == null ? 2e4 : opts.timeout);
      this._readyState = "closed";
      this.uri = uri;
      const _parser = opts.parser || parser;
      this.encoder = new _parser.Encoder();
      this.decoder = new _parser.Decoder();
      this._autoConnect = opts.autoConnect !== false;
      if (this._autoConnect)
        this.open();
    }
    reconnection(v) {
      if (!arguments.length)
        return this._reconnection;
      this._reconnection = !!v;
      return this;
    }
    reconnectionAttempts(v) {
      if (v === void 0)
        return this._reconnectionAttempts;
      this._reconnectionAttempts = v;
      return this;
    }
    reconnectionDelay(v) {
      var _a;
      if (v === void 0)
        return this._reconnectionDelay;
      this._reconnectionDelay = v;
      (_a = this.backoff) === null || _a === void 0 ? void 0 : _a.setMin(v);
      return this;
    }
    randomizationFactor(v) {
      var _a;
      if (v === void 0)
        return this._randomizationFactor;
      this._randomizationFactor = v;
      (_a = this.backoff) === null || _a === void 0 ? void 0 : _a.setJitter(v);
      return this;
    }
    reconnectionDelayMax(v) {
      var _a;
      if (v === void 0)
        return this._reconnectionDelayMax;
      this._reconnectionDelayMax = v;
      (_a = this.backoff) === null || _a === void 0 ? void 0 : _a.setMax(v);
      return this;
    }
    timeout(v) {
      if (!arguments.length)
        return this._timeout;
      this._timeout = v;
      return this;
    }
    maybeReconnectOnOpen() {
      if (!this._reconnecting && this._reconnection && this.backoff.attempts === 0) {
        this.reconnect();
      }
    }
    open(fn) {
      debug("readyState %s", this._readyState);
      if (~this._readyState.indexOf("open"))
        return this;
      debug("opening %s", this.uri);
      this.engine = eio(this.uri, this.opts);
      const socket = this.engine;
      const self2 = this;
      this._readyState = "opening";
      this.skipReconnect = false;
      const openSubDestroy = on_1.on(socket, "open", function() {
        self2.onopen();
        fn && fn();
      });
      const errorSub = on_1.on(socket, "error", (err) => {
        debug("error");
        self2.cleanup();
        self2._readyState = "closed";
        super.emit("error", err);
        if (fn) {
          fn(err);
        } else {
          self2.maybeReconnectOnOpen();
        }
      });
      if (this._timeout !== false) {
        const timeout = this._timeout;
        debug("connect attempt will timeout after %d", timeout);
        if (timeout === 0) {
          openSubDestroy();
        }
        const timer = setTimeout(() => {
          debug("connect attempt timed out after %d", timeout);
          openSubDestroy();
          socket.close();
          socket.emit("error", new Error("timeout"));
        }, timeout);
        this.subs.push(function subDestroy() {
          clearTimeout(timer);
        });
      }
      this.subs.push(openSubDestroy);
      this.subs.push(errorSub);
      return this;
    }
    connect(fn) {
      return this.open(fn);
    }
    onopen() {
      debug("open");
      this.cleanup();
      this._readyState = "open";
      super.emit("open");
      const socket = this.engine;
      this.subs.push(on_1.on(socket, "ping", this.onping.bind(this)), on_1.on(socket, "data", this.ondata.bind(this)), on_1.on(socket, "error", this.onerror.bind(this)), on_1.on(socket, "close", this.onclose.bind(this)), on_1.on(this.decoder, "decoded", this.ondecoded.bind(this)));
    }
    onping() {
      super.emit("ping");
    }
    ondata(data) {
      this.decoder.add(data);
    }
    ondecoded(packet) {
      super.emit("packet", packet);
    }
    onerror(err) {
      debug("error", err);
      super.emit("error", err);
    }
    socket(nsp, opts) {
      let socket = this.nsps[nsp];
      if (!socket) {
        socket = new socket_1.Socket(this, nsp, opts);
        this.nsps[nsp] = socket;
      }
      return socket;
    }
    _destroy(socket) {
      const nsps = Object.keys(this.nsps);
      for (const nsp of nsps) {
        const socket2 = this.nsps[nsp];
        if (socket2.active) {
          debug("socket %s is still active, skipping close", nsp);
          return;
        }
      }
      this._close();
    }
    _packet(packet) {
      debug("writing packet %j", packet);
      if (packet.query && packet.type === 0)
        packet.nsp += "?" + packet.query;
      const encodedPackets = this.encoder.encode(packet);
      for (let i = 0; i < encodedPackets.length; i++) {
        this.engine.write(encodedPackets[i], packet.options);
      }
    }
    cleanup() {
      debug("cleanup");
      this.subs.forEach((subDestroy) => subDestroy());
      this.subs.length = 0;
      this.decoder.destroy();
    }
    _close() {
      debug("disconnect");
      this.skipReconnect = true;
      this._reconnecting = false;
      if (this._readyState === "opening") {
        this.cleanup();
      }
      this.backoff.reset();
      this._readyState = "closed";
      if (this.engine)
        this.engine.close();
    }
    disconnect() {
      return this._close();
    }
    onclose(reason) {
      debug("onclose");
      this.cleanup();
      this.backoff.reset();
      this._readyState = "closed";
      super.emit("close", reason);
      if (this._reconnection && !this.skipReconnect) {
        this.reconnect();
      }
    }
    reconnect() {
      if (this._reconnecting || this.skipReconnect)
        return this;
      const self2 = this;
      if (this.backoff.attempts >= this._reconnectionAttempts) {
        debug("reconnect failed");
        this.backoff.reset();
        super.emit("reconnect_failed");
        this._reconnecting = false;
      } else {
        const delay = this.backoff.duration();
        debug("will wait %dms before reconnect attempt", delay);
        this._reconnecting = true;
        const timer = setTimeout(() => {
          if (self2.skipReconnect)
            return;
          debug("attempting reconnect");
          super.emit("reconnect_attempt", self2.backoff.attempts);
          if (self2.skipReconnect)
            return;
          self2.open((err) => {
            if (err) {
              debug("reconnect attempt error");
              self2._reconnecting = false;
              self2.reconnect();
              super.emit("reconnect_error", err);
            } else {
              debug("reconnect success");
              self2.onreconnect();
            }
          });
        }, delay);
        this.subs.push(function subDestroy() {
          clearTimeout(timer);
        });
      }
    }
    onreconnect() {
      const attempt = this.backoff.attempts;
      this._reconnecting = false;
      this.backoff.reset();
      super.emit("reconnect", attempt);
    }
  };
  exports2.Manager = Manager;
});

// node_modules/socket.io-client-next/build/index.js
var require_build3 = __commonJS((exports2, module2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.Socket = exports2.io = exports2.Manager = exports2.protocol = void 0;
  var url_1 = require_url2();
  var manager_1 = require_manager();
  var socket_1 = require_socket2();
  Object.defineProperty(exports2, "Socket", {enumerable: true, get: function() {
    return socket_1.Socket;
  }});
  var debug = require_browser4()("socket.io-client");
  module2.exports = exports2 = lookup;
  var cache = exports2.managers = {};
  function lookup(uri, opts) {
    if (typeof uri === "object") {
      opts = uri;
      uri = void 0;
    }
    opts = opts || {};
    const parsed = url_1.url(uri);
    const source = parsed.source;
    const id = parsed.id;
    const path = parsed.path;
    const sameNamespace = cache[id] && path in cache[id]["nsps"];
    const newConnection = opts.forceNew || opts["force new connection"] || opts.multiplex === false || sameNamespace;
    let io;
    if (newConnection) {
      debug("ignoring socket cache for %s", source);
      io = new manager_1.Manager(source, opts);
    } else {
      if (!cache[id]) {
        debug("new io instance for %s", source);
        cache[id] = new manager_1.Manager(source, opts);
      }
      io = cache[id];
    }
    if (parsed.query && !opts.query) {
      opts.query = parsed.query;
    }
    return io.socket(parsed.path, opts);
  }
  exports2.io = lookup;
  var socket_io_parser_1 = require_dist3();
  Object.defineProperty(exports2, "protocol", {enumerable: true, get: function() {
    return socket_io_parser_1.protocol;
  }});
  exports2.connect = lookup;
  var manager_2 = require_manager();
  Object.defineProperty(exports2, "Manager", {enumerable: true, get: function() {
    return manager_2.Manager;
  }});
});

// node_modules/stream-to-it/source.js
var require_source2 = __commonJS((exports2, module2) => {
  module2.exports = (readable) => {
    if (readable[Symbol.asyncIterator])
      return readable;
    if (readable.getReader) {
      return async function* () {
        const reader = readable.getReader();
        try {
          while (true) {
            const {done, value} = await reader.read();
            if (done)
              return;
            yield value;
          }
        } finally {
          reader.releaseLock();
        }
      }();
    }
    throw new Error("unknown stream");
  };
});

// node_modules/stream-to-it/sink.js
var require_sink2 = __commonJS((exports2, module2) => {
  var getIterator = require_get_iterator();
  module2.exports = (writable) => async (source) => {
    source = getIterator(source);
    const maybeEndSource = (source2) => {
      if (typeof source2.return === "function")
        source2.return();
    };
    let error = null;
    let errCb = null;
    const errorHandler = (err) => {
      error = err;
      if (errCb)
        errCb(err);
      maybeEndSource(source);
    };
    let closeCb = null;
    let closed = false;
    const closeHandler = () => {
      closed = true;
      if (closeCb)
        closeCb();
    };
    let finishCb = null;
    let finished = false;
    const finishHandler = () => {
      finished = true;
      if (finishCb)
        finishCb();
    };
    let drainCb = null;
    const drainHandler = () => {
      if (drainCb)
        drainCb();
    };
    const waitForDrainOrClose = () => {
      return new Promise((resolve, reject) => {
        closeCb = drainCb = resolve;
        errCb = reject;
        writable.once("drain", drainHandler);
      });
    };
    const waitForDone = () => {
      maybeEndSource(source);
      return new Promise((resolve, reject) => {
        if (closed || finished || error)
          return resolve();
        finishCb = closeCb = resolve;
        errCb = reject;
      });
    };
    const cleanup = () => {
      writable.removeListener("error", errorHandler);
      writable.removeListener("close", closeHandler);
      writable.removeListener("finish", finishHandler);
      writable.removeListener("drain", drainHandler);
    };
    writable.once("error", errorHandler);
    writable.once("close", closeHandler);
    writable.once("finish", finishHandler);
    try {
      for await (const value of source) {
        if (!writable.writable || writable.destroyed || error)
          break;
        if (writable.write(value) === false) {
          await waitForDrainOrClose();
        }
      }
    } catch (err) {
      if (!error) {
        writable.destroy();
      }
      error = err;
    }
    try {
      if (writable.writable) {
        writable.end();
      }
      await waitForDone();
      if (error)
        throw error;
    } finally {
      cleanup();
    }
  };
});

// node_modules/stream-to-it/duplex.js
var require_duplex2 = __commonJS((exports2, module2) => {
  var toSink = require_sink2();
  var toSource = require_source2();
  module2.exports = (duplex) => ({sink: toSink(duplex), source: toSource(duplex)});
});

// node_modules/stream-to-it/transform.js
var require_transform = __commonJS((exports2, module2) => {
  var toDuplex = require_duplex2();
  module2.exports = (transform) => async function* (source) {
    const duplex = toDuplex(transform);
    duplex.sink(source).catch((_) => {
    });
    yield* duplex.source;
  };
});

// node_modules/stream-to-it/index.js
var require_stream_to_it = __commonJS((exports2, module2) => {
  module2.exports = require_source2();
  module2.exports.source = require_source2();
  module2.exports.sink = require_sink2();
  module2.exports.transform = require_transform();
  module2.exports.duplex = require_duplex2();
});

// node_modules/libp2p-webrtc-star/src/socket-to-conn.js
var require_socket_to_conn2 = __commonJS((exports2, module2) => {
  "use strict";
  var abortable = require_abortable_iterator();
  var toIterable = require_stream_to_it();
  var {CLOSE_TIMEOUT} = require_constants17();
  var toMultiaddr = require_ip_port_to_multiaddr();
  var debug = require_browser4();
  var log = debug("libp2p:webrtc-star:socket");
  log.error = debug("libp2p:webrtc-star:socket:error");
  var toWebrtcMultiaddr = (address, port) => {
    if (!address || !port)
      return void 0;
    try {
      return toMultiaddr(address, port);
    } catch (err) {
      log.error(err);
      return toMultiaddr("0.0.0.0", port);
    }
  };
  module2.exports = (socket, options = {}) => {
    const {sink, source} = toIterable.duplex(socket);
    const remoteAddr = options.remoteAddr || toWebrtcMultiaddr(socket.remoteAddress, socket.remotePort);
    const localAddr = toWebrtcMultiaddr(socket.localAddress, socket.localPort);
    const maConn = {
      async sink(source2) {
        if (options.signal) {
          source2 = abortable(source2, options.signal);
        }
        try {
          await sink(async function* () {
            for await (const chunk of source2) {
              yield chunk instanceof Uint8Array ? chunk : chunk.slice();
            }
          }());
        } catch (err) {
          if (err.type !== "aborted") {
            log.error(err);
          }
        }
      },
      source: options.signal ? abortable(source, options.signal) : source,
      conn: socket,
      localAddr,
      remoteAddr,
      timeline: {open: Date.now()},
      close() {
        if (socket.destroyed)
          return;
        return new Promise((resolve, reject) => {
          const start = Date.now();
          const timeout = setTimeout(() => {
            if (maConn.remoteAddr) {
              const {host, port} = maConn.remoteAddr.toOptions();
              log("timeout closing socket to %s:%s after %dms, destroying it manually", host, port, Date.now() - start);
            }
            if (!socket.destroyed) {
              socket.destroy();
            }
          }, CLOSE_TIMEOUT);
          socket.once("close", () => {
            resolve();
          });
          socket.end((err) => {
            clearTimeout(timeout);
            maConn.timeline.close = Date.now();
            if (err)
              return reject(err);
          });
        });
      }
    };
    socket.once("close", () => {
      if (!maConn.timeline.close) {
        maConn.timeline.close = Date.now();
      }
    });
    return maConn;
  };
});

// node_modules/libp2p-webrtc-star/src/utils.js
var require_utils30 = __commonJS((exports2, module2) => {
  "use strict";
  var multiaddr = require_src11();
  function cleanUrlSIO(ma) {
    const maStrSplit = ma.toString().split("/");
    const tcpProto = ma.protos()[1].name;
    const wsProto = ma.protos()[2].name;
    const tcpPort = ma.stringTuples()[1][1];
    if (tcpProto !== "tcp" || wsProto !== "ws" && wsProto !== "wss") {
      throw new Error("invalid multiaddr: " + ma.toString());
    }
    if (!multiaddr.isName(ma)) {
      return "http://" + maStrSplit[2] + ":" + maStrSplit[4];
    }
    if (wsProto === "ws") {
      return "http://" + maStrSplit[2] + (tcpPort === 80 ? "" : ":" + tcpPort);
    }
    if (wsProto === "wss") {
      return "https://" + maStrSplit[2] + (tcpPort === 443 ? "" : ":" + tcpPort);
    }
  }
  function cleanMultiaddr(maStr) {
    const legacy = "/libp2p-webrtc-star";
    if (maStr.indexOf(legacy) !== -1) {
      maStr = maStr.substring(legacy.length, maStr.length);
      let ma = multiaddr(maStr);
      const tuppleIPFS = ma.stringTuples().filter((tupple) => {
        return tupple[0] === 421;
      })[0];
      ma = ma.decapsulate("p2p");
      ma = ma.encapsulate("/p2p-webrtc-star");
      ma = ma.encapsulate(`/p2p/${tuppleIPFS[1]}`);
      maStr = ma.toString();
    }
    return maStr;
  }
  module2.exports = {
    cleanUrlSIO,
    cleanMultiaddr
  };
});

// node_modules/libp2p-webrtc-star/src/listener.js
var require_listener2 = __commonJS((exports2, module2) => {
  "use strict";
  var EventEmitter = require_events();
  var debug = require_browser4();
  var log = debug("libp2p:webrtc-star:listener");
  log.error = debug("libp2p:webrtc-star:listener:error");
  var multiaddr = require_src11();
  var io = require_build3();
  var SimplePeer = require_libp2p_webrtc_peer();
  var pDefer = require_p_defer();
  var toConnection = require_socket_to_conn2();
  var {cleanUrlSIO} = require_utils30();
  var {CODE_P2P} = require_constants17();
  var sioOptions = {
    transports: ["websocket"],
    "force new connection": true,
    path: "/socket.io-next/"
  };
  module2.exports = ({handler, upgrader}, WebRTCStar, options = {}) => {
    const listener = new EventEmitter();
    let listeningAddr;
    listener.__connections = [];
    listener.__spChannels = new Map();
    listener.__pendingIntents = new Map();
    listener.listen = (ma) => {
      const defer = pDefer();
      listeningAddr = ma;
      if (!ma.protoCodes().includes(CODE_P2P) && upgrader.localPeer) {
        WebRTCStar._signallingAddr = ma.encapsulate(`/p2p/${upgrader.localPeer.toB58String()}`);
      } else {
        WebRTCStar._signallingAddr = ma;
      }
      const sioUrl = cleanUrlSIO(ma);
      log("Dialing to Signalling Server on: " + sioUrl);
      listener.io = io.connect(sioUrl, sioOptions);
      const incommingDial = (offer) => {
        if (offer.answer || offer.err || !offer.intentId) {
          return;
        }
        const intentId = offer.intentId;
        let pendings = listener.__pendingIntents.get(intentId);
        if (!pendings) {
          pendings = [];
          listener.__pendingIntents.set(intentId, pendings);
        }
        let channel = listener.__spChannels.get(intentId);
        if (channel) {
          channel.signal(offer.signal);
          return;
        } else if (offer.signal.type !== "offer") {
          pendings.push(offer);
          return;
        }
        const spOptions = {
          trickle: false,
          ...options
        };
        if (WebRTCStar.wrtc) {
          spOptions.wrtc = WebRTCStar.wrtc;
        }
        channel = new SimplePeer(spOptions);
        const onError = (err) => {
          log.error("incoming connectioned errored", err);
        };
        channel.on("error", onError);
        channel.once("close", (...args) => {
          channel.removeListener("error", onError);
        });
        channel.on("signal", (signal) => {
          offer.signal = signal;
          offer.answer = true;
          listener.io.emit("ss-handshake", offer);
        });
        channel.signal(offer.signal);
        for (const pendingOffer of pendings) {
          channel.signal(pendingOffer.signal);
        }
        listener.__pendingIntents.set(intentId, []);
        channel.once("connect", async () => {
          const maConn = toConnection(channel);
          log("new inbound connection %s", maConn.remoteAddr);
          let conn;
          try {
            conn = await upgrader.upgradeInbound(maConn);
          } catch (err) {
            log.error("inbound connection failed to upgrade", err);
            return maConn.close();
          }
          if (!conn.remoteAddr) {
            try {
              conn.remoteAddr = ma.decapsulateCode(CODE_P2P).encapsulate(`/p2p/${conn.remotePeer.toB58String()}`);
            } catch (err) {
              log.error("could not determine remote address", err);
            }
          }
          log("inbound connection %s upgraded", maConn.remoteAddr);
          trackConn(listener, maConn, intentId);
          listener.emit("connection", conn);
          handler(conn);
        });
        listener.__spChannels.set(intentId, channel);
      };
      listener.io.once("connect_error", (err) => defer.reject(err));
      listener.io.once("error", (err) => {
        listener.emit("error", err);
        listener.emit("close");
      });
      listener.io.on("ws-handshake", incommingDial);
      listener.io.on("ws-peer", WebRTCStar._peerDiscovered);
      listener.io.on("connect", () => {
        listener.io.emit("ss-join", WebRTCStar._signallingAddr.toString());
      });
      listener.io.once("connect", () => {
        listener.emit("listening");
        defer.resolve();
      });
      return defer.promise;
    };
    listener.close = async () => {
      listener.io && listener.io.emit("ss-leave");
      await Promise.all(listener.__connections.map((maConn) => maConn.close()));
      listener.emit("close");
    };
    listener.getAddrs = () => {
      return [listeningAddr];
    };
    WebRTCStar.listenersRefs[multiaddr.toString()] = listener;
    return listener;
  };
  function trackConn(listener, maConn, intentId) {
    listener.__connections.push(maConn);
    const untrackConn = () => {
      listener.__connections = listener.__connections.filter((c) => c !== maConn);
      listener.__spChannels.delete(intentId);
      listener.__pendingIntents.delete(intentId);
    };
    maConn.conn.once("close", untrackConn);
  }
});

// node_modules/libp2p-webrtc-star/src/index.js
var require_src46 = __commonJS((exports2, module2) => {
  "use strict";
  var debug = require_browser4();
  var log = debug("libp2p:webrtc-star");
  log.error = debug("libp2p:webrtc-star:error");
  var {EventEmitter} = require_events();
  var errcode = require_err_code();
  var withIs = require_class_is();
  var {AbortError} = require_abortable_iterator();
  var SimplePeer = require_libp2p_webrtc_peer();
  var {supportsWebRTCDataChannels: webrtcSupport} = require_supports();
  var multiaddr = require_src11();
  var mafmt = require_src12();
  var PeerId = require_src9();
  var {CODE_CIRCUIT} = require_constants17();
  var createListener = require_listener2();
  var toConnection = require_socket_to_conn2();
  var {cleanMultiaddr} = require_utils30();
  function noop() {
  }
  var WebRTCStar = class {
    constructor(options = {}) {
      if (!options.upgrader) {
        throw new Error("An upgrader must be provided. See https://github.com/libp2p/interface-transport#upgrader.");
      }
      this._upgrader = options.upgrader;
      this._signallingAddr = void 0;
      this.sioOptions = {
        transports: ["websocket"],
        "force new connection": true
      };
      if (options.wrtc) {
        this.wrtc = options.wrtc;
      }
      this.listenersRefs = {};
      this.discovery = new EventEmitter();
      this.discovery.tag = "webRTCStar";
      this.discovery._isStarted = false;
      this.discovery.start = () => {
        this.discovery._isStarted = true;
      };
      this.discovery.stop = () => {
        this.discovery._isStarted = false;
      };
      this._peerDiscovered = this._peerDiscovered.bind(this);
    }
    async dial(ma, options = {}) {
      const rawConn = await this._connect(ma, options);
      const maConn = toConnection(rawConn, {remoteAddr: ma, signal: options.signal});
      log("new outbound connection %s", maConn.remoteAddr);
      const conn = await this._upgrader.upgradeOutbound(maConn);
      log("outbound connection %s upgraded", maConn.remoteAddr);
      return conn;
    }
    _connect(ma, options = {}) {
      if (options.signal && options.signal.aborted) {
        throw new AbortError();
      }
      const spOptions = {
        initiator: true,
        trickle: false,
        ...options.spOptions || {}
      };
      if (this.wrtc) {
        spOptions.wrtc = this.wrtc;
      }
      const cOpts = ma.toOptions();
      const intentId = (~~(Math.random() * 1e9)).toString(36) + Date.now();
      const sioClient = this.listenersRefs[Object.keys(this.listenersRefs)[0]].io;
      return new Promise((resolve, reject) => {
        const start = Date.now();
        let connected;
        log("dialing %s:%s", cOpts.host, cOpts.port);
        const channel = new SimplePeer(spOptions);
        const onError = (err) => {
          if (!connected) {
            const msg = `connection error ${cOpts.host}:${cOpts.port}: ${err.message}`;
            log.error(msg);
            done(err);
          }
        };
        const onTimeout = () => {
          log("connnection timeout %s:%s", cOpts.host, cOpts.port);
          const err = errcode(new Error(`connection timeout after ${Date.now() - start}ms`), "ERR_CONNECT_TIMEOUT");
          channel.emit("error", err);
        };
        const onConnect = () => {
          connected = true;
          log("connection opened %s:%s", cOpts.host, cOpts.port);
          done(null);
        };
        const onAbort = () => {
          log.error("connection aborted %s:%s", cOpts.host, cOpts.port);
          channel.destroy();
          done(new AbortError());
        };
        const done = (err) => {
          channel.removeListener("timeout", onTimeout);
          channel.removeListener("connect", onConnect);
          options.signal && options.signal.removeEventListener("abort", onAbort);
          err ? reject(err) : resolve(channel);
        };
        channel.on("error", onError);
        channel.once("timeout", onTimeout);
        channel.once("connect", onConnect);
        channel.on("close", () => {
          channel.removeListener("error", onError);
        });
        options.signal && options.signal.addEventListener("abort", onAbort);
        channel.on("signal", (signal) => {
          sioClient.emit("ss-handshake", {
            intentId,
            srcMultiaddr: this._signallingAddr.toString(),
            dstMultiaddr: ma.toString(),
            signal
          });
        });
        sioClient.on("ws-handshake", (offer) => {
          if (offer.intentId === intentId && offer.err) {
            reject(errcode(offer.err instanceof Error ? offer.err : new Error(offer.err), "ERR_SIGNALLING_FAILED"));
          }
          if (offer.intentId !== intentId || !offer.answer || channel.destroyed) {
            return;
          }
          channel.signal(offer.signal);
        });
      });
    }
    createListener(options = {}, handler) {
      if (!webrtcSupport && !this.wrtc) {
        throw errcode(new Error("no WebRTC support"), "ERR_NO_WEBRTC_SUPPORT");
      }
      if (typeof options === "function") {
        handler = options;
        options = {};
      }
      handler = handler || noop;
      return createListener({handler, upgrader: this._upgrader}, this, options);
    }
    filter(multiaddrs) {
      multiaddrs = Array.isArray(multiaddrs) ? multiaddrs : [multiaddrs];
      return multiaddrs.filter((ma) => {
        if (ma.protoCodes().includes(CODE_CIRCUIT)) {
          return false;
        }
        return mafmt.WebRTCStar.matches(ma);
      });
    }
    _peerDiscovered(maStr) {
      if (!this.discovery._isStarted)
        return;
      log("Peer Discovered:", maStr);
      maStr = cleanMultiaddr(maStr);
      const ma = multiaddr(maStr);
      const peerId = PeerId.createFromB58String(ma.getPeerId());
      this.discovery.emit("peer", {
        id: peerId,
        multiaddrs: [ma]
      });
    }
  };
  module2.exports = withIs(WebRTCStar, {className: "WebRTCStar", symbolName: "@libp2p/js-libp2p-webrtc-star/webrtcstar"});
});

// node_modules/libp2p-mplex/node_modules/varint/encode.js
var require_encode9 = __commonJS((exports2, module2) => {
  module2.exports = encode;
  var MSB = 128;
  var REST = 127;
  var MSBALL = ~REST;
  var INT = Math.pow(2, 31);
  function encode(num, out, offset) {
    if (Number.MAX_SAFE_INTEGER && num > Number.MAX_SAFE_INTEGER) {
      encode.bytes = 0;
      throw new RangeError("Could not encode varint");
    }
    out = out || [];
    offset = offset || 0;
    var oldOffset = offset;
    while (num >= INT) {
      out[offset++] = num & 255 | MSB;
      num /= 128;
    }
    while (num & MSBALL) {
      out[offset++] = num & 255 | MSB;
      num >>>= 7;
    }
    out[offset] = num | 0;
    encode.bytes = offset - oldOffset + 1;
    return out;
  }
});

// node_modules/libp2p-mplex/node_modules/varint/decode.js
var require_decode9 = __commonJS((exports2, module2) => {
  module2.exports = read;
  var MSB = 128;
  var REST = 127;
  function read(buf, offset) {
    var res = 0, offset = offset || 0, shift = 0, counter = offset, b, l = buf.length;
    do {
      if (counter >= l || shift > 49) {
        read.bytes = 0;
        throw new RangeError("Could not decode varint");
      }
      b = buf[counter++];
      res += shift < 28 ? (b & REST) << shift : (b & REST) * Math.pow(2, shift);
      shift += 7;
    } while (b >= MSB);
    read.bytes = counter - offset;
    return res;
  }
});

// node_modules/libp2p-mplex/node_modules/varint/length.js
var require_length6 = __commonJS((exports2, module2) => {
  var N1 = Math.pow(2, 7);
  var N2 = Math.pow(2, 14);
  var N3 = Math.pow(2, 21);
  var N4 = Math.pow(2, 28);
  var N5 = Math.pow(2, 35);
  var N6 = Math.pow(2, 42);
  var N7 = Math.pow(2, 49);
  var N8 = Math.pow(2, 56);
  var N9 = Math.pow(2, 63);
  module2.exports = function(value) {
    return value < N1 ? 1 : value < N2 ? 2 : value < N3 ? 3 : value < N4 ? 4 : value < N5 ? 5 : value < N6 ? 6 : value < N7 ? 7 : value < N8 ? 8 : value < N9 ? 9 : 10;
  };
});

// node_modules/libp2p-mplex/node_modules/varint/index.js
var require_varint7 = __commonJS((exports2, module2) => {
  module2.exports = {
    encode: require_encode9(),
    decode: require_decode9(),
    encodingLength: require_length6()
  };
});

// node_modules/libp2p-mplex/src/coder/encode.browser.js
var require_encode_browser = __commonJS((exports2, module2) => {
  "use strict";
  var varint = require_varint7();
  var BufferList = require_BufferList();
  var POOL_SIZE = 10 * 1024;
  var Encoder = class {
    constructor() {
      this._pool = new Uint8Array(POOL_SIZE);
      this._poolOffset = 0;
    }
    write(msg) {
      const pool = this._pool;
      let offset = this._poolOffset;
      varint.encode(msg.id << 3 | msg.type, pool, offset);
      offset += varint.encode.bytes;
      varint.encode(msg.data ? msg.data.length : 0, pool, offset);
      offset += varint.encode.bytes;
      const header = pool.subarray(this._poolOffset, offset);
      if (POOL_SIZE - offset < 100) {
        this._pool = new Uint8Array(POOL_SIZE);
        this._poolOffset = 0;
      } else {
        this._poolOffset = offset;
      }
      if (!msg.data)
        return header;
      return [header, msg.data];
    }
  };
  var encoder = new Encoder();
  module2.exports = (source) => async function* encode() {
    for await (const msg of source) {
      if (Array.isArray(msg)) {
        yield new BufferList(msg.map((m) => encoder.write(m)));
      } else {
        yield new BufferList(encoder.write(msg));
      }
    }
  }();
});

// node_modules/libp2p-mplex/src/coder/decode.js
var require_decode10 = __commonJS((exports2, module2) => {
  "use strict";
  var varint = require_varint7();
  var BufferList = require_BufferList();
  module2.exports = (source) => async function* decode() {
    const decoder = new Decoder();
    for await (const chunk of source) {
      const msgs = decoder.write(chunk);
      if (msgs.length)
        yield msgs;
    }
  }();
  var Decoder = class {
    constructor() {
      this._buffer = new BufferList();
      this._bufferProxy = new Proxy({}, {
        get: (_, prop) => prop[0] === "l" ? this._buffer[prop] : this._buffer.get(parseInt(prop))
      });
      this._headerInfo = null;
    }
    write(chunk) {
      if (!chunk || !chunk.length)
        return [];
      this._buffer.append(chunk);
      const msgs = [];
      while (true) {
        if (!this._headerInfo) {
          try {
            this._headerInfo = this._decodeHeader(this._bufferProxy);
          } catch (_) {
            break;
          }
        }
        const {id, type, length, offset} = this._headerInfo;
        const bufferedDataLength = this._buffer.length - offset;
        if (bufferedDataLength < length)
          break;
        msgs.push({id, type, data: this._buffer.shallowSlice(offset, offset + length)});
        this._buffer.consume(offset + length);
        this._headerInfo = null;
      }
      return msgs;
    }
    _decodeHeader(data) {
      const h = varint.decode(data);
      let offset = varint.decode.bytes;
      const length = varint.decode(data, offset);
      offset += varint.decode.bytes;
      return {id: h >> 3, type: h & 7, offset, length};
    }
  };
});

// node_modules/libp2p-mplex/src/coder/index.js
var require_coder = __commonJS((exports2) => {
  "use strict";
  exports2.encode = require_encode_browser();
  exports2.decode = require_decode10();
});

// node_modules/libp2p-mplex/src/restrict-size.js
var require_restrict_size = __commonJS((exports2, module2) => {
  "use strict";
  var MAX_MSG_SIZE = 1 << 20;
  module2.exports = (max) => {
    max = max || MAX_MSG_SIZE;
    const checkSize = (msg) => {
      if (msg.data && msg.data.length > max) {
        throw Object.assign(new Error("message size too large!"), {code: "ERR_MSG_TOO_BIG"});
      }
    };
    return (source) => {
      return async function* restrictSize() {
        for await (const msg of source) {
          if (Array.isArray(msg)) {
            msg.forEach(checkSize);
          } else {
            checkSize(msg);
          }
          yield msg;
        }
      }();
    };
  };
  module2.exports.MAX_MSG_SIZE = MAX_MSG_SIZE;
});

// node_modules/libp2p-mplex/src/message-types.js
var require_message_types = __commonJS((exports2) => {
  "use strict";
  var MessageTypes = Object.freeze({
    NEW_STREAM: 0,
    MESSAGE_RECEIVER: 1,
    MESSAGE_INITIATOR: 2,
    CLOSE_RECEIVER: 3,
    CLOSE_INITIATOR: 4,
    RESET_RECEIVER: 5,
    RESET_INITIATOR: 6
  });
  exports2.MessageTypes = MessageTypes;
  exports2.InitiatorMessageTypes = Object.freeze({
    NEW_STREAM: MessageTypes.NEW_STREAM,
    MESSAGE: MessageTypes.MESSAGE_INITIATOR,
    CLOSE: MessageTypes.CLOSE_INITIATOR,
    RESET: MessageTypes.RESET_INITIATOR
  });
  exports2.ReceiverMessageTypes = Object.freeze({
    MESSAGE: MessageTypes.MESSAGE_RECEIVER,
    CLOSE: MessageTypes.CLOSE_RECEIVER,
    RESET: MessageTypes.RESET_RECEIVER
  });
  exports2.MessageTypeNames = Object.freeze(Object.entries(MessageTypes).reduce((obj, e) => {
    obj[e[1]] = e[0];
    return obj;
  }, {}));
});

// node_modules/libp2p-mplex/src/stream.js
var require_stream = __commonJS((exports2, module2) => {
  "use strict";
  var abortable = require_abortable_iterator();
  var AbortController = require_browser3();
  var log = require_browser4()("libp2p:mplex:stream");
  var pushable = require_it_pushable();
  var BufferList = require_BufferList();
  var errCode = require_err_code();
  var {MAX_MSG_SIZE} = require_restrict_size();
  var {InitiatorMessageTypes, ReceiverMessageTypes} = require_message_types();
  var ERR_MPLEX_STREAM_RESET = "ERR_MPLEX_STREAM_RESET";
  var ERR_MPLEX_STREAM_ABORT = "ERR_MPLEX_STREAM_ABORT";
  module2.exports = ({id, name, send, onEnd = () => {
  }, type = "initiator", maxMsgSize = MAX_MSG_SIZE}) => {
    const abortController = new AbortController();
    const resetController = new AbortController();
    const Types = type === "initiator" ? InitiatorMessageTypes : ReceiverMessageTypes;
    const externalId = type === "initiator" ? `i${id}` : `r${id}`;
    name = String(name == null ? id : name);
    let sourceEnded = false;
    let sinkEnded = false;
    let endErr;
    const onSourceEnd = (err) => {
      if (sourceEnded)
        return;
      sourceEnded = true;
      log("%s stream %s source end", type, name, err);
      if (err && !endErr)
        endErr = err;
      if (sinkEnded) {
        stream.timeline.close = Date.now();
        onEnd(endErr);
      }
    };
    const onSinkEnd = (err) => {
      if (sinkEnded)
        return;
      sinkEnded = true;
      log("%s stream %s sink end", type, name, err);
      if (err && !endErr)
        endErr = err;
      if (sourceEnded) {
        stream.timeline.close = Date.now();
        onEnd(endErr);
      }
    };
    const stream = {
      close: () => stream.source.end(),
      abort: (err) => {
        log("%s stream %s abort", type, name, err);
        stream.source.end(err);
        abortController.abort();
        onSinkEnd(err);
      },
      reset: () => {
        const err = errCode(new Error("stream reset"), ERR_MPLEX_STREAM_RESET);
        resetController.abort();
        stream.source.end(err);
        onSinkEnd(err);
      },
      sink: async (source) => {
        source = abortable(source, [
          {signal: abortController.signal, options: {abortMessage: "stream aborted", abortCode: ERR_MPLEX_STREAM_ABORT}},
          {signal: resetController.signal, options: {abortMessage: "stream reset", abortCode: ERR_MPLEX_STREAM_RESET}}
        ]);
        if (type === "initiator") {
          send({id, type: Types.NEW_STREAM, data: name});
        }
        try {
          for await (let data of source) {
            while (data.length) {
              if (data.length <= maxMsgSize) {
                send({id, type: Types.MESSAGE, data});
                break;
              }
              data = BufferList.isBufferList(data) ? data : new BufferList(data);
              send({id, type: Types.MESSAGE, data: data.shallowSlice(0, maxMsgSize)});
              data.consume(maxMsgSize);
            }
          }
        } catch (err) {
          if (err.code === ERR_MPLEX_STREAM_RESET) {
            log("%s stream %s reset", type, name);
          } else {
            log("%s stream %s error", type, name, err);
            send({id, type: Types.RESET});
          }
          stream.source.end(err);
          return onSinkEnd(err);
        }
        send({id, type: Types.CLOSE});
        onSinkEnd();
      },
      source: pushable(onSourceEnd),
      timeline: {
        open: Date.now(),
        close: null
      },
      id: externalId
    };
    return stream;
  };
});

// node_modules/libp2p-mplex/src/mplex.js
var require_mplex = __commonJS((exports2, module2) => {
  "use strict";
  var pipe = require_it_pipe();
  var pushable = require_it_pushable();
  var log = require_browser4()("libp2p:mplex");
  var abortable = require_abortable_iterator();
  var Coder = require_coder();
  var restrictSize = require_restrict_size();
  var {MessageTypes, MessageTypeNames} = require_message_types();
  var createStream = require_stream();
  var Mplex = class {
    constructor(options) {
      options = options || {};
      options = typeof options === "function" ? {onStream: options} : options;
      this._streamId = 0;
      this._streams = {
        initiators: new Map(),
        receivers: new Map()
      };
      this._options = options;
      this.sink = this._createSink();
      this.source = this._createSource();
      this.onStream = options.onStream;
      this.onStreamEnd = options.onStreamEnd;
    }
    get streams() {
      const streams = [];
      this._streams.initiators.forEach((stream) => {
        streams.push(stream);
      });
      this._streams.receivers.forEach((stream) => {
        streams.push(stream);
      });
      return streams;
    }
    newStream(name) {
      const id = this._streamId++;
      name = name == null ? id.toString() : String(name);
      const registry = this._streams.initiators;
      return this._newStream({id, name, type: "initiator", registry});
    }
    _newReceiverStream({id, name}) {
      const registry = this._streams.receivers;
      return this._newStream({id, name, type: "receiver", registry});
    }
    _newStream({id, name, type, registry}) {
      if (registry.has(id)) {
        throw new Error(`${type} stream ${id} already exists!`);
      }
      log("new %s stream %s %s", type, id, name);
      const send = (msg) => {
        if (log.enabled) {
          log("%s stream %s %s send", type, id, name, {...msg, type: MessageTypeNames[msg.type], data: msg.data && msg.data.slice()});
        }
        return this.source.push(msg);
      };
      const onEnd = () => {
        log("%s stream %s %s ended", type, id, name);
        registry.delete(id);
        this.onStreamEnd && this.onStreamEnd(stream);
      };
      const stream = createStream({id, name, send, type, onEnd, maxMsgSize: this._options.maxMsgSize});
      registry.set(id, stream);
      return stream;
    }
    _createSink() {
      return async (source) => {
        if (this._options.signal) {
          source = abortable(source, this._options.signal);
        }
        try {
          await pipe(source, Coder.decode, restrictSize(this._options.maxMsgSize), async (source2) => {
            for await (const msgs of source2) {
              for (const msg of msgs) {
                this._handleIncoming(msg);
              }
            }
          });
        } catch (err) {
          log("error in sink", err);
          return this.source.end(err);
        }
        this.source.end();
      };
    }
    _createSource() {
      const onEnd = (err) => {
        const {initiators, receivers} = this._streams;
        for (const s of initiators.values())
          s.abort(err);
        for (const s of receivers.values())
          s.abort(err);
      };
      const source = pushable({onEnd, writev: true});
      return Object.assign(Coder.encode(source), {
        push: source.push,
        end: source.end,
        return: source.return
      });
    }
    _handleIncoming({id, type, data}) {
      if (log.enabled) {
        log("incoming message", {id, type: MessageTypeNames[type], data: data.slice()});
      }
      if (type === MessageTypes.NEW_STREAM && this.onStream) {
        const stream2 = this._newReceiverStream({id, name: data.toString()});
        return this.onStream(stream2);
      }
      const list = type & 1 ? this._streams.initiators : this._streams.receivers;
      const stream = list.get(id);
      if (!stream)
        return log("missing stream %s", id);
      switch (type) {
        case MessageTypes.MESSAGE_INITIATOR:
        case MessageTypes.MESSAGE_RECEIVER:
          stream.source.push(data);
          break;
        case MessageTypes.CLOSE_INITIATOR:
        case MessageTypes.CLOSE_RECEIVER:
          stream.close();
          break;
        case MessageTypes.RESET_INITIATOR:
        case MessageTypes.RESET_RECEIVER:
          stream.reset();
          break;
        default:
          log("unknown message type %s", type);
      }
    }
  };
  Mplex.multicodec = "/mplex/6.7.0";
  module2.exports = Mplex;
});

// node_modules/libp2p-mplex/src/index.js
var require_src47 = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = require_mplex();
});

// node_modules/bcrypto/lib/internal/assert.js
var require_assert2 = __commonJS((exports2, module2) => {
  /*!
   * assert.js - assert for bcrypto
   * Copyright (c) 2020, Christopher Jeffrey (MIT License).
   * https://github.com/bcoin-org/bcrypto
   */
  "use strict";
  function assert(val, msg) {
    if (!val) {
      const err = new Error(msg || "Assertion failed");
      if (Error.captureStackTrace)
        Error.captureStackTrace(err, assert);
      throw err;
    }
  }
  module2.exports = assert;
});

// node_modules/bcrypto/lib/internal/custom-browser.js
var require_custom_browser = __commonJS((exports2) => {
  /*!
   * custom.js - custom inspect symbol for bcrypto
   * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).
   * https://github.com/bcoin-org/bcrypto
   */
  "use strict";
  exports2.custom = "inspect";
});

// node_modules/bcrypto/lib/js/bn.js
var require_bn2 = __commonJS((exports2, module2) => {
  /*!
   * bn.js - big numbers for bcrypto
   * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).
   * https://github.com/bcoin-org/bcrypto
   *
   * Parts of this software are based on indutny/bn.js:
   *   Copyright (c) 2015, Fedor Indutny (MIT License).
   *   https://github.com/indutny/bn.js
   *
   * Parts of this software are based on golang/go:
   *   Copyright (c) 2009, The Go Authors. All rights reserved.
   *   https://github.com/golang/go
   *
   * Parts of this software are based on openssl/openssl:
   *   Copyright (c) 1998-2018, The OpenSSL Project (Apache License v2.0).
   *   Copyright (c) 1995-1998, Eric A. Young, Tim J. Hudson. All rights reserved.
   *   https://github.com/openssl/openssl
   *
   * Parts of this software are based on libgmp:
   *   Copyright (c) 1991-1997, 1999-2014, Free Software Foundation, Inc.
   *   https://gmplib.org/
   *
   * Parts of this software are based on v8/v8:
   *   Copyright (c) 2017, The V8 Project Authors (BSD-Style License).
   *   https://github.com/v8/v8
   *
   * Resources:
   *   https://github.com/indutny/bn.js/blob/master/lib/bn.js
   *   https://github.com/indutny/miller-rabin/blob/master/lib/mr.js
   *   https://github.com/golang/go/blob/master/src/math/big/int.go
   *   https://github.com/golang/go/blob/master/src/math/big/nat.go
   *   https://github.com/golang/go/blob/master/src/math/big/prime.go
   *   https://github.com/openssl/openssl/tree/master/crypto/bn
   *   https://github.com/openssl/openssl/blob/master/crypto/bn/bn_kron.c
   *   https://github.com/gnutls/nettle/blob/master/mini-gmp.c
   *   https://github.com/v8/v8/blob/master/src/objects/bigint.cc
   */
  "use strict";
  var {custom} = require_custom_browser();
  var zeros = [
    "",
    "0",
    "00",
    "000",
    "0000",
    "00000",
    "000000",
    "0000000",
    "00000000",
    "000000000",
    "0000000000",
    "00000000000",
    "000000000000",
    "0000000000000",
    "00000000000000",
    "000000000000000",
    "0000000000000000",
    "00000000000000000",
    "000000000000000000",
    "0000000000000000000",
    "00000000000000000000",
    "000000000000000000000",
    "0000000000000000000000",
    "00000000000000000000000",
    "000000000000000000000000",
    "0000000000000000000000000"
  ];
  var groupSizes = [
    0,
    25,
    16,
    12,
    11,
    10,
    9,
    8,
    8,
    7,
    7,
    7,
    7,
    6,
    6,
    6,
    6,
    6,
    6,
    6,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5,
    5
  ];
  var groupBases = [
    0,
    33554432,
    43046721,
    16777216,
    48828125,
    60466176,
    40353607,
    16777216,
    43046721,
    1e7,
    19487171,
    35831808,
    62748517,
    7529536,
    11390625,
    16777216,
    24137569,
    34012224,
    47045881,
    64e6,
    4084101,
    5153632,
    6436343,
    7962624,
    9765625,
    11881376,
    14348907,
    17210368,
    20511149,
    243e5,
    28629151,
    33554432,
    39135393,
    45435424,
    52521875,
    60466176
  ];
  var primes = {
    p192: null,
    p224: null,
    p521: null,
    k256: null,
    p251: null,
    p25519: null,
    p448: null
  };
  var modes = {
    NONE: 0,
    QUO: 1,
    REM: 2,
    BOTH: 3,
    EUCLID: 4,
    ALL: 7
  };
  var WND_WIDTH = 4;
  var WND_SIZE = 1 << WND_WIDTH - 1;
  var HAS_BIGINT = typeof BigInt === "function";
  var BN = class {
    constructor(num, base, endian) {
      this.words = [0];
      this.length = 1;
      this.negative = 0;
      this.red = null;
      this.from(num, base, endian);
    }
    _iadd(a, b) {
      let carry = 0;
      let i = 0;
      if (a.length < b.length)
        [a, b] = [b, a];
      if (a !== this)
        this._alloc(a.length);
      for (; i < b.length; i++) {
        const r = (a.words[i] | 0) + (b.words[i] | 0) + carry;
        this.words[i] = r & 67108863;
        carry = r >>> 26;
      }
      for (; carry !== 0 && i < a.length; i++) {
        const r = (a.words[i] | 0) + carry;
        this.words[i] = r & 67108863;
        carry = r >>> 26;
      }
      this.length = a.length;
      if (carry !== 0) {
        this._alloc(this.length + 1);
        this.words[this.length++] = carry;
      } else if (a !== this) {
        for (; i < a.length; i++)
          this.words[i] = a.words[i];
      }
      return this;
    }
    _iaddn(num) {
      this.words[0] += num;
      if (this.words[0] < 67108864)
        return this;
      let i = 0;
      this._alloc(this.length + 1);
      this.words[this.length] = 0;
      for (; i < this.length && this.words[i] >= 67108864; i++) {
        this.words[i] -= 67108864;
        this.words[i + 1] += 1;
      }
      this.length = Math.max(this.length, i + 1);
      return this;
    }
    iadd(num) {
      enforce(BN.isBN(num), "num", "bignum");
      if (this.negative === num.negative) {
        this._iadd(this, num);
      } else {
        const cmp = this.ucmp(num);
        if (cmp === 0) {
          this.words[0] = 0;
          this.length = 1;
          this.negative = 0;
          return this;
        }
        if (cmp < 0) {
          this._isub(num, this);
          this.negative ^= 1;
        } else {
          this._isub(this, num);
        }
      }
      return this;
    }
    iaddn(num) {
      enforce(isSMI(num), "num", "smi");
      const negative = num < 0 | 0;
      if (negative)
        num = -num;
      if (this.negative === negative) {
        this._iaddn(num);
      } else {
        if (this.length === 1 && this.words[0] < num) {
          this.words[0] = num - this.words[0];
          this.negative ^= 1;
        } else {
          this._isubn(num);
        }
      }
      return this;
    }
    add(num) {
      enforce(BN.isBN(num), "num", "bignum");
      if (num.length > this.length)
        return num.clone().iadd(this);
      return this.clone().iadd(num);
    }
    addn(num) {
      return this.clone().iaddn(num);
    }
    _isub(a, b) {
      let carry = 0;
      let i = 0;
      assert(a.length >= b.length);
      if (a !== this)
        this._alloc(a.length);
      for (; i < b.length; i++) {
        const r = (a.words[i] | 0) - (b.words[i] | 0) + carry;
        carry = r >> 26;
        this.words[i] = r & 67108863;
      }
      for (; carry !== 0 && i < a.length; i++) {
        const r = (a.words[i] | 0) + carry;
        carry = r >> 26;
        this.words[i] = r & 67108863;
      }
      assert(carry === 0);
      if (a !== this) {
        for (; i < a.length; i++)
          this.words[i] = a.words[i];
      }
      this.length = Math.max(this.length, i);
      return this._strip();
    }
    _isubn(num) {
      this.words[0] -= num;
      if (this.words[0] >= 0)
        return this._normalize();
      assert(this.length !== 1);
      this._alloc(this.length + 1);
      for (let i = 0; i < this.length && this.words[i] < 0; i++) {
        this.words[i] += 67108864;
        this.words[i + 1] -= 1;
      }
      this.words[this.length] = 0;
      return this._strip();
    }
    isub(num) {
      enforce(BN.isBN(num), "num", "bignum");
      if (this.negative !== num.negative) {
        this._iadd(this, num);
      } else {
        const cmp = this.ucmp(num);
        if (cmp === 0) {
          this.words[0] = 0;
          this.length = 1;
          this.negative = 0;
          return this;
        }
        if (cmp < 0) {
          this._isub(num, this);
          this.negative ^= 1;
        } else {
          this._isub(this, num);
        }
      }
      return this;
    }
    isubn(num) {
      enforce(isSMI(num), "num", "smi");
      const negative = num < 0 | 0;
      if (negative)
        num = -num;
      if (this.negative !== negative) {
        this._iaddn(num);
      } else {
        if (this.length === 1 && this.words[0] < num) {
          this.words[0] = num - this.words[0];
          this.negative ^= 1;
        } else {
          this._isubn(num);
        }
      }
      return this;
    }
    sub(num) {
      return this.clone().isub(num);
    }
    subn(num) {
      return this.clone().isubn(num);
    }
    _mul(num, out) {
      enforce(BN.isBN(num), "num", "bignum");
      enforce(BN.isBN(out), "out", "bignum");
      if (this.length === 10 && num.length === 10)
        return comb10MulTo(this, num, out);
      const len = this.length + num.length;
      if (len < 63)
        return smallMulTo(this, num, out);
      if (len < 1024)
        return bigMulTo(this, num, out);
      return jumboMulTo(this, num, out);
    }
    imul(num) {
      return this.mul(num)._move(this);
    }
    imuln(num) {
      enforce(isSMI(num), "num", "smi");
      const neg = num < 0 | 0;
      if (neg)
        num = -num;
      let carry = 0;
      for (let i = 0; i < this.length; i++) {
        const w = this.words[i] * num;
        const lo = (w & 67108863) + (carry & 67108863);
        carry >>= 26;
        carry += w / 67108864 | 0;
        carry += lo >>> 26;
        this.words[i] = lo & 67108863;
      }
      this.negative ^= neg;
      if (carry !== 0) {
        this._alloc(this.length + 1);
        this.words[this.length++] = carry;
      } else {
        this._strip();
      }
      return this;
    }
    mul(num) {
      enforce(BN.isBN(num), "num", "bignum");
      const len = this.length + num.length;
      const out = new BN();
      out.words = new Array(len);
      for (let i = 0; i < len; i++)
        out.words[i] = 0;
      return this._mul(num, out);
    }
    muln(num) {
      return this.clone().imuln(num);
    }
    mulShift(num, bits) {
      enforce(BN.isBN(num), "num", "bignum");
      enforce(bits >>> 0 === bits, "bits", "uint32");
      const r = this.mul(num);
      const b = r.utestn(bits - 1);
      r.iushrn(bits);
      if (this.negative ^ num.negative)
        return r.isubn(b);
      return r.iaddn(b);
    }
    _div(num, flags) {
      enforce(BN.isBN(num), "num", "bignum");
      assert((flags & modes.ALL) === flags);
      assert(flags !== modes.NONE);
      const a = this;
      const b = num;
      nonzero(!b.isZero());
      if (a.isZero())
        return [new BN(0), new BN(0)];
      const as = a.negative;
      const bs = b.negative;
      a.negative = 0;
      b.negative = 0;
      let q = null;
      let r = null;
      if (a.ucmp(b) < 0) {
        if (flags & modes.QUO)
          q = new BN(0);
        if (flags & modes.REM)
          r = a.clone();
      } else if (b.length === 1) {
        if (flags & modes.QUO)
          q = a.quon(b.words[0]);
        if (flags & modes.REM)
          r = a.remn(b.words[0]);
      } else {
        [q, r] = a._wordDiv(b, flags);
      }
      a.negative = as;
      b.negative = bs;
      if (flags & modes.QUO) {
        q.negative = a.negative ^ b.negative;
        q._normalize();
      }
      if (flags & modes.REM) {
        r.negative = a.negative;
        r._normalize();
      }
      if (flags & modes.EUCLID) {
        if (flags & modes.QUO) {
          assert((flags & modes.REM) !== 0);
          if (r.negative !== 0) {
            if (b.negative !== 0)
              q.iaddn(1);
            else
              q.isubn(1);
          }
        }
        if (flags & modes.REM) {
          if (r.negative !== 0) {
            if (b.negative !== 0)
              r.isub(b);
            else
              r.iadd(b);
          }
        }
      }
      return [q, r];
    }
    _wordDiv(num, flags) {
      let a = this.clone();
      let b = num;
      let q = null;
      let hi;
      const word = b.words[b.length - 1] | 0;
      const shift = 26 - countBits(word);
      if (shift !== 0) {
        b = b.clone();
        a.iushln(shift);
        b.iushln(shift);
        hi = b.words[b.length - 1] | 0;
      } else {
        hi = word;
      }
      const m = a.length - b.length;
      assert(m >= 0);
      if (flags & modes.QUO) {
        q = new BN(0);
        q.length = m + 1;
        q.words = new Array(q.length);
        for (let i = 0; i < q.length; i++)
          q.words[i] = 0;
      }
      const d = a.clone();
      d._ishlnsubmul(b, 1, m);
      if (d.negative === 0) {
        if (q)
          q.words[m] = 1;
        a = d;
      }
      for (let j = m - 1; j >= 0; j--) {
        const ahi = a.words[b.length + j];
        const alo = a.words[b.length + j - 1];
        const quo = (ahi * 67108864 + alo) / hi | 0;
        let qj = Math.min(quo, 67108863);
        a._ishlnsubmul(b, qj, j);
        while (a.negative !== 0) {
          qj -= 1;
          a.negative = 0;
          a._ishlnsubmul(b, 1, j);
          a.ineg();
        }
        if (q)
          q.words[j] = qj;
      }
      if (q)
        q._strip();
      if (flags & modes.REM && shift !== 0)
        a.iushrn(shift);
      return [q, a];
    }
    _ishlnsubmul(num, mul, shift) {
      let carry = 0;
      let i = 0;
      this._expand(num.length + shift);
      for (; i < num.length; i++) {
        const k = (this.words[i + shift] | 0) + carry;
        const r = num.words[i] * mul;
        const w = k - (r & 67108863);
        carry = (w >> 26) - (r / 67108864 | 0);
        this.words[i + shift] = w & 67108863;
      }
      for (; i < this.length - shift; i++) {
        const w = (this.words[i + shift] | 0) + carry;
        carry = w >> 26;
        this.words[i + shift] = w & 67108863;
      }
      if (carry === 0)
        return this._strip();
      assert(carry === -1);
      carry = 0;
      for (let i2 = 0; i2 < this.length; i2++) {
        const w = -(this.words[i2] | 0) + carry;
        carry = w >> 26;
        this.words[i2] = w & 67108863;
      }
      this.negative = 1;
      return this._strip();
    }
    quorem(num) {
      return this._div(num, modes.BOTH);
    }
    iquo(num) {
      return this.quo(num)._move(this);
    }
    iquon(num) {
      enforce(isSMI(num), "num", "smi");
      nonzero(num !== 0);
      const neg = num < 0 | 0;
      if (neg)
        num = -num;
      let carry = 0;
      for (let i = this.length - 1; i >= 0; i--) {
        const w = (this.words[i] | 0) + carry * 67108864;
        this.words[i] = w / num | 0;
        carry = w % num;
      }
      this.negative ^= neg;
      return this._strip();
    }
    quo(num) {
      return this._div(num, modes.QUO)[0];
    }
    quon(num) {
      return this.clone().iquon(num);
    }
    irem(num) {
      return this.rem(num)._move(this);
    }
    iremn(num) {
      let m = this.remrn(num);
      if (m < 0)
        m = -m;
      this.words[0] = m;
      this.length = 1;
      return this._normalize();
    }
    rem(num) {
      return this._div(num, modes.REM)[1];
    }
    remn(num) {
      return this.clone().iremn(num);
    }
    remrn(num) {
      enforce(isSMI(num), "num", "smi");
      nonzero(num !== 0);
      if (num < 0)
        num = -num;
      const p = (1 << 26) % num;
      let acc = 0;
      for (let i = this.length - 1; i >= 0; i--)
        acc = (p * acc + (this.words[i] | 0)) % num;
      return this.negative !== 0 ? -acc | 0 : acc;
    }
    divmod(num) {
      return this._div(num, modes.BOTH | modes.EUCLID);
    }
    idiv(num) {
      return this.div(num)._move(this);
    }
    idivn(num) {
      if (this.negative === 0)
        return this.iquon(num);
      const r = this.remrn(num);
      this.iquon(num);
      if (r < 0) {
        if (num < 0)
          this.iaddn(1);
        else
          this.isubn(1);
      }
      return this;
    }
    div(num) {
      return this._div(num, modes.BOTH | modes.EUCLID)[0];
    }
    divn(num) {
      return this.clone().idivn(num);
    }
    imod(num) {
      if (this.ucmp(num) < 0) {
        if (this.negative !== 0) {
          this._isub(num, this);
          this.negative = 0;
        }
        return this;
      }
      return this.mod(num)._move(this);
    }
    imodn(num) {
      this.words[0] = this.modrn(num);
      this.length = 1;
      this.negative = 0;
      return this;
    }
    mod(num) {
      return this._div(num, modes.REM | modes.EUCLID)[1];
    }
    modn(num) {
      return this.clone().imodn(num);
    }
    modrn(num) {
      enforce(isSMI(num), "num", "smi");
      let r = this.remrn(num);
      if (r < 0) {
        if (num < 0)
          r -= num;
        else
          r += num;
      }
      return r;
    }
    divRound(num) {
      const [q, r] = this.quorem(num);
      if (r.isZero())
        return q;
      const bit = num.words[0] & 1;
      num.iushrn(1);
      const cmp = r.ucmp(num);
      num.iushln(1);
      num.words[0] |= bit;
      if (cmp < 0 || num.isOdd() && cmp === 0)
        return q;
      if (this.negative ^ num.negative)
        return q.isubn(1);
      return q.iaddn(1);
    }
    ipow(num) {
      return this.pow(num)._move(this);
    }
    ipown(num) {
      return this.pown(num)._move(this);
    }
    pow(num) {
      enforce(BN.isBN(num), "num", "bignum");
      let b = countBits(num.words[num.length - 1]);
      let r = new BN(1);
      for (let i = num.length - 1; i >= 0; i--) {
        const word = num.words[i];
        for (let j = b - 1; j >= 0; j--) {
          r = r.sqr();
          if (word >> j & 1)
            r = r.mul(this);
        }
        b = 26;
      }
      return r;
    }
    pown(num) {
      enforce(isSMI(num), "num", "smi");
      if (num < 0)
        num = -num;
      if (num === 0)
        return new BN(1);
      if (num === 1)
        return this.clone();
      const bits = countBits(num);
      let r = this;
      for (let i = bits - 2; i >= 0; i--) {
        r = r.sqr();
        if (num >> i & 1)
          r = r.mul(this);
      }
      return r;
    }
    isqr() {
      return this.imul(this);
    }
    sqr() {
      return this.mul(this);
    }
    _rootrem(pow, rem) {
      enforce(pow >>> 0 === pow, "num", "uint32");
      if (pow === 0)
        throw new RangeError("Zeroth root.");
      if (~pow & this.negative)
        throw new RangeError("Negative with even root.");
      if (this.ucmpn(1) <= 0)
        return [this.clone(), new BN(0)];
      let u = new BN(0);
      let t = BN.shift(1, this.bitLength() / pow + 1 | 0);
      let v, r;
      if (this.negative !== 0)
        t.ineg();
      if (pow === 2) {
        do {
          u = t;
          t = this.quo(u);
          t.iadd(u);
          t.iushrn(1);
        } while (t.ucmp(u) < 0);
      } else {
        do {
          u = t;
          t = u.pown(pow - 1);
          t = this.quo(t);
          v = u.muln(pow - 1);
          t.iadd(v);
          t = t.quon(pow);
        } while (t.ucmp(u) < 0);
      }
      if (rem) {
        t = u.pown(pow);
        r = this.sub(t);
      }
      return [u, r];
    }
    rootrem(pow) {
      return this._rootrem(pow, 1);
    }
    iroot(pow) {
      return this.root(pow)._move(this);
    }
    root(pow) {
      return this._rootrem(pow, 0)[0];
    }
    isPower(pow) {
      enforce(pow >>> 0 === pow, "num", "uint32");
      if (pow === 0 || ~pow & this.negative)
        return false;
      const [, r] = this.rootrem(pow);
      return r.sign() === 0;
    }
    sqrtrem() {
      return this.rootrem(2);
    }
    isqrt() {
      return this.sqrt()._move(this);
    }
    sqrt() {
      return this.root(2);
    }
    isSquare() {
      return this.isPower(2);
    }
    iand(num) {
      enforce(BN.isBN(num), "num", "bignum");
      let x = this;
      let y = num;
      if (x === y)
        return x;
      if ((x.negative | y.negative) === 0)
        return x.iuand(y);
      if ((x.negative & y.negative) === 1) {
        x.iaddn(1);
        y.iaddn(1);
        x.iuor(y);
        x.isubn(1);
        y.isubn(1);
        return x;
      }
      if (x.negative !== 0)
        [x, y] = [y.clone(), x];
      const width = x.bitLength();
      y.iaddn(1);
      y.inotn(width);
      x.iuand(y);
      y.inotn(width);
      y.isubn(1);
      return x._move(this);
    }
    iandn(num) {
      enforce(isSMI(num), "num", "smi");
      if ((this.negative | num < 0) !== 0)
        return this.iand(new BN(num));
      this.words[0] &= num;
      this.length = 1;
      return this;
    }
    and(num) {
      return this.clone().iand(num);
    }
    andn(num) {
      return this.clone().iandn(num);
    }
    andrn(num) {
      enforce(isSMI(num), "num", "smi");
      if ((this.negative | num < 0) !== 0) {
        const n = this.iand(new BN(num));
        if (n.length > 1)
          throw new RangeError("Number exceeds 26 bits.");
        return n.negative !== 0 ? -n.words[0] : n.words[0];
      }
      return this.words[0] & num;
    }
    iuand(num) {
      enforce(BN.isBN(num), "num", "bignum");
      this.length = Math.min(this.length, num.length);
      for (let i = 0; i < this.length; i++)
        this.words[i] &= num.words[i];
      return this._strip();
    }
    iuandn(num) {
      enforce(isSMI(num), "num", "smi");
      this.words[0] &= Math.abs(num);
      this.length = 1;
      return this._normalize();
    }
    uand(num) {
      return this.clone().iuand(num);
    }
    uandn(num) {
      return this.clone().iuandn(num);
    }
    uandrn(num) {
      enforce(isSMI(num), "num", "smi");
      const n = this.words[0] & Math.abs(num);
      return this.negative !== 0 ? -n | 0 : n;
    }
    ior(num) {
      enforce(BN.isBN(num), "num", "bignum");
      let x = this;
      let y = num;
      if (x === y)
        return x;
      if ((x.negative | y.negative) === 0)
        return x.iuor(y);
      if ((x.negative & y.negative) === 1) {
        x.iaddn(1);
        y.iaddn(1);
        x.iuand(y);
        x.isubn(1);
        y.isubn(1);
        return x;
      }
      y = y.clone();
      if (x.negative !== 0)
        [x, y] = [y, x];
      y.iaddn(1);
      x.inotn(y.bitLength());
      y.iuand(x);
      y.isubn(1);
      return y._move(this);
    }
    iorn(num) {
      enforce(isSMI(num), "num", "smi");
      if ((this.negative | num < 0) !== 0)
        return this.ior(new BN(num));
      this.words[0] |= num;
      return this;
    }
    or(num) {
      return this.clone().ior(num);
    }
    orn(num) {
      return this.clone().iorn(num);
    }
    iuor(num) {
      enforce(BN.isBN(num), "num", "bignum");
      this._expand(num.length);
      for (let i = 0; i < num.length; i++)
        this.words[i] |= num.words[i];
      return this;
    }
    iuorn(num) {
      enforce(isSMI(num), "num", "smi");
      this.words[0] |= Math.abs(num);
      return this;
    }
    uor(num) {
      return this.clone().iuor(num);
    }
    uorn(num) {
      return this.clone().iuorn(num);
    }
    ixor(num) {
      enforce(BN.isBN(num), "num", "bignum");
      let x = this;
      let y = num;
      if (x === y) {
        x.words[0] = 0;
        x.length = 1;
        x.negative = 0;
        return x;
      }
      if ((x.negative | y.negative) === 0)
        return x.iuxor(y);
      if ((x.negative & y.negative) === 1) {
        x.iaddn(1);
        y.iaddn(1);
        x.iuxor(y);
        x.ineg();
        y.isubn(1);
        return x;
      }
      if (x.negative !== 0)
        [x, y] = [y.clone(), x];
      y.iaddn(1);
      x.iuxor(y);
      x.iaddn(1);
      x.ineg();
      y.isubn(1);
      return x._move(this);
    }
    ixorn(num) {
      enforce(isSMI(num), "num", "smi");
      if ((this.negative | num < 0) !== 0)
        return this.ixor(new BN(num));
      this.words[0] ^= num;
      return this;
    }
    xor(num) {
      return this.clone().ixor(num);
    }
    xorn(num) {
      return this.clone().ixorn(num);
    }
    iuxor(num) {
      enforce(BN.isBN(num), "num", "bignum");
      let a = this;
      let b = num;
      if (a.length < b.length)
        [a, b] = [b, a];
      let i = 0;
      for (; i < b.length; i++)
        this.words[i] = a.words[i] ^ b.words[i];
      if (a !== this) {
        this._alloc(a.length);
        for (; i < a.length; i++)
          this.words[i] = a.words[i];
      }
      this.length = a.length;
      return this._strip();
    }
    iuxorn(num) {
      enforce(isSMI(num), "num", "smi");
      this.words[0] ^= Math.abs(num);
      return this._normalize();
    }
    uxor(num) {
      return this.clone().iuxor(num);
    }
    uxorn(num) {
      return this.clone().iuxorn(num);
    }
    inot() {
      if (this.negative !== 0) {
        this.ineg().isubn(1);
      } else {
        this.iaddn(1).ineg();
      }
      return this;
    }
    not() {
      return this.clone().inot();
    }
    inotn(width) {
      enforce(width >>> 0 === width, "width", "uint32");
      const r = width % 26;
      let s = Math.ceil(width / 26);
      let i = 0;
      this._expand(s);
      if (r > 0)
        s -= 1;
      for (; i < s; i++)
        this.words[i] ^= 67108863;
      if (r > 0)
        this.words[i] ^= (1 << r) - 1;
      return this._strip();
    }
    notn(width) {
      return this.clone().inotn(width);
    }
    ishl(num) {
      enforce(BN.isBN(num), "bits", "bignum");
      enforce(num.bitLength() <= 32, "bits", "uint32");
      return this.ishln(num.toNumber());
    }
    ishln(bits) {
      return this.iushln(bits);
    }
    shl(num) {
      return this.clone().ishl(num);
    }
    shln(bits) {
      return this.clone().ishln(bits);
    }
    iushl(num) {
      enforce(BN.isBN(num), "bits", "bignum");
      enforce(num.bitLength() <= 32, "bits", "uint32");
      return this.iushln(num.toNumber());
    }
    iushln(bits) {
      enforce(bits >>> 0 === bits, "bits", "uint32");
      const r = bits % 26;
      const s = (bits - r) / 26;
      const mask = (1 << r) - 1 << 26 - r;
      if (r !== 0) {
        let carry = 0;
        for (let i = 0; i < this.length; i++) {
          const ncarry = this.words[i] & mask;
          const c = (this.words[i] | 0) - ncarry << r;
          this.words[i] = c | carry;
          carry = ncarry >>> 26 - r;
        }
        if (carry !== 0) {
          this._alloc(this.length + 1);
          this.words[this.length++] = carry;
        }
      }
      if (s !== 0) {
        this._alloc(this.length + s);
        for (let i = this.length - 1; i >= 0; i--)
          this.words[i + s] = this.words[i];
        for (let i = 0; i < s; i++)
          this.words[i] = 0;
        this.length += s;
      }
      return this._strip();
    }
    ushl(num) {
      return this.clone().iushl(num);
    }
    ushln(bits) {
      return this.clone().iushln(bits);
    }
    _split(bits, output) {
      const r = bits % 26;
      const s = Math.min((bits - r) / 26, this.length);
      const mask = (1 << r) - 1;
      if (output) {
        output._alloc(s);
        for (let i = 0; i < s; i++)
          output.words[i] = this.words[i];
        output.length = s;
      }
      if (s === 0) {
      } else if (this.length > s) {
        this.length -= s;
        for (let i = 0; i < this.length; i++)
          this.words[i] = this.words[i + s];
      } else {
        this.words[0] = 0;
        this.length = 1;
      }
      let carry = 0;
      if (r !== 0) {
        for (let i = this.length - 1; i >= 0; i--) {
          const word = this.words[i] | 0;
          this.words[i] = carry << 26 - r | word >>> r;
          carry = word & mask;
        }
      }
      if (output) {
        if (carry !== 0) {
          output._alloc(output.length + 1);
          output.words[output.length++] = carry;
        } else {
          if (output.length === 0)
            output.words[output.length++] = 0;
          output._strip();
        }
      }
      return this._strip();
    }
    ishr(num) {
      enforce(BN.isBN(num), "bits", "bignum");
      enforce(num.bitLength() <= 32, "bits", "uint32");
      return this.ishrn(num.toNumber());
    }
    ishrn(bits) {
      enforce(bits >>> 0 === bits, "bits", "uint32");
      if (this.negative !== 0) {
        this.iaddn(1);
        this.iushrn(bits);
        this.isubn(1);
        return this;
      }
      return this.iushrn(bits);
    }
    shr(num) {
      return this.clone().ishr(num);
    }
    shrn(bits) {
      return this.clone().ishrn(bits);
    }
    iushr(num) {
      enforce(BN.isBN(num), "bits", "bignum");
      enforce(num.bitLength() <= 32, "bits", "uint32");
      return this.iushrn(num.toNumber());
    }
    iushrn(bits) {
      enforce(bits >>> 0 === bits, "bits", "uint32");
      return this._split(bits, null);
    }
    ushr(num) {
      return this.clone().iushr(num);
    }
    ushrn(bits) {
      return this.clone().iushrn(bits);
    }
    setn(bit, val) {
      enforce(bit >>> 0 === bit, "bit", "uint32");
      if (this.negative !== 0) {
        this.iaddn(1);
        this.usetn(bit, !val);
        this.isubn(1);
        return this;
      }
      return this.usetn(bit, val);
    }
    usetn(bit, val) {
      enforce(bit >>> 0 === bit, "bit", "uint32");
      const r = bit % 26;
      const s = (bit - r) / 26;
      this._expand(s + 1);
      if (val)
        this.words[s] |= 1 << r;
      else
        this.words[s] &= ~(1 << r);
      return this._strip();
    }
    testn(bit) {
      enforce(bit >>> 0 === bit, "bit", "uint32");
      const r = bit % 26;
      const s = (bit - r) / 26;
      if (this.length <= s)
        return this.negative;
      const w = this.words[s];
      const val = w >> r & 1;
      if (this.negative !== 0) {
        if (r > 0 && w & (1 << r) - 1)
          return val ^ 1;
        let j = s;
        while (j--) {
          if (this.words[j] > 0)
            return val ^ 1;
        }
      }
      return val;
    }
    utestn(bit) {
      enforce(bit >>> 0 === bit, "bit", "uint32");
      const r = bit % 26;
      const s = (bit - r) / 26;
      if (this.length <= s)
        return 0;
      return this.words[s] >> r & 1;
    }
    imaskn(bits) {
      enforce(bits >>> 0 === bits, "bits", "uint32");
      if (this.negative !== 0) {
        this.iaddn(1);
        this.inotn(bits + 1);
        this.ineg();
      }
      return this.iumaskn(bits);
    }
    maskn(bits) {
      return this.clone().imaskn(bits);
    }
    iumaskn(bits) {
      enforce(bits >>> 0 === bits, "bits", "uint32");
      const r = bits % 26;
      let s = (bits - r) / 26;
      if (this.length <= s)
        return this;
      if (r !== 0)
        s += 1;
      this.length = Math.min(s, this.length);
      if (r !== 0)
        this.words[this.length - 1] &= (1 << r) - 1;
      if (this.length === 0)
        this.words[this.length++] = 0;
      return this._strip();
    }
    umaskn(bits) {
      return this.clone().iumaskn(bits);
    }
    andln(num) {
      return this.words[0] & num;
    }
    bit(pos) {
      return this.utestn(pos);
    }
    bits(pos, width) {
      enforce(pos >>> 0 === pos, "pos", "uint32");
      enforce(width >>> 0 === width, "width", "uint32");
      enforce(width <= 26, "width", "width");
      const shift = pos % 26;
      const index = (pos - shift) / 26;
      if (index >= this.length)
        return 0;
      let bits = this.words[index] >> shift & (1 << width) - 1;
      if (shift + width > 26 && index + 1 < this.length) {
        const more = shift + width - 26;
        const next = this.words[index + 1] & (1 << more) - 1;
        bits |= next << 26 - shift;
      }
      return bits;
    }
    ineg() {
      if (!this.isZero())
        this.negative ^= 1;
      return this;
    }
    neg() {
      return this.clone().ineg();
    }
    iabs() {
      this.negative = 0;
      return this;
    }
    abs() {
      return this.clone().iabs();
    }
    cmp(num) {
      enforce(BN.isBN(num), "num", "bignum");
      if (this.negative !== num.negative)
        return num.negative - this.negative;
      const res = this.ucmp(num);
      if (this.negative !== 0)
        return -res | 0;
      return res;
    }
    cmpn(num) {
      enforce(isSMI(num), "num", "smi");
      const negative = num < 0 | 0;
      if (this.negative !== negative)
        return negative - this.negative;
      const res = this.ucmpn(num);
      if (this.negative !== 0)
        return -res | 0;
      return res;
    }
    eq(num) {
      return this.cmp(num) === 0;
    }
    eqn(num) {
      return this.cmpn(num) === 0;
    }
    gt(num) {
      return this.cmp(num) > 0;
    }
    gtn(num) {
      return this.cmpn(num) > 0;
    }
    gte(num) {
      return this.cmp(num) >= 0;
    }
    gten(num) {
      return this.cmpn(num) >= 0;
    }
    lt(num) {
      return this.cmp(num) < 0;
    }
    ltn(num) {
      return this.cmpn(num) < 0;
    }
    lte(num) {
      return this.cmp(num) <= 0;
    }
    lten(num) {
      return this.cmpn(num) <= 0;
    }
    sign() {
      if (this.negative !== 0)
        return -1;
      if (this.length === 1 && this.words[0] === 0)
        return 0;
      return 1;
    }
    isZero() {
      return this.length === 1 && this.words[0] === 0;
    }
    isNeg() {
      return this.negative !== 0;
    }
    isPos() {
      return this.negative === 0;
    }
    isOdd() {
      return (this.words[0] & 1) === 1;
    }
    isEven() {
      return (this.words[0] & 1) === 0;
    }
    ucmp(num) {
      enforce(BN.isBN(num), "num", "bignum");
      if (this.length < num.length)
        return -1;
      if (this.length > num.length)
        return 1;
      for (let i = this.length - 1; i >= 0; i--) {
        const a = this.words[i] | 0;
        const b = num.words[i] | 0;
        if (a === b)
          continue;
        return (a > b) - (a < b);
      }
      return 0;
    }
    ucmpn(num) {
      enforce(isSMI(num), "num", "smi");
      if (this.length > 1)
        return 1;
      const w = this.words[0] | 0;
      if (num < 0)
        num = -num;
      return (w > num) - (w < num);
    }
    legendre(num) {
      const red2 = HAS_BIGINT ? BN.red(num) : BN.mont(num);
      return this.toRed(red2).redLegendre();
    }
    jacobi(num) {
      enforce(BN.isBN(num), "num", "bignum");
      if (num.isZero() || num.isEven())
        throw new Error("jacobi: `num` must be odd.");
      let a = this._cloneNormal();
      let b = num.clone();
      let j = 1;
      if (b.isNeg()) {
        if (a.isNeg())
          j = -1;
        b.ineg();
      }
      if (a.isNeg() || a.ucmp(b) >= 0)
        a.imod(b);
      while (!a.isZero()) {
        const bits = a._makeOdd();
        if (bits & 1) {
          const bmod82 = b.andln(7);
          if (bmod82 === 3 || bmod82 === 5)
            j = -j;
        }
        if (a.ucmp(b) < 0) {
          [a, b] = [b, a];
          if (a.andln(3) === 3 && b.andln(3) === 3)
            j = -j;
        }
        a._isub(a, b).iushrn(1);
        const bmod8 = b.andln(7);
        if (bmod8 === 3 || bmod8 === 5)
          j = -j;
      }
      if (b.cmpn(1) !== 0)
        return 0;
      return j;
    }
    kronecker(num) {
      enforce(BN.isBN(num), "num", "bignum");
      const table = [
        0,
        1,
        0,
        -1,
        0,
        -1,
        0,
        1
      ];
      let a = this._cloneNormal();
      let b = num.clone();
      let k = 1;
      if (b.isZero())
        return a.ucmpn(1) === 0 ? k : 0;
      if (!a.isOdd() && !b.isOdd())
        return 0;
      const bits = b._makeOdd();
      if (bits & 1)
        k = table[a.andln(7)];
      if (b.isNeg()) {
        if (a.isNeg())
          k = -k;
        b.ineg();
      }
      while (!a.isZero()) {
        const bits2 = a._makeOdd();
        if (bits2 & 1)
          k *= table[b.andln(7)];
        const w = a.words[0] ^ a.negative * 67108863;
        if (w & b.words[0] & 2)
          k = -k;
        b.imod(a);
        [a, b] = [b, a];
        b.negative = 0;
      }
      if (b.cmpn(1) !== 0)
        return 0;
      return k;
    }
    igcd(num) {
      return this.gcd(num)._move(this);
    }
    gcd(num) {
      enforce(BN.isBN(num), "num", "bignum");
      if (this.isZero())
        return num.abs();
      if (num.isZero())
        return this.abs();
      let a = this.clone();
      let b = num.clone();
      a.negative = 0;
      b.negative = 0;
      const shift = a._factor2(b);
      if (shift !== 0) {
        a.iushrn(shift);
        b.iushrn(shift);
      }
      for (; ; ) {
        a._makeOdd();
        b._makeOdd();
        const cmp = a.ucmp(b);
        if (cmp < 0) {
          [a, b] = [b, a];
        } else if (cmp === 0 || b.ucmpn(1) === 0) {
          break;
        }
        a._isub(a, b);
      }
      return b.iushln(shift);
    }
    ilcm(num) {
      return this.lcm(num)._move(this);
    }
    lcm(num) {
      enforce(BN.isBN(num), "num", "bignum");
      if (this.isZero() || num.isZero())
        return new BN(0);
      return this.quo(this.gcd(num)).mul(num).iabs();
    }
    egcd(num) {
      enforce(BN.isBN(num), "num", "bignum");
      if (this.isZero()) {
        return [
          new BN(0),
          new BN(num.sign()),
          num.abs()
        ];
      }
      if (num.isZero()) {
        return [
          new BN(this.sign()),
          new BN(0),
          this.abs()
        ];
      }
      const x = this.clone();
      const y = num.clone();
      x.negative = 0;
      y.negative = 0;
      const A = new BN(1);
      const B = new BN(0);
      const C = new BN(0);
      const D = new BN(1);
      const g = x._factor2(y);
      if (g > 0) {
        x.iushrn(g);
        y.iushrn(g);
      }
      const xp = x.clone();
      const yp = y.clone();
      while (!x.isZero()) {
        let i = x._makeOdd();
        let j = y._makeOdd();
        while (i--) {
          if (A.isOdd() || B.isOdd()) {
            A.iadd(yp);
            B.isub(xp);
          }
          A.iushrn(1);
          B.iushrn(1);
        }
        while (j--) {
          if (C.isOdd() || D.isOdd()) {
            C.iadd(yp);
            D.isub(xp);
          }
          C.iushrn(1);
          D.iushrn(1);
        }
        if (x.cmp(y) >= 0) {
          x.isub(y);
          A.isub(C);
          B.isub(D);
        } else {
          y.isub(x);
          C.isub(A);
          D.isub(B);
        }
      }
      if (this.negative !== 0)
        C.ineg();
      if (num.negative !== 0)
        D.ineg();
      return [C, D, y.iushln(g)];
    }
    iinvert(num) {
      return this.invert(num)._move(this);
    }
    invert(num) {
      enforce(BN.isBN(num), "num", "bignum");
      range(num.sign() > 0, "invert");
      if (num.isOdd())
        return this._invertp(num);
      if (num.cmpn(1) === 0)
        throw new RangeError("Not invertible.");
      const [s, , g] = this.egcd(num);
      if (g.cmpn(1) !== 0)
        throw new RangeError("Not invertible.");
      return s.imod(num);
    }
    ifermat(num) {
      return this.fermat(num)._move(this);
    }
    fermat(num) {
      const red2 = HAS_BIGINT ? BN.red(num) : BN.mont(num);
      return this.toRed(red2).redFermat().fromRed();
    }
    ipowm(y, m, mont) {
      return this.powm(y, m, mont)._move(this);
    }
    powm(y, m, mont) {
      const red2 = !HAS_BIGINT && mont ? BN.mont(m) : BN.red(m);
      return this.toRed(red2).redPow(y).fromRed();
    }
    ipowmn(y, m, mont) {
      return this.powmn(y, m, mont)._move(this);
    }
    powmn(y, m, mont) {
      const red2 = mont ? BN.mont(m) : BN.red(m);
      return this.toRed(red2).redPown(y).fromRed();
    }
    isqrtm(p) {
      return this.sqrtm(p)._move(this);
    }
    sqrtm(p) {
      enforce(BN.isBN(p), "p", "bignum");
      let red2;
      if (p.andln(3) === 3 || p.andln(7) === 5) {
        red2 = BN.red(p);
      } else {
        red2 = BN.mont(p);
      }
      return this.toRed(red2).redSqrt().fromRed();
    }
    isqrtpq(p, q) {
      return this.sqrtpq(p, q)._move(this);
    }
    sqrtpq(p, q) {
      const sp = this.sqrtm(p);
      const sq = this.sqrtm(q);
      const [mp, mq] = p.egcd(q);
      const lhs = sq.mul(mp).mul(p);
      const rhs = sp.mul(mq).mul(q);
      const n = p.mul(q);
      return lhs.iadd(rhs).imod(n);
    }
    isPrime(rng, reps, limit) {
      enforce(reps >>> 0 === reps, "reps", "uint32");
      if (!this.isPrimeMR(rng, reps + 1, true))
        return false;
      if (!this.isPrimeLucas(limit))
        return false;
      return true;
    }
    isPrimeMR(rng, reps, force2 = false) {
      enforce(reps >>> 0 === reps, "reps", "uint32");
      enforce(reps > 0, "reps", "integer");
      enforce(typeof force2 === "boolean", "force2", "boolean");
      const n = this;
      if (n.cmpn(7) < 0) {
        return n.cmpn(2) === 0 || n.cmpn(3) === 0 || n.cmpn(5) === 0;
      }
      if (n.isEven())
        return false;
      const nm1 = n.subn(1);
      const nm3 = nm1.subn(2);
      const k = nm1.zeroBits();
      const q = nm1.ushrn(k);
      const red2 = BN.red(n);
      const rnm1 = nm1.toRed(red2);
      const rone = new BN(1).toRed(red2);
      next:
        for (let i = 0; i < reps; i++) {
          let x;
          if (i === reps - 1 && force2) {
            x = new BN(2);
          } else {
            x = BN.random(rng, 0, nm3);
            x.iaddn(2);
          }
          let y = x.toRed(red2).redPow(q);
          if (y.cmp(rone) === 0 || y.cmp(rnm1) === 0)
            continue;
          for (let j = 1; j < k; j++) {
            y = y.redSqr();
            if (y.cmp(rnm1) === 0)
              continue next;
            if (y.cmp(rone) === 0)
              return false;
          }
          return false;
        }
      return true;
    }
    isPrimeLucas(limit = 0) {
      enforce(limit >>> 0 === limit, "limit", "uint32");
      const n = this;
      if (n.cmpn(1) <= 0)
        return false;
      if (n.isEven())
        return n.cmpn(2) === 0;
      let p = 3;
      for (; ; ) {
        if (p > 1e4) {
          throw new Error(`Cannot find (D/n) = -1 for ${n.toString(10)}.`);
        }
        if (limit !== 0 && p > limit) {
          return false;
        }
        const d = new BN(p * p - 4);
        const j = d.jacobi(n);
        if (j === -1)
          break;
        if (j === 0)
          return n.cmpn(p + 2) === 0;
        if (p === 40) {
          if (n.isSquare())
            return false;
        }
        p += 1;
      }
      const s = n.addn(1);
      const r = s._makeOdd();
      let vk = new BN(2);
      let vk1 = new BN(p);
      for (let i = s.bitLength(); i >= 0; i--) {
        if (s.utestn(i)) {
          vk = vk.mul(vk1).isubn(p).imod(n);
          vk1 = vk1.sqr().isubn(2).imod(n);
        } else {
          vk1 = vk1.mul(vk).isubn(p).imod(n);
          vk = vk.sqr().isubn(2).imod(n);
        }
      }
      if (vk.cmpn(2) === 0 || vk.cmp(n.subn(2)) === 0) {
        const a = vk.muln(p).imod(n);
        const b = vk1.ushln(1).imod(n);
        if (a.cmp(b) === 0)
          return true;
      }
      for (let t = 0; t < r - 1; t++) {
        if (vk.isZero())
          return true;
        if (vk.cmpn(2) === 0)
          return false;
        vk = vk.sqr().isubn(2).imod(n);
      }
      return false;
    }
    toTwos(width) {
      if (this.negative !== 0)
        return this.abs().inotn(width).iaddn(1);
      return this.clone();
    }
    fromTwos(width) {
      enforce(width >>> 0 === width, "width", "uint32");
      range(width > 0, "width");
      if (this.testn(width - 1))
        return this.notn(width).iaddn(1).ineg();
      return this.clone();
    }
    toRed(ctx) {
      enforce(ctx instanceof Red, "ctx", "reduction context");
      if (this.red)
        throw new Error("Already in reduction context.");
      return ctx.convertTo(this);
    }
    fromRed() {
      red(this.red, "fromRed");
      return this.red.convertFrom(this);
    }
    forceRed(ctx) {
      enforce(ctx instanceof Red, "ctx", "reduction context");
      if (this.red) {
        if (!ctx.m.eq(this.red.m) || ctx.mont !== this.red.mont)
          throw new Error("Already in reduction context.");
      } else {
        range(this.negative === 0, "red");
        range(this.ucmp(ctx.m) < 0, "red");
      }
      return this.clone()._forceRed(ctx);
    }
    redIAdd(num) {
      enforce(BN.isBN(num), "num", "bignum");
      red(this.red, "redIAdd");
      return this.red.iadd(this, num);
    }
    redAdd(num) {
      enforce(BN.isBN(num), "num", "bignum");
      red(this.red, "redAdd");
      return this.red.add(this, num);
    }
    redIAddn(num) {
      enforce(isSMI(num), "num", "smi");
      red(this.red, "redIAddn");
      return this.red.iaddn(this, num);
    }
    redAddn(num) {
      enforce(isSMI(num), "num", "smi");
      red(this.red, "redAddn");
      return this.red.addn(this, num);
    }
    redISub(num) {
      enforce(BN.isBN(num), "num", "bignum");
      red(this.red, "redISub");
      return this.red.isub(this, num);
    }
    redSub(num) {
      enforce(BN.isBN(num), "num", "bignum");
      red(this.red, "redSub");
      return this.red.sub(this, num);
    }
    redISubn(num) {
      enforce(isSMI(num), "num", "smi");
      red(this.red, "redISubn");
      return this.red.isubn(this, num);
    }
    redSubn(num) {
      enforce(isSMI(num), "num", "smi");
      red(this.red, "redSubn");
      return this.red.subn(this, num);
    }
    redIMul(num) {
      enforce(BN.isBN(num), "num", "bignum");
      red(this.red, "redIMul");
      return this.red.imul(this, num);
    }
    redMul(num) {
      enforce(BN.isBN(num), "num", "bignum");
      red(this.red, "redMul");
      return this.red.mul(this, num);
    }
    redIMuln(num) {
      enforce(isSMI(num), "num", "smi");
      red(this.red, "redIMuln");
      return this.red.imuln(this, num);
    }
    redMuln(num) {
      enforce(isSMI(num), "num", "smi");
      red(this.red, "redMuln");
      return this.red.muln(this, num);
    }
    redIDiv(num) {
      enforce(BN.isBN(num), "num", "bignum");
      red(this.red, "redIDiv");
      return this.red.idiv(this, num);
    }
    redDiv(num) {
      enforce(BN.isBN(num), "num", "bignum");
      red(this.red, "redDiv");
      return this.red.div(this, num);
    }
    redIDivn(num) {
      enforce(isSMI(num), "num", "smi");
      red(this.red, "redIDivn");
      return this.red.idivn(this, num);
    }
    redDivn(num) {
      enforce(isSMI(num), "num", "smi");
      red(this.red, "redDivn");
      return this.red.divn(this, num);
    }
    redIPow(num) {
      enforce(BN.isBN(num), "num", "bignum");
      red(this.red, "redIPow");
      nonred(!num.red, "redIPow");
      return this.red.ipow(this, num);
    }
    redPow(num) {
      enforce(BN.isBN(num), "num", "bignum");
      red(this.red, "redPow");
      nonred(!num.red, "redPow");
      return this.red.pow(this, num);
    }
    redIPown(num) {
      enforce(isSMI(num), "num", "smi");
      red(this.red, "redIPown");
      return this.red.ipown(this, num);
    }
    redPown(num) {
      enforce(isSMI(num), "num", "smi");
      red(this.red, "redPown");
      return this.red.pown(this, num);
    }
    redISqr() {
      red(this.red, "redISqr");
      return this.red.isqr(this);
    }
    redSqr() {
      red(this.red, "redSqr");
      return this.red.sqr(this);
    }
    redISqrt() {
      red(this.red, "redISqrt");
      return this.red.isqrt(this);
    }
    redSqrt() {
      red(this.red, "redSqrt");
      return this.red.sqrt(this);
    }
    redIDivSqrt(v) {
      red(this.red, "redIDivSqrt");
      return this.red.idivsqrt(this, v);
    }
    redDivSqrt(v) {
      red(this.red, "redDivSqrt");
      return this.red.divsqrt(this, v);
    }
    redIsSquare() {
      red(this.red, "redIsSquare");
      return this.red.isSquare(this);
    }
    redIShl(num) {
      enforce(BN.isBN(num), "num", "bignum");
      red(this.red, "redIShl");
      nonred(!num.red, "redIShl");
      return this.red.ishl(this, num);
    }
    redShl(num) {
      enforce(BN.isBN(num), "num", "bignum");
      red(this.red, "redShl");
      nonred(!num.red, "redShl");
      return this.red.shl(this, num);
    }
    redIShln(num) {
      enforce(num >>> 0 === num, "num", "uint32");
      red(this.red, "redIShln");
      return this.red.ishln(this, num);
    }
    redShln(num) {
      enforce(num >>> 0 === num, "num", "uint32");
      red(this.red, "redShln");
      return this.red.shln(this, num);
    }
    redINeg() {
      red(this.red, "redINeg");
      return this.red.ineg(this);
    }
    redNeg() {
      red(this.red, "redNeg");
      return this.red.neg(this);
    }
    redEq(num) {
      enforce(BN.isBN(num), "num", "bignum");
      red(this.red, "redEq");
      return this.red.eq(this, num);
    }
    redEqn(num) {
      enforce(isSMI(num), "num", "smi");
      red(this.red, "redEqn");
      return this.red.eqn(this, num);
    }
    redIsHigh() {
      red(this.red, "redIsHigh");
      return this.red.isHigh(this);
    }
    redIsLow() {
      red(this.red, "redIsLow");
      return this.red.isLow(this);
    }
    redIsOdd() {
      red(this.red, "redIsOdd");
      return this.red.isOdd(this);
    }
    redIsEven() {
      red(this.red, "redIsEven");
      return this.red.isEven(this);
    }
    redLegendre() {
      red(this.red, "redLegendre");
      return this.red.legendre(this);
    }
    redJacobi() {
      red(this.red, "redJacobi");
      return this.red.jacobi(this);
    }
    redKronecker() {
      red(this.red, "redKronecker");
      return this.red.kronecker(this);
    }
    redIInvert() {
      red(this.red, "redIInvert");
      return this.red.iinvert(this);
    }
    redInvert() {
      red(this.red, "redInvert");
      return this.red.invert(this);
    }
    redIFermat() {
      red(this.red, "redIFermat");
      return this.red.ifermat(this);
    }
    redFermat() {
      red(this.red, "redFermat");
      return this.red.fermat(this);
    }
    _move(dest) {
      dest.words = this.words;
      dest.length = this.length;
      dest.negative = this.negative;
      dest.red = this.red;
      return dest;
    }
    _alloc(size) {
      while (this.words.length < size)
        this.words.push(0);
      return this;
    }
    _expand(size) {
      this._alloc(size);
      while (this.length < size)
        this.words[this.length++] = 0;
      return this;
    }
    _strip() {
      while (this.length > 1 && this.words[this.length - 1] === 0)
        this.length -= 1;
      return this._normalize();
    }
    _normalize() {
      assert(this.length > 0);
      if (this.length === 1 && this.words[0] === 0)
        this.negative = 0;
      return this;
    }
    _check() {
      assert(this.length > 0);
      assert(this.length <= this.words.length);
      if (this.length === 1) {
        if (this.words[0] === 0)
          assert(this.negative === 0);
        return this;
      }
      assert(this.words[this.length - 1] !== 0);
      return this;
    }
    _invertp(p) {
      enforce(BN.isBN(p), "p", "bignum");
      range(p.sign() > 0, "invert");
      assert(p.isOdd());
      if (p.cmpn(1) === 0)
        throw new RangeError("Not invertible.");
      const a = this.clone();
      const b = p.clone();
      const u = new BN(1);
      const v = new BN(0);
      if (a.isNeg() || a.ucmp(b) >= 0)
        a.imod(b);
      while (!a.isZero()) {
        let i = a._makeOdd();
        let j = b._makeOdd();
        while (i--) {
          if (u.isOdd())
            u._iadd(u, p);
          u.iushrn(1);
        }
        while (j--) {
          if (v.isOdd())
            v._iadd(v, p);
          v.iushrn(1);
        }
        if (a.ucmp(b) >= 0) {
          a._isub(a, b);
          if (u.ucmp(v) < 0) {
            u._isub(v, u);
            u._isub(p, u);
          } else {
            u._isub(u, v);
          }
        } else {
          b._isub(b, a);
          if (v.ucmp(u) < 0) {
            v._isub(u, v);
            v._isub(p, v);
          } else {
            v._isub(v, u);
          }
        }
      }
      if (b.cmpn(1) !== 0)
        throw new RangeError("Not invertible.");
      assert(v.negative === 0);
      assert(v.ucmp(p) < 0);
      return v;
    }
    _makeOdd() {
      const shift = this.zeroBits();
      if (shift > 0)
        this.iushrn(shift);
      return shift;
    }
    _factor2(num) {
      if ((this.words[0] | num.words[0]) & 1)
        return 0;
      const len = Math.min(this.length, num.length);
      let r = 0;
      for (let i = 0; i < len; i++) {
        const b = zeroBits(this.words[i] | num.words[i]);
        r += b;
        if (b !== 26)
          break;
      }
      return r;
    }
    _cloneNormal() {
      return this.red ? this.fromRed() : this.clone();
    }
    _forceRed(ctx) {
      this.red = ctx;
      return this;
    }
    clone() {
      const copy = new BN();
      copy.words = new Array(this.length);
      for (let i = 0; i < this.length; i++)
        copy.words[i] = this.words[i];
      copy.length = this.length;
      copy.negative = this.negative;
      copy.red = this.red;
      return copy;
    }
    inject(num) {
      enforce(BN.isBN(num), "num", "bignum");
      this._alloc(num.length);
      for (let i = 0; i < num.length; i++)
        this.words[i] = num.words[i];
      this.length = num.length;
      this.negative = num.negative;
      this.red = num.red;
      return this;
    }
    set(num, endian) {
      return this.fromNumber(num, endian);
    }
    swap(num) {
      enforce(BN.isBN(num), "num", "bignum");
      const x = this;
      const y = num;
      [x.words, y.words] = [y.words, x.words];
      [x.length, y.length] = [y.length, x.length];
      [x.negative, y.negative] = [y.negative, x.negative];
      [x.red, y.red] = [y.red, x.red];
      return x;
    }
    reverse() {
      const neg = this.negative;
      this.fromBuffer(this.toBuffer("be"), "le");
      this.negative = neg;
      return this;
    }
    byteLength() {
      return Math.ceil(this.bitLength() / 8);
    }
    bitLength() {
      const w = this.words[this.length - 1];
      const hi = countBits(w);
      return (this.length - 1) * 26 + hi;
    }
    zeroBits() {
      if (this.isZero())
        return 0;
      if (this.isOdd())
        return 0;
      let r = 0;
      for (let i = 0; i < this.length; i++) {
        const b = zeroBits(this.words[i]);
        r += b;
        if (b !== 26)
          break;
      }
      return r;
    }
    isSafe() {
      if (this.length <= 2)
        return true;
      if (this.length === 3 && this.words[2] === 1)
        return true;
      return false;
    }
    word(pos) {
      enforce(pos >>> 0 === pos, "pos", "uint32");
      if (pos >= this.length)
        return 0;
      return this.words[pos];
    }
    [custom]() {
      let prefix = "BN";
      if (this.red)
        prefix = "BN-R";
      return `<${prefix}: ${this.toString(10)}>`;
    }
    toNumber() {
      let num = this.words[0];
      if (this.length === 2) {
        num += this.words[1] * 67108864;
      } else if (this.length === 3 && this.words[2] === 1) {
        num += 4503599627370496 + this.words[1] * 67108864;
      } else if (this.length > 2) {
        throw new RangeError("Number can only safely store up to 53 bits.");
      }
      return this.negative !== 0 ? -num : num;
    }
    toDouble() {
      let num = 0;
      for (let i = this.length - 1; i >= 0; i--)
        num = num * 67108864 + this.words[i];
      return this.negative !== 0 ? -num : num;
    }
    valueOf() {
      return this.toDouble();
    }
    toBigInt() {
      if (!HAS_BIGINT)
        throw new Error("BigInt is not supported!");
      const s52 = BigInt(52);
      const s26 = BigInt(26);
      let i = this.length - 1;
      let num = BigInt(0);
      for (; i >= 1; i -= 2) {
        const hi = this.words[i] * 67108864;
        const lo = this.words[i - 1];
        num = num << s52 | BigInt(hi + lo);
      }
      if (i >= 0)
        num = num << s26 | BigInt(this.words[0]);
      return this.negative !== 0 ? -num : num;
    }
    toBool() {
      return !this.isZero();
    }
    toString(base, padding) {
      base = getBase(base);
      if (padding == null)
        padding = 0;
      if (padding === 0)
        padding = 1;
      enforce(base >>> 0 === base, "base", "uint32");
      enforce(padding >>> 0 === padding, "padding", "uint32");
      if (base < 2 || base > 36)
        throw new RangeError("Base ranges between 2 and 36.");
      this._check();
      if (base === 16) {
        let out2 = "";
        let off = 0;
        let carry = 0;
        for (let i = 0; i < this.length; i++) {
          const w = this.words[i];
          const word = ((w << off | carry) & 16777215).toString(16);
          carry = w >>> 24 - off & 16777215;
          if (carry !== 0 || i !== this.length - 1)
            out2 = zeros[6 - word.length] + word + out2;
          else
            out2 = word + out2;
          off += 2;
          if (off >= 26) {
            off -= 26;
            i -= 1;
          }
        }
        if (carry !== 0)
          out2 = carry.toString(16) + out2;
        while (out2.length % padding !== 0)
          out2 = "0" + out2;
        if (this.negative !== 0)
          out2 = "-" + out2;
        return out2;
      }
      const groupSize = groupSizes[base - 1];
      const groupBase = groupBases[base - 1];
      const c = this.clone();
      let out = "";
      c.negative = 0;
      while (!c.isZero()) {
        const r = c.remrn(groupBase).toString(base);
        c.iquon(groupBase);
        if (!c.isZero())
          out = zeros[groupSize - r.length] + r + out;
        else
          out = r + out;
      }
      if (this.isZero())
        out = "0";
      while (out.length % padding !== 0)
        out = "0" + out;
      if (this.negative !== 0)
        out = "-" + out;
      return out;
    }
    toJSON() {
      return this.toString(16, 2);
    }
    toArray(endian, length) {
      return this.toArrayLike(Array, endian, length);
    }
    toBuffer(endian, length) {
      return this.toArrayLike(Buffer, endian, length);
    }
    toArrayLike(ArrayType, endian, length) {
      if (endian == null)
        endian = "be";
      if (length == null)
        length = 0;
      enforce(typeof ArrayType === "function", "ArrayType", "function");
      enforce(endian === "be" || endian === "le", "endian", "endianness");
      enforce(length >>> 0 === length, "length", "uint32");
      this._check();
      const bytes = this.byteLength();
      const size = length || Math.max(1, bytes);
      if (bytes > size)
        throw new RangeError("Byte array longer than desired length.");
      const res = allocate(ArrayType, size);
      if (endian === "be") {
        let pos = res.length - 1;
        let carry = 0;
        for (let i = 0; i < this.length; i++) {
          const shift = (i & 3) << 1;
          const word = this.words[i] << shift | carry;
          res[pos--] = word & 255;
          if (pos >= 0)
            res[pos--] = word >>> 8 & 255;
          if (pos >= 0)
            res[pos--] = word >>> 16 & 255;
          if (shift === 6) {
            if (pos >= 0)
              res[pos--] = word >>> 24 & 255;
            carry = 0;
          } else {
            carry = word >>> 24;
          }
        }
        if (pos >= 0) {
          res[pos--] = carry;
          while (pos >= 0)
            res[pos--] = 0;
          carry = 0;
        }
        assert(carry === 0);
      } else {
        let pos = 0;
        let carry = 0;
        for (let i = 0; i < this.length; i++) {
          const shift = (i & 3) << 1;
          const word = this.words[i] << shift | carry;
          res[pos++] = word & 255;
          if (pos < res.length)
            res[pos++] = word >>> 8 & 255;
          if (pos < res.length)
            res[pos++] = word >>> 16 & 255;
          if (shift === 6) {
            if (pos < res.length)
              res[pos++] = word >>> 24 & 255;
            carry = 0;
          } else {
            carry = word >>> 24;
          }
        }
        if (pos < res.length) {
          res[pos++] = carry;
          while (pos < res.length)
            res[pos++] = 0;
          carry = 0;
        }
        assert(carry === 0);
      }
      return res;
    }
    encode(endian, length) {
      return this.toBuffer(endian, length);
    }
    of(num, endian) {
      return this.fromNumber(num, endian);
    }
    fromNumber(num, endian) {
      if (endian == null)
        endian = "be";
      enforce(isInteger(num), "num", "integer");
      enforce(endian === "be" || endian === "le", "endian", "endianness");
      const neg = num < 0 | 0;
      if (neg)
        num = -num;
      if (num < 67108864) {
        this.words[0] = num & 67108863;
        this.length = 1;
      } else if (num < 4503599627370496) {
        this.words = [
          num & 67108863,
          num / 67108864 & 67108863
        ];
        this.length = 2;
      } else {
        this.words = [
          num & 67108863,
          num / 67108864 & 67108863,
          1
        ];
        this.length = 3;
      }
      this.negative = neg;
      if (endian === "le")
        this.reverse();
      return this;
    }
    fromDouble(num, endian) {
      if (endian == null)
        endian = "be";
      enforce(typeof num === "number", "num", "double");
      enforce(endian === "be" || endian === "le", "endian", "endianness");
      if (!isFinite(num))
        num = 0;
      const neg = num <= -1 | 0;
      if (num < 0)
        num = -num;
      num = Math.floor(num);
      this.words = [];
      while (num > 0) {
        const lo = num % 67108864;
        const hi = (num - lo) / 67108864;
        this.words.push(lo);
        num = hi;
      }
      if (this.words.length === 0)
        this.words.push(0);
      this.length = this.words.length;
      this.negative = neg;
      if (endian === "le")
        this.reverse();
      return this;
    }
    fromBigInt(num, endian) {
      if (endian == null)
        endian = "be";
      enforce(typeof num === "bigint", "num", "bigint");
      enforce(endian === "be" || endian === "le", "endian", "endianness");
      if (!HAS_BIGINT)
        throw new Error("BigInt is not supported!");
      const start = num < BigInt(0) | 0;
      this._fromHex(num.toString(16), start);
      this.negative = start;
      if (endian === "le")
        this.reverse();
      return this;
    }
    fromBool(value) {
      enforce(typeof value === "boolean", "value", "boolean");
      this.words[0] = value | 0;
      this.length = 1;
      this.negative = 0;
      return this;
    }
    fromString(str, base, endian) {
      if (base === "le" || base === "be")
        [base, endian] = [endian, base];
      base = getBase(base);
      if (endian == null)
        endian = "be";
      enforce(typeof str === "string", "string", "string");
      enforce(base >>> 0 === base, "base", "uint32");
      enforce(endian === "be" || endian === "le", "endian", "endianness");
      if (base < 2 || base > 36)
        throw new Error("Base ranges between 2 and 36.");
      str = str.replace(/\s+/g, "");
      let start = 0;
      if (str.length > 0 && str.charCodeAt(0) === 45)
        start = 1;
      if (base === 16)
        this._fromHex(str, start);
      else
        this._fromBase(str, base, start);
      this.negative = start;
      this._normalize();
      if (endian === "le")
        this.reverse();
      return this;
    }
    _fromHex(str, start) {
      this.length = Math.max(2, Math.ceil((str.length - start) / 6));
      this.words = new Array(this.length);
      for (let i2 = 0; i2 < this.length; i2++)
        this.words[i2] = 0;
      let off = 0;
      let i = str.length - 6;
      let j = 0;
      for (; i >= start; i -= 6) {
        const w = parseHex(str, i, i + 6);
        this.words[j] |= w << off & 67108863;
        this.words[j + 1] |= w >>> 26 - off & 4194303;
        off += 24;
        if (off >= 26) {
          off -= 26;
          j += 1;
        }
      }
      if (i + 6 !== start) {
        const w = parseHex(str, start, i + 6);
        this.words[j] |= w << off & 67108863;
        this.words[j + 1] |= w >>> 26 - off & 4194303;
      }
      return this._strip();
    }
    _fromBase(str, base, start) {
      this.words[0] = 0;
      this.length = 1;
      this.negative = 0;
      let limbLen = 0;
      let limbPow = 1;
      for (; limbPow <= 67108863; limbPow *= base)
        limbLen += 1;
      limbLen -= 1;
      limbPow = limbPow / base | 0;
      const total = str.length - start;
      const mod = total % limbLen;
      const end = Math.min(total, total - mod) + start;
      let i = start;
      for (; i < end; i += limbLen) {
        const word = parseBase(str, i, i + limbLen, base);
        this.imuln(limbPow);
        this._iaddn(word);
      }
      if (mod !== 0) {
        const pow = Math.pow(base, mod);
        const word = parseBase(str, i, str.length, base);
        this.imuln(pow);
        this._iaddn(word);
      }
      return this;
    }
    fromJSON(json) {
      if (BN.isBN(json)) {
        if (json.red)
          return json.fromRed();
        return json.clone();
      }
      if (Array.isArray(json)) {
        for (const chunk of json)
          enforce(typeof chunk === "string", "chunk", "string");
        json = json.join("");
      }
      return this.fromString(json, 16);
    }
    fromBN(num) {
      return this.inject(num);
    }
    fromArray(data, endian) {
      enforce(Array.isArray(data), "data", "array");
      return this.fromArrayLike(data, endian);
    }
    fromBuffer(data, endian) {
      enforce(Buffer.isBuffer(data), "data", "buffer");
      return this.fromArrayLike(data, endian);
    }
    fromArrayLike(data, endian) {
      if (endian == null)
        endian = "be";
      enforce(data && data.length >>> 0 === data.length, "data", "array-like");
      enforce(endian === "be" || endian === "le", "endian", "endianness");
      if (data.length === 0) {
        this.words[0] = 0;
        this.length = 1;
        this.negative = 0;
        return this;
      }
      this.length = Math.max(2, Math.ceil(data.length / 3));
      this.words = new Array(this.length);
      this.negative = 0;
      for (let i = 0; i < this.length; i++)
        this.words[i] = 0;
      const left = data.length % 3;
      let off = 0;
      let j = 0;
      let w = 0;
      if (endian === "be") {
        for (let i = data.length - 1; i >= 2; i -= 3) {
          const w2 = data[i] | data[i - 1] << 8 | data[i - 2] << 16;
          this.words[j] |= w2 << off & 67108863;
          this.words[j + 1] = w2 >>> 26 - off & 67108863;
          off += 24;
          if (off >= 26) {
            off -= 26;
            j += 1;
          }
        }
        switch (left) {
          case 2:
            w = data[1] | data[0] << 8;
            break;
          case 1:
            w = data[0];
            break;
        }
      } else {
        const len = data.length - left;
        for (let i = 0; i < len; i += 3) {
          const w2 = data[i] | data[i + 1] << 8 | data[i + 2] << 16;
          this.words[j] |= w2 << off & 67108863;
          this.words[j + 1] = w2 >>> 26 - off & 67108863;
          off += 24;
          if (off >= 26) {
            off -= 26;
            j += 1;
          }
        }
        switch (left) {
          case 2:
            w = data[len] | data[len + 1] << 8;
            break;
          case 1:
            w = data[len];
            break;
        }
      }
      if (left > 0) {
        this.words[j] |= w << off & 67108863;
        this.words[j + 1] = w >>> 26 - off & 67108863;
      }
      return this._strip();
    }
    decode(data, endian) {
      return this.fromBuffer(data, endian);
    }
    from(num, base, endian) {
      if (num == null)
        return this;
      if (base === "le" || base === "be")
        [base, endian] = [endian, base];
      if (typeof num === "number")
        return this.fromNumber(num, endian);
      if (typeof num === "bigint")
        return this.fromBigInt(num, endian);
      if (typeof num === "string")
        return this.fromString(num, base, endian);
      if (typeof num === "object") {
        if (BN.isBN(num))
          return this.fromBN(num, endian);
        if (num.length >>> 0 === num.length)
          return this.fromArrayLike(num, endian);
      }
      if (typeof num === "boolean")
        return this.fromBool(num);
      throw new TypeError("Non-numeric object passed to BN.");
    }
    static min(...args) {
      let min = null;
      for (const num of args) {
        enforce(BN.isBN(num), "num", "bignum");
        if (!min || num.cmp(min) < 0)
          min = num;
      }
      return min || new BN(0);
    }
    static max(...args) {
      let max = null;
      for (const num of args) {
        enforce(BN.isBN(num), "num", "bignum");
        if (!max || num.cmp(max) > 0)
          max = num;
      }
      return max || new BN(0);
    }
    static cmp(a, b) {
      enforce(BN.isBN(a), "a", "bignum");
      return a.cmp(b);
    }
    static ucmp(a, b) {
      enforce(BN.isBN(a), "a", "bignum");
      return a.ucmp(b);
    }
    static red(num) {
      return new Red(num);
    }
    static barrett(num) {
      return new Barrett(num);
    }
    static mont(num) {
      return new Mont(num);
    }
    static _prime(name) {
      if (primes[name])
        return primes[name];
      let prime;
      if (name === "p192")
        prime = new P192();
      else if (name === "p224")
        prime = new P224();
      else if (name === "p521")
        prime = new P521();
      else if (name === "k256")
        prime = new K256();
      else if (name === "p251")
        prime = new P251();
      else if (name === "p25519")
        prime = new P25519();
      else if (name === "p448")
        prime = new P448();
      else
        throw new Error(`Unknown prime: "${name}".`);
      primes[name] = prime;
      return prime;
    }
    static prime(name) {
      return BN._prime(name).p.clone();
    }
    static pow(num, exp) {
      if (num === 2)
        return BN.shift(1, exp);
      return new BN().fromNumber(num).pown(exp);
    }
    static shift(num, bits) {
      if (num === 1)
        return new BN(0).usetn(bits, 1);
      return new BN().fromNumber(num).ishln(bits);
    }
    static mask(bits) {
      return BN.shift(1, bits).isubn(1);
    }
    static randomBits(rng, bits) {
      enforce(rng != null, "rng", "rng");
      enforce(bits >>> 0 === bits, "bits", "uint32");
      if (typeof rng === "object") {
        enforce(typeof rng.randomBytes === "function", "rng", "rng");
        const size = bits + 7 >>> 3;
        const total = size * 8;
        const bytes = rng.randomBytes(size);
        enforce(Buffer.isBuffer(bytes), "bytes", "buffer");
        if (bytes.length !== size)
          throw new RangeError("Invalid number of bytes returned from RNG.");
        const num2 = BN.fromBuffer(bytes);
        if (total > bits)
          num2.iushrn(total - bits);
        return num2;
      }
      enforce(typeof rng === "function", "rng", "rng");
      const num = rng(bits);
      enforce(BN.isBN(num), "num", "bignum");
      range(num.negative === 0, "RNG");
      nonred(!num.red, "RNG");
      if (num.bitLength() > bits)
        throw new RangeError("Invalid number of bits returned from RNG.");
      return num;
    }
    static random(rng, min, max) {
      min = BN.cast(min, 16);
      max = BN.cast(max, 16);
      if (min.cmp(max) > 0)
        throw new RangeError("Minimum cannot be greater than maximum.");
      const space = max.sub(min).iabs();
      const bits = space.bitLength();
      if (bits === 0)
        return min.clone();
      for (; ; ) {
        const num = BN.randomBits(rng, bits);
        if (num.cmp(space) >= 0)
          continue;
        num.iadd(min);
        return num;
      }
    }
    static of(num, endian) {
      return new BN().of(num, endian);
    }
    static fromNumber(num, endian) {
      return new BN().fromNumber(num, endian);
    }
    static fromDouble(num, endian) {
      return new BN().fromDouble(num, endian);
    }
    static fromBigInt(num, endian) {
      return new BN().fromBigInt(num, endian);
    }
    static fromBool(value) {
      return new BN().fromBool(value);
    }
    static fromString(str, base, endian) {
      return new BN().fromString(str, base, endian);
    }
    static fromJSON(json) {
      return new BN().fromJSON(json);
    }
    static fromBN(num) {
      return new BN().fromBN(num);
    }
    static fromArray(data, endian) {
      return new BN().fromArray(data, endian);
    }
    static fromBuffer(data, endian) {
      return new BN().fromBuffer(data, endian);
    }
    static fromArrayLike(data, endian) {
      return new BN().fromArrayLike(data, endian);
    }
    static decode(data, endian) {
      return new BN().decode(data, endian);
    }
    static from(num, base, endian) {
      return new BN().from(num, base, endian);
    }
    static cast(num, base, endian) {
      if (BN.isBN(num))
        return num;
      return new BN(num, base, endian);
    }
    static isBN(obj) {
      return obj instanceof BN;
    }
  };
  BN.BN = BN;
  BN.wordSize = 26;
  BN.native = 0;
  var Prime = class {
    constructor(name, p) {
      this.name = name;
      this.p = new BN(p, 16);
      this.n = this.p.bitLength();
      this.k = BN.shift(1, this.n).isub(this.p);
      this.lo = this.p.clone();
      this.one = this.p.clone();
    }
    ireduce(num) {
      const neg = num.negative !== 0;
      let bits = num.bitLength();
      assert(bits <= this.n * 2);
      num.negative = 0;
      while (bits > this.n) {
        this.split(num, this.lo);
        this.imulK(num);
        num._iadd(num, this.lo);
        bits = num.bitLength();
      }
      const cmp = bits < this.n ? -1 : num.ucmp(this.p);
      if (cmp === 0) {
        num.words[0] = 0;
        num.length = 1;
      } else if (cmp > 0) {
        num._isub(num, this.p);
      } else {
      }
      if (neg && !num.isZero())
        num._isub(this.p, num);
      return num;
    }
    split(input, out) {
      input._split(this.n, out);
    }
    imulK(num) {
      return num.imul(this.k);
    }
    pm2(x1) {
      throw new Error("Not implemented.");
    }
    fermat(x) {
      return this.pm2(x);
    }
  };
  var Prime34 = class extends Prime {
    constructor(name, p) {
      super(name, p);
    }
    pm3d4(x1) {
      throw new Error("Not implemented.");
    }
    pp1d4(x1) {
      throw new Error("Not implemented.");
    }
    sqrt(x) {
      const {red: red2} = x;
      const r = this.pp1d4(x);
      if (!red2.sqr(r).eq(x))
        throw new SquareRootError(r);
      return r;
    }
    divsqrt(u, v) {
      const {red: red2} = u;
      const u2 = red2.sqr(u);
      const u3 = red2.mul(u2, u);
      const u5 = red2.mul(u3, u2);
      const v3 = red2.mul(red2.sqr(v), v);
      const p = this.pm3d4(red2.mul(u5, v3));
      const x = red2.mul(red2.mul(u3, v), p);
      const c = red2.mul(v, red2.sqr(x));
      if (c.eq(u))
        return x;
      throw new SquareRootError(x);
    }
  };
  var Prime58 = class extends Prime {
    constructor(name, p, sm1) {
      super(name, p);
      this.sm1 = new BN(sm1, 16);
    }
    pm5d8(x1) {
      throw new Error("Not implemented.");
    }
    pp3d8(x1) {
      throw new Error("Not implemented.");
    }
    sqrt(x) {
      const {red: red2} = x;
      const sm1 = this.sm1._forceRed(red2);
      const r = this.pp3d8(x);
      if (red2.sqr(r).eq(x))
        return r;
      const c = red2.mul(r, sm1);
      if (red2.sqr(c).eq(x))
        return c;
      throw new SquareRootError(r);
    }
    divsqrt(u, v) {
      const {red: red2} = u;
      const sm1 = this.sm1._forceRed(red2);
      const v3 = red2.mul(red2.sqr(v), v);
      const v7 = red2.mul(red2.sqr(v3), v);
      const p = this.pm5d8(red2.mul(u, v7));
      const x = red2.mul(red2.mul(u, v3), p);
      const c = red2.mul(v, red2.sqr(x));
      if (c.eq(u))
        return x;
      const mc = red2.ineg(c);
      if (mc.eq(u))
        return red2.mul(x, sm1);
      if (mc.eq(red2.mul(u, sm1)))
        throw new SquareRootError(red2.mul(x, sm1));
      throw new SquareRootError(x);
    }
  };
  var Prime116 = class extends Prime {
    constructor(name, p, g) {
      super(name, p);
      this.g = new BN(g, 16);
      this.z = this.p.subn(1).zeroBits();
    }
    powS(x1) {
      throw new Error("Not implemented.");
    }
    powE(x1) {
      throw new Error("Not implemented.");
    }
    sqrt(x) {
      const {red: red2} = x;
      switch (red2.jacobi(x)) {
        case -1:
          throw new SquareRootError(x);
        case 0:
          return x.clone();
        case 1:
          break;
      }
      let g = this.g._forceRed(red2);
      let y = this.powE(x);
      let b = this.powS(x);
      let k = this.z;
      for (; ; ) {
        let t = b;
        let m = 0;
        while (t.cmpn(1) !== 0 && m < k) {
          t = red2.sqr(t);
          m += 1;
        }
        if (m === 0)
          break;
        assert(m < k);
        t = red2.sqrn(g, k - m - 1);
        g = red2.sqr(t);
        y = red2.mul(y, t);
        b = red2.mul(b, g);
        k = m;
      }
      return y;
    }
    divsqrt(u, v) {
      const {red: red2} = u;
      if (v.isZero())
        throw new SquareRootError(v);
      return this.sqrt(red2.div(u, v));
    }
  };
  var P192 = class extends Prime34 {
    constructor() {
      super("p192", "ffffffff ffffffff ffffffff fffffffeffffffff ffffffff");
    }
    imulK(num) {
      const one = this.one.inject(num);
      return num.iushln(64)._iadd(num, one);
    }
    core(x1) {
      const {red: red2} = x1;
      const x2 = red2.sqrnmul(x1, 1, x1);
      const x3 = red2.sqrnmul(x2, 1, x1);
      const x6 = red2.sqrnmul(x3, 3, x3);
      const x12 = red2.sqrnmul(x6, 6, x6);
      const x24 = red2.sqrnmul(x12, 12, x12);
      const x30 = red2.sqrnmul(x24, 6, x6);
      const x31 = red2.sqrnmul(x30, 1, x1);
      const x62 = red2.sqrnmul(x31, 31, x31);
      const x124 = red2.sqrnmul(x62, 62, x62);
      const x127 = red2.sqrnmul(x124, 3, x3);
      const r0 = red2.sqrn(x127, 1);
      const r1 = red2.sqrnmul(r0, 62, x62);
      return r1;
    }
    pm3d4(x1) {
      return this.core(x1);
    }
    pm2(x1) {
      const {red: red2} = x1;
      const r0 = this.core(x1);
      const r1 = red2.sqrn(r0, 1);
      const r2 = red2.sqrnmul(r1, 1, x1);
      return r2;
    }
    pp1d4(x1) {
      const {red: red2} = x1;
      const x2 = red2.sqrnmul(x1, 1, x1);
      const x4 = red2.sqrnmul(x2, 2, x2);
      const x8 = red2.sqrnmul(x4, 4, x4);
      const x16 = red2.sqrnmul(x8, 8, x8);
      const x32 = red2.sqrnmul(x16, 16, x16);
      const x64 = red2.sqrnmul(x32, 32, x32);
      const x128 = red2.sqrnmul(x64, 64, x64);
      const r0 = red2.sqrn(x128, 62);
      return r0;
    }
  };
  var P224 = class extends Prime116 {
    constructor() {
      super("p224", "ffffffff ffffffff ffffffff ffffffff00000000 00000000 00000001", "6a0fec67 8598a792 0c55b2d4 0b2d6ffbbea3d8ce f3fb3632 dc691b74");
    }
    imulK(num) {
      const one = this.one.inject(num);
      return num.iushln(96)._isub(num, one);
    }
    powS(x1) {
      const {red: red2} = x1;
      const x2 = red2.sqrnmul(x1, 1, x1);
      const x4 = red2.sqrnmul(x2, 2, x2);
      const x8 = red2.sqrnmul(x4, 4, x4);
      const x16 = red2.sqrnmul(x8, 8, x8);
      const x32 = red2.sqrnmul(x16, 16, x16);
      const x64 = red2.sqrnmul(x32, 32, x32);
      const x128 = red2.sqrnmul(x64, 64, x64);
      return x128;
    }
    powE(x1) {
      const {red: red2} = x1;
      const r0 = red2.sqrn(x1, 127);
      return r0;
    }
    pm2(x1) {
      const {red: red2} = x1;
      const x2 = red2.sqrnmul(x1, 1, x1);
      const x3 = red2.sqrnmul(x2, 1, x1);
      const x6 = red2.sqrnmul(x3, 3, x3);
      const x12 = red2.sqrnmul(x6, 6, x6);
      const x24 = red2.sqrnmul(x12, 12, x12);
      const x48 = red2.sqrnmul(x24, 24, x24);
      const x96 = red2.sqrnmul(x48, 48, x48);
      const x120 = red2.sqrnmul(x96, 24, x24);
      const x126 = red2.sqrnmul(x120, 6, x6);
      const x127 = red2.sqrnmul(x126, 1, x1);
      const r0 = red2.sqrn(x127, 1);
      const r1 = red2.sqrnmul(r0, 96, x96);
      return r1;
    }
  };
  var P521 = class extends Prime34 {
    constructor() {
      super("p521", "000001ff ffffffff ffffffff ffffffffffffffff ffffffff ffffffff ffffffffffffffff ffffffff ffffffff ffffffffffffffff ffffffff ffffffff ffffffffffffffff");
    }
    imulK(num) {
      return num;
    }
    core(x1) {
      const {red: red2} = x1;
      const x2 = red2.sqrnmul(x1, 1, x1);
      const x3 = red2.sqrnmul(x2, 1, x1);
      const x6 = red2.sqrnmul(x3, 3, x3);
      const x7 = red2.sqrnmul(x6, 1, x1);
      const x8 = red2.sqrnmul(x7, 1, x1);
      const x16 = red2.sqrnmul(x8, 8, x8);
      const x32 = red2.sqrnmul(x16, 16, x16);
      const x64 = red2.sqrnmul(x32, 32, x32);
      const x128 = red2.sqrnmul(x64, 64, x64);
      const x256 = red2.sqrnmul(x128, 128, x128);
      const x512 = red2.sqrnmul(x256, 256, x256);
      const x519 = red2.sqrnmul(x512, 7, x7);
      return x519;
    }
    pm3d4(x1) {
      return this.core(x1);
    }
    pm2(x1) {
      const {red: red2} = x1;
      const r0 = this.core(x1);
      const r1 = red2.sqrn(r0, 1);
      const r2 = red2.sqrnmul(r1, 1, x1);
      return r2;
    }
    pp1d4(x1) {
      const {red: red2} = x1;
      const r0 = red2.sqrn(x1, 519);
      return r0;
    }
  };
  var K256 = class extends Prime34 {
    constructor() {
      super("k256", "ffffffff ffffffff ffffffff ffffffffffffffff ffffffff fffffffe fffffc2f");
    }
    split(input, output) {
      const mask = 4194303;
      const len = Math.min(input.length, 9);
      output._alloc(len + 1);
      for (let i2 = 0; i2 < len; i2++)
        output.words[i2] = input.words[i2];
      output.length = len;
      if (input.length <= 9) {
        output._strip();
        input.words[0] = 0;
        input.length = 1;
        return;
      }
      let prev = input.words[9];
      let i = 10;
      output.words[output.length++] = prev & mask;
      output._strip();
      for (; i < input.length; i++) {
        const next = input.words[i] | 0;
        input.words[i - 10] = (next & mask) << 4 | prev >>> 22;
        prev = next;
      }
      prev >>>= 22;
      input.words[i - 10] = prev;
      if (prev === 0 && input.length > 10)
        input.length -= 10;
      else
        input.length -= 9;
      input._strip();
    }
    imulK(num) {
      num._expand(num.length + 2);
      let lo = 0;
      for (let i = 0; i < num.length; i++) {
        const w = num.words[i];
        lo += w * 977;
        num.words[i] = lo & 67108863;
        lo = w * 64 + Math.floor(lo / 67108864);
      }
      if (num.words[num.length - 1] === 0) {
        num.length -= 1;
        if (num.words[num.length - 1] === 0)
          num.length -= 1;
      }
      return num;
    }
    core(x1, x2) {
      const {red: red2} = x1;
      const x3 = red2.sqrnmul(x2, 1, x1);
      const x6 = red2.sqrnmul(x3, 3, x3);
      const x9 = red2.sqrnmul(x6, 3, x3);
      const x11 = red2.sqrnmul(x9, 2, x2);
      const x22 = red2.sqrnmul(x11, 11, x11);
      const x44 = red2.sqrnmul(x22, 22, x22);
      const x88 = red2.sqrnmul(x44, 44, x44);
      const x176 = red2.sqrnmul(x88, 88, x88);
      const x220 = red2.sqrnmul(x176, 44, x44);
      const x223 = red2.sqrnmul(x220, 3, x3);
      const r0 = red2.sqrn(x223, 1);
      const r1 = red2.sqrnmul(r0, 22, x22);
      const r2 = red2.sqrn(r1, 4);
      return r2;
    }
    pm3d4(x1) {
      const {red: red2} = x1;
      const x2 = red2.sqrnmul(x1, 1, x1);
      const r2 = this.core(x1, x2);
      const r3 = red2.sqrnmul(r2, 1, x1);
      const r4 = red2.sqrn(r3, 1);
      const r5 = red2.sqrnmul(r4, 2, x2);
      return r5;
    }
    pm2(x1) {
      const {red: red2} = x1;
      const x2 = red2.sqrnmul(x1, 1, x1);
      const r2 = this.core(x1, x2);
      const r3 = red2.sqrnmul(r2, 1, x1);
      const r4 = red2.sqrn(r3, 1);
      const r5 = red2.sqrnmul(r4, 2, x2);
      const r6 = red2.sqrn(r5, 1);
      const r7 = red2.sqrnmul(r6, 1, x1);
      return r7;
    }
    pp1d4(x1) {
      const {red: red2} = x1;
      const x2 = red2.sqrnmul(x1, 1, x1);
      const r2 = this.core(x1, x2);
      const r3 = red2.sqrnmul(r2, 2, x2);
      const r4 = red2.sqrn(r3, 2);
      return r4;
    }
  };
  var P251 = class extends Prime34 {
    constructor() {
      super("p251", "07ffffff ffffffff ffffffff ffffffffffffffff ffffffff ffffffff fffffff7");
    }
    imulK(num) {
      if (num.isZero())
        return num;
      let carry = 0;
      for (let i = 0; i < num.length; i++) {
        const w = num.words[i] * 9 + carry;
        carry = w >>> 26;
        num.words[i] = w & 67108863;
      }
      if (carry !== 0) {
        num._alloc(num.length + 1);
        num.words[num.length++] = carry;
      }
      return num;
    }
    core(x1) {
      const {red: red2} = x1;
      const x2 = red2.sqrnmul(x1, 1, x1);
      const x3 = red2.sqrnmul(x2, 1, x1);
      const x6 = red2.sqrnmul(x3, 3, x3);
      const x12 = red2.sqrnmul(x6, 6, x6);
      const x24 = red2.sqrnmul(x12, 12, x12);
      const x48 = red2.sqrnmul(x24, 24, x24);
      const x96 = red2.sqrnmul(x48, 48, x48);
      const x192 = red2.sqrnmul(x96, 96, x96);
      const x240 = red2.sqrnmul(x192, 48, x48);
      const x246 = red2.sqrnmul(x240, 6, x6);
      const x247 = red2.sqrnmul(x246, 1, x1);
      return x247;
    }
    pm3d4(x1) {
      const {red: red2} = x1;
      const r0 = this.core(x1);
      const r1 = red2.sqrn(r0, 1);
      const r2 = red2.sqrnmul(r1, 1, x1);
      return r2;
    }
    pm2(x1) {
      const {red: red2} = x1;
      const r0 = this.core(x1);
      const r1 = red2.sqrn(r0, 1);
      const r2 = red2.sqrnmul(r1, 1, x1);
      const r3 = red2.sqrn(r2, 1);
      const r4 = red2.sqrnmul(r3, 1, x1);
      return r4;
    }
    pp1d4(x1) {
      const {red: red2} = x1;
      const r0 = this.core(x1);
      const r1 = red2.sqrnmul(r0, 1, x1);
      const r2 = red2.sqrn(r1, 1);
      return r2;
    }
  };
  var P25519 = class extends Prime58 {
    constructor() {
      super("p25519", "7fffffff ffffffff ffffffff ffffffffffffffff ffffffff ffffffff ffffffed", "2b832480 4fc1df0b 2b4d0099 3dfbd7a72f431806 ad2fe478 c4ee1b27 4a0ea0b0");
    }
    imulK(num) {
      let carry = 0;
      for (let i = 0; i < num.length; i++) {
        const w = num.words[i] * 19 + carry;
        carry = w >>> 26;
        num.words[i] = w & 67108863;
      }
      if (carry !== 0) {
        num._alloc(num.length + 1);
        num.words[num.length++] = carry;
      }
      return num;
    }
    core(x1, x2) {
      const {red: red2} = x1;
      const x4 = red2.sqrnmul(x2, 2, x2);
      const x5 = red2.sqrnmul(x4, 1, x1);
      const x10 = red2.sqrnmul(x5, 5, x5);
      const x20 = red2.sqrnmul(x10, 10, x10);
      const x40 = red2.sqrnmul(x20, 20, x20);
      const x50 = red2.sqrnmul(x40, 10, x10);
      const x100 = red2.sqrnmul(x50, 50, x50);
      const x200 = red2.sqrnmul(x100, 100, x100);
      const x250 = red2.sqrnmul(x200, 50, x50);
      return x250;
    }
    pm5d8(x1) {
      const {red: red2} = x1;
      const x2 = red2.sqrnmul(x1, 1, x1);
      const r0 = this.core(x1, x2);
      const r1 = red2.sqrn(r0, 1);
      const r2 = red2.sqrnmul(r1, 1, x1);
      return r2;
    }
    pm2(x1) {
      const {red: red2} = x1;
      const x2 = red2.sqrnmul(x1, 1, x1);
      const r0 = this.core(x1, x2);
      const r1 = red2.sqrn(r0, 1);
      const r2 = red2.sqrnmul(r1, 1, x1);
      const r3 = red2.sqrn(r2, 1);
      const r4 = red2.sqrnmul(r3, 2, x2);
      return r4;
    }
    pp3d8(x1) {
      const {red: red2} = x1;
      const x2 = red2.sqrnmul(x1, 1, x1);
      const r0 = this.core(x1, x2);
      const r1 = red2.sqrnmul(r0, 1, x1);
      const r2 = red2.sqrn(r1, 1);
      return r2;
    }
  };
  var P448 = class extends Prime34 {
    constructor() {
      super("p448", "ffffffff ffffffff ffffffff ffffffffffffffff ffffffff fffffffe ffffffffffffffff ffffffff ffffffff ffffffffffffffff ffffffff");
    }
    imulK(num) {
      const one = this.one.inject(num);
      return num.iushln(224)._iadd(num, one);
    }
    core(x1, x2) {
      const {red: red2} = x1;
      const x3 = red2.sqrnmul(x2, 1, x1);
      const x6 = red2.sqrnmul(x3, 3, x3);
      const x9 = red2.sqrnmul(x6, 3, x3);
      const x11 = red2.sqrnmul(x9, 2, x2);
      const x22 = red2.sqrnmul(x11, 11, x11);
      const x44 = red2.sqrnmul(x22, 22, x22);
      const x88 = red2.sqrnmul(x44, 44, x44);
      const x176 = red2.sqrnmul(x88, 88, x88);
      const x220 = red2.sqrnmul(x176, 44, x44);
      const x222 = red2.sqrnmul(x220, 2, x2);
      return x222;
    }
    pm3d4(x1) {
      const {red: red2} = x1;
      const x2 = red2.sqrnmul(x1, 1, x1);
      const x222 = this.core(x1, x2);
      const r0 = red2.sqrnmul(x222, 1, x1);
      const r1 = red2.sqrn(r0, 1);
      const r2 = red2.sqrnmul(r1, 222, x222);
      return r2;
    }
    pm2(x1) {
      const {red: red2} = x1;
      const r0 = this.pm3d4(x1);
      const r1 = red2.sqrn(r0, 1);
      const r2 = red2.sqrnmul(r1, 1, x1);
      return r2;
    }
    pp1d4(x1) {
      const {red: red2} = x1;
      const x2 = red2.sqrnmul(x1, 1, x1);
      const r0 = this.core(x1, x2);
      const r1 = red2.sqrnmul(r0, 2, x2);
      const r2 = red2.sqrn(r1, 222);
      return r2;
    }
  };
  var Red = class {
    constructor(m) {
      let prime = null;
      if (typeof m === "string") {
        prime = BN._prime(m);
        m = prime.p;
      }
      enforce(BN.isBN(m), "m", "bignum");
      nonred(!m.red, "reduction");
      range(m.sign() > 0, "reduction");
      this.m = m;
      this.prime = prime;
      this.mb = null;
      this.sm1 = null;
    }
    _verify1(a) {
      range(a.negative === 0, "red");
      red(a.red != null, "red");
    }
    _verify2(a, b) {
      range((a.negative | b.negative) === 0, "red");
      red(a.red != null && a.red === b.red, "red");
    }
    get mont() {
      return false;
    }
    precompute() {
      if (this.sm1 === null && this.m.andln(7) === 5) {
        if (this.prime) {
          this.sm1 = this.prime.sm1.clone()._forceRed(this);
        } else {
          const x = new BN(2).toRed(this);
          const e = this.m.subn(1).iushrn(2);
          this.sm1 = this.pow(x, e);
        }
      }
      return this;
    }
    convertTo(num) {
      const res = num.mod(this.m);
      res.red = this;
      return res;
    }
    convertFrom(num) {
      const res = num.clone();
      res.red = null;
      return res;
    }
    intTo(a) {
      return a;
    }
    intFrom(a) {
      return a;
    }
    imod(a) {
      if (this.prime)
        return this.prime.ireduce(a)._forceRed(this);
      return a.imod(this.m)._forceRed(this);
    }
    iadd(a, b) {
      this._verify2(a, b);
      a._iadd(a, b);
      if (a.ucmp(this.m) >= 0)
        a._isub(a, this.m);
      return a;
    }
    add(a, b) {
      if (a.length < b.length)
        return this.iadd(b.clone(), a);
      return this.iadd(a.clone(), b);
    }
    iaddn(a, num) {
      this._verify1(a);
      if (num < 0)
        return this.isubn(a, -num);
      if (this.m.length === 1)
        num %= this.m.words[0];
      a._iaddn(num);
      if (a.ucmp(this.m) >= 0)
        a._isub(a, this.m);
      return a;
    }
    addn(a, num) {
      return this.iaddn(a.clone(), num);
    }
    isub(a, b) {
      this._verify2(a, b);
      const cmp = a.ucmp(b);
      if (cmp === 0) {
        a.words[0] = 0;
        a.length = 1;
        return a;
      }
      if (cmp < 0) {
        a._isub(b, a);
        a._isub(this.m, a);
      } else {
        a._isub(a, b);
      }
      return a;
    }
    sub(a, b) {
      return this.isub(a.clone(), b);
    }
    isubn(a, num) {
      this._verify1(a);
      if (num < 0)
        return this.iaddn(a, -num);
      if (this.m.length === 1)
        num %= this.m.words[0];
      if (a.length === 1 && a.words[0] < num) {
        a.words[0] = num - a.words[0];
        a._isub(this.m, a);
      } else {
        a._isubn(num);
      }
      return a;
    }
    subn(a, num) {
      return this.isubn(a.clone(), num);
    }
    imul(a, b) {
      this._verify2(a, b);
      return this.imod(a.imul(b));
    }
    mul(a, b) {
      this._verify2(a, b);
      return this.imod(a.mul(b));
    }
    imuln(a, num) {
      this._verify1(a);
      if (a.isZero())
        return a;
      if (num === 0) {
        a.words[0] = 0;
        a.length = 1;
        return a;
      }
      const neg = num < 0;
      if (neg)
        num = -num;
      if (this.m.length === 1)
        num %= this.m.words[0];
      a.imuln(num);
      if (num <= 16) {
        while (a.ucmp(this.m) >= 0)
          a._isub(a, this.m);
      } else {
        this.imod(a);
      }
      if (neg)
        this.ineg(a);
      return a;
    }
    muln(a, num) {
      return this.imuln(a.clone(), num);
    }
    idiv(a, b) {
      return this.div(a, b)._move(a);
    }
    div(a, b) {
      return this.mul(a, this.invert(b));
    }
    idivn(a, num) {
      return this.divn(a, num)._move(a);
    }
    divn(a, num) {
      return this.div(a, this.convertTo(new BN(num)));
    }
    ipow(a, num) {
      return this.pow(a, num)._move(a);
    }
    pow(a, num) {
      this._verify1(a);
      if (num.isNeg())
        a = this.invert(a);
      if (num.length === 1)
        return this.pown(a, num.words[0]);
      if (HAS_BIGINT && !this.prime)
        return this.powInt(a, num);
      return this.powNum(a, num);
    }
    powNum(a, num) {
      const one = new BN(1).toRed(this);
      const wnd = new Array(WND_SIZE);
      const a2 = this.sqr(a);
      wnd[0] = a;
      for (let i2 = 1; i2 < WND_SIZE; i2++)
        wnd[i2] = this.mul(wnd[i2 - 1], a2);
      let i = num.bitLength();
      let r = one;
      while (i >= WND_WIDTH) {
        let width = WND_WIDTH;
        let bits = num.bits(i - width, width);
        if (bits < WND_SIZE) {
          r = this.sqr(r);
          i -= 1;
          continue;
        }
        while ((bits & 1) === 0) {
          width -= 1;
          bits >>= 1;
        }
        if (r === one) {
          r = wnd[bits >> 1].clone();
        } else {
          r = this.sqrn(r, width);
          r = this.mul(r, wnd[bits >> 1]);
        }
        i -= width;
      }
      if (i > 0) {
        const bits = num.bits(0, i);
        while (i--) {
          r = this.sqr(r);
          if (bits >> i & 1)
            r = this.mul(r, a);
        }
      }
      return r;
    }
    powInt(a, num) {
      if (this.mb === null)
        this.mb = this.m.toBigInt();
      const x = this.intFrom(a.toBigInt());
      const y = powInt(x, num, this.mb);
      const z = this.intTo(y);
      return BN.fromBigInt(z)._forceRed(this);
    }
    sqrn(a, n) {
      while (n--)
        a = this.sqr(a);
      return a;
    }
    sqrnmul(a, n, b) {
      return this.mul(this.sqrn(a, n), b);
    }
    ipown(a, num) {
      return this.pown(a, num)._move(a);
    }
    pown(a, num) {
      this._verify1(a);
      if (num < 0) {
        a = this.invert(a);
        num = -num;
      }
      if (num === 0)
        return new BN(1).toRed(this);
      if (num === 1)
        return a.clone();
      const bits = countBits(num);
      let r = a;
      for (let i = bits - 2; i >= 0; i--) {
        r = this.sqr(r);
        if (num >> i & 1)
          r = this.mul(r, a);
      }
      return r;
    }
    isqr(a) {
      return this.imul(a, a);
    }
    sqr(a) {
      return this.mul(a, a);
    }
    isqrt(x) {
      return this.sqrt(x)._move(x);
    }
    sqrt(x) {
      this._verify1(x);
      if (this.prime)
        return this.prime.sqrt(x);
      if (this.m.andln(3) === 3)
        return this.sqrt3mod4(x);
      if (this.m.andln(7) === 5) {
        if (this.sm1 != null)
          return this.sqrt5mod8sm1(x);
        return this.sqrt5mod8(x);
      }
      return this.sqrt0(x);
    }
    sqrt3mod4(x) {
      const e = this.m.addn(1).iushrn(2);
      const b = this.pow(x, e);
      if (!this.sqr(b).eq(x))
        throw new SquareRootError(b);
      return b;
    }
    sqrt5mod8(x) {
      const one = new BN(1).toRed(this);
      const e = this.m.ushrn(3);
      const x2 = this.add(x, x);
      const alpha = this.pow(x2, e);
      const beta = this.mul(x2, this.sqr(alpha));
      const b = this.mul(this.mul(alpha, x), this.isub(beta, one));
      if (!this.sqr(b).eq(x))
        throw new SquareRootError(b);
      return b;
    }
    sqrt5mod8sm1(x) {
      const e = this.m.addn(3).iushrn(3);
      const b = this.pow(x, e);
      if (this.sqr(b).eq(x))
        return b;
      const c = this.mul(b, this.sm1);
      if (this.sqr(c).eq(x))
        return c;
      throw new SquareRootError(b);
    }
    sqrt0(x) {
      if (this.m.cmpn(1) === 0 || !this.m.isOdd())
        throw new Error("Invalid prime.");
      switch (this.jacobi(x)) {
        case -1:
          throw new SquareRootError(x);
        case 0:
          return x.clone();
        case 1:
          break;
      }
      const one = new BN(1).toRed(this);
      const s = this.m.subn(1);
      const e = s._makeOdd();
      const n = new BN(2).toRed(this);
      while (this.jacobi(n) !== -1)
        this.iadd(n, one);
      let g = this.pow(n, s);
      let b = this.pow(x, s);
      let y = this.pow(x, s.iaddn(1).iushrn(1));
      let k = e;
      for (; ; ) {
        let t = b;
        let m = 0;
        while (!t.eq(one) && m < k) {
          t = this.sqr(t);
          m += 1;
        }
        if (m === 0)
          break;
        assert(m < k);
        t = this.sqrn(g, k - m - 1);
        g = this.sqr(t);
        y = this.mul(y, t);
        b = this.mul(b, g);
        k = m;
      }
      return y;
    }
    idivsqrt(u, v) {
      return this.divsqrt(u, v)._move(u);
    }
    divsqrt(u, v) {
      this._verify2(u, v);
      if (u.isZero() && v.isZero())
        throw new SquareRootError(v);
      if (this.prime)
        return this.prime.divsqrt(u, v);
      if (this.m.andln(3) === 3)
        return this.divsqrt3mod4(u, v);
      if (this.sm1 != null && this.m.andln(7) === 5)
        return this.divsqrt5mod8(u, v);
      if (v.isZero())
        throw new SquareRootError(v);
      return this.sqrt(this.div(u, v));
    }
    divsqrt3mod4(u, v) {
      const e = this.m.subn(3).iushrn(2);
      const u2 = this.sqr(u);
      const u3 = this.mul(u2, u);
      const u5 = this.mul(u3, u2);
      const v3 = this.mul(this.sqr(v), v);
      const p = this.pow(this.mul(u5, v3), e);
      const x = this.mul(this.mul(u3, v), p);
      const c = this.mul(v, this.sqr(x));
      if (c.eq(u))
        return x;
      throw new SquareRootError(x);
    }
    divsqrt5mod8(u, v) {
      const e = this.m.subn(5).iushrn(3);
      const v3 = this.mul(this.sqr(v), v);
      const v7 = this.mul(this.sqr(v3), v);
      const p = this.pow(this.mul(u, v7), e);
      const x = this.mul(this.mul(u, v3), p);
      const c = this.mul(v, this.sqr(x));
      if (c.eq(u))
        return x;
      const mc = this.ineg(c);
      if (mc.eq(u))
        return this.mul(x, this.sm1);
      if (mc.eq(this.mul(u, this.sm1)))
        throw new SquareRootError(this.mul(x, this.sm1));
      throw new SquareRootError(x);
    }
    isSquare(a) {
      if (this.m.isOdd())
        return this.jacobi(a) >= 0;
      return this.kronecker(a) >= 0;
    }
    ishl(a, num) {
      this._verify1(a);
      return this.imod(a.iushl(num));
    }
    shl(a, num) {
      return this.ishl(a.clone(), num);
    }
    ishln(a, num) {
      this._verify1(a);
      a.iushln(num);
      if (num <= 4) {
        while (a.ucmp(this.m) >= 0)
          a._isub(a, this.m);
      } else {
        this.imod(a);
      }
      return a;
    }
    shln(a, num) {
      return this.ishln(a.clone(), num);
    }
    ineg(a) {
      this._verify1(a);
      if (!a.isZero())
        a._isub(this.m, a);
      return a;
    }
    neg(a) {
      return this.ineg(a.clone());
    }
    eq(a, b) {
      this._verify2(a, b);
      return a.ucmp(b) === 0;
    }
    eqn(a, num) {
      this._verify1(a);
      if (this.m.length === 1) {
        num %= this.m.words[0];
        if (num < 0)
          num += this.m.words[0];
        return a.ucmpn(num) === 0;
      }
      if (num < 0) {
        this.m._isubn(-num);
        const cmp = a.ucmp(this.m);
        this.m._iaddn(-num);
        return cmp === 0;
      }
      return a.ucmpn(num) === 0;
    }
    isHigh(a) {
      return !this.isLow(a);
    }
    isLow(a) {
      this._verify1(a);
      return a.ucmp(this.m.ushrn(1)) <= 0;
    }
    isOdd(a) {
      this._verify1(a);
      return a.isOdd();
    }
    isEven(a) {
      this._verify1(a);
      return a.isEven();
    }
    legendre(num) {
      this._verify1(num);
      if (this.m.isEven())
        throw new Error("legendre: `num` must be odd.");
      const e = this.m.subn(1).iushrn(1);
      const symbol = this.pow(num, e);
      if (symbol.isZero())
        return 0;
      const one = new BN(1).toRed(this);
      if (symbol.eq(one))
        return 1;
      if (symbol.eq(this.ineg(one)))
        return -1;
      throw new Error("Invalid prime.");
    }
    jacobi(a) {
      this._verify1(a);
      return a.jacobi(this.m);
    }
    kronecker(a) {
      this._verify1(a);
      return a.kronecker(this.m);
    }
    iinvert(a) {
      return this.invert(a)._move(a);
    }
    invert(a) {
      this._verify1(a);
      return a.invert(this.m)._forceRed(this);
    }
    ifermat(a) {
      return this.fermat(a)._move(a);
    }
    fermat(a) {
      this._verify1(a);
      if (a.isZero() || this.m.cmpn(1) === 0)
        throw new RangeError("Not invertible.");
      if (this.prime)
        return this.prime.fermat(a);
      return this.pow(a, this.m.subn(2));
    }
    invertAll(elems) {
      enforce(Array.isArray(elems), "elems", "array");
      for (const elem of elems) {
        enforce(BN.isBN(elem), "elem", "bignum");
        this._verify1(elem);
      }
      if (this.m.cmpn(1) === 0 || this.m.isEven())
        throw new RangeError("Not invertible.");
      const len = elems.length;
      const invs = new Array(len);
      if (len === 0)
        return invs;
      let acc = new BN(1).toRed(this);
      for (let i = 0; i < len; i++) {
        if (elems[i].isZero()) {
          invs[i] = elems[i].clone();
          continue;
        }
        invs[i] = acc;
        acc = this.mul(acc, elems[i]);
      }
      acc = this.invert(acc);
      for (let i = len - 1; i >= 0; i--) {
        if (elems[i].isZero())
          continue;
        invs[i] = this.mul(acc, invs[i]);
        acc = this.mul(acc, elems[i]);
      }
      return invs;
    }
    [custom]() {
      if (this.prime)
        return `<Red: ${this.prime.name}>`;
      return `<Red: ${this.m.toString(10)}>`;
    }
  };
  var Barrett = class extends Red {
    constructor(m) {
      super(m);
      this.prime = null;
      this.n = this.m.bitLength();
      if (this.n % 26 !== 0)
        this.n += 26 - this.n % 26;
      this.k = this.n * 2;
      this.w = this.k / 26;
      this.b = BN.shift(1, this.k).div(this.m);
    }
    convertTo(num) {
      if (num.length > this.w)
        return super.convertTo(num);
      return this.imod(num.clone());
    }
    _shift(q) {
      let i = 0;
      let j = this.w;
      while (j < q.length)
        q.words[i++] = q.words[j++];
      if (i === 0)
        q.words[i++] = 0;
      q.length = i;
    }
    imod(a) {
      const neg = a.negative;
      assert(a.length <= this.w);
      a.negative = 0;
      const q = a.mul(this.b);
      this._shift(q);
      a._isub(a, q.mul(this.m));
      if (a.ucmp(this.m) >= 0)
        a._isub(a, this.m);
      if (neg && !a.isZero())
        a._isub(this.m, a);
      a.red = this;
      return a;
    }
  };
  var Mont = class extends Red {
    constructor(m) {
      super(m);
      this.prime = null;
      this.n = this.m.length * 26;
      this.r = BN.shift(1, this.n);
      this.r2 = BN.shift(1, this.n * 2).imod(this.m);
      this.ri = this.r.invert(this.m);
      this.mi = this.r.mul(this.ri).isubn(1).div(this.m);
      this.rib = null;
    }
    get mont() {
      return true;
    }
    convertTo(num) {
      if (num.isNeg() || num.ucmp(this.m) >= 0)
        return this.imod(num.ushln(this.n));
      return this.mul(num, this.r2);
    }
    convertFrom(num) {
      const r = this.mul(num, new BN(1));
      r.red = null;
      return r;
    }
    intTo(a) {
      return (a << BigInt(this.n)) % this.mb;
    }
    intFrom(a) {
      if (this.rib === null)
        this.rib = this.ri.toBigInt();
      return a * this.rib % this.mb;
    }
    iaddn(a, num) {
      return this.iadd(a, this.convertTo(new BN(num)));
    }
    isubn(a, num) {
      return this.isub(a, this.convertTo(new BN(num)));
    }
    imul(a, b) {
      return this.mul(a, b)._move(a);
    }
    mul(a, b) {
      if (a.isZero() || b.isZero())
        return new BN(0)._forceRed(this);
      const t = a.mul(b);
      const c = t.umaskn(this.n).mul(this.mi).iumaskn(this.n);
      const u = t.iadd(c.mul(this.m)).iushrn(this.n);
      if (u.ucmp(this.m) >= 0)
        u._isub(u, this.m);
      return u._forceRed(this);
    }
    imuln(a, num) {
      this._verify1(a);
      if (a.isZero())
        return a;
      if (num === 0) {
        a.words[0] = 0;
        a.length = 1;
        return a;
      }
      const neg = num < 0;
      if (neg)
        num = -num;
      if (this.m.length === 1)
        num %= this.m.words[0];
      const bits = countBits(num);
      if (bits > 5) {
        this.imul(a, this.convertTo(new BN(num)));
      } else if ((num & num - 1) === 0) {
        for (let i = 0; i < bits - 1; i++)
          this.iadd(a, a);
      } else {
        const c = a.clone();
        for (let i = bits - 2; i >= 0; i--) {
          this.iadd(a, a);
          if (num >> i & 1)
            this.iadd(a, c);
        }
      }
      if (neg)
        this.ineg(a);
      return a;
    }
    eqn(a, num) {
      this._verify1(a);
      if (num === 0)
        return a.isZero();
      return a.ucmp(this.convertTo(new BN(num))) === 0;
    }
    isLow(a) {
      this._verify1(a);
      return this.convertFrom(a).ucmp(this.m.ushrn(1)) <= 0;
    }
    isOdd(a) {
      this._verify1(a);
      return this.convertFrom(a).isOdd();
    }
    isEven(a) {
      this._verify1(a);
      return this.convertFrom(a).isEven();
    }
    invert(a) {
      this._verify1(a);
      return this.imod(a.invert(this.m).mul(this.r2));
    }
  };
  function makeError(Error2, msg, start) {
    const err = new Error2(msg);
    if (Error2.captureStackTrace)
      Error2.captureStackTrace(err, start);
    return err;
  }
  function assert(value, message) {
    if (!value) {
      const msg = message || "Assertion failed.";
      throw makeError(Error, msg, assert);
    }
  }
  function enforce(value, name, type) {
    if (!value) {
      const msg = `"${name}" must be a(n) ${type}.`;
      throw makeError(TypeError, msg, enforce);
    }
  }
  function range(value, name) {
    if (!value) {
      const msg = `"${name}" only works with positive numbers.`;
      throw makeError(RangeError, msg, range);
    }
  }
  function red(value, name) {
    if (!value) {
      const msg = `"${name}" only works with red numbers.`;
      throw makeError(TypeError, msg, red);
    }
  }
  function nonred(value, name) {
    if (!value) {
      const msg = `"${name}" only works with normal numbers.`;
      throw makeError(TypeError, msg, nonred);
    }
  }
  function nonzero(value) {
    if (!value) {
      const msg = "Cannot divide by zero.";
      throw makeError(RangeError, msg, nonzero);
    }
  }
  var SquareRootError = class extends Error {
    constructor(result) {
      super();
      this.name = "SquareRootError";
      this.message = "X is not a square mod P.";
      this.result = result.fromRed();
      if (Error.captureStackTrace)
        Error.captureStackTrace(this, SquareRootError);
    }
  };
  function isInteger(num) {
    return Number.isSafeInteger(num);
  }
  function isSMI(num) {
    return isInteger(num) && num >= -67108863 && num <= 67108863;
  }
  function allocate(ArrayType, size) {
    if (ArrayType.allocUnsafeSlow)
      return ArrayType.allocUnsafeSlow(size);
    return new ArrayType(size);
  }
  function getBase(base) {
    if (base == null)
      return 10;
    if (typeof base === "number")
      return base;
    switch (base) {
      case "bin":
        return 2;
      case "oct":
        return 8;
      case "dec":
        return 10;
      case "hex":
        return 16;
    }
    return 0;
  }
  function countBits(w) {
    if (Math.clz32)
      return 32 - Math.clz32(w);
    let t = w;
    let r = 0;
    if (t >= 4096) {
      r += 13;
      t >>>= 13;
    }
    if (t >= 64) {
      r += 7;
      t >>>= 7;
    }
    if (t >= 8) {
      r += 4;
      t >>>= 4;
    }
    if (t >= 2) {
      r += 2;
      t >>>= 2;
    }
    return r + t;
  }
  function zeroBits(w) {
    if (w === 0)
      return 26;
    let t = w;
    let r = 0;
    if ((t & 8191) === 0) {
      r += 13;
      t >>>= 13;
    }
    if ((t & 127) === 0) {
      r += 7;
      t >>>= 7;
    }
    if ((t & 15) === 0) {
      r += 4;
      t >>>= 4;
    }
    if ((t & 3) === 0) {
      r += 2;
      t >>>= 2;
    }
    if ((t & 1) === 0)
      r += 1;
    return r;
  }
  function parseHex(str, start, end) {
    const len = Math.min(str.length, end);
    let r = 0;
    let z = 0;
    for (let i = start; i < len; i++) {
      const c = str.charCodeAt(i) - 48;
      r <<= 4;
      let b;
      if (c >= 49 && c <= 54) {
        b = c - 49 + 10;
      } else if (c >= 17 && c <= 22) {
        b = c - 17 + 10;
      } else {
        b = c;
      }
      r |= b;
      z |= b;
    }
    if (z & ~15)
      throw new Error("Invalid string.");
    return r;
  }
  function parseBase(str, start, end, mul) {
    const len = Math.min(str.length, end);
    let r = 0;
    for (let i = start; i < len; i++) {
      const c = str.charCodeAt(i) - 48;
      r *= mul;
      let b;
      if (c >= 49) {
        b = c - 49 + 10;
      } else if (c >= 17) {
        b = c - 17 + 10;
      } else {
        b = c;
      }
      if (c < 0 || c > 207 || b >= mul)
        throw new Error("Invalid string.");
      r += b;
    }
    return r;
  }
  function powInt(x, e, m) {
    const one = BigInt(1);
    const wnd = new Array(WND_SIZE);
    const x2 = x * x % m;
    wnd[0] = x;
    for (let i2 = 1; i2 < WND_SIZE; i2++)
      wnd[i2] = wnd[i2 - 1] * x2 % m;
    let i = e.bitLength();
    let r = one;
    while (i >= WND_WIDTH) {
      let width = WND_WIDTH;
      let bits = e.bits(i - width, width);
      if (bits < WND_SIZE) {
        r = r * r % m;
        i -= 1;
        continue;
      }
      while ((bits & 1) === 0) {
        width -= 1;
        bits >>= 1;
      }
      if (r === one) {
        r = wnd[bits >> 1];
      } else {
        r = sqrn(r, width, m);
        r = r * wnd[bits >> 1] % m;
      }
      i -= width;
    }
    if (i > 0) {
      const bits = e.bits(0, i);
      while (i--) {
        r = r * r % m;
        if (bits >> i & 1)
          r = r * x % m;
      }
    }
    return r;
  }
  function sqrn(x, n, m) {
    for (let i = 0; i < n; i++)
      x = x * x % m;
    return x;
  }
  function smallMulTo(self2, num, out) {
    const len = self2.length + num.length;
    out.negative = self2.negative ^ num.negative;
    out._alloc(len);
    out.length = len;
    const a = self2.words[0];
    const b = num.words[0];
    const r = a * b;
    const lo = r & 67108863;
    let carry = r / 67108864 | 0;
    let k = 1;
    out.words[0] = lo;
    for (; k < out.length - 1; k++) {
      let ncarry = carry >>> 26;
      let rword = carry & 67108863;
      const min = Math.max(0, k - self2.length + 1);
      const max = Math.min(k, num.length - 1);
      for (let j = min; j <= max; j++) {
        const i = k - j;
        const a2 = self2.words[i];
        const b2 = num.words[j];
        const r2 = a2 * b2 + rword;
        ncarry += r2 / 67108864 | 0;
        rword = r2 & 67108863;
      }
      out.words[k] = rword | 0;
      carry = ncarry | 0;
    }
    if (carry !== 0)
      out.words[k] = carry | 0;
    else
      out.length -= 1;
    return out._strip();
  }
  function bigMulTo(self2, num, out) {
    const len = self2.length + num.length;
    out.negative = self2.negative ^ num.negative;
    out._alloc(len);
    out.length = len;
    let carry = 0;
    let hncarry = 0;
    let k = 0;
    for (; k < out.length - 1; k++) {
      let ncarry = hncarry;
      hncarry = 0;
      let rword = carry & 67108863;
      const min = Math.max(0, k - self2.length + 1);
      const max = Math.min(k, num.length - 1);
      for (let j = min; j <= max; j++) {
        const i = k - j;
        const a = self2.words[i];
        const b = num.words[j];
        const r = a * b;
        let lo = r & 67108863;
        ncarry = ncarry + (r / 67108864 | 0) | 0;
        lo = lo + rword | 0;
        rword = lo & 67108863;
        ncarry = ncarry + (lo >>> 26) | 0;
        hncarry += ncarry >>> 26;
        ncarry &= 67108863;
      }
      out.words[k] = rword;
      carry = ncarry;
      ncarry = hncarry;
    }
    if (carry !== 0)
      out.words[k] = carry;
    else
      out.length -= 1;
    return out._strip();
  }
  function jumboMulTo(x, y, out) {
    if (!HAS_BIGINT || x.length + y.length > 82595519)
      return bigMulTo(x, y, out);
    const zero = BigInt(0);
    const mask = BigInt(67108863);
    const shift = BigInt(26);
    let z = x.toBigInt() * y.toBigInt();
    const neg = z < zero | 0;
    if (neg)
      z = -z;
    let i = 0;
    while (z > zero) {
      out.words[i++] = Number(z & mask);
      z >>= shift;
    }
    if (i === 0)
      out.words[i++] = 0;
    out.length = i;
    out.negative = neg;
    return out;
  }
  function comb10MulTo(self2, num, out) {
    const a = self2.words;
    const b = num.words;
    const o = out.words;
    const a0 = a[0] | 0;
    const al0 = a0 & 8191;
    const ah0 = a0 >>> 13;
    const a1 = a[1] | 0;
    const al1 = a1 & 8191;
    const ah1 = a1 >>> 13;
    const a2 = a[2] | 0;
    const al2 = a2 & 8191;
    const ah2 = a2 >>> 13;
    const a3 = a[3] | 0;
    const al3 = a3 & 8191;
    const ah3 = a3 >>> 13;
    const a4 = a[4] | 0;
    const al4 = a4 & 8191;
    const ah4 = a4 >>> 13;
    const a5 = a[5] | 0;
    const al5 = a5 & 8191;
    const ah5 = a5 >>> 13;
    const a6 = a[6] | 0;
    const al6 = a6 & 8191;
    const ah6 = a6 >>> 13;
    const a7 = a[7] | 0;
    const al7 = a7 & 8191;
    const ah7 = a7 >>> 13;
    const a8 = a[8] | 0;
    const al8 = a8 & 8191;
    const ah8 = a8 >>> 13;
    const a9 = a[9] | 0;
    const al9 = a9 & 8191;
    const ah9 = a9 >>> 13;
    const b0 = b[0] | 0;
    const bl0 = b0 & 8191;
    const bh0 = b0 >>> 13;
    const b1 = b[1] | 0;
    const bl1 = b1 & 8191;
    const bh1 = b1 >>> 13;
    const b2 = b[2] | 0;
    const bl2 = b2 & 8191;
    const bh2 = b2 >>> 13;
    const b3 = b[3] | 0;
    const bl3 = b3 & 8191;
    const bh3 = b3 >>> 13;
    const b4 = b[4] | 0;
    const bl4 = b4 & 8191;
    const bh4 = b4 >>> 13;
    const b5 = b[5] | 0;
    const bl5 = b5 & 8191;
    const bh5 = b5 >>> 13;
    const b6 = b[6] | 0;
    const bl6 = b6 & 8191;
    const bh6 = b6 >>> 13;
    const b7 = b[7] | 0;
    const bl7 = b7 & 8191;
    const bh7 = b7 >>> 13;
    const b8 = b[8] | 0;
    const bl8 = b8 & 8191;
    const bh8 = b8 >>> 13;
    const b9 = b[9] | 0;
    const bl9 = b9 & 8191;
    const bh9 = b9 >>> 13;
    let c = 0;
    let lo, mid, hi;
    out.negative = self2.negative ^ num.negative;
    out._alloc(20);
    out.length = 19;
    lo = Math.imul(al0, bl0);
    mid = Math.imul(al0, bh0);
    mid = mid + Math.imul(ah0, bl0) | 0;
    hi = Math.imul(ah0, bh0);
    let w0 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w0 >>> 26) | 0;
    w0 &= 67108863;
    lo = Math.imul(al1, bl0);
    mid = Math.imul(al1, bh0);
    mid = mid + Math.imul(ah1, bl0) | 0;
    hi = Math.imul(ah1, bh0);
    lo = lo + Math.imul(al0, bl1) | 0;
    mid = mid + Math.imul(al0, bh1) | 0;
    mid = mid + Math.imul(ah0, bl1) | 0;
    hi = hi + Math.imul(ah0, bh1) | 0;
    let w1 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w1 >>> 26) | 0;
    w1 &= 67108863;
    lo = Math.imul(al2, bl0);
    mid = Math.imul(al2, bh0);
    mid = mid + Math.imul(ah2, bl0) | 0;
    hi = Math.imul(ah2, bh0);
    lo = lo + Math.imul(al1, bl1) | 0;
    mid = mid + Math.imul(al1, bh1) | 0;
    mid = mid + Math.imul(ah1, bl1) | 0;
    hi = hi + Math.imul(ah1, bh1) | 0;
    lo = lo + Math.imul(al0, bl2) | 0;
    mid = mid + Math.imul(al0, bh2) | 0;
    mid = mid + Math.imul(ah0, bl2) | 0;
    hi = hi + Math.imul(ah0, bh2) | 0;
    let w2 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w2 >>> 26) | 0;
    w2 &= 67108863;
    lo = Math.imul(al3, bl0);
    mid = Math.imul(al3, bh0);
    mid = mid + Math.imul(ah3, bl0) | 0;
    hi = Math.imul(ah3, bh0);
    lo = lo + Math.imul(al2, bl1) | 0;
    mid = mid + Math.imul(al2, bh1) | 0;
    mid = mid + Math.imul(ah2, bl1) | 0;
    hi = hi + Math.imul(ah2, bh1) | 0;
    lo = lo + Math.imul(al1, bl2) | 0;
    mid = mid + Math.imul(al1, bh2) | 0;
    mid = mid + Math.imul(ah1, bl2) | 0;
    hi = hi + Math.imul(ah1, bh2) | 0;
    lo = lo + Math.imul(al0, bl3) | 0;
    mid = mid + Math.imul(al0, bh3) | 0;
    mid = mid + Math.imul(ah0, bl3) | 0;
    hi = hi + Math.imul(ah0, bh3) | 0;
    let w3 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w3 >>> 26) | 0;
    w3 &= 67108863;
    lo = Math.imul(al4, bl0);
    mid = Math.imul(al4, bh0);
    mid = mid + Math.imul(ah4, bl0) | 0;
    hi = Math.imul(ah4, bh0);
    lo = lo + Math.imul(al3, bl1) | 0;
    mid = mid + Math.imul(al3, bh1) | 0;
    mid = mid + Math.imul(ah3, bl1) | 0;
    hi = hi + Math.imul(ah3, bh1) | 0;
    lo = lo + Math.imul(al2, bl2) | 0;
    mid = mid + Math.imul(al2, bh2) | 0;
    mid = mid + Math.imul(ah2, bl2) | 0;
    hi = hi + Math.imul(ah2, bh2) | 0;
    lo = lo + Math.imul(al1, bl3) | 0;
    mid = mid + Math.imul(al1, bh3) | 0;
    mid = mid + Math.imul(ah1, bl3) | 0;
    hi = hi + Math.imul(ah1, bh3) | 0;
    lo = lo + Math.imul(al0, bl4) | 0;
    mid = mid + Math.imul(al0, bh4) | 0;
    mid = mid + Math.imul(ah0, bl4) | 0;
    hi = hi + Math.imul(ah0, bh4) | 0;
    let w4 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w4 >>> 26) | 0;
    w4 &= 67108863;
    lo = Math.imul(al5, bl0);
    mid = Math.imul(al5, bh0);
    mid = mid + Math.imul(ah5, bl0) | 0;
    hi = Math.imul(ah5, bh0);
    lo = lo + Math.imul(al4, bl1) | 0;
    mid = mid + Math.imul(al4, bh1) | 0;
    mid = mid + Math.imul(ah4, bl1) | 0;
    hi = hi + Math.imul(ah4, bh1) | 0;
    lo = lo + Math.imul(al3, bl2) | 0;
    mid = mid + Math.imul(al3, bh2) | 0;
    mid = mid + Math.imul(ah3, bl2) | 0;
    hi = hi + Math.imul(ah3, bh2) | 0;
    lo = lo + Math.imul(al2, bl3) | 0;
    mid = mid + Math.imul(al2, bh3) | 0;
    mid = mid + Math.imul(ah2, bl3) | 0;
    hi = hi + Math.imul(ah2, bh3) | 0;
    lo = lo + Math.imul(al1, bl4) | 0;
    mid = mid + Math.imul(al1, bh4) | 0;
    mid = mid + Math.imul(ah1, bl4) | 0;
    hi = hi + Math.imul(ah1, bh4) | 0;
    lo = lo + Math.imul(al0, bl5) | 0;
    mid = mid + Math.imul(al0, bh5) | 0;
    mid = mid + Math.imul(ah0, bl5) | 0;
    hi = hi + Math.imul(ah0, bh5) | 0;
    let w5 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w5 >>> 26) | 0;
    w5 &= 67108863;
    lo = Math.imul(al6, bl0);
    mid = Math.imul(al6, bh0);
    mid = mid + Math.imul(ah6, bl0) | 0;
    hi = Math.imul(ah6, bh0);
    lo = lo + Math.imul(al5, bl1) | 0;
    mid = mid + Math.imul(al5, bh1) | 0;
    mid = mid + Math.imul(ah5, bl1) | 0;
    hi = hi + Math.imul(ah5, bh1) | 0;
    lo = lo + Math.imul(al4, bl2) | 0;
    mid = mid + Math.imul(al4, bh2) | 0;
    mid = mid + Math.imul(ah4, bl2) | 0;
    hi = hi + Math.imul(ah4, bh2) | 0;
    lo = lo + Math.imul(al3, bl3) | 0;
    mid = mid + Math.imul(al3, bh3) | 0;
    mid = mid + Math.imul(ah3, bl3) | 0;
    hi = hi + Math.imul(ah3, bh3) | 0;
    lo = lo + Math.imul(al2, bl4) | 0;
    mid = mid + Math.imul(al2, bh4) | 0;
    mid = mid + Math.imul(ah2, bl4) | 0;
    hi = hi + Math.imul(ah2, bh4) | 0;
    lo = lo + Math.imul(al1, bl5) | 0;
    mid = mid + Math.imul(al1, bh5) | 0;
    mid = mid + Math.imul(ah1, bl5) | 0;
    hi = hi + Math.imul(ah1, bh5) | 0;
    lo = lo + Math.imul(al0, bl6) | 0;
    mid = mid + Math.imul(al0, bh6) | 0;
    mid = mid + Math.imul(ah0, bl6) | 0;
    hi = hi + Math.imul(ah0, bh6) | 0;
    let w6 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w6 >>> 26) | 0;
    w6 &= 67108863;
    lo = Math.imul(al7, bl0);
    mid = Math.imul(al7, bh0);
    mid = mid + Math.imul(ah7, bl0) | 0;
    hi = Math.imul(ah7, bh0);
    lo = lo + Math.imul(al6, bl1) | 0;
    mid = mid + Math.imul(al6, bh1) | 0;
    mid = mid + Math.imul(ah6, bl1) | 0;
    hi = hi + Math.imul(ah6, bh1) | 0;
    lo = lo + Math.imul(al5, bl2) | 0;
    mid = mid + Math.imul(al5, bh2) | 0;
    mid = mid + Math.imul(ah5, bl2) | 0;
    hi = hi + Math.imul(ah5, bh2) | 0;
    lo = lo + Math.imul(al4, bl3) | 0;
    mid = mid + Math.imul(al4, bh3) | 0;
    mid = mid + Math.imul(ah4, bl3) | 0;
    hi = hi + Math.imul(ah4, bh3) | 0;
    lo = lo + Math.imul(al3, bl4) | 0;
    mid = mid + Math.imul(al3, bh4) | 0;
    mid = mid + Math.imul(ah3, bl4) | 0;
    hi = hi + Math.imul(ah3, bh4) | 0;
    lo = lo + Math.imul(al2, bl5) | 0;
    mid = mid + Math.imul(al2, bh5) | 0;
    mid = mid + Math.imul(ah2, bl5) | 0;
    hi = hi + Math.imul(ah2, bh5) | 0;
    lo = lo + Math.imul(al1, bl6) | 0;
    mid = mid + Math.imul(al1, bh6) | 0;
    mid = mid + Math.imul(ah1, bl6) | 0;
    hi = hi + Math.imul(ah1, bh6) | 0;
    lo = lo + Math.imul(al0, bl7) | 0;
    mid = mid + Math.imul(al0, bh7) | 0;
    mid = mid + Math.imul(ah0, bl7) | 0;
    hi = hi + Math.imul(ah0, bh7) | 0;
    let w7 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w7 >>> 26) | 0;
    w7 &= 67108863;
    lo = Math.imul(al8, bl0);
    mid = Math.imul(al8, bh0);
    mid = mid + Math.imul(ah8, bl0) | 0;
    hi = Math.imul(ah8, bh0);
    lo = lo + Math.imul(al7, bl1) | 0;
    mid = mid + Math.imul(al7, bh1) | 0;
    mid = mid + Math.imul(ah7, bl1) | 0;
    hi = hi + Math.imul(ah7, bh1) | 0;
    lo = lo + Math.imul(al6, bl2) | 0;
    mid = mid + Math.imul(al6, bh2) | 0;
    mid = mid + Math.imul(ah6, bl2) | 0;
    hi = hi + Math.imul(ah6, bh2) | 0;
    lo = lo + Math.imul(al5, bl3) | 0;
    mid = mid + Math.imul(al5, bh3) | 0;
    mid = mid + Math.imul(ah5, bl3) | 0;
    hi = hi + Math.imul(ah5, bh3) | 0;
    lo = lo + Math.imul(al4, bl4) | 0;
    mid = mid + Math.imul(al4, bh4) | 0;
    mid = mid + Math.imul(ah4, bl4) | 0;
    hi = hi + Math.imul(ah4, bh4) | 0;
    lo = lo + Math.imul(al3, bl5) | 0;
    mid = mid + Math.imul(al3, bh5) | 0;
    mid = mid + Math.imul(ah3, bl5) | 0;
    hi = hi + Math.imul(ah3, bh5) | 0;
    lo = lo + Math.imul(al2, bl6) | 0;
    mid = mid + Math.imul(al2, bh6) | 0;
    mid = mid + Math.imul(ah2, bl6) | 0;
    hi = hi + Math.imul(ah2, bh6) | 0;
    lo = lo + Math.imul(al1, bl7) | 0;
    mid = mid + Math.imul(al1, bh7) | 0;
    mid = mid + Math.imul(ah1, bl7) | 0;
    hi = hi + Math.imul(ah1, bh7) | 0;
    lo = lo + Math.imul(al0, bl8) | 0;
    mid = mid + Math.imul(al0, bh8) | 0;
    mid = mid + Math.imul(ah0, bl8) | 0;
    hi = hi + Math.imul(ah0, bh8) | 0;
    let w8 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w8 >>> 26) | 0;
    w8 &= 67108863;
    lo = Math.imul(al9, bl0);
    mid = Math.imul(al9, bh0);
    mid = mid + Math.imul(ah9, bl0) | 0;
    hi = Math.imul(ah9, bh0);
    lo = lo + Math.imul(al8, bl1) | 0;
    mid = mid + Math.imul(al8, bh1) | 0;
    mid = mid + Math.imul(ah8, bl1) | 0;
    hi = hi + Math.imul(ah8, bh1) | 0;
    lo = lo + Math.imul(al7, bl2) | 0;
    mid = mid + Math.imul(al7, bh2) | 0;
    mid = mid + Math.imul(ah7, bl2) | 0;
    hi = hi + Math.imul(ah7, bh2) | 0;
    lo = lo + Math.imul(al6, bl3) | 0;
    mid = mid + Math.imul(al6, bh3) | 0;
    mid = mid + Math.imul(ah6, bl3) | 0;
    hi = hi + Math.imul(ah6, bh3) | 0;
    lo = lo + Math.imul(al5, bl4) | 0;
    mid = mid + Math.imul(al5, bh4) | 0;
    mid = mid + Math.imul(ah5, bl4) | 0;
    hi = hi + Math.imul(ah5, bh4) | 0;
    lo = lo + Math.imul(al4, bl5) | 0;
    mid = mid + Math.imul(al4, bh5) | 0;
    mid = mid + Math.imul(ah4, bl5) | 0;
    hi = hi + Math.imul(ah4, bh5) | 0;
    lo = lo + Math.imul(al3, bl6) | 0;
    mid = mid + Math.imul(al3, bh6) | 0;
    mid = mid + Math.imul(ah3, bl6) | 0;
    hi = hi + Math.imul(ah3, bh6) | 0;
    lo = lo + Math.imul(al2, bl7) | 0;
    mid = mid + Math.imul(al2, bh7) | 0;
    mid = mid + Math.imul(ah2, bl7) | 0;
    hi = hi + Math.imul(ah2, bh7) | 0;
    lo = lo + Math.imul(al1, bl8) | 0;
    mid = mid + Math.imul(al1, bh8) | 0;
    mid = mid + Math.imul(ah1, bl8) | 0;
    hi = hi + Math.imul(ah1, bh8) | 0;
    lo = lo + Math.imul(al0, bl9) | 0;
    mid = mid + Math.imul(al0, bh9) | 0;
    mid = mid + Math.imul(ah0, bl9) | 0;
    hi = hi + Math.imul(ah0, bh9) | 0;
    let w9 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w9 >>> 26) | 0;
    w9 &= 67108863;
    lo = Math.imul(al9, bl1);
    mid = Math.imul(al9, bh1);
    mid = mid + Math.imul(ah9, bl1) | 0;
    hi = Math.imul(ah9, bh1);
    lo = lo + Math.imul(al8, bl2) | 0;
    mid = mid + Math.imul(al8, bh2) | 0;
    mid = mid + Math.imul(ah8, bl2) | 0;
    hi = hi + Math.imul(ah8, bh2) | 0;
    lo = lo + Math.imul(al7, bl3) | 0;
    mid = mid + Math.imul(al7, bh3) | 0;
    mid = mid + Math.imul(ah7, bl3) | 0;
    hi = hi + Math.imul(ah7, bh3) | 0;
    lo = lo + Math.imul(al6, bl4) | 0;
    mid = mid + Math.imul(al6, bh4) | 0;
    mid = mid + Math.imul(ah6, bl4) | 0;
    hi = hi + Math.imul(ah6, bh4) | 0;
    lo = lo + Math.imul(al5, bl5) | 0;
    mid = mid + Math.imul(al5, bh5) | 0;
    mid = mid + Math.imul(ah5, bl5) | 0;
    hi = hi + Math.imul(ah5, bh5) | 0;
    lo = lo + Math.imul(al4, bl6) | 0;
    mid = mid + Math.imul(al4, bh6) | 0;
    mid = mid + Math.imul(ah4, bl6) | 0;
    hi = hi + Math.imul(ah4, bh6) | 0;
    lo = lo + Math.imul(al3, bl7) | 0;
    mid = mid + Math.imul(al3, bh7) | 0;
    mid = mid + Math.imul(ah3, bl7) | 0;
    hi = hi + Math.imul(ah3, bh7) | 0;
    lo = lo + Math.imul(al2, bl8) | 0;
    mid = mid + Math.imul(al2, bh8) | 0;
    mid = mid + Math.imul(ah2, bl8) | 0;
    hi = hi + Math.imul(ah2, bh8) | 0;
    lo = lo + Math.imul(al1, bl9) | 0;
    mid = mid + Math.imul(al1, bh9) | 0;
    mid = mid + Math.imul(ah1, bl9) | 0;
    hi = hi + Math.imul(ah1, bh9) | 0;
    let w10 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w10 >>> 26) | 0;
    w10 &= 67108863;
    lo = Math.imul(al9, bl2);
    mid = Math.imul(al9, bh2);
    mid = mid + Math.imul(ah9, bl2) | 0;
    hi = Math.imul(ah9, bh2);
    lo = lo + Math.imul(al8, bl3) | 0;
    mid = mid + Math.imul(al8, bh3) | 0;
    mid = mid + Math.imul(ah8, bl3) | 0;
    hi = hi + Math.imul(ah8, bh3) | 0;
    lo = lo + Math.imul(al7, bl4) | 0;
    mid = mid + Math.imul(al7, bh4) | 0;
    mid = mid + Math.imul(ah7, bl4) | 0;
    hi = hi + Math.imul(ah7, bh4) | 0;
    lo = lo + Math.imul(al6, bl5) | 0;
    mid = mid + Math.imul(al6, bh5) | 0;
    mid = mid + Math.imul(ah6, bl5) | 0;
    hi = hi + Math.imul(ah6, bh5) | 0;
    lo = lo + Math.imul(al5, bl6) | 0;
    mid = mid + Math.imul(al5, bh6) | 0;
    mid = mid + Math.imul(ah5, bl6) | 0;
    hi = hi + Math.imul(ah5, bh6) | 0;
    lo = lo + Math.imul(al4, bl7) | 0;
    mid = mid + Math.imul(al4, bh7) | 0;
    mid = mid + Math.imul(ah4, bl7) | 0;
    hi = hi + Math.imul(ah4, bh7) | 0;
    lo = lo + Math.imul(al3, bl8) | 0;
    mid = mid + Math.imul(al3, bh8) | 0;
    mid = mid + Math.imul(ah3, bl8) | 0;
    hi = hi + Math.imul(ah3, bh8) | 0;
    lo = lo + Math.imul(al2, bl9) | 0;
    mid = mid + Math.imul(al2, bh9) | 0;
    mid = mid + Math.imul(ah2, bl9) | 0;
    hi = hi + Math.imul(ah2, bh9) | 0;
    let w11 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w11 >>> 26) | 0;
    w11 &= 67108863;
    lo = Math.imul(al9, bl3);
    mid = Math.imul(al9, bh3);
    mid = mid + Math.imul(ah9, bl3) | 0;
    hi = Math.imul(ah9, bh3);
    lo = lo + Math.imul(al8, bl4) | 0;
    mid = mid + Math.imul(al8, bh4) | 0;
    mid = mid + Math.imul(ah8, bl4) | 0;
    hi = hi + Math.imul(ah8, bh4) | 0;
    lo = lo + Math.imul(al7, bl5) | 0;
    mid = mid + Math.imul(al7, bh5) | 0;
    mid = mid + Math.imul(ah7, bl5) | 0;
    hi = hi + Math.imul(ah7, bh5) | 0;
    lo = lo + Math.imul(al6, bl6) | 0;
    mid = mid + Math.imul(al6, bh6) | 0;
    mid = mid + Math.imul(ah6, bl6) | 0;
    hi = hi + Math.imul(ah6, bh6) | 0;
    lo = lo + Math.imul(al5, bl7) | 0;
    mid = mid + Math.imul(al5, bh7) | 0;
    mid = mid + Math.imul(ah5, bl7) | 0;
    hi = hi + Math.imul(ah5, bh7) | 0;
    lo = lo + Math.imul(al4, bl8) | 0;
    mid = mid + Math.imul(al4, bh8) | 0;
    mid = mid + Math.imul(ah4, bl8) | 0;
    hi = hi + Math.imul(ah4, bh8) | 0;
    lo = lo + Math.imul(al3, bl9) | 0;
    mid = mid + Math.imul(al3, bh9) | 0;
    mid = mid + Math.imul(ah3, bl9) | 0;
    hi = hi + Math.imul(ah3, bh9) | 0;
    let w12 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w12 >>> 26) | 0;
    w12 &= 67108863;
    lo = Math.imul(al9, bl4);
    mid = Math.imul(al9, bh4);
    mid = mid + Math.imul(ah9, bl4) | 0;
    hi = Math.imul(ah9, bh4);
    lo = lo + Math.imul(al8, bl5) | 0;
    mid = mid + Math.imul(al8, bh5) | 0;
    mid = mid + Math.imul(ah8, bl5) | 0;
    hi = hi + Math.imul(ah8, bh5) | 0;
    lo = lo + Math.imul(al7, bl6) | 0;
    mid = mid + Math.imul(al7, bh6) | 0;
    mid = mid + Math.imul(ah7, bl6) | 0;
    hi = hi + Math.imul(ah7, bh6) | 0;
    lo = lo + Math.imul(al6, bl7) | 0;
    mid = mid + Math.imul(al6, bh7) | 0;
    mid = mid + Math.imul(ah6, bl7) | 0;
    hi = hi + Math.imul(ah6, bh7) | 0;
    lo = lo + Math.imul(al5, bl8) | 0;
    mid = mid + Math.imul(al5, bh8) | 0;
    mid = mid + Math.imul(ah5, bl8) | 0;
    hi = hi + Math.imul(ah5, bh8) | 0;
    lo = lo + Math.imul(al4, bl9) | 0;
    mid = mid + Math.imul(al4, bh9) | 0;
    mid = mid + Math.imul(ah4, bl9) | 0;
    hi = hi + Math.imul(ah4, bh9) | 0;
    let w13 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w13 >>> 26) | 0;
    w13 &= 67108863;
    lo = Math.imul(al9, bl5);
    mid = Math.imul(al9, bh5);
    mid = mid + Math.imul(ah9, bl5) | 0;
    hi = Math.imul(ah9, bh5);
    lo = lo + Math.imul(al8, bl6) | 0;
    mid = mid + Math.imul(al8, bh6) | 0;
    mid = mid + Math.imul(ah8, bl6) | 0;
    hi = hi + Math.imul(ah8, bh6) | 0;
    lo = lo + Math.imul(al7, bl7) | 0;
    mid = mid + Math.imul(al7, bh7) | 0;
    mid = mid + Math.imul(ah7, bl7) | 0;
    hi = hi + Math.imul(ah7, bh7) | 0;
    lo = lo + Math.imul(al6, bl8) | 0;
    mid = mid + Math.imul(al6, bh8) | 0;
    mid = mid + Math.imul(ah6, bl8) | 0;
    hi = hi + Math.imul(ah6, bh8) | 0;
    lo = lo + Math.imul(al5, bl9) | 0;
    mid = mid + Math.imul(al5, bh9) | 0;
    mid = mid + Math.imul(ah5, bl9) | 0;
    hi = hi + Math.imul(ah5, bh9) | 0;
    let w14 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w14 >>> 26) | 0;
    w14 &= 67108863;
    lo = Math.imul(al9, bl6);
    mid = Math.imul(al9, bh6);
    mid = mid + Math.imul(ah9, bl6) | 0;
    hi = Math.imul(ah9, bh6);
    lo = lo + Math.imul(al8, bl7) | 0;
    mid = mid + Math.imul(al8, bh7) | 0;
    mid = mid + Math.imul(ah8, bl7) | 0;
    hi = hi + Math.imul(ah8, bh7) | 0;
    lo = lo + Math.imul(al7, bl8) | 0;
    mid = mid + Math.imul(al7, bh8) | 0;
    mid = mid + Math.imul(ah7, bl8) | 0;
    hi = hi + Math.imul(ah7, bh8) | 0;
    lo = lo + Math.imul(al6, bl9) | 0;
    mid = mid + Math.imul(al6, bh9) | 0;
    mid = mid + Math.imul(ah6, bl9) | 0;
    hi = hi + Math.imul(ah6, bh9) | 0;
    let w15 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w15 >>> 26) | 0;
    w15 &= 67108863;
    lo = Math.imul(al9, bl7);
    mid = Math.imul(al9, bh7);
    mid = mid + Math.imul(ah9, bl7) | 0;
    hi = Math.imul(ah9, bh7);
    lo = lo + Math.imul(al8, bl8) | 0;
    mid = mid + Math.imul(al8, bh8) | 0;
    mid = mid + Math.imul(ah8, bl8) | 0;
    hi = hi + Math.imul(ah8, bh8) | 0;
    lo = lo + Math.imul(al7, bl9) | 0;
    mid = mid + Math.imul(al7, bh9) | 0;
    mid = mid + Math.imul(ah7, bl9) | 0;
    hi = hi + Math.imul(ah7, bh9) | 0;
    let w16 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w16 >>> 26) | 0;
    w16 &= 67108863;
    lo = Math.imul(al9, bl8);
    mid = Math.imul(al9, bh8);
    mid = mid + Math.imul(ah9, bl8) | 0;
    hi = Math.imul(ah9, bh8);
    lo = lo + Math.imul(al8, bl9) | 0;
    mid = mid + Math.imul(al8, bh9) | 0;
    mid = mid + Math.imul(ah8, bl9) | 0;
    hi = hi + Math.imul(ah8, bh9) | 0;
    let w17 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w17 >>> 26) | 0;
    w17 &= 67108863;
    lo = Math.imul(al9, bl9);
    mid = Math.imul(al9, bh9);
    mid = mid + Math.imul(ah9, bl9) | 0;
    hi = Math.imul(ah9, bh9);
    let w18 = (c + lo | 0) + ((mid & 8191) << 13) | 0;
    c = (hi + (mid >>> 13) | 0) + (w18 >>> 26) | 0;
    w18 &= 67108863;
    o[0] = w0;
    o[1] = w1;
    o[2] = w2;
    o[3] = w3;
    o[4] = w4;
    o[5] = w5;
    o[6] = w6;
    o[7] = w7;
    o[8] = w8;
    o[9] = w9;
    o[10] = w10;
    o[11] = w11;
    o[12] = w12;
    o[13] = w13;
    o[14] = w14;
    o[15] = w15;
    o[16] = w16;
    o[17] = w17;
    o[18] = w18;
    if (c !== 0) {
      o[19] = c;
      out.length += 1;
    }
    return out;
  }
  if (!Math.imul)
    comb10MulTo = smallMulTo;
  BN.Red = Red;
  module2.exports = BN;
});

// node_modules/bcrypto/lib/bn-browser.js
var require_bn_browser = __commonJS((exports2, module2) => {
  /*!
   * bn.js - big numbers for bcrypto
   * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
   * https://github.com/bcoin-org/bcrypto
   */
  "use strict";
  module2.exports = require_bn2();
});

// node_modules/bcrypto/lib/js/elliptic.js
var require_elliptic4 = __commonJS((exports2) => {
  /*!
   * elliptic.js - elliptic curves for bcrypto
   * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).
   * https://github.com/bcoin-org/bcrypto
   *
   * Parts of this software are based on indutny/elliptic:
   *   Copyright (c) 2014, Fedor Indutny (MIT License).
   *   https://github.com/indutny/elliptic
   *
   * Formulas from DJB and Tanja Lange [EFD].
   *
   * References:
   *
   *   [GECC] Guide to Elliptic Curve Cryptography
   *     D. Hankerson, A. Menezes, and S. Vanstone
   *     https://tinyurl.com/guide-to-ecc
   *
   *   [GLV] Faster Point Multiplication on Elliptic Curves
   *     R. Gallant, R. Lambert, and S. Vanstone
   *     https://link.springer.com/content/pdf/10.1007/3-540-44647-8_11.pdf
   *
   *   [MONT1] Montgomery curves and the Montgomery ladder
   *     Daniel J. Bernstein, Tanja Lange
   *     https://eprint.iacr.org/2017/293.pdf
   *
   *   [SQUARED] Elligator Squared
   *     Mehdi Tibouchi
   *     https://eprint.iacr.org/2014/043.pdf
   *
   *   [SEC1] SEC 1 - Standards for Efficient Cryptography Group
   *     Certicom Research
   *     https://www.secg.org/sec1-v2.pdf
   *
   *   [SEC2] SEC 2: Recommended Elliptic Curve Domain Parameters
   *     Certicom Research
   *     https://www.secg.org/sec2-v2.pdf
   *
   *   [SIDE1] Elliptic Curves and Side-Channel Attacks
   *     Marc Joye
   *     https://pdfs.semanticscholar.org/8d69/9645033e25d74fcfd4cbf07a770d2e943e14.pdf
   *
   *   [BLIND] Side-Channel Analysis on Blinding Regular Scalar Multiplications
   *     B. Feix, M. Roussellet, A. Venelli
   *     https://eprint.iacr.org/2014/191.pdf
   *
   *   [ALT] Alternative Elliptic Curve Representations
   *     R. Struik
   *     https://tools.ietf.org/id/draft-ietf-lwig-curve-representations-02.html
   *
   *   [ARITH1] Arithmetic of Elliptic Curves
   *     Christophe Doche, Tanja Lange
   *     Handbook of Elliptic and Hyperelliptic Curve Cryptography
   *     Page 267, Section 13 (978-1-58488-518-4)
   *     https://hyperelliptic.org/HEHCC/index.html
   *
   *   [ARITH2] The Arithmetic of Elliptic Curves, 2nd Edition
   *     Joseph H. Silverman
   *     http://www.pdmi.ras.ru/~lowdimma/BSD/Silverman-Arithmetic_of_EC.pdf
   *
   *   [EFD] Explicit-Formulas Database
   *     Daniel J. Bernstein, Tanja Lange
   *     https://hyperelliptic.org/EFD/index.html
   *
   *   [SAFE] SafeCurves: choosing safe curves for elliptic-curve cryptography
   *     Daniel J. Bernstein
   *     https://safecurves.cr.yp.to/
   *
   *   [4GLV] Refinement of the Four-Dimensional GLV Method on Elliptic Curves
   *     Hairong Yi, Yuqing Zhu, and Dongdai Lin
   *     http://www.site.uottawa.ca/~cadams/papers/prepro/paper_19_slides.pdf
   *
   *   [SSWU1] Efficient Indifferentiable Hashing into Ordinary Elliptic Curves
   *     E. Brier, J. Coron, T. Icart, D. Madore, H. Randriam, M. Tibouchi
   *     https://eprint.iacr.org/2009/340.pdf
   *
   *   [SSWU2] Rational points on certain hyperelliptic curves over finite fields
   *     Maciej Ulas
   *     https://arxiv.org/abs/0706.1448
   *
   *   [H2EC] Hashing to Elliptic Curves
   *     A. Faz-Hernandez, S. Scott, N. Sullivan, R. S. Wahby, C. A. Wood
   *     https://git.io/JeWz6
   *     https://github.com/cfrg/draft-irtf-cfrg-hash-to-curve
   *
   *   [SVDW1] Construction of Rational Points on Elliptic Curves
   *     A. Shallue, C. E. van de Woestijne
   *     https://works.bepress.com/andrew_shallue/1/download/
   *
   *   [SVDW2] Indifferentiable Hashing to Barreto-Naehrig Curves
   *     Pierre-Alain Fouque, Mehdi Tibouchi
   *     https://www.di.ens.fr/~fouque/pub/latincrypt12.pdf
   *
   *   [SVDW3] Covert ECDH over secp256k1
   *     Pieter Wuille
   *     https://gist.github.com/sipa/29118d3fcfac69f9930d57433316c039
   *
   *   [MONT2] Montgomery Curve (wikipedia)
   *     https://en.wikipedia.org/wiki/Montgomery_curve
   *
   *   [MONT3] Montgomery Curves and their arithmetic
   *     C. Costello, B. Smith
   *     https://eprint.iacr.org/2017/212.pdf
   *
   *   [ELL2] Elliptic-curve points indistinguishable from uniform random strings
   *     D. Bernstein, M. Hamburg, A. Krasnova, T. Lange
   *     https://elligator.cr.yp.to/elligator-20130828.pdf
   *
   *   [RFC7748] Elliptic Curves for Security
   *     A. Langley, M. Hamburg, S. Turner
   *     https://tools.ietf.org/html/rfc7748
   *
   *   [TWISTED] Twisted Edwards Curves
   *     D. Bernstein, P. Birkner, M. Joye, T. Lange, C. Peters
   *     https://eprint.iacr.org/2008/013.pdf
   *
   *   [ELL1] Injective Encodings to Elliptic Curves
   *     P. Fouque, A. Joux, M. Tibouchi
   *     https://eprint.iacr.org/2013/373.pdf
   *
   *   [ISOGENY] Twisting Edwards curves with isogenies
   *     Mike Hamburg
   *     https://www.shiftleft.org/papers/isogeny/isogeny.pdf
   *
   *   [RFC8032] Edwards-Curve Digital Signature Algorithm (EdDSA)
   *     S. Josefsson, SJD AB, I. Liusvaara
   *     https://tools.ietf.org/html/rfc8032
   *
   *   [SCHNORR] Schnorr Signatures for secp256k1
   *     Pieter Wuille
   *     https://github.com/sipa/bips/blob/d194620/bip-schnorr.mediawiki
   *
   *   [BIP340] Schnorr Signatures for secp256k1
   *     Pieter Wuille, Jonas Nick, Tim Ruffing
   *     https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki
   *
   *   [JCEN12] Efficient Software Implementation of Public-Key Cryptography
   *            on Sensor Networks Using the MSP430X Microcontroller
   *     C. P. L. Gouvea, L. B. Oliveira, J. Lopez
   *     http://conradoplg.cryptoland.net/files/2010/12/jcen12.pdf
   *
   *   [FIPS186] Federal Information Processing Standards Publication
   *     National Institute of Standards and Technology
   *     https://tinyurl.com/fips-186-3
   *
   *   [RFC5639] Elliptic Curve Cryptography (ECC) Brainpool
   *             Standard Curves and Curve Generation
   *     M. Lochter, BSI, J. Merkle
   *     https://tools.ietf.org/html/rfc5639
   *
   *   [TWISTEQ] Twisted Edwards & Short Weierstrass Equivalence
   *     Christopher Jeffrey
   *     https://gist.github.com/chjj/16ba7fa08d64e8dda269a9fe5b2a8bbc
   *
   *   [ECPM] Elliptic Curve Point Multiplication (wikipedia)
   *     https://en.wikipedia.org/wiki/Elliptic_curve_point_multiplication
   */
  "use strict";
  var {custom} = require_custom_browser();
  var BN = require_bn_browser();
  var types = {
    AFFINE: 0,
    JACOBIAN: 1,
    PROJECTIVE: 2,
    EXTENDED: 3
  };
  var jsfIndex = [
    -3,
    -1,
    -5,
    -7,
    0,
    7,
    5,
    1,
    3
  ];
  var USE_FIXED = false;
  var uid = 0;
  var Curve = class {
    constructor(Point2, type, conf) {
      this.Point = null;
      this.id = null;
      this.uid = uid++;
      this.ossl = null;
      this.type = "base";
      this.endian = "be";
      this.hash = null;
      this.prefix = null;
      this.context = false;
      this.prime = null;
      this.p = null;
      this.red = null;
      this.fieldSize = 0;
      this.fieldBits = 0;
      this.adjustedSize = 0;
      this.signBit = 0;
      this.mask = 0;
      this.n = null;
      this.h = null;
      this.q = null;
      this.z = null;
      this.g = null;
      this.nh = null;
      this.scalarSize = 0;
      this.scalarBits = 0;
      this.zero = null;
      this.one = null;
      this.two = null;
      this.three = null;
      this.four = null;
      this.i2 = null;
      this.i3 = null;
      this.i4 = null;
      this.i6 = null;
      this.torsion = null;
      this.endo = null;
      this.hi = null;
      this._init(Point2, type, conf);
    }
    _init(Point2, type, conf) {
      assert(typeof Point2 === "function");
      assert(typeof type === "string");
      assert(conf && typeof conf === "object");
      assert(conf.red == null || conf.red instanceof BN.Red);
      assert(conf.p != null, "Must pass a prime.");
      assert(conf.id == null || typeof conf.id === "string");
      assert(conf.ossl == null || typeof conf.ossl === "string");
      assert(conf.endian == null || typeof conf.endian === "string");
      assert(conf.hash == null || typeof conf.hash === "string");
      assert(conf.prefix == null || typeof conf.prefix === "string");
      assert(conf.context == null || typeof conf.context === "boolean");
      assert(conf.prime == null || typeof conf.prime === "string");
      assert(conf.torsion == null || Array.isArray(conf.torsion));
      this.Point = Point2;
      this.id = conf.id || null;
      this.ossl = conf.ossl || null;
      this.type = type;
      this.endian = conf.endian || (type === "short" ? "be" : "le");
      this.hash = conf.hash || null;
      this.prefix = conf.prefix ? Buffer.from(conf.prefix, "binary") : null;
      this.context = conf.context || false;
      this.prime = conf.prime || null;
      this.p = BN.fromJSON(conf.p);
      if (conf.red) {
        this.red = conf.red;
      } else {
        this.red = conf.prime ? BN.red(conf.prime) : BN.mont(this.p);
        this.red.precompute();
      }
      this.fieldSize = this.p.byteLength();
      this.fieldBits = this.p.bitLength();
      this.adjustedSize = this.fieldSize + ((this.fieldBits & 7) === 0);
      this.signBit = this.adjustedSize * 8 - 1;
      this.mask = 255;
      if ((this.fieldBits & 7) !== 0)
        this.mask = (1 << (this.fieldBits & 7)) - 1;
      this.n = BN.fromJSON(conf.n || "0");
      this.h = BN.fromJSON(conf.h || "1");
      this.q = this.n.mul(this.h);
      this.z = BN.fromJSON(conf.z || "0").toRed(this.red);
      this.g = null;
      this.nh = this.n.ushrn(1);
      this.scalarSize = this.n.byteLength();
      this.scalarBits = this.n.bitLength();
      this.zero = new BN(0).toRed(this.red);
      this.one = new BN(1).toRed(this.red);
      this.two = new BN(2).toRed(this.red);
      this.three = new BN(3).toRed(this.red);
      this.four = new BN(4).toRed(this.red);
      this.i2 = this.two.redInvert();
      this.i3 = this.three.redInvert();
      this.i4 = this.i2.redSqr();
      this.i6 = this.i2.redMul(this.i3);
      this.torsion = new Array(this.h.word(0));
      for (let i = 0; i < this.torsion.length; i++)
        this.torsion[i] = this.point();
      this.endo = null;
      this.hi = null;
      this._scale = memoize(this._scale, this);
      this.isIsomorphic = memoize(this.isIsomorphic, this);
      this.isIsogenous = memoize(this.isIsogenous, this);
      assert(this.p.sign() > 0 && this.p.isOdd());
      assert(this.n.sign() >= 0);
      assert(this.h.sign() > 0 && this.h.cmpn(255) <= 0);
      assert(this.endian === "be" || this.endian === "le");
      return this;
    }
    _finalize(conf) {
      assert(conf && typeof conf === "object");
      this.g = conf.g ? this.pointFromJSON(conf.g) : this.point();
      if (conf.torsion) {
        assert(conf.torsion.length === this.torsion.length);
        for (let i = 0; i < this.torsion.length; i++)
          this.torsion[i] = this.pointFromJSON(conf.torsion[i]);
      }
      return this;
    }
    _findTorsion() {
      assert(!this.n.isZero());
      const h = this.h.word(0);
      const x = this.one.redNeg();
      const out = [this.point()];
      const set = new Set();
      let len = h;
      while (out.length < len) {
        let p;
        x.redIAdd(this.one);
        try {
          p = this.pointFromX(x.clone());
        } catch (e) {
          continue;
        }
        try {
          p = p.mul(this.n);
        } catch (e) {
          len = 2;
          continue;
        }
        if (p.isInfinity())
          continue;
        p.normalize();
        for (const point of [p, p.neg()]) {
          const key = point.key();
          if (!set.has(key)) {
            out.push(point);
            set.add(key);
          }
        }
      }
      out.sort((a, b) => a.cmp(b));
      while (out.length < h)
        out.push(this.point());
      return out;
    }
    _fixedMul(p, k) {
      assert(p instanceof Point);
      assert(k instanceof BN);
      assert(p.pre && p.pre.windows);
      const {width, points} = p._getWindows(0, 0);
      const size = 1 << width;
      const bits = k.bitLength();
      const steps = (bits + width - 1) / width >>> 0;
      let acc = this.jpoint();
      for (let i = 0; i < steps; i++) {
        const bits2 = k.bits(i * width, width);
        acc = acc.add(points[i * size + bits2]);
      }
      if (k.isNeg())
        acc = acc.neg();
      return acc;
    }
    _fixedNafMul(p, k) {
      assert(p instanceof Point);
      assert(k instanceof BN);
      assert(p.pre && p.pre.doubles);
      const {step, points} = p._getDoubles(0, 0);
      const naf = getFixedNAF(k, 2, k.bitLength() + 1, step);
      const I = ((1 << step + 1) - (step % 2 === 0 ? 2 : 1)) / 3;
      let a = this.jpoint();
      let b = this.jpoint();
      for (let i = I; i > 0; i--) {
        for (let j = 0; j < naf.length; j++) {
          const nafW = naf[j];
          if (nafW === i)
            b = b.add(points[j]);
          else if (nafW === -i)
            b = b.sub(points[j]);
        }
        a = a.add(b);
      }
      return a;
    }
    _wnafMul(w, p, k) {
      assert(p instanceof Point);
      assert(k instanceof BN);
      const {width, points} = p._safeNAF(w);
      const naf = getNAF(k, width, k.bitLength() + 1);
      let acc = this.jpoint();
      for (let i = naf.length - 1; i >= 0; i--) {
        const z = naf[i];
        if (i !== naf.length - 1)
          acc = acc.dbl();
        if (z > 0)
          acc = acc.add(points[z - 1 >> 1]);
        else if (z < 0)
          acc = acc.sub(points[-z - 1 >> 1]);
      }
      return acc;
    }
    _wnafMulAdd(w, points, coeffs) {
      assert(w >>> 0 === w);
      assert(Array.isArray(points));
      assert(Array.isArray(coeffs));
      assert(points.length === coeffs.length);
      const length = points.length;
      const wnd = new Array(length);
      const naf = new Array(length);
      let max = 0;
      for (let i = 0; i < length; i++) {
        const point = points[i];
        const coeff = coeffs[i];
        assert(point instanceof Point);
        assert(coeff instanceof BN);
        if (i > 0 && point.type !== points[i - 1].type)
          throw new Error("Cannot mix points.");
        wnd[i] = null;
        naf[i] = null;
        max = Math.max(max, coeff.bitLength() + 1);
      }
      let ppoint = null;
      let pcoeff = null;
      let len = 0;
      for (let i = 0; i < length; i++) {
        const point = points[i];
        const coeff = coeffs[i];
        const pre = point._getNAF(0);
        if (pre) {
          wnd[len] = pre.points;
          naf[len] = getNAF(coeff, pre.width, max);
          len += 1;
          continue;
        }
        if (!ppoint) {
          ppoint = point;
          pcoeff = coeff;
          continue;
        }
        wnd[len] = ppoint._getJNAF(point);
        naf[len] = getJNAF(pcoeff, coeff, max);
        ppoint = null;
        pcoeff = null;
        len += 1;
      }
      if (ppoint) {
        const nafw = ppoint._safeNAF(w);
        wnd[len] = nafw.points;
        naf[len] = getNAF(pcoeff, nafw.width, max);
        len += 1;
      }
      let acc = this.jpoint();
      for (let i = max - 1; i >= 0; i--) {
        if (i !== max - 1)
          acc = acc.dbl();
        for (let j = 0; j < len; j++) {
          const z = naf[j][i];
          if (z > 0)
            acc = acc.add(wnd[j][z - 1 >> 1]);
          else if (z < 0)
            acc = acc.sub(wnd[j][-z - 1 >> 1]);
        }
      }
      return acc;
    }
    _endoWnafMulAdd(points, coeffs) {
      throw new Error("Not implemented.");
    }
    _scale(curve2, invert) {
      assert(curve2 instanceof Curve);
      assert(curve2.p.eq(this.p));
      switch (curve2.type) {
        case "short":
          return this._scaleShort(curve2, invert);
        case "mont":
          return this._scaleMont(curve2, invert);
        case "edwards":
          return this._scaleEdwards(curve2, invert);
        default:
          throw new Error("Not implemented.");
      }
    }
    _scaleShort(curve2, invert) {
      throw new Error("Not implemented.");
    }
    _scaleMont(curve2, invert) {
      throw new Error("Not implemented.");
    }
    _scaleEdwards(curve2, invert) {
      throw new Error("Not implemented.");
    }
    isElliptic() {
      throw new Error("Not implemented.");
    }
    jinv() {
      throw new Error("Not implemented.");
    }
    isComplete() {
      return false;
    }
    precompute(rng) {
      assert(!this.g.isInfinity(), "Must have base point.");
      assert(!this.n.isZero(), "Must have order.");
      this.g.precompute(this.n.bitLength(), rng);
      return this;
    }
    scalar(num, base, endian) {
      const k = new BN(num, base, endian);
      assert(!k.red);
      if (this.n.isZero())
        return k;
      return k.imod(this.n);
    }
    field(num, base, endian) {
      const x = BN.cast(num, base, endian);
      if (x.red)
        return x.forceRed(this.red);
      return x.toRed(this.red);
    }
    point(x, y) {
      throw new Error("Not implemented.");
    }
    jpoint(x, y, z) {
      throw new Error("Not implemented.");
    }
    xpoint(x, z) {
      throw new Error("Not implemented.");
    }
    cpoint(xx, xz, yy, yz) {
      assert(xx instanceof BN);
      assert(xz instanceof BN);
      assert(yy instanceof BN);
      assert(yz instanceof BN);
      if (xz.isZero() || yz.isZero())
        return this.point();
      const z = xz.redMul(yz).redInvert();
      const x = xx.redMul(yz).redMul(z);
      const y = yy.redMul(xz).redMul(z);
      return this.point(x, y);
    }
    solveX2(y) {
      throw new Error("Not implemented.");
    }
    solveX(y) {
      return this.solveX2(y).redSqrt();
    }
    solveY2(x) {
      throw new Error("Not implemented.");
    }
    solveY(x) {
      return this.solveY2(x).redSqrt();
    }
    validate(point) {
      throw new Error("Not implemented.");
    }
    pointFromX(x, sign) {
      throw new Error("Not implemented.");
    }
    pointFromY(y, sign) {
      throw new Error("Not implemented.");
    }
    isIsomorphic(curve2) {
      throw new Error("Not implemented.");
    }
    isIsogenous(curve2) {
      throw new Error("Not implemented.");
    }
    pointFromShort(point) {
      throw new Error("Not implemented.");
    }
    pointFromMont(point, sign) {
      throw new Error("Not implemented.");
    }
    pointFromEdwards(point) {
      throw new Error("Not implemented.");
    }
    pointFromUniform(u) {
      throw new Error("Not implemented.");
    }
    pointToUniform(p) {
      throw new Error("Not implemented.");
    }
    pointFromHash(bytes, pake = false) {
      assert(Buffer.isBuffer(bytes));
      assert(typeof pake === "boolean");
      if (bytes.length !== this.fieldSize * 2)
        throw new Error("Invalid hash size.");
      const s1 = bytes.slice(0, this.fieldSize);
      const s2 = bytes.slice(this.fieldSize);
      const u1 = this.decodeUniform(s1);
      const u2 = this.decodeUniform(s2);
      const p1 = this.pointFromUniform(u1);
      const p2 = this.pointFromUniform(u2);
      const p3 = p1.add(p2);
      return pake ? p3.mulH() : p3;
    }
    pointToHash(p, subgroup, rng) {
      assert(p instanceof this.Point);
      assert(subgroup >>> 0 === subgroup);
      const i = subgroup % this.torsion.length;
      const p0 = p.add(this.torsion[i]);
      for (; ; ) {
        const u1 = this.randomField(rng);
        const p1 = this.pointFromUniform(u1);
        if (p1.neg().eq(p1))
          continue;
        const p2 = p0.sub(p1);
        const hint = randomInt(rng);
        let u2;
        try {
          u2 = this.pointToUniform(p2, hint & 15);
        } catch (e) {
          if (e.message === "Invalid point.")
            continue;
          throw e;
        }
        const s1 = this.encodeUniform(u1, hint >>> 8);
        const s2 = this.encodeUniform(u2, hint >>> 16);
        return Buffer.concat([s1, s2]);
      }
    }
    randomScalar(rng) {
      const max = this.n.isZero() ? this.p : this.n;
      return BN.random(rng, 1, max);
    }
    randomField(rng) {
      return BN.random(rng, 1, this.p).toRed(this.red);
    }
    randomPoint(rng) {
      let p;
      for (; ; ) {
        const x = this.randomField(rng);
        const sign = (randomInt(rng) & 1) !== 0;
        try {
          p = this.pointFromX(x, sign);
        } catch (e) {
          continue;
        }
        assert(p.validate());
        return p.mulH();
      }
    }
    mulAll(points, coeffs) {
      return this.jmulAll(points, coeffs);
    }
    jmulAll(points, coeffs) {
      assert(Array.isArray(points));
      assert(points.length === 0 || points[0] instanceof Point);
      if (this.endo && points.length > 0 && points[0].type === types.AFFINE)
        return this._endoWnafMulAdd(points, coeffs);
      return this._wnafMulAdd(5, points, coeffs);
    }
    mulH(k) {
      assert(k instanceof BN);
      return this.imulH(k.clone());
    }
    imulH(k) {
      assert(k instanceof BN);
      assert(!k.red);
      const word = this.h.word(0);
      if ((word & word - 1) === 0) {
        const bits = this.h.bitLength();
        return k.iushln(bits - 1).imod(this.n);
      }
      return k.imuln(word).imod(this.n);
    }
    normalizeAll(points) {
      assert(Array.isArray(points));
      const len = points.length;
      const z = new Array(len);
      for (let i = 0; i < len; i++) {
        const p = points[i];
        assert(p instanceof Point);
        assert(p.curve === this);
        if (p.type === types.AFFINE) {
          z[i] = this.one;
          continue;
        }
        z[i] = p.z;
      }
      const zi = this.red.invertAll(z);
      const out = new Array(len);
      for (let i = 0; i < len; i++)
        out[i] = points[i].scale(zi[i]);
      return out;
    }
    affinizeAll(points) {
      return this.normalizeAll(points);
    }
    clamp(scalar) {
      assert(Buffer.isBuffer(scalar));
      assert(scalar.length === this.scalarSize);
      assert(this.scalarSize <= this.fieldSize);
      let top = this.fieldBits & 7 || 8;
      let lsb = 0;
      let msb = this.scalarSize - 1;
      if (this.endian === "be")
        [lsb, msb] = [msb, lsb];
      if (this.scalarSize < this.fieldSize)
        top = 8;
      scalar[lsb] &= -this.h.word(0) & 255;
      scalar[msb] &= (1 << top) - 1;
      scalar[msb] |= 1 << top - 1;
      return scalar;
    }
    splitHash(bytes) {
      assert(Buffer.isBuffer(bytes));
      assert(bytes.length === this.adjustedSize * 2);
      assert(this.scalarSize <= this.adjustedSize);
      let off = 0;
      if (this.endian === "be")
        off = this.adjustedSize - this.scalarSize;
      const scalar = bytes.slice(off, off + this.scalarSize);
      const prefix = bytes.slice(this.adjustedSize);
      this.clamp(scalar);
      return [scalar, prefix];
    }
    encodeField(x) {
      assert(x instanceof BN);
      assert(!x.red);
      return x.encode(this.endian, this.fieldSize);
    }
    decodeField(bytes) {
      assert(Buffer.isBuffer(bytes));
      if (bytes.length !== this.fieldSize)
        throw new Error("Invalid field element size.");
      return BN.decode(bytes, this.endian);
    }
    encodeAdjusted(x) {
      assert(x instanceof BN);
      assert(!x.red);
      return x.encode(this.endian, this.adjustedSize);
    }
    decodeAdjusted(bytes) {
      assert(Buffer.isBuffer(bytes));
      if (bytes.length !== this.adjustedSize)
        throw new Error("Invalid field element size.");
      return BN.decode(bytes, this.endian);
    }
    encodeScalar(k) {
      assert(k instanceof BN);
      assert(!k.red);
      return k.encode(this.endian, this.scalarSize);
    }
    decodeScalar(bytes) {
      assert(Buffer.isBuffer(bytes));
      if (bytes.length !== this.scalarSize)
        throw new Error("Invalid scalar size.");
      return BN.decode(bytes, this.endian);
    }
    encodeClamped(k) {
      return this.clamp(this.encodeScalar(k));
    }
    decodeClamped(bytes) {
      assert(Buffer.isBuffer(bytes));
      if (bytes.length !== this.scalarSize)
        throw new Error("Invalid scalar size.");
      const clamped = this.clamp(Buffer.from(bytes));
      return BN.decode(clamped, this.endian);
    }
    encodeUniform(x, bits) {
      assert(x instanceof BN);
      assert(bits >>> 0 === bits);
      const msb = this.endian === "le" ? this.fieldSize - 1 : 0;
      const bytes = x.fromRed().encode(this.endian, this.fieldSize);
      bytes[msb] |= bits & ~this.mask & 255;
      return bytes;
    }
    decodeUniform(bytes) {
      assert(Buffer.isBuffer(bytes));
      if (bytes.length !== this.fieldSize)
        throw new Error("Invalid field size.");
      const x = BN.decode(bytes, this.endian);
      x.iumaskn(this.fieldBits);
      return x.toRed(this.red);
    }
    encodePoint(point, compact) {
      assert(point instanceof Point);
      return point.encode(compact);
    }
    decodePoint(bytes) {
      throw new Error("Not implemented.");
    }
    encodeX(point) {
      throw new Error("Not implemented.");
    }
    decodeX(bytes) {
      throw new Error("Not implemented.");
    }
    decodeEven(bytes) {
      throw new Error("Not implemented.");
    }
    decodeSquare(bytes) {
      throw new Error("Not implemented.");
    }
    toShort() {
      throw new Error("Not implemented.");
    }
    toMont(b0) {
      throw new Error("Not implemented.");
    }
    toEdwards(a0) {
      throw new Error("Not implemented.");
    }
    pointToJSON(point, pre) {
      assert(point instanceof Point);
      return point.toJSON(pre);
    }
    pointFromJSON(json) {
      throw new Error("Not implemented.");
    }
    toJSON(pre) {
      let prefix, context;
      let n, z, endo;
      if (this.type === "edwards") {
        prefix = this.prefix ? this.prefix.toString() : null;
        context = this.context;
      }
      if (!this.n.isZero())
        n = this.n.toJSON();
      if (!this.z.isZero()) {
        z = this.z.fromRed();
        if (this.z.redIsHigh())
          z.isub(this.p);
        z = z.toString(16);
      }
      if (this.endo)
        endo = this.endo.toJSON();
      return {
        id: this.id,
        ossl: this.ossl,
        type: this.type,
        endian: this.endian,
        hash: this.hash,
        prefix,
        context,
        prime: this.prime,
        p: this.p.toJSON(),
        a: void 0,
        b: void 0,
        d: void 0,
        n,
        h: this.h.toString(16),
        s: void 0,
        z,
        c: void 0,
        g: this.g.toJSON(pre),
        endo
      };
    }
    static fromJSON(json) {
      return new this(json);
    }
  };
  var Point = class {
    constructor(curve2, type) {
      assert(curve2 instanceof Curve);
      assert(type >>> 0 === type);
      this.curve = curve2;
      this.type = type;
      this.pre = null;
    }
    _init() {
      throw new Error("Not implemented.");
    }
    _safeNAF(width) {
      assert(width >>> 0 === width);
      if (this.pre && this.pre.naf)
        return this.pre.naf;
      if (width === 0)
        return null;
      const size = 1 << width - 2;
      const points = new Array(size);
      const p = this.toJ();
      const dbl = size === 1 ? null : p.dbl();
      points[0] = p;
      for (let i = 1; i < size; i++)
        points[i] = points[i - 1].add(dbl);
      return new NAF(width, points);
    }
    _getNAF(width) {
      assert(width >>> 0 === width);
      if (this.pre && this.pre.naf)
        return this.pre.naf;
      if (width === 0)
        return null;
      const odds = this._safeNAF(width).points;
      const points = this.curve.affinizeAll(odds);
      return new NAF(width, points);
    }
    _getWindows(width, bits) {
      assert(width >>> 0 === width);
      assert(bits >>> 0 === bits);
      if (this.pre && this.pre.windows)
        return this.pre.windows;
      if (width === 0)
        return null;
      const size = 1 << width;
      const steps = (bits + width - 1) / width >>> 0;
      const wnds = new Array(steps * size);
      let g = this.toJ();
      for (let i = 0; i < steps; i++) {
        wnds[i * size] = this.curve.jpoint();
        for (let j = 1; j < size; j++)
          wnds[i * size + j] = wnds[i * size + j - 1].add(g);
        g = g.dblp(width);
      }
      const points = this.curve.affinizeAll(wnds);
      return new Windows(width, bits, points);
    }
    _getDoubles(step, power) {
      assert(step >>> 0 === step);
      assert(power >>> 0 === power);
      if (this.pre && this.pre.doubles)
        return this.pre.doubles;
      if (step === 0)
        return null;
      const len = Math.ceil(power / step) + 1;
      const dbls = new Array(len);
      let acc = this.toJ();
      let k = 0;
      dbls[k++] = acc;
      for (let i = 0; i < power; i += step) {
        for (let j = 0; j < step; j++)
          acc = acc.dbl();
        dbls[k++] = acc;
      }
      assert(k === len);
      const points = this.curve.affinizeAll(dbls);
      return new Doubles(step, points);
    }
    _getBeta() {
      return null;
    }
    _getBlinding(rng) {
      if (this.pre && this.pre.blinding)
        return this.pre.blinding;
      if (!rng)
        return null;
      if (this.curve.n.isZero())
        return null;
      const blind = this.curve.randomScalar(rng);
      const unblind = this.mul(blind);
      return new Blinding(blind, unblind);
    }
    _hasWindows(k) {
      assert(k instanceof BN);
      if (!this.pre || !this.pre.windows)
        return false;
      const {width, bits} = this.pre.windows;
      const steps = (bits + width - 1) / width >>> 0;
      return k.bitLength() <= steps * width;
    }
    _hasDoubles(k) {
      assert(k instanceof BN);
      if (!this.pre || !this.pre.doubles)
        return false;
      const {step, points} = this.pre.doubles;
      const power = k.bitLength() + 1;
      return points.length >= Math.ceil(power / step) + 1;
    }
    _getJNAF(point) {
      assert(point instanceof Point);
      assert(point.type === this.type);
      return [
        this,
        this.add(point),
        this.sub(point),
        point
      ];
    }
    _blind(k, rng) {
      assert(k instanceof BN);
      assert(!k.red);
      if (this.pre && this.pre.blinding) {
        const {blind, unblind} = this.pre.blinding;
        const t = k.sub(blind);
        return [this, t, unblind];
      }
      if (!rng)
        return [this, k, null];
      if (this.pre) {
        if (this.curve.n.isZero())
          return [this, k, null];
        const a = this.curve.randomScalar(rng);
        const r = a.mul(this.curve.n);
        const t = r.iadd(k);
        return [this, t, null];
      }
      const p = this.randomize(rng);
      return [p, k, null];
    }
    clone() {
      throw new Error("Not implemented.");
    }
    precompute(bits, rng) {
      assert(bits >>> 0 === bits);
      if (!this.pre)
        this.pre = new Precomp();
      if (!this.pre.naf)
        this.pre.naf = this._getNAF(9);
      if (USE_FIXED && !this.pre.windows)
        this.pre.windows = this._getWindows(4, bits);
      if (!this.pre.doubles)
        this.pre.doubles = this._getDoubles(4, bits + 1);
      if (!this.pre.beta)
        this.pre.beta = this._getBeta();
      if (!this.pre.blinding)
        this.pre.blinding = this._getBlinding(rng);
      return this;
    }
    validate() {
      return this.curve.validate(this);
    }
    normalize() {
      return this;
    }
    scale(a) {
      throw new Error("Not implemented.");
    }
    randomize(rng) {
      const z = this.curve.randomField(rng);
      return this.scale(z);
    }
    neg() {
      throw new Error("Not implemented.");
    }
    add(point) {
      throw new Error("Not implemented.");
    }
    sub(point) {
      assert(point instanceof Point);
      return this.add(point.neg());
    }
    dbl() {
      throw new Error("Not implemented.");
    }
    dblp(pow) {
      assert(pow >>> 0 === pow);
      let r = this;
      for (let i = 0; i < pow; i++)
        r = r.dbl();
      return r;
    }
    diffAddDbl(p, q) {
      throw new Error("Not implemented.");
    }
    getX() {
      throw new Error("Not implemented.");
    }
    getY() {
      throw new Error("Not implemented.");
    }
    eq(point) {
      throw new Error("Not implemented.");
    }
    cmp(point) {
      throw new Error("Not implemented.");
    }
    isInfinity() {
      throw new Error("Not implemented.");
    }
    isOrder2() {
      throw new Error("Not implemented.");
    }
    isOdd() {
      throw new Error("Not implemented.");
    }
    isEven() {
      throw new Error("Not implemented.");
    }
    isSquare() {
      throw new Error("Not implemented.");
    }
    eqX(x) {
      throw new Error("Not implemented.");
    }
    eqR(x) {
      throw new Error("Not implemented.");
    }
    isSmall() {
      if (this.isInfinity())
        return false;
      return this.jmulH().isInfinity();
    }
    hasTorsion() {
      if (this.isInfinity())
        return false;
      return !this.jmul(this.curve.n).isInfinity();
    }
    order() {
      const {h, n} = this.curve;
      let p = this.toJ();
      let q = new BN(1);
      while (!p.isInfinity()) {
        q.iaddn(1);
        if (q.cmp(h) > 0) {
          q = n.clone();
          break;
        }
        p = p.add(this);
      }
      return q;
    }
    mul(k) {
      return this.jmul(k);
    }
    muln(k) {
      return this.jmuln(k);
    }
    mulBlind(k, rng) {
      return this.jmulBlind(k, rng);
    }
    mulAdd(k1, p2, k2) {
      return this.jmulAdd(k1, p2, k2);
    }
    mulH() {
      return this.jmulH();
    }
    div(k) {
      return this.jdiv(k);
    }
    divn(k) {
      return this.jdivn(k);
    }
    divH() {
      return this.jdivH();
    }
    jmul(k) {
      if (USE_FIXED && this._hasWindows(k))
        return this.curve._fixedMul(this, k);
      if (this._hasDoubles(k))
        return this.curve._fixedNafMul(this, k);
      if (this.curve.endo && this.type === types.AFFINE)
        return this.curve._endoWnafMulAdd([this], [k]);
      return this.curve._wnafMul(5, this, k);
    }
    jmuln(k) {
      assert((k | 0) === k);
      return this.jmul(new BN(k));
    }
    jmulBlind(k, rng = null) {
      const [p, t, unblind] = this._blind(k, rng);
      const q = p.jmul(t);
      if (unblind)
        return q.add(unblind);
      return q;
    }
    jmulAdd(k1, p2, k2) {
      if (this.curve.endo && this.type === types.AFFINE)
        return this.curve._endoWnafMulAdd([this, p2], [k1, k2]);
      return this.curve._wnafMulAdd(5, [this, p2], [k1, k2]);
    }
    jmulH() {
      const word = this.curve.h.word(0);
      if ((word & word - 1) === 0) {
        const bits = this.curve.h.bitLength();
        return this.toJ().dblp(bits - 1);
      }
      return this.jmul(this.curve.h);
    }
    jdiv(k) {
      assert(k instanceof BN);
      assert(!k.red);
      return this.jmul(k.invert(this.curve.n));
    }
    jdivn(k) {
      assert(!this.curve.n.isZero());
      if (this.curve.h.cmpn(k) === 0)
        return this.jdivH();
      return this.jdiv(new BN(k));
    }
    jdivH() {
      if (this.curve.n.isZero())
        return this.toJ();
      if (this.curve.h.cmpn(1) === 0)
        return this.toJ();
      if (this.curve.hi === null)
        this.curve.hi = this.curve.h.invert(this.curve.n);
      return this.jmul(this.curve.hi);
    }
    toP() {
      return this.normalize();
    }
    toJ() {
      return this;
    }
    toX() {
      return this;
    }
    key() {
      if (this.isInfinity())
        return `${this.curve.uid}:oo`;
      this.normalize();
      const x = this.getX().toString(16);
      const y = this.getY().toString(16);
      return `${this.curve.uid}:${x},${y}`;
    }
    encode(compact) {
      throw new Error("Not implemented.");
    }
    static decode(curve2, bytes) {
      throw new Error("Not implemented.");
    }
    encodeX() {
      throw new Error("Not implemented.");
    }
    static decodeX(curve2, bytes) {
      throw new Error("Not implemented.");
    }
    static decodeEven(curve2, bytes) {
      throw new Error("Not implemented.");
    }
    static decodeSquare(curve2, bytes) {
      throw new Error("Not implemented.");
    }
    toJSON(pre) {
      throw new Error("Not implemented.");
    }
    static fromJSON(curve2, json) {
      throw new Error("Not implemented.");
    }
    [custom]() {
      return "<Point>";
    }
  };
  var ShortCurve = class extends Curve {
    constructor(conf) {
      super(ShortPoint, "short", conf);
      this.a = BN.fromJSON(conf.a).toRed(this.red);
      this.b = BN.fromJSON(conf.b).toRed(this.red);
      this.c = BN.fromJSON(conf.c || "0").toRed(this.red);
      this.ai = this.a.isZero() ? this.zero : this.a.redInvert();
      this.zi = this.z.isZero() ? this.zero : this.z.redInvert();
      this.zeroA = this.a.isZero();
      this.threeA = this.a.eq(this.three.redNeg());
      this.redN = this.n.toRed(this.red);
      this.pmodn = this.p.clone();
      this.highOrder = this.n.cmp(this.p) >= 0;
      this.smallGap = false;
      this._finalize(conf);
    }
    _finalize(conf) {
      super._finalize(conf);
      if (conf.endo != null)
        this.endo = Endo.fromJSON(this, conf.endo);
      else
        this.endo = this._getEndomorphism();
      if (!this.n.isZero()) {
        this.pmodn = this.p.mod(this.n);
        this.smallGap = this.p.div(this.n).cmpn(1) <= 0;
      }
      return this;
    }
    static _isomorphism(curveA, curveB, custom2, odd) {
      assert(curveA instanceof BN);
      assert(curveB instanceof BN);
      assert(custom2 instanceof BN);
      assert(odd == null || typeof odd === "boolean");
      assert(!curveA.isZero() || !curveB.isZero());
      if (custom2.isZero())
        throw new Error("Invalid coefficient.");
      if (curveA.isZero()) {
        const customB = custom2;
        const u62 = customB.redDiv(curveB);
        const u22 = uncube(u62);
        assert(u22.redJacobi() === 1);
        return [curveA.clone(), customB.clone()];
      }
      if (curveB.isZero()) {
        const customA2 = custom2;
        const u42 = customA2.redDiv(curveA);
        const u22 = u42.redSqrt();
        if (u22.redJacobi() !== 1)
          u22.redINeg();
        if (u22.redJacobi() !== 1)
          throw new Error("Invalid `a` coefficient.");
        return [customA2.clone(), curveB.clone()];
      }
      const customA = custom2;
      const u4 = customA.redDiv(curveA);
      const u2 = u4.redSqrt();
      if (odd != null) {
        if (u2.redIsOdd() !== odd)
          u2.redINeg();
      } else {
        if (u2.redJacobi() !== 1)
          u2.redINeg();
      }
      if (u2.redJacobi() !== 1)
        throw new Error("Invalid `a` coefficient.");
      const u6 = u4.redMul(u2);
      const a = curveA.redMul(u4);
      const b = curveB.redMul(u6);
      assert(a.eq(customA));
      return [a, b];
    }
    _short(a0, odd) {
      return ShortCurve._isomorphism(this.a, this.b, a0, odd);
    }
    _mont(b0, odd) {
      const [r, s] = this._findRS(odd);
      const b = s.redInvert();
      const a = r.redMuln(3).redMul(b);
      if (b0 != null)
        return MontCurve._isomorphism(a, b, b0);
      return [a, b];
    }
    _edwards(a0, odd) {
      const [r, s] = this._findRS(odd);
      const r3 = r.redMuln(3);
      const s2 = s.redMuln(2);
      const a = r3.redAdd(s2);
      const d = r3.redSub(s2);
      if (a0 != null)
        return EdwardsCurve._isomorphism(a, d, a0);
      return [a, d];
    }
    _findRS(sign) {
      assert(sign == null || typeof sign === "boolean");
      assert(this.h.word(0) >= 4);
      assert(!this.n.isZero());
      const x = this.one.redNeg();
      let p;
      for (; ; ) {
        x.redIAdd(this.one);
        try {
          p = this.pointFromX(x.clone());
        } catch (e) {
          continue;
        }
        p = p.mul(this.n);
        if (p.isInfinity())
          continue;
        if (!p.y.isZero())
          continue;
        break;
      }
      const r = p.x;
      const r2 = r.redSqr();
      const s = r2.redMuln(3).redIAdd(this.a).redSqrt();
      if (sign != null) {
        if (s.redIsOdd() !== sign)
          s.redINeg();
      }
      return [r, s];
    }
    _scale0(a, b) {
      assert(this.a.isZero() === a.isZero());
      assert(this.b.isZero() === b.isZero());
      if (this.a.isZero()) {
        const u62 = this.b.redDiv(this.field(b));
        const u22 = uncube(u62);
        const u5 = u22.redSqrt();
        const u32 = u22.redMul(u5);
        assert(u32.redSqr().eq(u62));
        assert(!u5.isZero());
        return [u22, u32];
      }
      if (this.b.isZero()) {
        const u42 = this.a.redDiv(this.field(a));
        const u22 = u42.redSqrt();
        if (u22.redJacobi() !== 1)
          u22.redINeg();
        const u5 = u22.redSqrt();
        const u32 = u22.redMul(u5);
        assert(u32.redMul(u5).eq(u42));
        assert(!u5.isZero());
        return [u22, u32];
      }
      const u4 = this.a.redDiv(this.field(a));
      const u6 = this.b.redDiv(this.field(b));
      const u2 = u4.redSqrt();
      if (!u4.redMul(u2).eq(u6))
        u2.redINeg();
      assert(u4.redMul(u2).eq(u6));
      const u = u2.redSqrt();
      const u3 = u2.redMul(u);
      assert(!u.isZero());
      return [u2, u3];
    }
    _scale1(x, y) {
      const u2 = this.g.x.redDiv(this.field(x));
      const u3 = this.g.y.redDiv(this.field(y));
      const u = u2.redSqrt();
      if (!u2.redMul(u).eq(u3))
        u.redINeg();
      assert(u2.redMul(u).eq(u3));
      assert(!u.isZero());
      return [u2, u3];
    }
    _scaleShort(curve2) {
      assert(curve2 instanceof ShortCurve);
      if (this.g.isInfinity() || curve2.g.isInfinity())
        return this._scale0(curve2.a, curve2.b);
      return this._scale1(curve2.g.x, curve2.g.y);
    }
    _scaleMont(curve2) {
      assert(curve2 instanceof MontCurve);
      if (this.g.isInfinity() || curve2.g.isInfinity()) {
        const [a, b] = curve2._short();
        return this._scale0(a, b);
      }
      const {x, y} = curve2.g;
      const nx = x.redAdd(curve2.a3).redMul(curve2.bi);
      const ny = y.redMul(curve2.bi);
      return this._scale1(nx, ny);
    }
    _scaleEdwards(curve2) {
      assert(curve2 instanceof EdwardsCurve);
      if (this.g.isInfinity() || curve2.g.isInfinity()) {
        const [a, b] = curve2._short();
        return this._scale0(a, b);
      }
      const {x, y, z} = curve2.g;
      const a5 = curve2.a.redMuln(5);
      const d5 = curve2.d.redMuln(5);
      const dma = curve2.d.redSub(curve2.a);
      const d5a = d5.redSub(curve2.a);
      const da5 = curve2.d.redSub(a5);
      const ypz = y.redAdd(z);
      const ymz = y.redSub(z);
      const xx = d5a.redMul(y).redIAdd(da5.redMul(z));
      const xz = ymz.redMuln(12);
      const yy = dma.redMul(ypz).redMul(z);
      const yz = ymz.redMul(x).redIMuln(4);
      const zi = xz.redMul(yz).redInvert();
      const nx = xx.redMul(yz).redMul(zi);
      const ny = yy.redMul(xz).redMul(zi);
      return this._scale1(nx, ny);
    }
    _getEndomorphism(index = 0) {
      if (this.n.isZero() || this.g.isInfinity())
        return null;
      if (!this.zeroA || this.p.modrn(3) !== 1 || this.n.modrn(3) !== 1)
        return null;
      const [b1, b2] = this._getEndoRoots(this.p);
      const beta = [b1, b2][index & 1].toRed(this.red);
      const [l1, l2] = this._getEndoRoots(this.n);
      const p = this.point(this.g.x.redMul(beta), this.g.y);
      let lambda;
      if (this.g.mul(l1).eq(p)) {
        lambda = l1;
      } else {
        assert(this.g.mul(l2).eq(p));
        lambda = l2;
      }
      const basis = this._getEndoBasis(lambda);
      const pre = this._getEndoPrecomp(basis);
      return new Endo(beta, lambda, basis, pre);
    }
    _getEndoRoots(num) {
      const red = num === this.p ? this.red : BN.mont(num);
      const two = new BN(2).toRed(red);
      const three = new BN(3).toRed(red);
      const i2 = two.redInvert();
      const s1 = three.redNeg().redSqrt().redMul(i2);
      const s2 = s1.redNeg();
      const r1 = s1.redSub(i2).fromRed();
      const r2 = s2.redSub(i2).fromRed();
      return [r1, r2].sort(BN.cmp);
    }
    _getEndoBasis(lambda) {
      const [rl, tl, rl1, tl1, rl2, tl2] = this._egcdSqrt(lambda);
      const a1 = rl1;
      const b1 = tl1.neg();
      const lhs = rl.sqr().iadd(tl.sqr());
      const rhs = rl2.sqr().iadd(tl2.sqr());
      let a2, b2;
      if (lhs.cmp(rhs) <= 0) {
        a2 = rl;
        b2 = tl.neg();
      } else {
        a2 = rl2;
        b2 = tl2.neg();
      }
      return [
        new Vector(a1, b1),
        new Vector(a2, b2)
      ];
    }
    _egcdSqrt(lambda) {
      assert(lambda instanceof BN);
      assert(!lambda.red);
      assert(lambda.sign() > 0);
      assert(this.n.sign() > 0);
      const sqrtn = this.n.ushrn(this.n.bitLength() >>> 1);
      let u = lambda;
      let v = this.n.clone();
      let x1 = new BN(1);
      let y1 = new BN(0);
      let x2 = new BN(0);
      let y2 = new BN(1);
      let rl, tl;
      let rl1, tl1;
      let i = 0;
      let j = 0;
      let p;
      while (!u.isZero() && i < 2) {
        const q = v.quo(u);
        const r = v.sub(q.mul(u));
        const x = x2.sub(q.mul(x1));
        const y = y2.sub(q.mul(y1));
        if (j === 0 && r.cmp(sqrtn) < 0) {
          rl = p;
          tl = x1;
          rl1 = r;
          tl1 = x;
          j = 1;
        }
        p = r;
        v = u;
        u = r;
        x2 = x1;
        x1 = x;
        y2 = y1;
        y1 = y;
        i += j;
      }
      assert(j !== 0, "Could not find r < sqrt(n).");
      const rl2 = x2;
      const tl2 = x1;
      return [
        rl,
        tl,
        rl1,
        tl1,
        rl2,
        tl2
      ];
    }
    _getEndoPrecomp(basis) {
      assert(Array.isArray(basis));
      assert(basis.length === 2);
      assert(basis[0] instanceof Vector);
      assert(basis[1] instanceof Vector);
      const [v1, v2] = basis;
      const d = v1.a.mul(v2.b).isub(v1.b.mul(v2.a));
      const bits = d.bitLength();
      const align = bits >= 160;
      assert(d.eq(this.n));
      let shift = bits + Math.ceil(bits / 2) + 1;
      let g1, g2;
      if (align)
        shift -= shift & 63;
      while (shift > bits) {
        g1 = v2.b.ushln(shift).divRound(d);
        g2 = v1.b.ushln(shift).divRound(d);
        if (g1.ucmp(d) < 0 && g2.ucmp(d) < 0)
          break;
        if (align)
          shift -= 64;
        else
          shift -= 1;
      }
      if (shift <= bits)
        throw new Error("Could not calculate g1 and g2.");
      return [shift, g1, g2];
    }
    _endoSplit(k) {
      assert(k instanceof BN);
      assert(!k.red);
      assert(!this.n.isZero());
      const [v1, v2] = this.endo.basis;
      const c1 = v2.b.mul(k).divRound(this.n);
      const c2 = v1.b.neg().mul(k).divRound(this.n);
      const p1 = c1.mul(v1.a);
      const p2 = c2.mul(v2.a);
      const q1 = c1.ineg().mul(v1.b);
      const q2 = c2.mul(v2.b);
      const k1 = k.sub(p1).isub(p2);
      const k2 = q1.isub(q2);
      return [k1, k2];
    }
    _endoBeta(point) {
      assert(point instanceof ShortPoint);
      return [point, point._getBeta()];
    }
    _endoWnafMulAdd(points, coeffs) {
      assert(Array.isArray(points));
      assert(Array.isArray(coeffs));
      assert(points.length === coeffs.length);
      assert(this.endo != null);
      const len = points.length;
      const npoints = new Array(len * 2);
      const ncoeffs = new Array(len * 2);
      for (let i = 0; i < len; i++) {
        const [p1, p2] = this._endoBeta(points[i]);
        const [k1, k2] = this._endoSplit(coeffs[i]);
        npoints[i * 2 + 0] = p1;
        ncoeffs[i * 2 + 0] = k1;
        npoints[i * 2 + 1] = p2;
        ncoeffs[i * 2 + 1] = k2;
      }
      return this._wnafMulAdd(5, npoints, ncoeffs);
    }
    _sswu(u) {
      const {b, z, ai, zi, one} = this;
      const z2 = z.redSqr();
      const ba = b.redNeg().redMul(ai);
      const bza = b.redMul(zi).redMul(ai);
      const u2 = u.redSqr();
      const u4 = u2.redSqr();
      const t0 = z2.redMul(u4).redIAdd(z.redMul(u2));
      const t1 = t0.isZero() ? t0 : t0.redInvert();
      const x1 = t1.isZero() ? bza : ba.redMul(one.redAdd(t1));
      const x2 = z.redMul(u2).redMul(x1);
      const y1 = this.solveY2(x1);
      const y2 = this.solveY2(x2);
      const alpha = y1.redIsSquare() | 0;
      const x = [x1, x2][alpha ^ 1];
      const y = [y1, y2][alpha ^ 1].redSqrt();
      if (y.redIsOdd() !== u.redIsOdd())
        y.redINeg();
      return this.point(x, y);
    }
    _sswui(p, hint) {
      const {a, b, z} = this;
      const {x, y} = p;
      const r = hint & 3;
      const a2x2 = a.redSqr().redMul(x.redSqr());
      const abx2 = a.redMul(b).redMul(x).redIMuln(2);
      const b23 = b.redSqr().redMuln(3);
      const axb = a.redMul(x).redIAdd(b);
      const c = a2x2.redISub(abx2).redISub(b23).redSqrt();
      const n0 = axb.redSub(c).redINeg();
      const n1 = axb.redAdd(c).redINeg();
      const d0 = axb.redMul(z).redIMuln(2);
      const d1 = b.redMul(z).redIMuln(2);
      const n = [n0, n1][r & 1];
      const d = [d0, d1][r >>> 1];
      const u = n.redDivSqrt(d);
      if (u.redIsOdd() !== y.redIsOdd())
        u.redINeg();
      return u;
    }
    _svdwf(u) {
      const {c, z, zi, i2, i3} = this;
      const gz = this.solveY2(z);
      const z3 = i3.redMul(zi.redSqr());
      const u2 = u.redSqr();
      const u4 = u2.redSqr();
      const t1 = u2.redAdd(gz);
      const u2t1 = u2.redMul(t1);
      const t2 = u2t1.isZero() ? u2t1 : u2t1.redInvert();
      const t3 = u4.redMul(t2).redMul(c);
      const t4 = t1.redSqr().redMul(t1);
      const x1 = c.redSub(z).redMul(i2).redISub(t3);
      const x2 = t3.redSub(c.redAdd(z).redMul(i2));
      const x3 = z.redSub(t4.redMul(t2).redMul(z3));
      const y1 = this.solveY2(x1);
      const y2 = this.solveY2(x2);
      const y3 = this.solveY2(x3);
      const alpha = y1.redJacobi() | 1;
      const beta = y2.redJacobi() | 1;
      const i = mod((alpha - 1) * beta, 3);
      const x = [x1, x2, x3][i];
      const y = [y1, y2, y3][i];
      return [x, y];
    }
    _svdw(u) {
      const [x, yy] = this._svdwf(u);
      const y = yy.redSqrt();
      if (y.redIsOdd() !== u.redIsOdd())
        y.redINeg();
      return this.point(x, y);
    }
    _svdwi(p, hint) {
      const {b, c, z, zero, two} = this;
      const {x, y} = p;
      const r = hint & 3;
      const z2 = z.redSqr();
      const z3 = z2.redMul(z);
      const z4 = z2.redSqr();
      const gz = z3.redAdd(b);
      const gz2 = gz.redMuln(2);
      const xx = x.redSqr();
      const x2z = x.redMuln(2).redIAdd(z);
      const xz2 = x.redMul(z2);
      const c0 = c.redSub(x2z);
      const c1 = c.redAdd(x2z);
      const t0 = xx.redMul(z2).redIAdd(z4).redIMuln(9);
      const t1 = x.redMul(z3).redIMuln(18);
      const t2 = gz.redMul(x.redSub(z)).redIMuln(12);
      const t3 = r >= 2 ? t0.redISub(t1).redIAdd(t2).redSqrt() : zero;
      const t4 = t3.redMul(z);
      const t5 = z3.redISub(xz2).redIMuln(3).redISub(gz2);
      const n0 = gz.redMul(c0);
      const n1 = gz.redMul(c1);
      const n2 = t5.redAdd(t4);
      const n3 = t5.redSub(t4);
      const d2 = two;
      const n = [n0, n1, n2, n3][r];
      const d = [c1, c0, d2, d2][r];
      const u = n.redDivSqrt(d);
      const [x0] = this._svdwf(u);
      if (!x0.eq(x))
        throw new Error("Invalid point.");
      if (u.redIsOdd() !== y.redIsOdd())
        u.redINeg();
      return u;
    }
    isElliptic() {
      const {a, b} = this;
      const a2 = a.redSqr();
      const a3 = a2.redMul(a);
      const b2 = b.redSqr();
      const d = b2.redMuln(27).redIAdd(a3.redMuln(4));
      return !d.isZero();
    }
    jinv() {
      const {a, b} = this;
      const a2 = a.redSqr();
      const a3 = a2.redMul(a);
      const b2 = b.redSqr();
      const t0 = a3.redMuln(4);
      const lhs = t0.redMuln(1728);
      const rhs = b2.redMuln(27).redIAdd(t0);
      if (rhs.isZero())
        throw new Error("Curve is not elliptic.");
      return lhs.redDiv(rhs).fromRed();
    }
    point(x, y) {
      return new ShortPoint(this, x, y);
    }
    jpoint(x, y, z) {
      return new JPoint(this, x, y, z);
    }
    solveX(y) {
      assert(y instanceof BN);
      if (!this.a.isZero())
        throw new Error("Not implemented.");
      const y2 = y.redSqr();
      const x3 = y2.redSub(this.b);
      return cubeRoots(x3);
    }
    solveY2(x) {
      assert(x instanceof BN);
      const x3 = x.redSqr().redMul(x);
      const y2 = x3.redIAdd(this.b);
      if (!this.zeroA) {
        if (this.threeA)
          y2.redIAdd(x.redMuln(-3));
        else
          y2.redIAdd(this.a.redMul(x));
      }
      return y2;
    }
    validate(point) {
      assert(point instanceof ShortPoint);
      if (point.inf)
        return true;
      const {x, y} = point;
      const y2 = this.solveY2(x);
      return y.redSqr().eq(y2);
    }
    pointFromX(x, sign = null) {
      assert(x instanceof BN);
      assert(sign == null || typeof sign === "boolean");
      if (!x.red)
        x = x.toRed(this.red);
      const y = this.solveY(x);
      if (sign != null) {
        if (this.h.cmpn(1) > 0) {
          if (y.isZero() && sign)
            throw new Error("Invalid point.");
        }
        if (y.redIsOdd() !== sign)
          y.redINeg();
      }
      return this.point(x, y);
    }
    pointFromY(y, index = 0) {
      assert(y instanceof BN);
      assert(index >>> 0 === index);
      if (!y.red)
        y = y.toRed(this.red);
      const coords = this.solveX(y);
      if (index >= coords.length)
        throw new Error("Invalid X coordinate index.");
      const x = coords[index];
      return this.point(x, y);
    }
    isIsomorphic(curve2) {
      assert(curve2 instanceof Curve);
      if (!curve2.p.eq(this.p))
        return false;
      let u2, u3;
      try {
        [u2, u3] = this._scale(curve2);
      } catch (e) {
        return false;
      }
      if (curve2.type === "short") {
        const a = this.field(curve2.a).redMul(u2.redSqr());
        const b = this.field(curve2.b).redMul(u3.redSqr());
        return this.a.eq(a) && this.b.eq(b);
      }
      if (curve2.type === "mont") {
        const {a3, bi} = curve2;
        const x = this.field(a3.redMul(bi)).redMul(u2);
        const y2 = this.solveY2(x);
        return y2.isZero();
      }
      if (curve2.type === "edwards") {
        const x = this.field(curve2.ad6).redMul(u2);
        const y2 = this.solveY2(x);
        return y2.isZero();
      }
      return false;
    }
    isIsogenous(curve2) {
      assert(curve2 instanceof Curve);
      return false;
    }
    pointFromShort(point) {
      assert(point instanceof ShortPoint);
      if (this.isIsomorphic(point.curve)) {
        if (point.isInfinity())
          return this.point();
        const [u2, u3] = this._scale(point.curve);
        const x = this.field(point.x);
        const y = this.field(point.y);
        const nx = x.redMul(u2);
        const ny = y.redMul(u3);
        return this.point(nx, ny);
      }
      throw new Error("Not implemented.");
    }
    pointFromMont(point) {
      assert(point instanceof MontPoint);
      if (this.isIsomorphic(point.curve)) {
        if (point.isInfinity())
          return this.point();
        const {a3, bi} = point.curve;
        const [u2, u3] = this._scale(point.curve);
        const nx = point.x.redAdd(a3).redMul(bi);
        const ny = point.y.redMul(bi);
        return this.point(this.field(nx).redMul(u2), this.field(ny).redMul(u3));
      }
      throw new Error("Not implemented.");
    }
    pointFromEdwards(point) {
      assert(point instanceof EdwardsPoint);
      if (this.isIsomorphic(point.curve)) {
        const {a, d, ad6} = point.curve;
        const [u2, u3] = this._scale(point.curve);
        if (point.isInfinity())
          return this.point();
        if (point.x.isZero()) {
          const x2 = this.field(ad6).redMul(u2);
          return this.point(x2, this.zero);
        }
        const {x, y, z} = point;
        const a5 = a.redMuln(5);
        const d5 = d.redMuln(5);
        const dma = d.redSub(a);
        const d5a = d5.redSub(a);
        const da5 = d.redSub(a5);
        const ypz = y.redAdd(z);
        const ymz = y.redSub(z);
        const xx = d5a.redMul(y).redIAdd(da5.redMul(z));
        const xz = ymz.redMuln(12);
        const yy = dma.redMul(ypz).redMul(z);
        const yz = ymz.redMul(x).redIMuln(4);
        return this.cpoint(this.field(xx).redMul(u2), this.field(xz), this.field(yy).redMul(u3), this.field(yz));
      }
      throw new Error("Not implemented.");
    }
    pointFromUniform(u) {
      assert(u instanceof BN);
      if (this.z.isZero() || this.b.isZero())
        throw new Error("Not implemented.");
      if (!this.a.isZero())
        return this._sswu(u);
      if (!this.c.isZero())
        return this._svdw(u);
      throw new Error("Not implemented.");
    }
    pointToUniform(p, hint) {
      assert(p instanceof ShortPoint);
      assert(hint >>> 0 === hint);
      if (this.z.isZero() || this.b.isZero())
        throw new Error("Not implemented.");
      if (p.isInfinity())
        throw new Error("Invalid point.");
      const i = (hint >>> 4 & 15) % this.torsion.length;
      const q = p.add(this.torsion[i]);
      return wrapErrors(() => {
        if (!this.a.isZero())
          return this._sswui(q, hint);
        if (!this.c.isZero())
          return this._svdwi(q, hint);
        throw new Error("Not implemented.");
      });
    }
    mulAll(points, coeffs) {
      return super.mulAll(points, coeffs).toP();
    }
    affinizeAll(points) {
      const out = this.normalizeAll(points);
      for (let i = 0; i < out.length; i++)
        out[i] = out[i].toP();
      return out;
    }
    decodePoint(bytes) {
      return ShortPoint.decode(this, bytes);
    }
    encodeX(point) {
      assert(point instanceof Point);
      return point.encodeX();
    }
    decodeEven(bytes) {
      return ShortPoint.decodeEven(this, bytes);
    }
    decodeSquare(bytes) {
      return ShortPoint.decodeSquare(this, bytes);
    }
    toShort(a0, odd, sign = null) {
      const [a, b] = this._short(a0, odd);
      const curve2 = new ShortCurve({
        red: this.red,
        prime: this.prime,
        p: this.p,
        a,
        b,
        n: this.n,
        h: this.h
      });
      if (sign != null) {
        const [, u3] = curve2._scale(this);
        if (u3.redIsOdd() !== sign)
          u3.redINeg();
      }
      if (!this.g.isInfinity())
        curve2.g = curve2.pointFromShort(this.g);
      for (let i = 0; i < this.h.word(0); i++)
        curve2.torsion[i] = curve2.pointFromShort(this.torsion[i]);
      return curve2;
    }
    toMont(b0, odd, sign = null) {
      const [a, b] = this._mont(b0, odd);
      const curve2 = new MontCurve({
        red: this.red,
        prime: this.prime,
        p: this.p,
        a,
        b,
        n: this.n,
        h: this.h
      });
      if (sign != null) {
        const [, u3] = this._scale(curve2);
        if (u3.redIsOdd() !== sign)
          u3.redINeg();
      }
      if (!this.g.isInfinity())
        curve2.g = curve2.pointFromShort(this.g);
      for (let i = 0; i < this.h.word(0); i++)
        curve2.torsion[i] = curve2.pointFromShort(this.torsion[i]);
      return curve2;
    }
    toEdwards(a0, odd, sign = null) {
      const [a, d] = this._edwards(a0, odd);
      const curve2 = new EdwardsCurve({
        red: this.red,
        prime: this.prime,
        p: this.p,
        a,
        d,
        n: this.n,
        h: this.h
      });
      if (sign != null) {
        const [, u3] = this._scale(curve2);
        if (u3.redIsOdd() !== sign)
          u3.redINeg();
      }
      if (!this.g.isInfinity()) {
        curve2.g = curve2.pointFromShort(this.g);
        curve2.g.normalize();
      }
      if (curve2.isComplete()) {
        for (let i = 0; i < this.h.word(0); i++) {
          curve2.torsion[i] = curve2.pointFromShort(this.torsion[i]);
          curve2.torsion[i].normalize();
        }
      }
      return curve2;
    }
    pointFromJSON(json) {
      return ShortPoint.fromJSON(this, json);
    }
    toJSON(pre) {
      const json = super.toJSON(pre);
      json.a = this.a.fromRed().toJSON();
      json.b = this.b.fromRed().toJSON();
      if (!this.c.isZero())
        json.c = this.c.fromRed().toJSON();
      return json;
    }
  };
  var ShortPoint = class extends Point {
    constructor(curve2, x, y) {
      assert(curve2 instanceof ShortCurve);
      super(curve2, types.AFFINE);
      this.x = this.curve.zero;
      this.y = this.curve.zero;
      this.inf = true;
      if (x != null)
        this._init(x, y);
    }
    _init(x, y) {
      assert(x instanceof BN);
      assert(y instanceof BN);
      this.x = x;
      this.y = y;
      if (!this.x.red)
        this.x = this.x.toRed(this.curve.red);
      if (!this.y.red)
        this.y = this.y.toRed(this.curve.red);
      this.inf = false;
    }
    _getBeta() {
      if (!this.curve.endo)
        return null;
      if (this.pre && this.pre.beta)
        return this.pre.beta;
      const xb = this.x.redMul(this.curve.endo.beta);
      const beta = this.curve.point(xb, this.y);
      if (this.pre) {
        beta.pre = this.pre.map((point) => {
          const xb2 = point.x.redMul(this.curve.endo.beta);
          return this.curve.point(xb2, point.y);
        });
        this.pre.beta = beta;
      }
      return beta;
    }
    _getJNAF(point) {
      assert(point instanceof ShortPoint);
      if (this.inf || point.inf)
        return super._getJNAF(point);
      const comb = [
        this,
        null,
        null,
        point
      ];
      if (this.y.eq(point.y)) {
        comb[1] = this.add(point);
        comb[2] = this.toJ().sub(point);
      } else if (this.y.eq(point.y.redNeg())) {
        comb[1] = this.toJ().add(point);
        comb[2] = this.sub(point);
      } else {
        comb[1] = this.toJ().add(point);
        comb[2] = this.toJ().sub(point);
      }
      return comb;
    }
    clone() {
      if (this.inf)
        return this.curve.point();
      return this.curve.point(this.x, this.y);
    }
    scale(a) {
      return this.toJ().scale(a);
    }
    neg() {
      if (this.inf)
        return this;
      return this.curve.point(this.x, this.y.redNeg());
    }
    add(p) {
      assert(p instanceof ShortPoint);
      if (this.inf)
        return p;
      if (p.inf)
        return this;
      if (this.x.eq(p.x)) {
        if (!this.y.eq(p.y))
          return this.curve.point();
        return this.dbl();
      }
      if (this.y.eq(p.y)) {
        const nx2 = this.x.redNeg().redISub(p.x);
        const ny2 = this.y.redNeg();
        return this.curve.point(nx2, ny2);
      }
      const h = this.x.redSub(p.x);
      const r = this.y.redSub(p.y);
      const l = r.redDiv(h);
      const nx = l.redSqr().redISub(this.x).redISub(p.x);
      const ny = l.redMul(this.x.redSub(nx)).redISub(this.y);
      return this.curve.point(nx, ny);
    }
    dbl() {
      if (this.inf)
        return this;
      if (this.y.isZero())
        return this.curve.point();
      const xx = this.x.redSqr();
      const m = xx.redIMuln(3).redIAdd(this.curve.a);
      const z = this.y.redMuln(2);
      const l = m.redDiv(z);
      const nx = l.redSqr().redISub(this.x).redISub(this.x);
      const ny = l.redMul(this.x.redSub(nx)).redISub(this.y);
      return this.curve.point(nx, ny);
    }
    dblp(pow) {
      return this.toJ().dblp(pow).toP();
    }
    getX() {
      if (this.inf)
        throw new Error("Invalid point.");
      return this.x.fromRed();
    }
    getY() {
      if (this.inf)
        throw new Error("Invalid point.");
      return this.y.fromRed();
    }
    eq(p) {
      assert(p instanceof ShortPoint);
      if (this === p)
        return true;
      if (this.inf)
        return p.inf;
      if (p.inf)
        return false;
      return this.x.eq(p.x) && this.y.eq(p.y);
    }
    cmp(point) {
      assert(point instanceof ShortPoint);
      if (this.inf && !point.inf)
        return -1;
      if (!this.inf && point.inf)
        return 1;
      if (this.inf && point.inf)
        return 0;
      return this.order().cmp(point.order()) || this.getX().cmp(point.getX()) || this.getY().cmp(point.getY());
    }
    isInfinity() {
      return this.inf;
    }
    isOrder2() {
      if (this.inf)
        return false;
      return this.y.isZero();
    }
    isOdd() {
      if (this.inf)
        return false;
      return this.y.redIsOdd();
    }
    isEven() {
      if (this.inf)
        return false;
      return this.y.redIsEven();
    }
    isSquare() {
      if (this.inf)
        return false;
      return this.y.redJacobi() !== -1;
    }
    eqX(x) {
      assert(x instanceof BN);
      assert(!x.red);
      if (this.inf)
        return false;
      return this.getX().eq(x);
    }
    eqR(x) {
      assert(x instanceof BN);
      assert(!x.red);
      assert(!this.curve.n.isZero());
      if (this.inf)
        return false;
      return this.getX().imod(this.curve.n).eq(x);
    }
    mul(k) {
      return super.mul(k).toP();
    }
    muln(k) {
      return super.muln(k).toP();
    }
    mulBlind(k, rng) {
      return super.mulBlind(k, rng).toP();
    }
    mulAdd(k1, p2, k2) {
      return super.mulAdd(k1, p2, k2).toP();
    }
    mulH() {
      return super.mulH().toP();
    }
    div(k) {
      return super.div(k).toP();
    }
    divn(k) {
      return super.divn(k).toP();
    }
    divH() {
      return super.divH().toP();
    }
    toP() {
      return this;
    }
    toJ() {
      if (this.inf)
        return this.curve.jpoint();
      return this.curve.jpoint(this.x, this.y, this.curve.one);
    }
    encode(compact) {
      if (compact == null)
        compact = true;
      assert(typeof compact === "boolean");
      const {fieldSize} = this.curve;
      if (this.inf)
        throw new Error("Invalid point.");
      if (compact) {
        const p2 = Buffer.alloc(1 + fieldSize);
        const x2 = this.curve.encodeField(this.getX());
        p2[0] = 2 | this.y.redIsOdd();
        x2.copy(p2, 1);
        return p2;
      }
      const p = Buffer.alloc(1 + fieldSize * 2);
      const x = this.curve.encodeField(this.getX());
      const y = this.curve.encodeField(this.getY());
      p[0] = 4;
      x.copy(p, 1);
      y.copy(p, 1 + fieldSize);
      return p;
    }
    static decode(curve2, bytes) {
      assert(curve2 instanceof ShortCurve);
      assert(Buffer.isBuffer(bytes));
      const len = curve2.fieldSize;
      if (bytes.length < 1 + len)
        throw new Error("Not a point.");
      const form = bytes[0];
      switch (form) {
        case 2:
        case 3: {
          if (bytes.length !== 1 + len)
            throw new Error("Invalid point size for compressed.");
          const x = curve2.decodeField(bytes.slice(1, 1 + len));
          if (x.cmp(curve2.p) >= 0)
            throw new Error("Invalid point.");
          const p = curve2.pointFromX(x, form === 3);
          assert(!p.isInfinity());
          return p;
        }
        case 4:
        case 6:
        case 7: {
          if (bytes.length !== 1 + len * 2)
            throw new Error("Invalid point size for uncompressed.");
          const x = curve2.decodeField(bytes.slice(1, 1 + len));
          const y = curve2.decodeField(bytes.slice(1 + len, 1 + 2 * len));
          if (x.cmp(curve2.p) >= 0 || y.cmp(curve2.p) >= 0)
            throw new Error("Invalid point.");
          if (form !== 4 && form !== (6 | y.isOdd()))
            throw new Error("Invalid hybrid encoding.");
          const p = curve2.point(x, y);
          if (!p.validate())
            throw new Error("Invalid point.");
          assert(!p.isInfinity());
          return p;
        }
        default: {
          throw new Error("Unknown point format.");
        }
      }
    }
    encodeX() {
      return this.curve.encodeField(this.getX());
    }
    static decodeEven(curve2, bytes) {
      assert(curve2 instanceof ShortCurve);
      const x = curve2.decodeField(bytes);
      if (x.cmp(curve2.p) >= 0)
        throw new Error("Invalid point.");
      return curve2.pointFromX(x, false);
    }
    static decodeSquare(curve2, bytes) {
      assert(curve2 instanceof ShortCurve);
      const x = curve2.decodeField(bytes);
      if (x.cmp(curve2.p) >= 0)
        throw new Error("Invalid point.");
      return curve2.pointFromX(x);
    }
    toJSON(pre) {
      if (this.inf)
        return [];
      const x = this.getX().toJSON();
      const y = this.getY().toJSON();
      if (pre === true && this.pre)
        return [x, y, this.pre.toJSON()];
      return [x, y];
    }
    toPretty() {
      if (this.inf)
        return [];
      const size = this.curve.fieldSize * 2;
      const x = toPretty(this.getX(), size);
      const y = toPretty(this.getY(), size);
      return [x, y];
    }
    static fromJSON(curve2, json) {
      assert(curve2 instanceof ShortCurve);
      assert(Array.isArray(json));
      assert(json.length === 0 || json.length === 2 || json.length === 3);
      if (json.length === 0)
        return curve2.point();
      const x = BN.fromJSON(json[0]);
      const y = BN.fromJSON(json[1]);
      const point = curve2.point(x, y);
      if (json.length > 2 && json[2] != null)
        point.pre = Precomp.fromJSON(point, json[2]);
      return point;
    }
    [custom]() {
      if (this.inf)
        return "<ShortPoint: Infinity>";
      return "<ShortPoint: x=" + this.x.fromRed().toString(16, 2) + " y=" + this.y.fromRed().toString(16, 2) + ">";
    }
  };
  var JPoint = class extends Point {
    constructor(curve2, x, y, z) {
      assert(curve2 instanceof ShortCurve);
      super(curve2, types.JACOBIAN);
      this.x = this.curve.one;
      this.y = this.curve.one;
      this.z = this.curve.zero;
      this.zOne = false;
      if (x != null)
        this._init(x, y, z);
    }
    _init(x, y, z) {
      assert(x instanceof BN);
      assert(y instanceof BN);
      assert(z == null || z instanceof BN);
      this.x = x;
      this.y = y;
      this.z = z || this.curve.one;
      if (!this.x.red)
        this.x = this.x.toRed(this.curve.red);
      if (!this.y.red)
        this.y = this.y.toRed(this.curve.red);
      if (!this.z.red)
        this.z = this.z.toRed(this.curve.red);
      this.zOne = this.z.eq(this.curve.one);
    }
    clone() {
      return this.curve.jpoint(this.x, this.y, this.z);
    }
    validate() {
      const {a, b} = this.curve;
      if (this.isInfinity())
        return true;
      if (this.zOne)
        return this.curve.validate(this.toP());
      const lhs = this.y.redSqr();
      const x3 = this.x.redSqr().redMul(this.x);
      const z2 = this.z.redSqr();
      const z4 = z2.redSqr();
      const z6 = z4.redMul(z2);
      const rhs = x3.redIAdd(b.redMul(z6));
      if (!this.curve.zeroA) {
        if (this.curve.threeA)
          rhs.redIAdd(z4.redIMuln(-3).redMul(this.x));
        else
          rhs.redIAdd(a.redMul(z4).redMul(this.x));
      }
      return lhs.eq(rhs);
    }
    normalize() {
      if (this.zOne)
        return this;
      if (this.isInfinity())
        return this;
      const a = this.z.redInvert();
      const aa = a.redSqr();
      this.x = this.x.redMul(aa);
      this.y = this.y.redMul(aa).redMul(a);
      this.z = this.curve.one;
      this.zOne = true;
      return this;
    }
    scale(a) {
      assert(a instanceof BN);
      if (this.isInfinity())
        return this.curve.jpoint();
      const aa = a.redSqr();
      const nx = this.x.redMul(aa);
      const ny = this.y.redMul(aa).redMul(a);
      const nz = this.z.redMul(a);
      return this.curve.jpoint(nx, ny, nz);
    }
    neg() {
      return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
    }
    add(p) {
      assert(p instanceof Point);
      if (p.type === types.AFFINE)
        return this._mixedAdd(p);
      return this._add(p);
    }
    _add(p) {
      assert(p instanceof JPoint);
      if (this.isInfinity())
        return p;
      if (p.isInfinity())
        return this;
      if (this.zOne)
        return p._addJA(this);
      if (p.zOne)
        return this._addJA(p);
      return this._addJJ(p);
    }
    _mixedAdd(p) {
      assert(p instanceof ShortPoint);
      if (this.isInfinity())
        return p.toJ();
      if (p.isInfinity())
        return this;
      return this._addJA(p);
    }
    _addJJ(p) {
      const z1z1 = this.z.redSqr();
      const z2z2 = p.z.redSqr();
      const u1 = this.x.redMul(z2z2);
      const u2 = p.x.redMul(z1z1);
      const s1 = this.y.redMul(p.z).redMul(z2z2);
      const s2 = p.y.redMul(this.z).redMul(z1z1);
      const h = u2.redISub(u1);
      const r = s2.redISub(s1);
      if (h.isZero()) {
        if (!r.isZero())
          return this.curve.jpoint();
        return this.dbl();
      }
      const hh = h.redSqr();
      const hhh = h.redMul(hh);
      const v = u1.redMul(hh);
      const nx = r.redSqr().redISub(hhh).redISub(v).redISub(v);
      const ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(hhh));
      const nz = this.z.redMul(p.z).redMul(h);
      return this.curve.jpoint(nx, ny, nz);
    }
    _addJA(p) {
      const z1z1 = this.z.redSqr();
      const u2 = p.x.redMul(z1z1);
      const s2 = p.y.redMul(this.z).redMul(z1z1);
      const h = u2.redISub(this.x);
      const r = s2.redISub(this.y).redIMuln(2);
      if (h.isZero()) {
        if (!r.isZero())
          return this.curve.jpoint();
        return this.dbl();
      }
      const i = h.redMuln(2).redSqr();
      const j = h.redMul(i);
      const v = this.x.redMul(i);
      const nx = r.redSqr().redISub(j).redISub(v).redISub(v);
      const ny = r.redMul(v.redISub(nx)).redISub(this.y.redMul(j).redIMuln(2));
      const nz = this.z.redMul(h).redIMuln(2);
      return this.curve.jpoint(nx, ny, nz);
    }
    dbl() {
      if (this.isInfinity())
        return this;
      if (this.y.isZero())
        return this.curve.jpoint();
      if (this.curve.zeroA)
        return this._dbl0();
      if (this.curve.threeA)
        return this._dbl3();
      return this._dblJ();
    }
    _dblJ() {
      const xx = this.x.redSqr();
      const yy = this.y.redSqr();
      const zz = this.z.redSqr();
      const s = this.x.redMul(yy).redIMuln(4);
      const m = xx.redIMuln(3).redIAdd(this.curve.a.redMul(zz.redSqr()));
      const t = m.redSqr().redISub(s).redISub(s);
      const nx = t;
      const ny = m.redMul(s.redISub(t)).redISub(yy.redSqr().redIMuln(8));
      const nz = this.y.redMul(this.z).redIMuln(2);
      return this.curve.jpoint(nx, ny, nz);
    }
    _dbl0() {
      const a = this.x.redSqr();
      const b = this.y.redSqr();
      const c = b.redSqr();
      const xb2 = b.redIAdd(this.x).redSqr();
      const d = xb2.redISub(a).redISub(c).redIMuln(2);
      const e = a.redIMuln(3);
      const f = e.redSqr();
      const nx = f.redISub(d).redISub(d);
      const ny = e.redMul(d.redISub(nx)).redISub(c.redIMuln(8));
      const nz = this.y.redMul(this.z).redIMuln(2);
      return this.curve.jpoint(nx, ny, nz);
    }
    _dbl3() {
      const delta = this.z.redSqr();
      const gamma = this.y.redSqr();
      const beta = this.x.redMul(gamma);
      const xmdelta = this.x.redSub(delta);
      const xpdelta = this.x.redAdd(delta);
      const alpha = xmdelta.redMul(xpdelta).redIMuln(3);
      const beta4 = beta.redIMuln(4);
      const beta8 = beta4.redMuln(2);
      const gamma28 = gamma.redSqr().redIMuln(8);
      const nx = alpha.redSqr().redISub(beta8);
      const nz = this.y.redAdd(this.z).redSqr().redISub(gamma).redISub(delta);
      const ny = alpha.redMul(beta4.redISub(nx)).redISub(gamma28);
      return this.curve.jpoint(nx, ny, nz);
    }
    getX() {
      if (this.isInfinity())
        throw new Error("Invalid point.");
      this.normalize();
      return this.x.fromRed();
    }
    getY() {
      if (this.isInfinity())
        throw new Error("Invalid point.");
      this.normalize();
      return this.y.fromRed();
    }
    eq(p) {
      assert(p instanceof JPoint);
      if (this === p)
        return true;
      if (this.isInfinity())
        return p.isInfinity();
      if (p.isInfinity())
        return false;
      if (this.z.eq(p.z)) {
        return this.x.eq(p.x) && this.y.eq(p.y);
      }
      const zz1 = this.z.redSqr();
      const zz2 = p.z.redSqr();
      const x1 = this.x.redMul(zz2);
      const x2 = p.x.redMul(zz1);
      if (!x1.eq(x2))
        return false;
      const zzz1 = zz1.redMul(this.z);
      const zzz2 = zz2.redMul(p.z);
      const y1 = this.y.redMul(zzz2);
      const y2 = p.y.redMul(zzz1);
      return y1.eq(y2);
    }
    cmp(point) {
      assert(point instanceof JPoint);
      const inf1 = this.isInfinity();
      const inf2 = point.isInfinity();
      if (inf1 && !inf2)
        return -1;
      if (!inf1 && inf2)
        return 1;
      if (inf1 && inf2)
        return 0;
      return this.order().cmp(point.order()) || this.getX().cmp(point.getX()) || this.getY().cmp(point.getY());
    }
    isInfinity() {
      return this.z.isZero();
    }
    isOrder2() {
      if (this.isInfinity())
        return false;
      return this.y.isZero();
    }
    isOdd() {
      if (this.isInfinity())
        return false;
      this.normalize();
      return this.y.redIsOdd();
    }
    isEven() {
      if (this.isInfinity())
        return false;
      this.normalize();
      return this.y.redIsEven();
    }
    isSquare() {
      if (this.isInfinity())
        return false;
      return this.y.redMul(this.z).redJacobi() !== -1;
    }
    eqX(x) {
      assert(x instanceof BN);
      assert(!x.red);
      if (this.isInfinity())
        return false;
      const zz = this.z.redSqr();
      const rx = x.toRed(this.curve.red).redMul(zz);
      return this.x.eq(rx);
    }
    eqR(x) {
      assert(x instanceof BN);
      assert(!x.red);
      if (!this.curve.smallGap)
        return this.toP().eqR(x);
      if (this.isInfinity())
        return false;
      if (x.cmp(this.curve.p) >= 0)
        return false;
      const zz = this.z.redSqr();
      const rx = x.toRed(this.curve.red).redMul(zz);
      if (this.x.eq(rx))
        return true;
      if (this.curve.highOrder)
        return false;
      if (x.cmp(this.curve.pmodn) >= 0)
        return false;
      const rn = this.curve.redN.redMul(zz);
      rx.redIAdd(rn);
      return this.x.eq(rx);
    }
    toP() {
      if (this.isInfinity())
        return this.curve.point();
      this.normalize();
      return this.curve.point(this.x, this.y);
    }
    toJ() {
      return this;
    }
    encode(compact) {
      return this.toP().encode(compact);
    }
    static decode(curve2, bytes) {
      return ShortPoint.decode(curve2, bytes).toJ();
    }
    encodeX() {
      return this.toP().encodeX();
    }
    static decodeEven(curve2, bytes) {
      return ShortPoint.decodeEven(curve2, bytes).toJ();
    }
    static decodeSquare(curve2, bytes) {
      return ShortPoint.decodeSquare(curve2, bytes).toJ();
    }
    toJSON(pre) {
      return this.toP().toJSON(pre);
    }
    toPretty() {
      return this.toP().toPretty();
    }
    static fromJSON(curve2, json) {
      return ShortPoint.fromJSON(curve2, json).toJ();
    }
    [custom]() {
      if (this.isInfinity())
        return "<JPoint: Infinity>";
      return "<JPoint: x=" + this.x.fromRed().toString(16, 2) + " y=" + this.y.fromRed().toString(16, 2) + " z=" + this.z.fromRed().toString(16, 2) + ">";
    }
  };
  var MontCurve = class extends Curve {
    constructor(conf) {
      super(MontPoint, "mont", conf);
      this.a = BN.fromJSON(conf.a).toRed(this.red);
      this.b = BN.fromJSON(conf.b).toRed(this.red);
      this.bi = this.b.redInvert();
      this.a2 = this.a.redAdd(this.two);
      this.a24 = this.a2.redMul(this.i4);
      this.a3 = this.a.redMul(this.i3);
      this.a0 = this.a.redMul(this.bi);
      this.b0 = this.bi.redSqr();
      this._finalize(conf);
    }
    static _isomorphism(curveA, curveB, customB) {
      assert(curveA instanceof BN);
      assert(curveB instanceof BN);
      assert(customB instanceof BN);
      const a = curveA.clone();
      const b = customB.clone();
      const c = curveB.redDiv(customB);
      if (c.redJacobi() !== 1)
        throw new Error("Invalid `b` coefficient.");
      return [a, b];
    }
    _short(a0, odd) {
      const {a, b, three} = this;
      const a2 = a.redSqr();
      const a3 = a2.redMul(a);
      const b2 = b.redSqr();
      const b3 = b2.redMul(b);
      const n0 = three.redSub(a2);
      const d0 = b2.redMuln(3);
      const n1 = a3.redMuln(2).redISub(a.redMuln(9));
      const d1 = b3.redMuln(27);
      const wa = n0.redDiv(d0);
      const wb = n1.redDiv(d1);
      if (a0 != null)
        return ShortCurve._isomorphism(wa, wb, a0, odd);
      return [wa, wb];
    }
    _mont(b0) {
      return MontCurve._isomorphism(this.a, this.b, b0);
    }
    _edwards(a0, invert = false) {
      assert(typeof invert === "boolean");
      const {two, bi} = this;
      const a = this.a.redAdd(two).redMul(bi);
      const d = this.a.redSub(two).redMul(bi);
      if (invert)
        a.swap(d);
      if (a0 != null)
        return EdwardsCurve._isomorphism(a, d, a0);
      return [a, d];
    }
    _scaleShort(curve2) {
      assert(curve2 instanceof ShortCurve);
      const [u2, u3] = curve2._scale(this);
      return [
        this.field(u2.redInvert()),
        this.field(u3.redInvert())
      ];
    }
    _scaleMont(curve2) {
      assert(curve2 instanceof MontCurve);
      if (this.g.isInfinity() || curve2.g.isInfinity())
        return this.field(curve2.b).redDivSqrt(this.b);
      return this.g.y.redDiv(this.field(curve2.g.y));
    }
    _scaleEdwards(curve2, invert) {
      assert(curve2 instanceof EdwardsCurve);
      const c = curve2._scale(this, invert);
      return this.field(c);
    }
    _solveY0(x) {
      assert(x instanceof BN);
      const a = this.a0;
      const b = this.b0;
      const x2 = x.redSqr();
      const x3 = x2.redMul(x);
      const y2 = x3.redIAdd(a.redMul(x2)).redIAdd(b.redMul(x));
      return y2;
    }
    _elligator2(u) {
      const lhs = this.a0.redNeg();
      const rhs = this.one.redAdd(this.z.redMul(u.redSqr()));
      if (rhs.isZero())
        rhs.inject(this.one);
      const x1 = lhs.redMul(rhs.redInvert());
      const x2 = x1.redNeg().redISub(this.a0);
      const y1 = this._solveY0(x1);
      const y2 = this._solveY0(x2);
      const alpha = y1.redIsSquare() | 0;
      const x0 = [x1, x2][alpha ^ 1];
      const y0 = [y1, y2][alpha ^ 1].redSqrt();
      if (y0.redIsOdd() !== u.redIsOdd())
        y0.redINeg();
      const x = this.b.redMul(x0);
      const y = this.b.redMul(y0);
      return this.point(x, y);
    }
    _invert2(p, hint) {
      const {x, y} = p;
      const r = hint & 1;
      const x0 = x.redMul(this.bi);
      const y0 = y.redMul(this.bi);
      const n = x0.redAdd(this.a0);
      const d = x0;
      const lhs = [n, d][r].redINeg();
      const rhs = [d, n][r].redMul(this.z);
      const u = lhs.redDivSqrt(rhs);
      if (u.redIsOdd() !== y0.redIsOdd())
        u.redINeg();
      return u;
    }
    isElliptic() {
      const a2 = this.a.redSqr();
      const d = this.b.redMul(a2.redSub(this.four));
      return !d.isZero();
    }
    jinv() {
      const {a, three, four} = this;
      const a2 = a.redSqr();
      const t0 = a2.redSub(three);
      const lhs = t0.redPown(3).redIMuln(256);
      const rhs = a2.redSub(four);
      if (rhs.isZero())
        throw new Error("Curve is not elliptic.");
      return lhs.redDiv(rhs).fromRed();
    }
    point(x, y) {
      return new MontPoint(this, x, y);
    }
    jpoint(x, y, z) {
      assert(x == null && y == null && z == null);
      return this.point();
    }
    xpoint(x, z) {
      return new XPoint(this, x, z);
    }
    solveY2(x) {
      assert(x instanceof BN);
      const x2 = x.redSqr();
      const x3 = x2.redMul(x);
      const by2 = x3.redIAdd(this.a.redMul(x2)).redIAdd(x);
      const y2 = by2.redMul(this.bi);
      return y2;
    }
    validate(point) {
      assert(point instanceof MontPoint);
      if (point.isInfinity())
        return true;
      const {x, y} = point;
      const y2 = this.solveY2(x);
      return y.redSqr().eq(y2);
    }
    pointFromX(x, sign = null) {
      assert(x instanceof BN);
      assert(sign == null || typeof sign === "boolean");
      if (!x.red)
        x = x.toRed(this.red);
      const y = this.solveY(x);
      if (sign != null) {
        if (y.isZero() && sign)
          throw new Error("Invalid point.");
        if (y.redIsOdd() !== sign)
          y.redINeg();
      }
      return this.point(x, y);
    }
    isIsomorphic(curve2, invert) {
      assert(curve2 instanceof Curve);
      if (!curve2.p.eq(this.p))
        return false;
      if (curve2.type === "mont") {
        const a = this.field(curve2.a);
        const b = this.field(curve2.b);
        if (!this.a.eq(a))
          return false;
        if (this.b.isZero())
          return false;
        const c = b.redDiv(this.b);
        return c.redJacobi() === 1;
      }
      return curve2.isIsomorphic(this, invert);
    }
    isIsogenous(curve2) {
      assert(curve2 instanceof Curve);
      if (curve2.type === "mont")
        return false;
      return curve2.isIsogenous(this);
    }
    pointFromShort(point) {
      assert(point instanceof ShortPoint);
      if (this.isIsomorphic(point.curve)) {
        if (point.isInfinity())
          return this.point();
        const {a3, b} = this;
        const [u2, u3] = this._scale(point.curve);
        const x = this.field(point.x).redMul(u2);
        const y = this.field(point.y).redMul(u3);
        const u = b.redMul(x).redISub(a3);
        const v = b.redMul(y);
        return this.point(u, v);
      }
      throw new Error("Not implemented.");
    }
    pointFromMont(point) {
      assert(point instanceof MontPoint);
      if (this.isIsomorphic(point.curve)) {
        if (point.isInfinity())
          return this.point();
        const c = this._scale(point.curve);
        const u = this.field(point.x);
        const v = this.field(point.y);
        const nu = u;
        const nv = c.redMul(v);
        return this.point(nu, nv);
      }
      throw new Error("Not implemented.");
    }
    pointFromEdwards(point) {
      assert(point instanceof EdwardsPoint);
      assert(point.curve.p.eq(this.p));
      const x = this.field(point.x);
      const y = this.field(point.y);
      const z = this.field(point.z);
      if (this.isIsogenous(point.curve)) {
        if (point.isInfinity())
          return this.point();
        if (point.x.isZero())
          return this.point(this.zero, this.zero);
        const c = z.redSqr().redIMuln(2);
        const uu = y.redSqr();
        const uz = x.redSqr();
        const vv = c.redISub(uz).redISub(uu).redMul(y);
        const vz = uz.redMul(x);
        return this.cpoint(uu, uz, vv, vz);
      }
      if (this.isIsomorphic(point.curve, true)) {
        if (point.isInfinity())
          return this.point();
        if (point.x.isZero())
          return this.point(this.zero, this.zero);
        const c = this._scale(point.curve, true);
        const uu = y.redAdd(z);
        const uz = y.redSub(z);
        const vv = c.redMul(z).redMul(uu);
        const vz = x.redMul(uz);
        return this.cpoint(uu, uz, vv, vz);
      }
      if (this.isIsomorphic(point.curve, false)) {
        if (point.isInfinity())
          return this.point();
        if (point.x.isZero())
          return this.point(this.zero, this.zero);
        const c = this._scale(point.curve, false);
        const uu = z.redAdd(y);
        const uz = z.redSub(y);
        const vv = c.redMul(z).redMul(uu);
        const vz = x.redMul(uz);
        return this.cpoint(uu, uz, vv, vz);
      }
      throw new Error("Not implemented.");
    }
    pointFromUniform(u) {
      assert(u instanceof BN);
      if (this.z.isZero() || this.a.isZero())
        throw new Error("Not implemented.");
      return this._elligator2(u);
    }
    pointToUniform(p, hint) {
      assert(p instanceof MontPoint);
      assert(hint >>> 0 === hint);
      if (this.z.isZero() || this.a.isZero())
        throw new Error("Not implemented.");
      if (p.isInfinity())
        throw new Error("Invalid point.");
      const i = (hint >>> 4 & 15) % this.torsion.length;
      const q = p.add(this.torsion[i]);
      return wrapErrors(() => {
        return this._invert2(q, hint);
      });
    }
    decodePoint(bytes, sign) {
      return MontPoint.decode(this, bytes, sign);
    }
    encodeX(point) {
      assert(point instanceof XPoint);
      return point.encode();
    }
    decodeX(bytes) {
      return XPoint.decode(this, bytes);
    }
    toShort(a0, odd, sign = null) {
      const [a, b] = this._short(a0, odd);
      const curve2 = new ShortCurve({
        red: this.red,
        prime: this.prime,
        p: this.p,
        a,
        b,
        n: this.n,
        h: this.h
      });
      if (sign != null) {
        const [, u3] = curve2._scale(this);
        if (u3.redIsOdd() !== sign)
          u3.redINeg();
      }
      if (!this.g.isInfinity())
        curve2.g = curve2.pointFromMont(this.g);
      for (let i = 0; i < this.h.word(0); i++)
        curve2.torsion[i] = curve2.pointFromMont(this.torsion[i]);
      return curve2;
    }
    toMont(b0, sign = null) {
      const [a, b] = this._mont(b0);
      const curve2 = new MontCurve({
        red: this.red,
        prime: this.prime,
        p: this.p,
        a,
        b,
        n: this.n,
        h: this.h,
        z: this.z
      });
      if (sign != null) {
        const c = curve2._scale(this);
        if (c.redIsOdd() !== sign)
          c.redINeg();
      }
      if (!this.g.isInfinity())
        curve2.g = curve2.pointFromMont(this.g);
      for (let i = 0; i < this.h.word(0); i++)
        curve2.torsion[i] = curve2.pointFromMont(this.torsion[i]);
      return curve2;
    }
    toEdwards(a0, invert, sign = null) {
      const [a, d] = this._edwards(a0, invert);
      const curve2 = new EdwardsCurve({
        red: this.red,
        prime: this.prime,
        p: this.p,
        a,
        d,
        n: this.n,
        h: this.h,
        z: this.z
      });
      if (sign != null) {
        const c = curve2._scale(this, invert);
        if (c.redIsOdd() !== sign)
          c.redINeg();
      }
      if (!this.g.isInfinity()) {
        curve2.g = curve2.pointFromMont(this.g);
        curve2.g.normalize();
      }
      if (curve2.isComplete()) {
        for (let i = 0; i < this.h.word(0); i++) {
          curve2.torsion[i] = curve2.pointFromMont(this.torsion[i]);
          curve2.torsion[i].normalize();
        }
      }
      return curve2;
    }
    pointFromJSON(json) {
      return MontPoint.fromJSON(this, json);
    }
    toJSON(pre) {
      const json = super.toJSON(pre);
      json.a = this.a.fromRed().toJSON();
      json.b = this.b.fromRed().toJSON();
      return json;
    }
  };
  var MontPoint = class extends Point {
    constructor(curve2, x, y) {
      assert(curve2 instanceof MontCurve);
      super(curve2, types.AFFINE);
      this.x = this.curve.zero;
      this.y = this.curve.zero;
      this.inf = true;
      if (x != null)
        this._init(x, y);
    }
    _init(x, y) {
      assert(x instanceof BN);
      assert(y instanceof BN);
      this.x = x;
      this.y = y;
      if (!this.x.red)
        this.x = this.x.toRed(this.curve.red);
      if (!this.y.red)
        this.y = this.y.toRed(this.curve.red);
      this.inf = false;
    }
    clone() {
      if (this.inf)
        return this.curve.point();
      return this.curve.point(this.x, this.y);
    }
    scale(a) {
      return this.clone();
    }
    randomize(rng) {
      return this.clone();
    }
    neg() {
      if (this.inf)
        return this;
      return this.curve.point(this.x, this.y.redNeg());
    }
    add(p) {
      assert(p instanceof MontPoint);
      if (this.inf)
        return p;
      if (p.inf)
        return this;
      if (this.x.eq(p.x)) {
        if (!this.y.eq(p.y))
          return this.curve.point();
        return this.dbl();
      }
      const h = p.x.redSub(this.x);
      const r = p.y.redSub(this.y);
      const l = r.redDiv(h);
      const k = this.curve.b.redMul(l.redSqr());
      const nx = k.redISub(this.curve.a).redISub(this.x).redISub(p.x);
      const ny = l.redMul(this.x.redSub(nx)).redISub(this.y);
      return this.curve.point(nx, ny);
    }
    dbl() {
      if (this.inf)
        return this;
      if (this.y.isZero())
        return this.curve.point();
      const m1 = this.x.redSqr().redIMuln(3);
      const m2 = this.curve.a.redMul(this.x).redIMuln(2);
      const m = m1.redIAdd(m2).redIAdd(this.curve.one);
      const z = this.curve.b.redMul(this.y).redIMuln(2);
      const l = m.redDiv(z);
      const k = this.curve.b.redMul(l.redSqr());
      const nx = k.redISub(this.curve.a).redISub(this.x).redISub(this.x);
      const ny = l.redMul(this.x.redSub(nx)).redISub(this.y);
      return this.curve.point(nx, ny);
    }
    getX() {
      if (this.inf)
        throw new Error("Invalid point.");
      return this.x.fromRed();
    }
    getY() {
      if (this.inf)
        throw new Error("Invalid point.");
      return this.y.fromRed();
    }
    eq(p) {
      assert(p instanceof MontPoint);
      if (this === p)
        return true;
      if (this.inf)
        return p.inf;
      if (p.inf)
        return false;
      return this.x.eq(p.x) && this.y.eq(p.y);
    }
    cmp(point) {
      assert(point instanceof MontPoint);
      if (this.inf && !point.inf)
        return -1;
      if (!this.inf && point.inf)
        return 1;
      if (this.inf && point.inf)
        return 0;
      return this.order().cmp(point.order()) || this.getX().cmp(point.getX()) || this.getY().cmp(point.getY());
    }
    isInfinity() {
      return this.inf;
    }
    isOrder2() {
      if (this.inf)
        return false;
      return this.y.isZero();
    }
    isOdd() {
      if (this.inf)
        return false;
      return this.y.redIsOdd();
    }
    isEven() {
      if (this.inf)
        return false;
      return this.y.redIsEven();
    }
    toP() {
      return this;
    }
    toJ() {
      return this;
    }
    toX() {
      if (this.inf)
        return this.curve.xpoint();
      return this.curve.xpoint(this.x, this.curve.one);
    }
    encode() {
      return this.toX().encode();
    }
    static decode(curve2, bytes, sign) {
      assert(curve2 instanceof MontCurve);
      return curve2.decodeX(bytes).toP(sign);
    }
    toJSON(pre) {
      if (this.inf)
        return [];
      const x = this.getX().toJSON();
      const y = this.getY().toJSON();
      return [x, y];
    }
    toPretty() {
      if (this.inf)
        return [];
      const size = this.curve.fieldSize * 2;
      const x = toPretty(this.getX(), size);
      const y = toPretty(this.getY(), size);
      return [x, y];
    }
    static fromJSON(curve2, json) {
      assert(curve2 instanceof MontCurve);
      assert(Array.isArray(json));
      assert(json.length === 0 || json.length === 2 || json.length === 3);
      if (json.length === 0)
        return curve2.point();
      const x = BN.fromJSON(json[0]);
      const y = BN.fromJSON(json[1]);
      return curve2.point(x, y);
    }
    [custom]() {
      if (this.inf)
        return "<MontPoint: Infinity>";
      return "<MontPoint: x=" + this.x.fromRed().toString(16, 2) + " y=" + this.y.fromRed().toString(16, 2) + ">";
    }
  };
  var XPoint = class extends Point {
    constructor(curve2, x, z) {
      assert(curve2 instanceof MontCurve);
      super(curve2, types.PROJECTIVE);
      this.x = this.curve.one;
      this.z = this.curve.zero;
      if (x != null)
        this._init(x, z);
    }
    _init(x, z) {
      assert(x instanceof BN);
      assert(z == null || z instanceof BN);
      this.x = x;
      this.z = z || this.curve.one;
      if (!this.x.red)
        this.x = this.x.toRed(this.curve.red);
      if (!this.z.red)
        this.z = this.z.toRed(this.curve.red);
    }
    clone() {
      return this.curve.xpoint(this.x, this.z);
    }
    precompute(power, rng) {
      return this;
    }
    validate() {
      if (this.isInfinity())
        return true;
      const {x, z} = this;
      const x2 = x.redSqr();
      const x3 = x2.redMul(x);
      const z2 = z.redSqr();
      const ax2 = this.curve.a.redMul(x2).redMul(z);
      const by2 = x3.redIAdd(ax2).redIAdd(x.redMul(z2));
      const y2 = by2.redMul(this.curve.bi);
      return y2.redMul(z).redJacobi() !== -1;
    }
    normalize() {
      if (this.isInfinity())
        return this;
      if (this.z.eq(this.curve.one))
        return this;
      this.x = this.x.redDiv(this.z);
      this.z = this.curve.one;
      return this;
    }
    scale(a) {
      assert(a instanceof BN);
      if (this.isInfinity())
        return this.curve.xpoint();
      const nx = this.x.redMul(a);
      const nz = this.z.redMul(a);
      return this.curve.xpoint(nx, nz);
    }
    neg() {
      return this;
    }
    dbl() {
      const a = this.x.redAdd(this.z);
      const aa = a.redSqr();
      const b = this.x.redSub(this.z);
      const bb = b.redSqr();
      const c = aa.redSub(bb);
      const nx = aa.redMul(bb);
      const nz = c.redMul(bb.redIAdd(this.curve.a24.redMul(c)));
      return this.curve.xpoint(nx, nz);
    }
    diffAddDbl(p2, p3) {
      assert(p2 instanceof XPoint);
      assert(p3 instanceof XPoint);
      const a = p2.x.redAdd(p2.z);
      const aa = a.redSqr();
      const b = p2.x.redSub(p2.z);
      const bb = b.redSqr();
      const e = aa.redSub(bb);
      const c = p3.x.redAdd(p3.z);
      const d = p3.x.redSub(p3.z);
      const da = d.redMul(a);
      const cb = c.redMul(b);
      const x5 = this.z.redMul(da.redAdd(cb).redSqr());
      const z5 = this.x.redMul(da.redISub(cb).redSqr());
      const x4 = aa.redMul(bb);
      const z4 = e.redMul(bb.redIAdd(this.curve.a24.redMul(e)));
      return [
        this.curve.xpoint(x4, z4),
        this.curve.xpoint(x5, z5)
      ];
    }
    getX() {
      if (this.isInfinity())
        throw new Error("Invalid point.");
      this.normalize();
      return this.x.fromRed();
    }
    getY(sign) {
      return this.toP(sign).getY();
    }
    eq(p) {
      assert(p instanceof XPoint);
      if (this === p)
        return true;
      if (this.isInfinity())
        return p.isInfinity();
      if (p.isInfinity())
        return false;
      if (this.z.eq(p.z))
        return this.x.eq(p.x);
      const x1 = this.x.redMul(p.z);
      const x2 = p.x.redMul(this.z);
      return x1.eq(x2);
    }
    cmp(point) {
      assert(point instanceof XPoint);
      const inf1 = this.isInfinity();
      const inf2 = point.isInfinity();
      if (inf1 && !inf2)
        return -1;
      if (!inf1 && inf2)
        return 1;
      if (inf1 && inf2)
        return 0;
      return this.order().cmp(point.order()) || this.getX().cmp(point.getX());
    }
    isInfinity() {
      return this.z.isZero();
    }
    isOrder2() {
      if (this.isInfinity())
        return false;
      return this.x.isZero();
    }
    isOdd() {
      return false;
    }
    isEven() {
      return false;
    }
    hasTorsion() {
      if (this.isInfinity())
        return false;
      if (this.x.isZero())
        return true;
      return super.hasTorsion();
    }
    order() {
      try {
        return this.toP().order();
      } catch (e) {
        return new BN(1);
      }
    }
    jmul(k) {
      assert(k instanceof BN);
      assert(!k.red);
      const bits = k.bitLength();
      let a = this.curve.xpoint();
      let b = this;
      for (let i = bits - 1; i >= 0; i--) {
        const bit = k.bit(i);
        if (bit === 0)
          [a, b] = this.diffAddDbl(a, b);
        else
          [b, a] = this.diffAddDbl(b, a);
      }
      return a;
    }
    jmulBlind(k, rng) {
      if (!rng)
        return this.jmul(k);
      return this.randomize(rng).jmul(k);
    }
    jmulAdd(k1, p2, k2) {
      throw new Error("Not implemented.");
    }
    toP(sign = null) {
      assert(sign == null || typeof sign === "boolean");
      if (this.isInfinity())
        return this.curve.point();
      this.normalize();
      return this.curve.pointFromX(this.x, sign);
    }
    toJ() {
      return this;
    }
    toX() {
      return this;
    }
    key() {
      if (this.isInfinity())
        return `${this.curve.uid}:oo`;
      this.normalize();
      const x = this.getX().toString(16);
      return `${this.curve.uid}:${x}`;
    }
    encode() {
      return this.curve.encodeField(this.getX());
    }
    static decode(curve2, bytes) {
      assert(curve2 instanceof MontCurve);
      const x = curve2.decodeField(bytes);
      x.iumaskn(curve2.fieldBits);
      const p = curve2.xpoint(x, curve2.one);
      assert(!p.isInfinity());
      return p;
    }
    toJSON(pre) {
      return this.toP().toJSON(pre);
    }
    toPretty() {
      return this.toP().toPretty();
    }
    static fromJSON(curve2, json) {
      return MontPoint.fromJSON(curve2, json).toX();
    }
    [custom]() {
      if (this.isInfinity())
        return "<XPoint: Infinity>";
      return "<XPoint: x=" + this.x.fromRed().toString(16, 2) + " z=" + this.z.fromRed().toString(16, 2) + ">";
    }
  };
  var EdwardsCurve = class extends Curve {
    constructor(conf) {
      super(EdwardsPoint, "edwards", conf);
      this.a = BN.fromJSON(conf.a).toRed(this.red);
      this.d = BN.fromJSON(conf.d).toRed(this.red);
      this.s = BN.fromJSON(conf.s || "0").toRed(this.red);
      this.si = this.s.isZero() ? this.zero : this.s.redInvert();
      this.k = this.d.redMuln(2);
      this.smi = -this.d.redNeg().word(0);
      this.ad6 = this.a.redAdd(this.d).redMul(this.i6);
      this.twisted = !this.a.eq(this.one);
      this.oneA = this.a.eq(this.one);
      this.mOneA = this.a.eq(this.one.redNeg());
      this.smallD = this.prime != null && this.d.redNeg().length === 1;
      this.alt = null;
      this._finalize(conf);
    }
    static _isomorphism(curveA, curveD, customA) {
      assert(curveA instanceof BN);
      assert(curveD instanceof BN);
      assert(customA instanceof BN);
      const a = customA.clone();
      const d = customA.redMul(curveD).redDiv(curveA);
      const c = curveA.redDiv(customA);
      if (c.redJacobi() !== 1)
        throw new Error("Invalid `a` coefficient.");
      return [a, d];
    }
    _short(a0, odd) {
      const {a, d} = this;
      const a2 = a.redSqr();
      const a3 = a2.redMul(a);
      const d2 = d.redSqr();
      const d3 = d2.redMul(d);
      const ad14 = a.redMul(d).redIMuln(14);
      const a2d = a2.redMul(d);
      const ad2 = a.redMul(d2);
      const t0 = a2d.redIAdd(ad2).redIMuln(33);
      const wa = a2.redAdd(ad14).redIAdd(d2).redDivn(-48);
      const wb = t0.redISub(a3).redISub(d3).redDivn(864);
      if (a0 != null)
        return ShortCurve._isomorphism(wa, wb, a0, odd);
      return [wa, wb];
    }
    _mont(b0, invert = false) {
      assert(typeof invert === "boolean");
      let apd, amd;
      if (invert) {
        apd = this.d.redAdd(this.a);
        amd = this.d.redSub(this.a);
      } else {
        apd = this.a.redAdd(this.d);
        amd = this.a.redSub(this.d);
      }
      const z = amd.redInvert();
      const a = apd.redMuln(2).redMul(z);
      const b = z.redMuln(4);
      if (b0 != null)
        return MontCurve._isomorphism(a, b, b0);
      return [a, b];
    }
    _edwards(a0) {
      return EdwardsCurve._isomorphism(this.a, this.d, a0);
    }
    _scaleShort(curve2) {
      assert(curve2 instanceof ShortCurve);
      const [u2, u3] = curve2._scale(this);
      return [
        this.field(u2.redInvert()),
        this.field(u3.redInvert())
      ];
    }
    _scaleMont(curve2, invert = false) {
      assert(curve2 instanceof MontCurve);
      assert(typeof invert === "boolean");
      if (this.g.isInfinity() || curve2.g.isInfinity()) {
        const [a] = curve2._edwards(null, invert);
        return this.field(a).redDivSqrt(this.a);
      }
      const x = curve2.g.x.redDiv(curve2.g.y);
      return this.g.x.redDiv(this.field(x));
    }
    _scaleEdwards(curve2) {
      assert(curve2 instanceof EdwardsCurve);
      if (this.g.isInfinity() || curve2.g.isInfinity())
        return this.field(curve2.a).redDivSqrt(this.a);
      return this.g.x.redDiv(this.field(curve2.g.x));
    }
    _mulA(num) {
      assert(num instanceof BN);
      if (this.oneA)
        return num.clone();
      if (this.mOneA)
        return num.redNeg();
      return this.a.redMul(num);
    }
    _mulD(num) {
      assert(num instanceof BN);
      if (this.smallD)
        return num.redMuln(this.smi);
      return this.d.redMul(num);
    }
    _elligator1(t) {
      const {s, si, i2, one, two} = this;
      const c = si.redSqr().redIMuln(2);
      const ci = s.redSqr().redMul(i2);
      const ci2 = ci.redSqr();
      const r = c.redAdd(ci);
      const r2 = r.redSqr().redISub(two);
      const cm1 = c.redSub(one);
      const uu = one.redSub(t);
      const uz = one.redAdd(t);
      const u = uz.isZero() ? uz : uu.redDiv(uz);
      const u2 = u.redSqr();
      const u3 = u2.redMul(u);
      const u5 = u3.redMul(u2);
      const v = u5.redAdd(r2.redMul(u3)).redIAdd(u);
      const f0 = this.field(v.redJacobi());
      const f1 = this.field(u2.redAdd(ci2).redJacobi());
      const f2 = f0.redMul(f1);
      const X = f0.redMul(u);
      const Y = f0.redMul(v).redSqrt().redMul(f2);
      const X1 = one.redAdd(X);
      const rX = r.redMul(X);
      const X12 = X1.redSqr();
      const xx = cm1.redMul(s).redMul(X).redMul(X1);
      const xz = u.isZero() ? this.one : Y;
      const yy = rX.redSub(X12);
      const yz = rX.redAdd(X12);
      return this.cpoint(xx, xz, yy, yz);
    }
    _invert1(p, hint) {
      const {s, si, i2, one} = this;
      const {x, y, z} = p;
      const sign = hint & 1;
      const c = si.redSqr().redIMuln(2);
      const ci = s.redSqr().redMul(i2);
      const ci2 = ci.redSqr();
      const r = c.redAdd(ci);
      const cm1 = c.redSub(one);
      const nn = y.redSub(z);
      const nz = y.redAdd(z).redIMuln(2);
      const n = nz.isZero() ? nz : nn.redDiv(nz);
      const nr1 = one.redAdd(n.redMul(r));
      const w2 = nr1.redSqr().redISub(one);
      const w = w2.redSqrt();
      const X = w.redSub(nr1);
      const X1 = one.redAdd(X);
      const YY = cm1.redMul(s).redMul(X).redMul(X1);
      const Y = YY.redMul(x.redMul(z));
      const X2 = X.redSqr().redIAdd(ci2);
      const Z = this.field(Y.redMul(X2).redJacobi());
      const u = Z.redMul(X);
      const tt = one.redSub(u);
      const tz = one.redAdd(u);
      const t = tz.isZero() ? tz : tt.redDiv(tz);
      if (t.redIsOdd() !== Boolean(sign))
        t.redINeg();
      return t;
    }
    _alt() {
      if (!this.alt)
        this.alt = this.toMont();
      return this.alt;
    }
    isElliptic() {
      const ad = this.a.redMul(this.d);
      const amd = this.a.redSub(this.d);
      return !ad.redMul(amd).isZero();
    }
    jinv() {
      const {a, d} = this;
      const ad = a.redMul(d);
      const amd4 = a.redSub(d).redPown(4);
      const a2 = a.redSqr();
      const d2 = d.redSqr();
      const t0 = a2.redAdd(ad.redMuln(14)).redIAdd(d2);
      const lhs = t0.redPown(3).redIMuln(16);
      const rhs = ad.redMul(amd4);
      if (rhs.isZero())
        throw new Error("Curve is not elliptic.");
      return lhs.redDiv(rhs).fromRed();
    }
    isComplete() {
      return this.a.redJacobi() === 1 && this.d.redJacobi() === -1;
    }
    point(x, y, z, t) {
      return new EdwardsPoint(this, x, y, z, t);
    }
    jpoint(x, y, z) {
      assert(x == null && y == null && z == null);
      return this.point();
    }
    cpoint(xx, xz, yy, yz) {
      assert(xx instanceof BN);
      assert(xz instanceof BN);
      assert(yy instanceof BN);
      assert(yz instanceof BN);
      const x = xx.redMul(yz);
      const y = yy.redMul(xz);
      const z = xz.redMul(yz);
      const t = xx.redMul(yy);
      return this.point(x, y, z, t);
    }
    solveX2(y) {
      assert(y instanceof BN);
      const y2 = y.redSqr();
      const rhs = this._mulD(y2).redISub(this.a);
      const lhs = y2.redISub(this.one);
      const x2 = lhs.redDiv(rhs);
      return x2;
    }
    solveX(y) {
      const y2 = y.redSqr();
      const rhs = this._mulD(y2).redISub(this.a);
      const lhs = y2.redISub(this.one);
      return lhs.redDivSqrt(rhs);
    }
    solveY2(x) {
      assert(x instanceof BN);
      const x2 = x.redSqr();
      const lhs = this._mulA(x2).redISub(this.one);
      const rhs = this._mulD(x2).redISub(this.one);
      const y2 = lhs.redDiv(rhs);
      return y2;
    }
    solveY(x) {
      const x2 = x.redSqr();
      const lhs = this._mulA(x2).redISub(this.one);
      const rhs = this._mulD(x2).redISub(this.one);
      return lhs.redDivSqrt(rhs);
    }
    validate(point) {
      assert(point instanceof EdwardsPoint);
      if (point.zOne) {
        const x22 = point.x.redSqr();
        const y22 = point.y.redSqr();
        const dxy2 = this._mulD(x22).redMul(y22);
        const lhs2 = this._mulA(x22).redIAdd(y22);
        const rhs2 = this.one.redAdd(dxy2);
        const tz2 = point.t;
        const xy2 = point.x.redMul(point.y);
        return lhs2.eq(rhs2) && tz2.eq(xy2);
      }
      const x2 = point.x.redSqr();
      const y2 = point.y.redSqr();
      const z2 = point.z.redSqr();
      const z4 = z2.redSqr();
      const dxy = this._mulD(x2).redMul(y2);
      const lhs = this._mulA(x2).redIAdd(y2).redMul(z2);
      const rhs = z4.redIAdd(dxy);
      const tz = point.t.redMul(point.z);
      const xy = point.x.redMul(point.y);
      return lhs.eq(rhs) && tz.eq(xy);
    }
    pointFromX(x, sign = null) {
      assert(x instanceof BN);
      assert(sign == null || typeof sign === "boolean");
      if (!x.red)
        x = x.toRed(this.red);
      const y = this.solveY(x);
      if (sign != null) {
        if (y.isZero() && sign)
          throw new Error("Invalid point.");
        if (y.redIsOdd() !== sign)
          y.redINeg();
      }
      return this.point(x, y);
    }
    pointFromY(y, sign = null) {
      assert(y instanceof BN);
      assert(sign == null || typeof sign === "boolean");
      if (!y.red)
        y = y.toRed(this.red);
      const x = this.solveX(y);
      if (sign != null) {
        if (x.isZero() && sign)
          throw new Error("Invalid point.");
        if (x.redIsOdd() !== sign)
          x.redINeg();
      }
      return this.point(x, y);
    }
    isIsomorphic(curve2, invert = false) {
      assert(curve2 instanceof Curve);
      assert(typeof invert === "boolean");
      if (!curve2.p.eq(this.p))
        return false;
      if (curve2.type === "short")
        return curve2.isIsomorphic(this);
      if (curve2.type === "mont") {
        const a = this.field(curve2.a);
        let apd, amd;
        if (invert) {
          apd = this.d.redAdd(this.a);
          amd = this.d.redSub(this.a);
        } else {
          apd = this.a.redAdd(this.d);
          amd = this.a.redSub(this.d);
        }
        return a.redMul(amd).eq(apd.redIMuln(2));
      }
      if (curve2.type === "edwards") {
        const a = this.field(curve2.a);
        const d = this.field(curve2.d);
        return this.a.redMul(d).eq(a.redMul(this.d));
      }
      return false;
    }
    isIsogenous(curve2) {
      assert(curve2 instanceof Curve);
      if (!curve2.p.eq(this.p))
        return false;
      if (curve2.type === "mont") {
        if (!this.a.eq(this.one))
          return false;
        const a = this.field(curve2.a);
        const b = this.field(curve2.b);
        const d24 = this.two.redSub(this.d.redMuln(4));
        return a.eq(d24) && b.eq(this.one);
      }
      if (curve2.type === "edwards") {
        const a = this.field(curve2.a);
        const d = this.field(curve2.d);
        return a.eq(this.a.redNeg()) && d.eq(this.d.redSub(this.a));
      }
      return false;
    }
    pointFromShort(point) {
      assert(point instanceof ShortPoint);
      if (this.isIsomorphic(point.curve)) {
        if (point.isInfinity())
          return this.point();
        if (point.y.isZero())
          return this.point(this.zero, this.one.redNeg());
        const {a, d} = this;
        const [u2, u3] = this._scale(point.curve);
        const a5 = a.redMuln(5);
        const d5 = d.redMuln(5);
        const x = this.field(point.x).redMul(u2);
        const y = this.field(point.y).redMul(u3);
        const x6 = x.redMuln(6);
        const x12 = x.redMuln(12);
        const xx = x6.redSub(a).redISub(d);
        const xz = y.redMuln(6);
        const yy = x12.redSub(a5).redIAdd(d);
        const yz = x12.redAdd(a).redISub(d5);
        return this.cpoint(xx, xz, yy, yz);
      }
      throw new Error("Not implemented.");
    }
    pointFromMont(point) {
      assert(point instanceof MontPoint);
      assert(point.curve.p.eq(this.p));
      const u = this.field(point.x);
      const v = this.field(point.y);
      if (this.isIsogenous(point.curve)) {
        if (point.isInfinity())
          return this.point();
        if (point.x.isZero())
          return this.point();
        const u2 = u.redSqr();
        const u3 = u2.redMul(u);
        const u4 = u3.redMul(u);
        const u5 = u4.redMul(u);
        const v2 = v.redSqr();
        const a = v.redMuln(4);
        const b = u2.redSub(this.one);
        const c = u2.redMuln(2);
        const d = v2.redMuln(4);
        const e = u3.redIMuln(2);
        const f = u.redMul(v2).redIMuln(4);
        const g = u2.redMul(v2).redIMuln(2);
        const h = v2.redIMuln(2);
        const xx = a.redMul(b);
        const xz = u4.redISub(c).redIAdd(d).redIAdd(this.one);
        const yy = u5.redSub(e).redISub(f).redIAdd(u).redINeg();
        const yz = u5.redISub(g).redISub(e).redISub(h).redIAdd(u);
        return this.cpoint(xx, xz, yy, yz).divn(4);
      }
      if (this.isIsomorphic(point.curve, true)) {
        if (point.isInfinity())
          return this.point();
        if (point.x.isZero())
          return this.point(this.zero, this.one.redNeg());
        const c = this._scale(point.curve, true);
        const xx = c.redMul(u);
        const xz = v;
        const yy = u.redAdd(this.one);
        const yz = u.redSub(this.one);
        return this.cpoint(xx, xz, yy, yz);
      }
      if (this.isIsomorphic(point.curve, false)) {
        if (point.isInfinity())
          return this.point();
        if (point.x.isZero())
          return this.point(this.zero, this.one.redNeg());
        const c = this._scale(point.curve, false);
        const xx = c.redMul(u);
        const xz = v;
        const yy = u.redSub(this.one);
        const yz = u.redAdd(this.one);
        return this.cpoint(xx, xz, yy, yz);
      }
      throw new Error("Not implemented.");
    }
    pointFromEdwards(point) {
      assert(point instanceof EdwardsPoint);
      assert(point.curve.p.eq(this.p));
      const a = this.field(point.curve.a);
      const x = this.field(point.x);
      const y = this.field(point.y);
      const z = this.field(point.z);
      const t = this.field(point.t);
      if (this.isIsogenous(point.curve)) {
        const xy = x.redMul(y);
        const x2 = x.redSqr();
        const y2 = y.redSqr();
        const z2 = z.redSqr();
        const ax2 = a.redMul(x2);
        const xx = xy.redIMuln(2);
        const xz = y2.redSub(ax2);
        const yy = y2.redAdd(ax2);
        const yz = z2.redIMuln(2).redISub(yy);
        const p = this.cpoint(xx, xz, yy, yz);
        return !this.twisted ? p.divn(4) : p;
      }
      if (this.isIsomorphic(point.curve)) {
        const c = this._scale(point.curve);
        const nx = c.redMul(x);
        const ny = y;
        const nz = z;
        const nt = c.redMul(t);
        return this.point(nx, ny, nz, nt);
      }
      throw new Error("Not implemented.");
    }
    pointFromUniform(u, curve2 = null) {
      assert(u instanceof BN);
      assert(u.red === this.red);
      assert(curve2 == null || curve2 instanceof MontCurve);
      if (!curve2)
        curve2 = this._alt();
      const u0 = curve2.field(u);
      const p0 = curve2.pointFromUniform(u0);
      return this.pointFromMont(p0);
    }
    pointToUniform(p, hint, curve2 = null) {
      assert(p instanceof EdwardsPoint);
      assert(hint >>> 0 === hint);
      assert(curve2 == null || curve2 instanceof MontCurve);
      if (!curve2)
        curve2 = this._alt();
      const i = (hint >> 4 & 15) % this.torsion.length;
      const q = p.add(this.torsion[i]);
      const p0 = curve2.pointFromEdwards(q);
      const u0 = curve2.pointToUniform(p0, hint & 15);
      return this.field(u0);
    }
    pointFromHash(bytes, pake, curve2 = null) {
      assert(curve2 == null || curve2 instanceof MontCurve);
      if (!curve2)
        curve2 = this._alt();
      const p0 = curve2.pointFromHash(bytes, pake);
      return this.pointFromMont(p0);
    }
    pointToHash(p, subgroup, rng, curve2 = null) {
      assert(p instanceof EdwardsPoint);
      assert(subgroup >>> 0 === subgroup);
      assert(curve2 == null || curve2 instanceof MontCurve);
      if (!curve2)
        curve2 = this._alt();
      const i = subgroup % this.torsion.length;
      const q = p.add(this.torsion[i]);
      const p0 = curve2.pointFromEdwards(q);
      return curve2.pointToHash(p0, 0, rng);
    }
    decodePoint(bytes) {
      return EdwardsPoint.decode(this, bytes);
    }
    toShort(a0, odd, sign = null) {
      const [a, b] = this._short(a0, odd);
      const curve2 = new ShortCurve({
        red: this.red,
        prime: this.prime,
        p: this.p,
        a,
        b,
        n: this.n,
        h: this.h
      });
      if (sign != null) {
        const [, u3] = curve2._scale(this);
        if (u3.redIsOdd() !== sign)
          u3.redINeg();
      }
      if (!this.g.isInfinity())
        curve2.g = curve2.pointFromEdwards(this.g);
      for (let i = 0; i < this.h.word(0); i++)
        curve2.torsion[i] = curve2.pointFromEdwards(this.torsion[i]);
      return curve2;
    }
    toMont(b0, invert, sign = null) {
      const [a, b] = this._mont(b0, invert);
      const curve2 = new MontCurve({
        red: this.red,
        prime: this.prime,
        p: this.p,
        a,
        b,
        n: this.n,
        h: this.h,
        z: this.z
      });
      if (sign != null) {
        const c = this._scale(curve2, invert);
        if (c.redIsOdd() !== sign)
          c.redINeg();
      }
      if (!this.g.isInfinity())
        curve2.g = curve2.pointFromEdwards(this.g);
      for (let i = 0; i < this.h.word(0); i++)
        curve2.torsion[i] = curve2.pointFromEdwards(this.torsion[i]);
      return curve2;
    }
    toEdwards(a0, sign = null) {
      const [a, d] = this._edwards(a0);
      const curve2 = new EdwardsCurve({
        red: this.red,
        prime: this.prime,
        p: this.p,
        a,
        d,
        n: this.n,
        h: this.h,
        z: this.z
      });
      if (sign != null) {
        const c = curve2._scale(this);
        if (c.redIsOdd() !== sign)
          c.redINeg();
      }
      if (!this.g.isInfinity()) {
        curve2.g = curve2.pointFromEdwards(this.g);
        curve2.g.normalize();
      }
      if (curve2.isComplete()) {
        for (let i = 0; i < this.h.word(0); i++) {
          curve2.torsion[i] = curve2.pointFromEdwards(this.torsion[i]);
          curve2.torsion[i].normalize();
        }
      }
      return curve2;
    }
    pointFromJSON(json) {
      return EdwardsPoint.fromJSON(this, json);
    }
    toJSON(pre) {
      const json = super.toJSON(pre);
      json.a = this.a.fromRed().toJSON();
      json.d = this.d.fromRed().toJSON();
      if (!this.s.isZero())
        json.s = this.s.fromRed().toJSON();
      return json;
    }
  };
  var EdwardsPoint = class extends Point {
    constructor(curve2, x, y, z, t) {
      assert(curve2 instanceof EdwardsCurve);
      super(curve2, types.EXTENDED);
      this.x = this.curve.zero;
      this.y = this.curve.one;
      this.z = this.curve.one;
      this.t = this.curve.zero;
      this.zOne = true;
      if (x != null)
        this._init(x, y, z, t);
    }
    _init(x, y, z, t) {
      assert(x instanceof BN);
      assert(y instanceof BN);
      assert(z == null || z instanceof BN);
      assert(t == null || t instanceof BN);
      this.x = x;
      this.y = y;
      this.z = z || this.curve.one;
      this.t = t || null;
      if (!this.x.red)
        this.x = this.x.toRed(this.curve.red);
      if (!this.y.red)
        this.y = this.y.toRed(this.curve.red);
      if (!this.z.red)
        this.z = this.z.toRed(this.curve.red);
      if (this.t && !this.t.red)
        this.t = this.t.toRed(this.curve.red);
      this.zOne = this.z.eq(this.curve.one);
      this._check();
      if (!this.t) {
        this.t = this.x.redMul(this.y);
        if (!this.zOne)
          this.t = this.t.redDiv(this.z);
      }
    }
    _check() {
      if (this.z.isZero())
        throw new Error("Invalid point.");
    }
    clone() {
      return this.curve.point(this.x, this.y, this.z, this.t);
    }
    normalize() {
      if (this.zOne)
        return this;
      const a = this.z.redInvert();
      this.x = this.x.redMul(a);
      this.y = this.y.redMul(a);
      this.t = this.t.redMul(a);
      this.z = this.curve.one;
      this.zOne = true;
      return this;
    }
    scale(a) {
      assert(a instanceof BN);
      const nx = this.x.redMul(a);
      const ny = this.y.redMul(a);
      const nz = this.z.redMul(a);
      const nt = this.t.redMul(a);
      return this.curve.point(nx, ny, nz, nt);
    }
    neg() {
      const nx = this.x.redNeg();
      const ny = this.y;
      const nz = this.z;
      const nt = this.t.redNeg();
      return this.curve.point(nx, ny, nz, nt);
    }
    add(p) {
      assert(p instanceof EdwardsPoint);
      if (this.isInfinity())
        return p;
      if (p.isInfinity())
        return this;
      if (this.zOne)
        return p._add(this);
      return this._add(p);
    }
    _add(p) {
      if (this.curve.mOneA)
        return this._addM1(p);
      return this._addA(p);
    }
    _addM1(p) {
      const a = this.y.redSub(this.x).redMul(p.y.redSub(p.x));
      const b = this.y.redAdd(this.x).redMul(p.y.redAdd(p.x));
      const c = this.t.redMul(this.curve.k).redMul(p.t);
      const d = p.zOne ? this.z.redAdd(this.z) : this.z.redMul(p.z).redIMuln(2);
      const e = b.redSub(a);
      const f = d.redSub(c);
      const g = d.redIAdd(c);
      const h = b.redIAdd(a);
      const nx = e.redMul(f);
      const ny = g.redMul(h);
      const nt = e.redMul(h);
      const nz = f.redMul(g);
      return this.curve.point(nx, ny, nz, nt);
    }
    _addA(p) {
      const a = this.x.redMul(p.x);
      const b = this.y.redMul(p.y);
      const c = this.curve._mulD(this.t).redMul(p.t);
      const d = p.zOne ? this.z.clone() : this.z.redMul(p.z);
      const xyxy = this.x.redAdd(this.y).redMul(p.x.redAdd(p.y));
      const e = xyxy.redISub(a).redISub(b);
      const f = d.redSub(c);
      const g = d.redIAdd(c);
      const h = b.redISub(this.curve._mulA(a));
      const nx = e.redMul(f);
      const ny = g.redMul(h);
      const nt = e.redMul(h);
      const nz = f.redMul(g);
      return this.curve.point(nx, ny, nz, nt);
    }
    dbl() {
      if (this.isInfinity())
        return this;
      return this._dbl();
    }
    _dbl() {
      const a = this.x.redSqr();
      const b = this.y.redSqr();
      const c = this.zOne ? this.curve.two : this.z.redSqr().redIMuln(2);
      const d = this.curve._mulA(a);
      const e = this.x.redAdd(this.y).redSqr().redISub(a).redISub(b);
      const g = d.redAdd(b);
      const f = g.redSub(c);
      const h = d.redISub(b);
      const nx = e.redMul(f);
      const ny = g.redMul(h);
      const nt = e.redMul(h);
      const nz = f.redMul(g);
      return this.curve.point(nx, ny, nz, nt);
    }
    getX() {
      this.normalize();
      return this.x.fromRed();
    }
    getY() {
      this.normalize();
      return this.y.fromRed();
    }
    eq(p) {
      assert(p instanceof EdwardsPoint);
      assert(!this.z.isZero());
      assert(!p.z.isZero());
      if (this === p)
        return true;
      if (this.z.eq(p.z)) {
        return this.x.eq(p.x) && this.y.eq(p.y);
      }
      const x1 = this.x.redMul(p.z);
      const x2 = p.x.redMul(this.z);
      if (!x1.eq(x2))
        return false;
      const y1 = this.y.redMul(p.z);
      const y2 = p.y.redMul(this.z);
      return y1.eq(y2);
    }
    cmp(point) {
      assert(point instanceof EdwardsPoint);
      return this.order().cmp(point.order()) || this.getY().cmp(point.getY()) || this.getX().cmp(point.getX());
    }
    isInfinity() {
      assert(!this.z.isZero());
      if (!this.x.isZero())
        return false;
      return this.y.eq(this.z);
    }
    isOrder2() {
      if (this.isInfinity())
        return false;
      return this.x.isZero();
    }
    isOdd() {
      this.normalize();
      return this.x.redIsOdd();
    }
    isEven() {
      this.normalize();
      return this.x.redIsEven();
    }
    toP() {
      return this.normalize();
    }
    toJ() {
      return this;
    }
    encode() {
      const y = this.getY();
      y.setn(this.curve.signBit, this.x.redIsOdd());
      return this.curve.encodeAdjusted(y);
    }
    static decode(curve2, bytes) {
      assert(curve2 instanceof EdwardsCurve);
      const y = curve2.decodeAdjusted(bytes);
      const sign = y.testn(curve2.signBit) !== 0;
      y.setn(curve2.signBit, 0);
      if (y.cmp(curve2.p) >= 0)
        throw new Error("Invalid point.");
      return curve2.pointFromY(y, sign);
    }
    toJSON(pre) {
      if (this.isInfinity())
        return [];
      const x = this.getX().toJSON();
      const y = this.getY().toJSON();
      if (pre === true && this.pre)
        return [x, y, this.pre.toJSON()];
      return [x, y];
    }
    toPretty() {
      const size = this.curve.fieldSize * 2;
      const x = toPretty(this.getX(), size);
      const y = toPretty(this.getY(), size);
      return [x, y];
    }
    static fromJSON(curve2, json) {
      assert(curve2 instanceof EdwardsCurve);
      assert(Array.isArray(json));
      assert(json.length === 0 || json.length === 2 || json.length === 3);
      if (json.length === 0)
        return curve2.point();
      const x = BN.fromJSON(json[0]);
      const y = BN.fromJSON(json[1]);
      const point = curve2.point(x, y);
      if (json.length > 2 && json[2] != null)
        point.pre = Precomp.fromJSON(point, json[2]);
      return point;
    }
    [custom]() {
      if (this.isInfinity())
        return "<EdwardsPoint: Infinity>";
      return "<EdwardsPoint: x=" + this.x.fromRed().toString(16, 2) + " y=" + this.y.fromRed().toString(16, 2) + " z=" + this.z.fromRed().toString(16, 2) + ">";
    }
  };
  var Precomp = class {
    constructor() {
      this.naf = null;
      this.windows = null;
      this.doubles = null;
      this.blinding = null;
      this.beta = null;
    }
    map(func) {
      assert(typeof func === "function");
      const out = new this.constructor();
      if (this.naf)
        out.naf = this.naf.map(func);
      if (this.doubles)
        out.doubles = this.doubles.map(func);
      return out;
    }
    toJSON() {
      return {
        naf: this.naf ? this.naf.toJSON() : null,
        windows: this.windows ? this.windows.toJSON() : null,
        doubles: this.doubles ? this.doubles.toJSON() : null,
        blinding: this.blinding ? this.blinding.toJSON() : void 0
      };
    }
    fromJSON(point, json) {
      assert(point instanceof Point);
      assert(json && typeof json === "object");
      if (json.naf != null)
        this.naf = NAF.fromJSON(point, json.naf);
      if (json.windows != null)
        this.windows = Windows.fromJSON(point, json.windows);
      if (json.doubles != null)
        this.doubles = Doubles.fromJSON(point, json.doubles);
      if (json.blinding != null)
        this.blinding = Blinding.fromJSON(point, json.blinding);
      return this;
    }
    static fromJSON(point, json) {
      return new this().fromJSON(point, json);
    }
  };
  var NAF = class {
    constructor(width, points) {
      this.width = width;
      this.points = points;
    }
    map(func) {
      assert(typeof func === "function");
      const {width} = this;
      const points = [];
      for (const point of this.points)
        points.push(func(point));
      return new this.constructor(width, points);
    }
    toJSON() {
      return {
        width: this.width,
        points: this.points.slice(1).map((point) => {
          return point.toJSON();
        })
      };
    }
    static fromJSON(point, json) {
      assert(point instanceof Point);
      assert(json && typeof json === "object");
      assert(json.width >>> 0 === json.width);
      assert(Array.isArray(json.points));
      const {curve: curve2} = point;
      const {width} = json;
      const points = [point];
      for (const item of json.points)
        points.push(curve2.pointFromJSON(item));
      return new this(width, points);
    }
  };
  var Windows = class {
    constructor(width, bits, points) {
      this.width = width;
      this.bits = bits;
      this.points = points;
    }
    toJSON() {
      return {
        width: this.width,
        bits: this.bits,
        points: this.points.slice(1).map((point) => {
          return point.toJSON();
        })
      };
    }
    static fromJSON(point, json) {
      assert(point instanceof Point);
      assert(json && typeof json === "object");
      assert(json.width >>> 0 === json.width);
      assert(json.bits >>> 0 === json.bits);
      assert(Array.isArray(json.points));
      const {curve: curve2} = point;
      const {width, bits} = json;
      const points = [point];
      for (const item of json.points)
        points.push(curve2.pointFromJSON(item));
      return new this(width, bits, points);
    }
  };
  var Doubles = class {
    constructor(step, points) {
      this.step = step;
      this.points = points;
    }
    map(func) {
      assert(typeof func === "function");
      const {step} = this;
      const points = [];
      for (const point of this.points)
        points.push(func(point));
      return new this.constructor(step, points);
    }
    toJSON() {
      return {
        step: this.step,
        points: this.points.slice(1).map((point) => {
          return point.toJSON();
        })
      };
    }
    static fromJSON(point, json) {
      assert(point instanceof Point);
      assert(json && typeof json === "object");
      assert(json.step >>> 0 === json.step);
      assert(Array.isArray(json.points));
      const {curve: curve2} = point;
      const {step} = json;
      const points = [point];
      for (const item of json.points)
        points.push(curve2.pointFromJSON(item));
      return new this(step, points);
    }
  };
  var Blinding = class {
    constructor(blind, unblind) {
      this.blind = blind;
      this.unblind = unblind;
    }
    toJSON() {
      return {
        blind: this.blind.toJSON(),
        unblind: this.unblind.toJSON()
      };
    }
    static fromJSON(point, json) {
      assert(point instanceof Point);
      assert(json && typeof json === "object");
      const {curve: curve2} = point;
      const blind = BN.fromJSON(json.blind);
      const unblind = curve2.pointFromJSON(json.unblind);
      return new this(blind, unblind);
    }
  };
  var Endo = class {
    constructor(beta, lambda, basis, pre) {
      this.beta = beta;
      this.lambda = lambda;
      this.basis = basis;
      this.pre = pre;
    }
    toJSON() {
      return {
        beta: this.beta.fromRed().toJSON(),
        lambda: this.lambda.toJSON(),
        basis: [
          this.basis[0].toJSON(),
          this.basis[1].toJSON()
        ],
        pre: [
          this.pre[0],
          this.pre[1].toJSON(),
          this.pre[2].toJSON()
        ]
      };
    }
    static fromJSON(curve2, json) {
      assert(curve2 instanceof Curve);
      assert(json && typeof json === "object");
      assert(Array.isArray(json.basis));
      assert(Array.isArray(json.pre));
      assert(json.basis.length === 2);
      assert(json.pre.length === 3);
      assert(json.pre[0] >>> 0 === json.pre[0]);
      const beta = BN.fromJSON(json.beta).toRed(curve2.red);
      const lambda = BN.fromJSON(json.lambda);
      const basis = [
        Vector.fromJSON(json.basis[0]),
        Vector.fromJSON(json.basis[1])
      ];
      const pre = [
        json.pre[0],
        BN.fromJSON(json.pre[1]),
        BN.fromJSON(json.pre[2])
      ];
      return new this(beta, lambda, basis, pre);
    }
  };
  var Vector = class {
    constructor(a, b) {
      this.a = a;
      this.b = b;
    }
    toJSON() {
      return {
        a: this.a.toJSON(),
        b: this.b.toJSON()
      };
    }
    static fromJSON(json) {
      assert(json && typeof json === "object");
      const a = BN.fromJSON(json.a);
      const b = BN.fromJSON(json.b);
      return new this(a, b);
    }
  };
  var P192 = class extends ShortCurve {
    constructor(pre) {
      super({
        id: "P192",
        ossl: "prime192v1",
        type: "short",
        endian: "be",
        hash: "SHA256",
        prime: "p192",
        p: [
          "ffffffff ffffffff ffffffff fffffffe",
          "ffffffff ffffffff"
        ],
        a: [
          "ffffffff ffffffff ffffffff fffffffe",
          "ffffffff fffffffc"
        ],
        b: [
          "64210519 e59c80e7 0fa7e9ab 72243049",
          "feb8deec c146b9b1"
        ],
        n: [
          "ffffffff ffffffff ffffffff 99def836",
          "146bc9b1 b4d22831"
        ],
        h: "1",
        z: "-5",
        g: [
          [
            "188da80e b03090f6 7cbf20eb 43a18800",
            "f4ff0afd 82ff1012"
          ],
          [
            "07192b95 ffc8da78 631011ed 6b24cdd5",
            "73f977a1 1e794811"
          ],
          pre
        ]
      });
    }
  };
  var P224 = class extends ShortCurve {
    constructor(pre) {
      super({
        id: "P224",
        ossl: "secp224r1",
        type: "short",
        endian: "be",
        hash: "SHA256",
        prime: "p224",
        p: [
          "ffffffff ffffffff ffffffff ffffffff",
          "00000000 00000000 00000001"
        ],
        a: [
          "ffffffff ffffffff ffffffff fffffffe",
          "ffffffff ffffffff fffffffe"
        ],
        b: [
          "b4050a85 0c04b3ab f5413256 5044b0b7",
          "d7bfd8ba 270b3943 2355ffb4"
        ],
        n: [
          "ffffffff ffffffff ffffffff ffff16a2",
          "e0b8f03e 13dd2945 5c5c2a3d"
        ],
        h: "1",
        z: "1f",
        g: [
          [
            "b70e0cbd 6bb4bf7f 321390b9 4a03c1d3",
            "56c21122 343280d6 115c1d21"
          ],
          [
            "bd376388 b5f723fb 4c22dfe6 cd4375a0",
            "5a074764 44d58199 85007e34"
          ],
          pre
        ]
      });
    }
  };
  var P256 = class extends ShortCurve {
    constructor(pre) {
      super({
        id: "P256",
        ossl: "prime256v1",
        type: "short",
        endian: "be",
        hash: "SHA256",
        prime: null,
        p: [
          "ffffffff 00000001 00000000 00000000",
          "00000000 ffffffff ffffffff ffffffff"
        ],
        a: [
          "ffffffff 00000001 00000000 00000000",
          "00000000 ffffffff ffffffff fffffffc"
        ],
        b: [
          "5ac635d8 aa3a93e7 b3ebbd55 769886bc",
          "651d06b0 cc53b0f6 3bce3c3e 27d2604b"
        ],
        n: [
          "ffffffff 00000000 ffffffff ffffffff",
          "bce6faad a7179e84 f3b9cac2 fc632551"
        ],
        h: "1",
        z: "-a",
        g: [
          [
            "6b17d1f2 e12c4247 f8bce6e5 63a440f2",
            "77037d81 2deb33a0 f4a13945 d898c296"
          ],
          [
            "4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16",
            "2bce3357 6b315ece cbb64068 37bf51f5"
          ],
          pre
        ]
      });
    }
  };
  var P384 = class extends ShortCurve {
    constructor(pre) {
      super({
        id: "P384",
        ossl: "secp384r1",
        type: "short",
        endian: "be",
        hash: "SHA384",
        prime: null,
        p: [
          "ffffffff ffffffff ffffffff ffffffff",
          "ffffffff ffffffff ffffffff fffffffe",
          "ffffffff 00000000 00000000 ffffffff"
        ],
        a: [
          "ffffffff ffffffff ffffffff ffffffff",
          "ffffffff ffffffff ffffffff fffffffe",
          "ffffffff 00000000 00000000 fffffffc"
        ],
        b: [
          "b3312fa7 e23ee7e4 988e056b e3f82d19",
          "181d9c6e fe814112 0314088f 5013875a",
          "c656398d 8a2ed19d 2a85c8ed d3ec2aef"
        ],
        n: [
          "ffffffff ffffffff ffffffff ffffffff",
          "ffffffff ffffffff c7634d81 f4372ddf",
          "581a0db2 48b0a77a ecec196a ccc52973"
        ],
        h: "1",
        z: "-c",
        g: [
          [
            "aa87ca22 be8b0537 8eb1c71e f320ad74",
            "6e1d3b62 8ba79b98 59f741e0 82542a38",
            "5502f25d bf55296c 3a545e38 72760ab7"
          ],
          [
            "3617de4a 96262c6f 5d9e98bf 9292dc29",
            "f8f41dbd 289a147c e9da3113 b5f0b8c0",
            "0a60b1ce 1d7e819d 7a431d7c 90ea0e5f"
          ],
          pre
        ]
      });
    }
  };
  var P521 = class extends ShortCurve {
    constructor(pre) {
      super({
        id: "P521",
        ossl: "secp521r1",
        type: "short",
        endian: "be",
        hash: "SHA512",
        prime: "p521",
        p: [
          "000001ff ffffffff ffffffff ffffffff",
          "ffffffff ffffffff ffffffff ffffffff",
          "ffffffff ffffffff ffffffff ffffffff",
          "ffffffff ffffffff ffffffff ffffffff",
          "ffffffff"
        ],
        a: [
          "000001ff ffffffff ffffffff ffffffff",
          "ffffffff ffffffff ffffffff ffffffff",
          "ffffffff ffffffff ffffffff ffffffff",
          "ffffffff ffffffff ffffffff ffffffff",
          "fffffffc"
        ],
        b: [
          "00000051 953eb961 8e1c9a1f 929a21a0",
          "b68540ee a2da725b 99b315f3 b8b48991",
          "8ef109e1 56193951 ec7e937b 1652c0bd",
          "3bb1bf07 3573df88 3d2c34f1 ef451fd4",
          "6b503f00"
        ],
        n: [
          "000001ff ffffffff ffffffff ffffffff",
          "ffffffff ffffffff ffffffff ffffffff",
          "fffffffa 51868783 bf2f966b 7fcc0148",
          "f709a5d0 3bb5c9b8 899c47ae bb6fb71e",
          "91386409"
        ],
        h: "1",
        z: "-4",
        g: [
          [
            "000000c6 858e06b7 0404e9cd 9e3ecb66",
            "2395b442 9c648139 053fb521 f828af60",
            "6b4d3dba a14b5e77 efe75928 fe1dc127",
            "a2ffa8de 3348b3c1 856a429b f97e7e31",
            "c2e5bd66"
          ],
          [
            "00000118 39296a78 9a3bc004 5c8a5fb4",
            "2c7d1bd9 98f54449 579b4468 17afbd17",
            "273e662c 97ee7299 5ef42640 c550b901",
            "3fad0761 353c7086 a272c240 88be9476",
            "9fd16650"
          ],
          pre
        ]
      });
    }
  };
  var SECP256K1 = class extends ShortCurve {
    constructor(pre) {
      super({
        id: "SECP256K1",
        ossl: "secp256k1",
        type: "short",
        endian: "be",
        hash: "SHA256",
        prime: "k256",
        p: [
          "ffffffff ffffffff ffffffff ffffffff",
          "ffffffff ffffffff fffffffe fffffc2f"
        ],
        a: "0",
        b: "7",
        n: [
          "ffffffff ffffffff ffffffff fffffffe",
          "baaedce6 af48a03b bfd25e8c d0364141"
        ],
        h: "1",
        z: "1",
        c: [
          "0a2d2ba9 3507f1df 233770c2 a797962c",
          "c61f6d15 da14ecd4 7d8d27ae 1cd5f852"
        ],
        g: [
          [
            "79be667e f9dcbbac 55a06295 ce870b07",
            "029bfcdb 2dce28d9 59f2815b 16f81798"
          ],
          [
            "483ada77 26a3c465 5da4fbfc 0e1108a8",
            "fd17b448 a6855419 9c47d08f fb10d4b8"
          ],
          pre
        ],
        endo: {
          beta: [
            "7ae96a2b 657c0710 6e64479e ac3434e9",
            "9cf04975 12f58995 c1396c28 719501ee"
          ],
          lambda: [
            "5363ad4c c05c30e0 a5261c02 8812645a",
            "122e22ea 20816678 df02967c 1b23bd72"
          ],
          basis: [
            {
              a: "3086d221a7d46bcde86c90e49284eb15",
              b: "-e4437ed6010e88286f547fa90abfe4c3"
            },
            {
              a: "114ca50f7a8e2f3f657c1108d9d44cfd8",
              b: "3086d221a7d46bcde86c90e49284eb15"
            }
          ],
          pre: [
            384,
            [
              "3086d221 a7d46bcd e86c90e4 9284eb15",
              "3daa8a14 71e8ca7f e893209a 45dbb031"
            ],
            [
              "-",
              "e4437ed6 010e8828 6f547fa9 0abfe4c4",
              "221208ac 9df506c6 1571b4ae 8ac47f71"
            ]
          ]
        }
      });
    }
  };
  var BRAINPOOLP256 = class extends ShortCurve {
    constructor(pre) {
      super({
        id: "BRAINPOOLP256",
        ossl: "brainpoolP256r1",
        type: "short",
        endian: "be",
        hash: "SHA256",
        prime: null,
        p: [
          "a9fb57db a1eea9bc 3e660a90 9d838d72",
          "6e3bf623 d5262028 2013481d 1f6e5377"
        ],
        a: [
          "7d5a0975 fc2c3057 eef67530 417affe7",
          "fb8055c1 26dc5c6c e94a4b44 f330b5d9"
        ],
        b: [
          "26dc5c6c e94a4b44 f330b5d9 bbd77cbf",
          "95841629 5cf7e1ce 6bccdc18 ff8c07b6"
        ],
        n: [
          "a9fb57db a1eea9bc 3e660a90 9d838d71",
          "8c397aa3 b561a6f7 901e0e82 974856a7"
        ],
        h: "1",
        z: "-2",
        g: [
          [
            "8bd2aeb9 cb7e57cb 2c4b482f fc81b7af",
            "b9de27e1 e3bd23c2 3a4453bd 9ace3262"
          ],
          [
            "547ef835 c3dac4fd 97f8461a 14611dc9",
            "c2774513 2ded8e54 5c1d54c7 2f046997"
          ],
          pre
        ]
      });
    }
  };
  var BRAINPOOLP384 = class extends ShortCurve {
    constructor(pre) {
      super({
        id: "BRAINPOOLP384",
        ossl: "brainpoolP384r1",
        type: "short",
        endian: "be",
        hash: "SHA384",
        prime: null,
        p: [
          "8cb91e82 a3386d28 0f5d6f7e 50e641df",
          "152f7109 ed5456b4 12b1da19 7fb71123",
          "acd3a729 901d1a71 87470013 3107ec53"
        ],
        a: [
          "7bc382c6 3d8c150c 3c72080a ce05afa0",
          "c2bea28e 4fb22787 139165ef ba91f90f",
          "8aa5814a 503ad4eb 04a8c7dd 22ce2826"
        ],
        b: [
          "04a8c7dd 22ce2826 8b39b554 16f0447c",
          "2fb77de1 07dcd2a6 2e880ea5 3eeb62d5",
          "7cb43902 95dbc994 3ab78696 fa504c11"
        ],
        n: [
          "8cb91e82 a3386d28 0f5d6f7e 50e641df",
          "152f7109 ed5456b3 1f166e6c ac0425a7",
          "cf3ab6af 6b7fc310 3b883202 e9046565"
        ],
        h: "1",
        z: "-5",
        g: [
          [
            "1d1c64f0 68cf45ff a2a63a81 b7c13f6b",
            "8847a3e7 7ef14fe3 db7fcafe 0cbd10e8",
            "e826e034 36d646aa ef87b2e2 47d4af1e"
          ],
          [
            "8abe1d75 20f9c2a4 5cb1eb8e 95cfd552",
            "62b70b29 feec5864 e19c054f f9912928",
            "0e464621 77918111 42820341 263c5315"
          ],
          pre
        ]
      });
    }
  };
  var BRAINPOOLP512 = class extends ShortCurve {
    constructor(pre) {
      super({
        id: "BRAINPOOLP512",
        ossl: "brainpoolP512r1",
        type: "short",
        endian: "be",
        hash: "SHA512",
        prime: null,
        p: [
          "aadd9db8 dbe9c48b 3fd4e6ae 33c9fc07",
          "cb308db3 b3c9d20e d6639cca 70330871",
          "7d4d9b00 9bc66842 aecda12a e6a380e6",
          "2881ff2f 2d82c685 28aa6056 583a48f3"
        ],
        a: [
          "7830a331 8b603b89 e2327145 ac234cc5",
          "94cbdd8d 3df91610 a83441ca ea9863bc",
          "2ded5d5a a8253aa1 0a2ef1c9 8b9ac8b5",
          "7f1117a7 2bf2c7b9 e7c1ac4d 77fc94ca"
        ],
        b: [
          "3df91610 a83441ca ea9863bc 2ded5d5a",
          "a8253aa1 0a2ef1c9 8b9ac8b5 7f1117a7",
          "2bf2c7b9 e7c1ac4d 77fc94ca dc083e67",
          "984050b7 5ebae5dd 2809bd63 8016f723"
        ],
        n: [
          "aadd9db8 dbe9c48b 3fd4e6ae 33c9fc07",
          "cb308db3 b3c9d20e d6639cca 70330870",
          "553e5c41 4ca92619 41866119 7fac1047",
          "1db1d381 085ddadd b5879682 9ca90069"
        ],
        h: "1",
        z: "7",
        g: [
          [
            "81aee4bd d82ed964 5a21322e 9c4c6a93",
            "85ed9f70 b5d916c1 b43b62ee f4d0098e",
            "ff3b1f78 e2d0d48d 50d1687b 93b97d5f",
            "7c6d5047 406a5e68 8b352209 bcb9f822"
          ],
          [
            "7dde385d 566332ec c0eabfa9 cf7822fd",
            "f209f700 24a57b1a a000c55b 881f8111",
            "b2dcde49 4a5f485e 5bca4bd8 8a2763ae",
            "d1ca2b2f a8f05406 78cd1e0f 3ad80892"
          ],
          pre
        ]
      });
    }
  };
  var X25519 = class extends MontCurve {
    constructor() {
      super({
        id: "X25519",
        ossl: "X25519",
        type: "mont",
        endian: "le",
        hash: "SHA512",
        prime: "p25519",
        p: [
          "7fffffff ffffffff ffffffff ffffffff",
          "ffffffff ffffffff ffffffff ffffffed"
        ],
        a: "76d06",
        b: "1",
        n: [
          "10000000 00000000 00000000 00000000",
          "14def9de a2f79cd6 5812631a 5cf5d3ed"
        ],
        h: "8",
        z: "2",
        g: [
          [
            "00000000 00000000 00000000 00000000",
            "00000000 00000000 00000000 00000009"
          ],
          [
            "5f51e65e 475f794b 1fe122d3 88b72eb3",
            "6dc2b281 92839e4d d6163a5d 81312c14"
          ]
        ],
        torsion: [
          [],
          [
            [
              "00000000 00000000 00000000 00000000",
              "00000000 00000000 00000000 00000000"
            ],
            [
              "00000000 00000000 00000000 00000000",
              "00000000 00000000 00000000 00000000"
            ]
          ],
          [
            [
              "00000000 00000000 00000000 00000000",
              "00000000 00000000 00000000 00000001"
            ],
            [
              "6be4f497 f9a9c2af c21fa77a d7f4a6ef",
              "635a11c7 284a9363 e9a248ef 9c884415"
            ]
          ],
          [
            [
              "00000000 00000000 00000000 00000000",
              "00000000 00000000 00000000 00000001"
            ],
            [
              "141b0b68 06563d50 3de05885 280b5910",
              "9ca5ee38 d7b56c9c 165db710 6377bbd8"
            ]
          ],
          [
            [
              "57119fd0 dd4e22d8 868e1c58 c45c4404",
              "5bef839c 55b1d0b1 248c50a3 bc959c5f"
            ],
            [
              "68c59389 3d458e64 31c6ca00 45fb5015",
              "20a44346 8eaa68dd 0f103842 048065b7"
            ]
          ],
          [
            [
              "57119fd0 dd4e22d8 868e1c58 c45c4404",
              "5bef839c 55b1d0b1 248c50a3 bc959c5f"
            ],
            [
              "173a6c76 c2ba719b ce3935ff ba04afea",
              "df5bbcb9 71559722 f0efc7bd fb7f9a36"
            ]
          ],
          [
            [
              "00b8495f 16056286 fdb1329c eb8d09da",
              "6ac49ff1 fae35616 aeb8413b 7c7aebe0"
            ],
            [
              "3931c129 569e83a5 29482c14 e628b457",
              "933bfc29 ed801b4d 68871483 92507b1a"
            ]
          ],
          [
            [
              "00b8495f 16056286 fdb1329c eb8d09da",
              "6ac49ff1 fae35616 aeb8413b 7c7aebe0"
            ],
            [
              "46ce3ed6 a9617c5a d6b7d3eb 19d74ba8",
              "6cc403d6 127fe4b2 9778eb7c 6daf84d3"
            ]
          ]
        ]
      });
    }
  };
  var X448 = class extends MontCurve {
    constructor() {
      super({
        id: "X448",
        ossl: "X448",
        type: "mont",
        endian: "le",
        hash: "SHAKE256",
        prime: "p448",
        p: [
          "ffffffff ffffffff ffffffff ffffffff",
          "ffffffff ffffffff fffffffe ffffffff",
          "ffffffff ffffffff ffffffff ffffffff",
          "ffffffff ffffffff"
        ],
        a: "262a6",
        b: "1",
        n: [
          "3fffffff ffffffff ffffffff ffffffff",
          "ffffffff ffffffff ffffffff 7cca23e9",
          "c44edb49 aed63690 216cc272 8dc58f55",
          "2378c292 ab5844f3"
        ],
        h: "4",
        z: "-1",
        g: [
          [
            "00000000 00000000 00000000 00000000",
            "00000000 00000000 00000000 00000000",
            "00000000 00000000 00000000 00000000",
            "00000000 00000005"
          ],
          [
            "7d235d12 95f5b1f6 6c98ab6e 58326fce",
            "cbae5d34 f55545d0 60f75dc2 8df3f6ed",
            "b8027e23 46430d21 1312c4b1 50677af7",
            "6fd7223d 457b5b1a"
          ]
        ],
        torsion: [
          [],
          [
            [
              "00000000 00000000 00000000 00000000",
              "00000000 00000000 00000000 00000000",
              "00000000 00000000 00000000 00000000",
              "00000000 00000000"
            ],
            [
              "00000000 00000000 00000000 00000000",
              "00000000 00000000 00000000 00000000",
              "00000000 00000000 00000000 00000000",
              "00000000 00000000"
            ]
          ],
          [
            [
              "ffffffff ffffffff ffffffff ffffffff",
              "ffffffff ffffffff fffffffe ffffffff",
              "ffffffff ffffffff ffffffff ffffffff",
              "ffffffff fffffffe"
            ],
            [
              "ba4d3a08 29b6112f 8812e51b a0bb2abe",
              "bc1cb08e b48e5569 36ba50fd d2e7d68a",
              "f8cb3216 0522425b 3f990812 abbe635a",
              "d37a21e1 7551b193"
            ]
          ],
          [
            [
              "ffffffff ffffffff ffffffff ffffffff",
              "ffffffff ffffffff fffffffe ffffffff",
              "ffffffff ffffffff ffffffff ffffffff",
              "ffffffff fffffffe"
            ],
            [
              "45b2c5f7 d649eed0 77ed1ae4 5f44d541",
              "43e34f71 4b71aa96 c945af01 2d182975",
              "0734cde9 faddbda4 c066f7ed 54419ca5",
              "2c85de1e 8aae4e6c"
            ]
          ]
        ]
      });
    }
  };
  var MONT448 = class extends MontCurve {
    constructor() {
      super({
        id: "MONT448",
        ossl: null,
        type: "mont",
        endian: "le",
        hash: "SHAKE256",
        prime: "p448",
        p: [
          "ffffffff ffffffff ffffffff ffffffff",
          "ffffffff ffffffff fffffffe ffffffff",
          "ffffffff ffffffff ffffffff ffffffff",
          "ffffffff ffffffff"
        ],
        a: [
          "b2cf97d2 d43459a9 31ed36b1 fc4e3cb5",
          "5d93f8d2 22746997 60ccffc6 49961ed6",
          "c5b05fca c24864ed 6fb59697 931b78da",
          "84ddecd8 ca2b5cfb"
        ],
        b: "1",
        n: [
          "3fffffff ffffffff ffffffff ffffffff",
          "ffffffff ffffffff ffffffff 7cca23e9",
          "c44edb49 aed63690 216cc272 8dc58f55",
          "2378c292 ab5844f3"
        ],
        h: "4",
        z: "-1",
        g: [
          [
            "ac0d24cc c6c75cb0 eb71f81e 7a6edf51",
            "48e88aee 009a2a24 e795687e c28e125a",
            "3e6730a6 0d46367b aa7fe99d 152128dc",
            "41321bc7 7817f059"
          ],
          [
            "5a4437f6 80c0d0db 9b061276 d5d0ffcc",
            "e786ff33 b6a53d30 98746425 82e66f09",
            "4433dae7 7244a6e2 6b11e905 7228f483",
            "556c41a5 913f55fe"
          ]
        ],
        torsion: [
          [],
          [
            [
              "00000000 00000000 00000000 00000000",
              "00000000 00000000 00000000 00000000",
              "00000000 00000000 00000000 00000000",
              "00000000 00000000"
            ],
            [
              "00000000 00000000 00000000 00000000",
              "00000000 00000000 00000000 00000000",
              "00000000 00000000 00000000 00000000",
              "00000000 00000000"
            ]
          ],
          [
            [
              "ffffffff ffffffff ffffffff ffffffff",
              "ffffffff ffffffff fffffffe ffffffff",
              "ffffffff ffffffff ffffffff ffffffff",
              "ffffffff fffffffe"
            ],
            [
              "bec92fd0 6da2acf2 b4e261e8 7cef0d34",
              "22e75c18 3c589857 b71924e5 73c2f9ce",
              "e18da5f2 466e2f39 3c2eedf0 f105a60a",
              "b40c717d 4f1e1fd7"
            ]
          ],
          [
            [
              "ffffffff ffffffff ffffffff ffffffff",
              "ffffffff ffffffff fffffffe ffffffff",
              "ffffffff ffffffff ffffffff ffffffff",
              "ffffffff fffffffe"
            ],
            [
              "4136d02f 925d530d 4b1d9e17 8310f2cb",
              "dd18a3e7 c3a767a8 48e6db19 8c3d0631",
              "1e725a0d b991d0c6 c3d1120f 0efa59f5",
              "4bf38e82 b0e1e028"
            ]
          ]
        ]
      });
    }
  };
  var ED25519 = class extends EdwardsCurve {
    constructor(pre) {
      super({
        id: "ED25519",
        ossl: "ED25519",
        type: "edwards",
        endian: "le",
        hash: "SHA512",
        prefix: "SigEd25519 no Ed25519 collisions",
        context: false,
        prime: "p25519",
        p: [
          "7fffffff ffffffff ffffffff ffffffff",
          "ffffffff ffffffff ffffffff ffffffed"
        ],
        a: "-1",
        d: [
          "52036cee 2b6ffe73 8cc74079 7779e898",
          "00700a4d 4141d8ab 75eb4dca 135978a3"
        ],
        n: [
          "10000000 00000000 00000000 00000000",
          "14def9de a2f79cd6 5812631a 5cf5d3ed"
        ],
        h: "8",
        z: "2",
        g: [
          [
            "216936d3 cd6e53fe c0a4e231 fdd6dc5c",
            "692cc760 9525a7b2 c9562d60 8f25d51a"
          ],
          [
            "66666666 66666666 66666666 66666666",
            "66666666 66666666 66666666 66666658"
          ],
          pre
        ],
        torsion: [
          [
            [
              "00000000 00000000 00000000 00000000",
              "00000000 00000000 00000000 00000000"
            ],
            [
              "00000000 00000000 00000000 00000000",
              "00000000 00000000 00000000 00000001"
            ]
          ],
          [
            [
              "00000000 00000000 00000000 00000000",
              "00000000 00000000 00000000 00000000"
            ],
            [
              "7fffffff ffffffff ffffffff ffffffff",
              "ffffffff ffffffff ffffffff ffffffec"
            ]
          ],
          [
            [
              "2b832480 4fc1df0b 2b4d0099 3dfbd7a7",
              "2f431806 ad2fe478 c4ee1b27 4a0ea0b0"
            ],
            [
              "00000000 00000000 00000000 00000000",
              "00000000 00000000 00000000 00000000"
            ]
          ],
          [
            [
              "547cdb7f b03e20f4 d4b2ff66 c2042858",
              "d0bce7f9 52d01b87 3b11e4d8 b5f15f3d"
            ],
            [
              "00000000 00000000 00000000 00000000",
              "00000000 00000000 00000000 00000000"
            ]
          ],
          [
            [
              "1fd5b9a0 06394a28 e9339932 38de4abb",
              "5c193c70 13e5e238 dea14646 c545d14a"
            ],
            [
              "05fc536d 880238b1 3933c6d3 05acdfd5",
              "f098eff2 89f4c345 b027b2c2 8f95e826"
            ]
          ],
          [
            [
              "602a465f f9c6b5d7 16cc66cd c721b544",
              "a3e6c38f ec1a1dc7 215eb9b9 3aba2ea3"
            ],
            [
              "05fc536d 880238b1 3933c6d3 05acdfd5",
              "f098eff2 89f4c345 b027b2c2 8f95e826"
            ]
          ],
          [
            [
              "1fd5b9a0 06394a28 e9339932 38de4abb",
              "5c193c70 13e5e238 dea14646 c545d14a"
            ],
            [
              "7a03ac92 77fdc74e c6cc392c fa53202a",
              "0f67100d 760b3cba 4fd84d3d 706a17c7"
            ]
          ],
          [
            [
              "602a465f f9c6b5d7 16cc66cd c721b544",
              "a3e6c38f ec1a1dc7 215eb9b9 3aba2ea3"
            ],
            [
              "7a03ac92 77fdc74e c6cc392c fa53202a",
              "0f67100d 760b3cba 4fd84d3d 706a17c7"
            ]
          ]
        ]
      });
    }
  };
  var ISO448 = class extends EdwardsCurve {
    constructor(pre) {
      super({
        id: "ISO448",
        ossl: null,
        type: "edwards",
        endian: "le",
        hash: "SHAKE256",
        prefix: "SigEd448",
        context: true,
        prime: "p448",
        p: [
          "ffffffff ffffffff ffffffff ffffffff",
          "ffffffff ffffffff fffffffe ffffffff",
          "ffffffff ffffffff ffffffff ffffffff",
          "ffffffff ffffffff"
        ],
        a: "1",
        d: [
          "d78b4bdc 7f0daf19 f24f38c2 9373a2cc",
          "ad461572 42a50f37 809b1da3 412a12e7",
          "9ccc9c81 264cfe9a d0809970 58fb61c4",
          "243cc32d baa156b9"
        ],
        n: [
          "3fffffff ffffffff ffffffff ffffffff",
          "ffffffff ffffffff ffffffff 7cca23e9",
          "c44edb49 aed63690 216cc272 8dc58f55",
          "2378c292 ab5844f3"
        ],
        h: "4",
        z: "-1",
        g: [
          [
            "79a70b2b 70400553 ae7c9df4 16c792c6",
            "1128751a c9296924 0c25a07d 728bdc93",
            "e21f7787 ed697224 9de732f3 8496cd11",
            "69871309 3e9c04fc"
          ],
          [
            "7fffffff ffffffff ffffffff ffffffff",
            "ffffffff ffffffff ffffffff 80000000",
            "00000000 00000000 00000000 00000000",
            "00000000 00000001"
          ],
          pre
        ],
        torsion: [
          [
            [
              "00000000 00000000 00000000 00000000",
              "00000000 00000000 00000000 00000000",
              "00000000 00000000 00000000 00000000",
              "00000000 00000000"
            ],
            [
              "00000000 00000000 00000000 00000000",
              "00000000 00000000 00000000 00000000",
              "00000000 00000000 00000000 00000000",
              "00000000 00000001"
            ]
          ],
          [
            [
              "00000000 00000000 00000000 00000000",
              "00000000 00000000 00000000 00000000",
              "00000000 00000000 00000000 00000000",
              "00000000 00000000"
            ],
            [
              "ffffffff ffffffff ffffffff ffffffff",
              "ffffffff ffffffff fffffffe ffffffff",
              "ffffffff ffffffff ffffffff ffffffff",
              "ffffffff fffffffe"
            ]
          ],
          [
            [
              "00000000 00000000 00000000 00000000",
              "00000000 00000000 00000000 00000000",
              "00000000 00000000 00000000 00000000",
              "00000000 00000001"
            ],
            [
              "00000000 00000000 00000000 00000000",
              "00000000 00000000 00000000 00000000",
              "00000000 00000000 00000000 00000000",
              "00000000 00000000"
            ]
          ],
          [
            [
              "ffffffff ffffffff ffffffff ffffffff",
              "ffffffff ffffffff fffffffe ffffffff",
              "ffffffff ffffffff ffffffff ffffffff",
              "ffffffff fffffffe"
            ],
            [
              "00000000 00000000 00000000 00000000",
              "00000000 00000000 00000000 00000000",
              "00000000 00000000 00000000 00000000",
              "00000000 00000000"
            ]
          ]
        ]
      });
    }
  };
  var ED448 = class extends EdwardsCurve {
    constructor(pre) {
      super({
        id: "ED448",
        ossl: "ED448",
        type: "edwards",
        endian: "le",
        hash: "SHAKE256",
        prefix: "SigEd448",
        context: true,
        prime: "p448",
        p: [
          "ffffffff ffffffff ffffffff ffffffff",
          "ffffffff ffffffff fffffffe ffffffff",
          "ffffffff ffffffff ffffffff ffffffff",
          "ffffffff ffffffff"
        ],
        a: "1",
        d: [
          "ffffffff ffffffff ffffffff ffffffff",
          "ffffffff ffffffff fffffffe ffffffff",
          "ffffffff ffffffff ffffffff ffffffff",
          "ffffffff ffff6756"
        ],
        n: [
          "3fffffff ffffffff ffffffff ffffffff",
          "ffffffff ffffffff ffffffff 7cca23e9",
          "c44edb49 aed63690 216cc272 8dc58f55",
          "2378c292 ab5844f3"
        ],
        h: "4",
        z: "-1",
        g: [
          [
            "4f1970c6 6bed0ded 221d15a6 22bf36da",
            "9e146570 470f1767 ea6de324 a3d3a464",
            "12ae1af7 2ab66511 433b80e1 8b00938e",
            "2626a82b c70cc05e"
          ],
          [
            "693f4671 6eb6bc24 88762037 56c9c762",
            "4bea7373 6ca39840 87789c1e 05a0c2d7",
            "3ad3ff1c e67c39c4 fdbd132c 4ed7c8ad",
            "9808795b f230fa14"
          ],
          pre
        ],
        torsion: [
          [
            [
              "00000000 00000000 00000000 00000000",
              "00000000 00000000 00000000 00000000",
              "00000000 00000000 00000000 00000000",
              "00000000 00000000"
            ],
            [
              "00000000 00000000 00000000 00000000",
              "00000000 00000000 00000000 00000000",
              "00000000 00000000 00000000 00000000",
              "00000000 00000001"
            ]
          ],
          [
            [
              "00000000 00000000 00000000 00000000",
              "00000000 00000000 00000000 00000000",
              "00000000 00000000 00000000 00000000",
              "00000000 00000000"
            ],
            [
              "ffffffff ffffffff ffffffff ffffffff",
              "ffffffff ffffffff fffffffe ffffffff",
              "ffffffff ffffffff ffffffff ffffffff",
              "ffffffff fffffffe"
            ]
          ],
          [
            [
              "00000000 00000000 00000000 00000000",
              "00000000 00000000 00000000 00000000",
              "00000000 00000000 00000000 00000000",
              "00000000 00000001"
            ],
            [
              "00000000 00000000 00000000 00000000",
              "00000000 00000000 00000000 00000000",
              "00000000 00000000 00000000 00000000",
              "00000000 00000000"
            ]
          ],
          [
            [
              "ffffffff ffffffff ffffffff ffffffff",
              "ffffffff ffffffff fffffffe ffffffff",
              "ffffffff ffffffff ffffffff ffffffff",
              "ffffffff fffffffe"
            ],
            [
              "00000000 00000000 00000000 00000000",
              "00000000 00000000 00000000 00000000",
              "00000000 00000000 00000000 00000000",
              "00000000 00000000"
            ]
          ]
        ]
      });
    }
  };
  var curves = {
    __proto__: null,
    P192,
    P224,
    P256,
    P384,
    P521,
    SECP256K1,
    BRAINPOOLP256,
    BRAINPOOLP384,
    BRAINPOOLP512,
    X25519,
    X448,
    MONT448,
    ED25519,
    ISO448,
    ED448
  };
  var cache = {
    __proto__: null,
    P192: null,
    P224: null,
    P256: null,
    P384: null,
    P521: null,
    SECP256K1: null,
    BRAINPOOLP256: null,
    BRAINPOOLP384: null,
    BRAINPOOLP512: null,
    X25519: null,
    X448: null,
    MONT448: null,
    ED25519: null,
    ISO448: null,
    ED448: null
  };
  function curve(name, ...args) {
    assert(typeof name === "string");
    const key = name.toUpperCase();
    let curve2 = cache[key];
    if (!curve2) {
      const Curve2 = curves[key];
      if (!Curve2)
        throw new Error(`Curve not found: "${name}".`);
      curve2 = new Curve2(...args);
      cache[key] = curve2;
    }
    return curve2;
  }
  function register(name, Curve2) {
    assert(typeof name === "string");
    assert(typeof Curve2 === "function");
    const key = name.toUpperCase();
    if (curves[key])
      throw new Error(`Curve already registered: "${name}".`);
    curves[key] = Curve2;
    cache[key] = null;
  }
  function getNAF(k, width, max) {
    assert(k instanceof BN);
    assert(!k.red);
    assert(width >>> 0 === width);
    assert(max >>> 0 === max);
    const naf = new Array(max);
    const bits = k.bitLength() + 1;
    const sign = k.sign() | 1;
    assert(bits <= max);
    for (let i2 = 0; i2 < max; i2++)
      naf[i2] = 0;
    let i = 0;
    let carry = 0;
    let word;
    while (i < bits) {
      if (k.bit(i) === carry) {
        i += 1;
        continue;
      }
      word = k.bits(i, width) + carry;
      carry = word >> width - 1 & 1;
      word -= carry << width;
      naf[i] = sign * word;
      i += width;
    }
    assert(carry === 0);
    return naf;
  }
  function getFixedNAF(k, width, max, step) {
    assert(step >>> 0 === step);
    const naf = getNAF(k, width, max);
    const len = Math.ceil(naf.length / step);
    const repr = new Array(len);
    let i = 0;
    for (let j = 0; j < naf.length; j += step) {
      let nafW = 0;
      for (let k2 = j + step - 1; k2 >= j; k2--)
        nafW = (nafW << 1) + naf[k2];
      repr[i++] = nafW;
    }
    assert(i === len);
    return repr;
  }
  function getJSF(k1, k2, max) {
    assert(k1 instanceof BN);
    assert(k2 instanceof BN);
    assert(!k1.red);
    assert(!k2.red);
    assert(max >>> 0 === max);
    const jsf = [new Array(max), new Array(max)];
    const bits = Math.max(k1.bitLength(), k2.bitLength()) + 1;
    const s1 = k1.sign() | 1;
    const s2 = k2.sign() | 1;
    assert(bits <= max);
    let d1 = 0;
    let d2 = 0;
    for (let i = 0; i < bits; i++) {
      const b1 = k1.bits(i, 3);
      const b2 = k2.bits(i, 3);
      let m14 = (b1 & 3) + d1 & 3;
      let m24 = (b2 & 3) + d2 & 3;
      let u1 = 0;
      let u2 = 0;
      if (m14 === 3)
        m14 = -1;
      if (m24 === 3)
        m24 = -1;
      if (m14 & 1) {
        const m8 = (b1 & 7) + d1 & 7;
        if ((m8 === 3 || m8 === 5) && m24 === 2)
          u1 = -m14;
        else
          u1 = m14;
      }
      if (m24 & 1) {
        const m8 = (b2 & 7) + d2 & 7;
        if ((m8 === 3 || m8 === 5) && m14 === 2)
          u2 = -m24;
        else
          u2 = m24;
      }
      jsf[0][i] = u1 * s1;
      jsf[1][i] = u2 * s2;
      if (2 * d1 === 1 + u1)
        d1 = 1 - d1;
      if (2 * d2 === 1 + u2)
        d2 = 1 - d2;
    }
    for (let i = bits; i < max; i++) {
      jsf[0][i] = 0;
      jsf[1][i] = 0;
    }
    return jsf;
  }
  function getJNAF(c1, c2, max) {
    const jsf = getJSF(c1, c2, max);
    const naf = new Array(max);
    for (let i = 0; i < max; i++) {
      const ja = jsf[0][i];
      const jb = jsf[1][i];
      naf[i] = jsfIndex[(ja + 1) * 3 + (jb + 1)];
    }
    return naf;
  }
  function assert(val, msg) {
    if (!val) {
      const err = new Error(msg || "Assertion failed");
      if (Error.captureStackTrace)
        Error.captureStackTrace(err, assert);
      throw err;
    }
  }
  function wrapErrors(fn) {
    assert(typeof fn === "function");
    try {
      return fn();
    } catch (e) {
      if (e.message === "X is not a square mod P." || e.message === "Not invertible.") {
        throw new Error("Invalid point.");
      }
      throw e;
    }
  }
  function mod(x, y) {
    let r = x % y;
    if (r < 0) {
      if (y < 0)
        r -= y;
      else
        r += y;
    }
    return r;
  }
  function cubeRoot(x) {
    assert(x instanceof BN);
    assert(x.red);
    const p = x.red.m;
    if (p.cmpn(3) <= 0)
      return x.clone();
    if (p.modrn(3) === 2) {
      const e = p.ushln(1).isubn(1).idivn(3);
      return x.redPow(e);
    }
    const mod9 = p.modrn(9);
    if (mod9 === 4) {
      const e = p.ushln(1).iaddn(1).idivn(9);
      const r = x.redPow(e);
      const c = r.redSqr().redMul(r);
      if (!c.eq(x))
        throw new Error("X is not a cube mod P.");
      return r;
    }
    if (mod9 === 7) {
      const e = p.addn(2).idivn(9);
      const r = x.redPow(e);
      const c = r.redSqr().redMul(r);
      if (!c.eq(x))
        throw new Error("X is not a cube mod P.");
      return r;
    }
    throw new Error("Not implemented.");
  }
  function cubeRoots(x) {
    const r0 = cubeRoot(x);
    if (x.red.m.modrn(3) === 1) {
      const two = new BN(2).toRed(x.red);
      const three = new BN(3).toRed(x.red);
      const i2 = two.redInvert();
      const s1 = three.redNeg().redSqrt().redMul(i2);
      const s2 = s1.redNeg();
      const u1 = s1.redSub(i2);
      const u2 = s2.redSub(i2);
      const r1 = r0.redMul(u1);
      const r2 = r0.redMul(u2);
      return [r0, r1, r2];
    }
    return [r0];
  }
  function uncube(x) {
    for (const root of cubeRoots(x)) {
      if (root.redJacobi() >= 0)
        return root;
    }
    throw new Error("X^(1/3) is not a square mod P.");
  }
  function randomInt(rng) {
    return BN.randomBits(rng, 32).toNumber();
  }
  function memoize(method, self2) {
    const cache2 = new WeakMap();
    return function memoized(curve2, invert) {
      const i = invert & 1;
      const item = cache2.get(curve2);
      if (item && item[i] !== null)
        return item[i];
      const result = method.call(self2, curve2, invert);
      if (!cache2.has(curve2))
        cache2.set(curve2, [null, null]);
      cache2.get(curve2)[i] = result;
      return result;
    };
  }
  function toPretty(x, size) {
    assert(x instanceof BN);
    assert(size >>> 0 === size);
    if (size & 7)
      size += 8 - (size & 7);
    const str = x.toString(16, size);
    const chunks = [];
    const out = [];
    assert((str.length & 7) === 0);
    for (let i = 0; i < str.length; i += 8)
      chunks.push(str.slice(i, i + 8));
    for (let i = 0; i < chunks.length; i += 4)
      out.push(chunks.slice(i, i + 4).join(" "));
    return out;
  }
  exports2.Curve = Curve;
  exports2.Point = Point;
  exports2.ShortCurve = ShortCurve;
  exports2.ShortPoint = ShortPoint;
  exports2.JPoint = JPoint;
  exports2.MontCurve = MontCurve;
  exports2.MontPoint = MontPoint;
  exports2.XPoint = XPoint;
  exports2.EdwardsCurve = EdwardsCurve;
  exports2.EdwardsPoint = EdwardsPoint;
  exports2.curves = curves;
  exports2.curve = curve;
  exports2.register = register;
});

// node_modules/bcrypto/lib/js/random.js
var require_random2 = __commonJS((exports2) => {
  /*!
   * random.js - random number generator for bcrypto
   * Copyright (c) 2014-2019, Christopher Jeffrey (MIT License).
   * https://github.com/bcoin-org/bcrypto
   *
   * Resources:
   *   https://wiki.openssl.org/index.php/Random_Numbers
   *   https://csrc.nist.gov/projects/random-bit-generation/
   *   http://www.pcg-random.org/posts/bounded-rands.html
   *   https://developer.mozilla.org/en-US/docs/Web/API/Crypto/getRandomValues
   */
  "use strict";
  var assert = require_assert2();
  var crypto2 = global.crypto || global.msCrypto;
  var HAS_CRYPTO = crypto2 && typeof crypto2.getRandomValues === "function";
  var randomValues = HAS_CRYPTO ? crypto2.getRandomValues.bind(crypto2) : null;
  var pool = new Uint32Array(16);
  var MAX_BYTES = 65536;
  var poolPos = 0;
  function randomBytes(size) {
    assert(size >>> 0 === size);
    const data = Buffer.alloc(size);
    randomFillSync(data, 0, size);
    return data;
  }
  function randomFill(data, off, size) {
    assert(Buffer.isBuffer(data));
    if (off == null)
      off = 0;
    assert(off >>> 0 === off);
    if (size == null)
      size = data.length - off;
    assert(size >>> 0 === size);
    assert(off + size <= data.length);
    randomFillSync(data, off, size);
    return data;
  }
  function randomInt() {
    if ((poolPos & 15) === 0) {
      getRandomValues(pool);
      poolPos = 0;
    }
    return pool[poolPos++];
  }
  function randomRange(min, max) {
    assert(min >>> 0 === min);
    assert(max >>> 0 === max);
    assert(max >= min);
    const space = max - min;
    if (space === 0)
      return min;
    const top = -space >>> 0;
    let x, r;
    do {
      x = randomInt();
      r = x % space;
    } while (x - r > top);
    return r + min;
  }
  function getRandomValues(array) {
    if (!HAS_CRYPTO)
      throw new Error("Entropy source not available.");
    return randomValues(array);
  }
  function randomFillSync(data, off, size) {
    assert(Buffer.isBuffer(data));
    assert(data.buffer instanceof ArrayBuffer);
    assert(data.byteOffset >>> 0 === data.byteOffset);
    assert(data.byteLength >>> 0 === data.byteLength);
    assert(off >>> 0 === off);
    assert(size >>> 0 === size);
    assert(off + size <= data.byteLength);
    if (size > 2 ** 31 - 1)
      throw new RangeError('The value "size" is out of range.');
    const offset = data.byteOffset + off;
    const array = new Uint8Array(data.buffer, offset, size);
    if (array.length > MAX_BYTES) {
      for (let i = 0; i < array.length; i += MAX_BYTES) {
        let j = i + MAX_BYTES;
        if (j > array.length)
          j = array.length;
        getRandomValues(array.subarray(i, j));
      }
    } else {
      if (array.length > 0)
        getRandomValues(array);
    }
  }
  exports2.native = 0;
  exports2.randomBytes = randomBytes;
  exports2.randomFill = randomFill;
  exports2.randomInt = randomInt;
  exports2.randomRange = randomRange;
});

// node_modules/bcrypto/lib/random-browser.js
var require_random_browser2 = __commonJS((exports2, module2) => {
  /*!
   * random.js - random for bcrypto
   * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
   * https://github.com/bcoin-org/bcrypto
   */
  "use strict";
  module2.exports = require_random2();
});

// node_modules/bcrypto/lib/js/ecdh.js
var require_ecdh = __commonJS((exports2, module2) => {
  /*!
   * ecdh.js - ECDH for bcrypto
   * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).
   * https://github.com/bcoin-org/bcrypto
   *
   * Resources:
   *   https://cr.yp.to/ecdh.html
   *   https://cr.yp.to/ecdh/curve25519-20060209.pdf
   *   https://tools.ietf.org/html/rfc7748
   */
  "use strict";
  var assert = require_assert2();
  var BN = require_bn_browser();
  var elliptic = require_elliptic4();
  var rng = require_random_browser2();
  var ECDH = class {
    constructor(id, eid, pre) {
      assert(typeof id === "string");
      assert(!eid || typeof eid === "string");
      this.id = id;
      this.type = "ecdh";
      this.eid = eid || null;
      this._pre = pre || null;
      this._curve = null;
      this._edwards = null;
      this.native = 0;
    }
    get curve() {
      if (!this._curve)
        this._curve = elliptic.curve(this.id);
      return this._curve;
    }
    get edwards() {
      if (this.eid && !this._edwards) {
        this._edwards = elliptic.curve(this.eid, this._pre);
        this._edwards.precompute(rng);
        this._pre = null;
      }
      return this._edwards;
    }
    get size() {
      return this.curve.fieldSize;
    }
    get bits() {
      return this.curve.fieldBits;
    }
    privateKeyGenerate() {
      const key = rng.randomBytes(this.curve.scalarSize);
      return this.curve.clamp(key);
    }
    privateKeyVerify(key) {
      assert(Buffer.isBuffer(key));
      return key.length === this.curve.scalarSize;
    }
    privateKeyExport(key, sign) {
      const pub = this.publicKeyCreate(key);
      const {x, y} = this.publicKeyExport(pub, sign);
      return {
        d: Buffer.from(key),
        x,
        y
      };
    }
    privateKeyImport(json) {
      assert(json && typeof json === "object");
      const a = BN.decode(json.d, this.curve.endian);
      if (a.byteLength() > this.curve.scalarSize)
        throw new Error("Invalid private key.");
      return this.curve.encodeScalar(a);
    }
    publicKeyCreate(key) {
      const a = this.curve.decodeClamped(key);
      if (this.edwards && this.edwards.g.pre) {
        const A2 = this.edwards.g.mulBlind(a);
        const P = this.curve.pointFromEdwards(A2);
        return P.encode();
      }
      const G = this.curve.g.toX();
      const A = G.mulBlind(a, rng);
      return A.encode();
    }
    publicKeyConvert(key, sign) {
      assert(sign == null || typeof sign === "boolean");
      if (!this.edwards)
        throw new Error("No equivalent edwards curve.");
      const A = this.curve.decodePoint(key);
      const P = this.edwards.pointFromMont(A);
      if (sign != null) {
        if (P.isOdd() !== sign)
          return P.neg().encode();
      }
      return P.encode();
    }
    publicKeyFromUniform(bytes) {
      const u = this.curve.decodeUniform(bytes);
      const A = this.curve.pointFromUniform(u);
      return A.encode();
    }
    publicKeyToUniform(key, hint = rng.randomInt()) {
      const A = this.curve.decodePoint(key);
      const u = this.curve.pointToUniform(A, hint);
      return this.curve.encodeUniform(u, hint >>> 8);
    }
    publicKeyFromHash(bytes, pake = false) {
      const A = this.curve.pointFromHash(bytes, pake);
      return A.encode();
    }
    publicKeyToHash(key, subgroup = rng.randomInt()) {
      const A = this.curve.decodePoint(key);
      return this.curve.pointToHash(A, subgroup, rng);
    }
    publicKeyVerify(key) {
      assert(Buffer.isBuffer(key));
      let A;
      try {
        A = this.curve.decodeX(key);
      } catch (e) {
        return false;
      }
      return A.validate();
    }
    publicKeyIsSmall(key) {
      assert(Buffer.isBuffer(key));
      let A;
      try {
        A = this.curve.decodeX(key);
      } catch (e) {
        return false;
      }
      if (!A.validate())
        return false;
      return A.isSmall();
    }
    publicKeyHasTorsion(key) {
      assert(Buffer.isBuffer(key));
      let A;
      try {
        A = this.curve.decodeX(key);
      } catch (e) {
        return false;
      }
      if (!A.validate())
        return false;
      return A.hasTorsion();
    }
    publicKeyExport(key, sign) {
      const {x, y} = this.curve.decodePoint(key, sign);
      return {
        x: this.curve.encodeField(x.fromRed()),
        y: this.curve.encodeField(y.fromRed())
      };
    }
    publicKeyImport(json) {
      assert(json && typeof json === "object");
      const x = BN.decode(json.x, this.curve.endian);
      if (x.cmp(this.curve.p) >= 0)
        throw new Error("Invalid point.");
      if (json.y != null) {
        const y = BN.decode(json.y, this.curve.endian);
        if (y.cmp(this.curve.p) >= 0)
          throw new Error("Invalid point.");
        const A2 = this.curve.point(x, y);
        if (!A2.validate())
          throw new Error("Invalid point.");
        return A2.encode();
      }
      const A = this.curve.pointFromX(x);
      return A.encode();
    }
    derive(pub, priv) {
      const A = this.curve.decodeX(pub);
      const a = this.curve.decodeClamped(priv);
      const P = A.mulBlind(a, rng);
      return P.encode();
    }
  };
  module2.exports = ECDH;
});

// node_modules/bcrypto/lib/js/precomputed/ed25519.json
var require_ed255193 = __commonJS((exports2, module2) => {
  module2.exports = {
    naf: {
      width: 9,
      points: [
        [
          "67ae9c4a22928f491ff4ae743edac83a6343981981624886ac62485fd3f8e25c",
          "1267b1d177ee69aba126a18e60269ef79f16ec176724030402c3684878f5b4d4"
        ],
        [
          "49fda73eade3587bfcef7cf7d12da5de5c2819f93e1be1a591409cc0322ef233",
          "5f4825b298feae6fe02c6e148992466631282eca89430b5d10d21f83d676c8ed"
        ],
        [
          "14568685fcf4bd4ee9e3ee194b1d810783e809f3bbf1ce955855981af50e4107",
          "31c563e32b47d52f87ce6468dd36ad41f0882b46f7abf23d12c4c4b59f4062b8"
        ],
        [
          "357cc970c80071651bf336e06f9422b886d80e5c2e4e0294d3e023065185715c",
          "7f3d23c2c2dd0df4b2befce956f2d2fd1f789013236e4430c74e44845522f1c0"
        ],
        [
          "14e528b1154be417b6cf078dd6712438d381a5b2c593d552ff2fd2c1207cf3cb",
          "2d9082313f21ab975a6f7ce340ff0fce1258591c3c9c58d4308f2dc36a033713"
        ],
        [
          "107427e0d5f366ccdb33adf0282d304f8843e3e88d22b7b83780e073b7c05fed",
          "12dbb00ded538b7478466022d2da89b83740cfb2289a272387efe1aeea401f80"
        ],
        [
          "4f162deaec2ec435dc5ac6f95d20419ed9631374770189cb90617f3e66a18dc1",
          "12cbfb2d04ff22f55162f70164d29331ace5af18a19a9aa1946d4cc4ad2e5cdf"
        ],
        [
          "7dc52d5a7db816e9b850741ea2fd72918d94985b85a20b4dc5597853a876df6a",
          "6f6d2bca60003ef9f24ac245cc919fb717b188723b34f901cd6cfe9bec97be04"
        ],
        [
          "1d81f74a5ba45c7022e8c140d763b9c1b0e281a5304696e74f791a3a04a94472",
          "3f185a93d95a4347227c5bb6ddd65cf42e1830823f435f3083fe6102691d55b9"
        ],
        [
          "6f0ac78e5eb90e87958588f9d47541edf252cb1dde3d073cc45e3e7ef9365716",
          "6628d116b7975ae5f323e5ddf4f8cc35ae06d5c5c7d8a56effc66051336d289e"
        ],
        [
          "2188ac423c67db5625915e05222a391bcaf91f05d9b7cc2cab5798b2d2e14d95",
          "23240c559c57b79a4df69a23fc46e50504277b1fa49369ab663d79782b33c0ee"
        ],
        [
          "794241471ed9ceb009384b370cb8790fca98552ecb822dc06b19362c36353455",
          "71e918c03cdfca7207772e8d18ee8f9d92d79a0a83f378912362bc68d311dcd0"
        ],
        [
          "163bc180c22dfc5da23c5c052107bba93a88b4360aa1d4e729611d8f5a7f8079",
          "631107a6ba83f7458194b9766a0a54f638ca20daf800384dbae1498677501939"
        ],
        [
          "39a32a30f3eb1da0eb7e3903b8ace3da3890b24b61a3a9e79db663b5db0f7a5d",
          "4d4c54675dc1f1c9a1af9ca0010045dc803c16af345823136dd203715d67c491"
        ],
        [
          "38085391a0e2831f59c33fcce7591515784d359925f11ff958e0e4658efac0e9",
          "42918001a829f49b5634e34ab7fac21b30e24660669ed91955cc31944a19e62a"
        ],
        [
          "5e3573b049d6135ffbbbbd9a480617434f2455b4a591f719e91153eeb75a32a1",
          "54bc665420c789da1105d53983c1a0fc33bcc2690cd9b37d6566e21a85892871"
        ],
        [
          "7ed068b25b82c05fdc0e46bd80a357f3acd2f5c3b9330bc8d474e5b28270f6eb",
          "01da83a187da8ccca704d46557a462551d70df7f943a681c3b97b1db6a21b7d3"
        ],
        [
          "05ca3370e7516f6686111b72650aab4c5484407f14b515ade03951c6a14a0aa3",
          "6f407fc537b95277966e7f0f5e64b86904bf7baee091cee6011a3611834c6903"
        ],
        [
          "624cb312b698bbd6dbca79b8d2b53cb5d8b3ab33c19306e87c18211f095ab9c3",
          "5b3336b2751e97c793731ac9b9a2243b6229f6d0bbea6b619395d0e5200bd8a3"
        ],
        [
          "1ddf6ece608fe2901b34b7e4f47cfcb75e947e293c704d8121b11a31a051b5f9",
          "5e2dc58e9a48a749ce5296d229cfb34f96a147a8246d2e9844d52b52112ea94e"
        ],
        [
          "396b384f3d61cfc060308fbb1c941ebc9418e2d9abd81316e08d625f48c0e101",
          "7223e5f7b66d1ca24962bac273a7aa6618cc60cb8a64a8837e0261107e7ad644"
        ],
        [
          "53cc3dca3410277fb38d75e4ac0dde8e77a99c817170dbc9696cffe7890fbd50",
          "2592a3aafce64d7c69f4de468d5d5aa19845f5ca08f64a0a40e37d23ececbbe1"
        ],
        [
          "34705fe600f5aed77b29d3eacdffcd45d886904156d43dc550bb7fc889cc1368",
          "299153c141a8950ffbcc8e9352993e642fa39a476200dd4acf42e158dbe3b01e"
        ],
        [
          "5969255bd089181b991fce96b1792ba330a14f8a0b061f8118c9c336b8504618",
          "680a805fa0ae93c2a12b193517fb1147d355547e4ab18a9d6ca21575bbb4d7a4"
        ],
        [
          "27d1d57fa8808d3d452df14bda4248b37902752163b1fd499a92456c59918ecb",
          "0a42f1c0f4c5d7de9e82904f0b4ff63988d31fedb8aad9d8ae009c7a1dff09c3"
        ],
        [
          "0811d14bfdfdcf2144edd9cf55bce584a9ba17aec3eac8aaa82987ad703d9b8a",
          "42bea70d46f3ee0df0ec77d24c5495ea56ada2e0415920470c4746b68306376e"
        ],
        [
          "4de090761b863cb0f0650297f154a8e66d00c5119c38e5dd05303d905d527a4a",
          "5eef0efd105361ce198a30e09e7e7edffbe3d70189e63ca68cf6057b9772baa8"
        ],
        [
          "1d45517858ce45556aaee056ebab7e0ef3dc9ae3740aed570f3e76bfb4fc4817",
          "0b5a9d8fe8b7ccb04c0a5ef77798a3ec6e1bc1138604eb05e83844f0d4c5c699"
        ],
        [
          "4285edbe9117f30aae1ef5ee419eb1d472106c6b3d7f3ce3701e39324b0eeafc",
          "503aa6104a682bcf2c0a60c84f4c22b50b0caa0fed8db87dedc7173eae04bdbd"
        ],
        [
          "3ef830cbeff9b79039b1b6bd9bb52bbcfa56d008d91b9703ea1c80351f8687d6",
          "62349ff5d8dbd216a874769eec152ef9734bea9240eed623992c7553dc8ee4c8"
        ],
        [
          "649a996e6d4d3b60ccb526939ed8929134107e03e2fd4648eaa2fa9830822c1a",
          "1648311b942fe95d492a1ace5e5235c1aea860d036d2475cc8964cd1acedee9c"
        ],
        [
          "3a95596d97770d050d1ecc075d58a74f5fe6b4b8222740534ba22c8be73f9d56",
          "15a80cdcc03317a830fa4a7461de6bac136993e0a797f83b405c161a34c98fd7"
        ],
        [
          "2d265d3fe1c88903ca93685209418deec5af886bf0d9fdb3f499d831cbb76ce1",
          "08376fb0663d3aa220948612b519af4a6a1f956622b15a305fb2e60a84210b3c"
        ],
        [
          "642cb15498d8c6b25803f3e56b98e2ea185ac808cbeab5eb0a610ed5babb9385",
          "21b5ca5020a9e5a2334c0bee15193ea16c909963ffa6e1d93df4b239abeaeb3e"
        ],
        [
          "38e576301ff6cdd0822a19c6d610d445d3967e2bada903abb6220f68c6e79bef",
          "458fe689e31a24952d2817dda4349109c1b26ef31699fa36c4f8389eeb60eac0"
        ],
        [
          "372bec78d75011a0ef2233cd08790a7f15c1ec1e3a78cac8d6652678641780db",
          "32e9e47cf2f48612ed3e2c2006ea0c0c8476d3562aa88cefb67ec97abdb538e8"
        ],
        [
          "1aa3756aabcc3eb65afee34e0a15dd67bfb9fb199eb131f4cc6a3ca9ec4d1c77",
          "42333e27831add6eb49af80e17347c63c26dd684758096ee3dbdbe03a49159ae"
        ],
        [
          "38db16447d79d3590c4a36e20286beadfbae91a4eed2e5e7dd4f975ac0537dc5",
          "1c48ccaed60ec12ce862ea71165bba7df1739845df2a857f4ef0a0f714f96daa"
        ],
        [
          "176b78984cddfddef90bae619c6a98e951d9a7ac7d6af218ae7e76b273212fb7",
          "7b5b93eda77443f366e2a127abe12212aad8536767ec1c5861143f777db85852"
        ],
        [
          "042d154bf7b4a7bd73897ae528c6bc552ea58d74f8109e8e4052d3e9d38bb0f6",
          "42d1831323e279f9f7ee9e3470ba20ca7edc3245eca5d8ffa182de120a71fc90"
        ],
        [
          "1f8d28dd4f286a8d0687b626b01204434bf5874a9550d6e375116490c154e108",
          "1ce82e2360367e06f41757fd45239f9bc2c61609139446b09b55a9c43da98bb8"
        ],
        [
          "613eb914c015076e9ae8356bf508c289e50b1c87d9e2546f6e406362e248e5e5",
          "3edbaafcd8c41ef4aa18b254137d201a2ef0ca4ca28807156bc949e920b97353"
        ],
        [
          "27bf43826bf0310b4b3e3a405eff790a1d77a8d48b04891246cff8e193cb03a9",
          "16a24d749cc1d234fbe8af9cfd782c3aaa5869d6db0afa7b4d4c67037514f2ea"
        ],
        [
          "769a6a59746d7bead417bdd9c3b5f5ae1dbd924083ffd9e88df7714f57a675c2",
          "22dc1267cfb2b41c590abb7dc3df45619af688d0421f2bdfb50748335ec5da25"
        ],
        [
          "795734ee4fcc24194219d25d41a2889cdb942f765848e9df63bff0b158c7224d",
          "756420ab5c71127d39d2e79907634a177af0e483e08484ea4d7b76f7100669b5"
        ],
        [
          "644d12fc5e7fcac5aeb5911d8240971a99fc59fdd2903f46958e6896aefbcf46",
          "173450789fcd40172e8124fea56f7aedad2ee13fa8fc5209cc8cb572175216dc"
        ],
        [
          "5deca767ef17b9e8d4f351f5c8ad1fcc50e97a2ed687516bf5210679fd6c1110",
          "4ddf2207da12f700708089989da016f3307ce5721c9e27c952599d67898aa396"
        ],
        [
          "296dcb24cb3185d037a94bef93c97cacd09fc7050ba8472da59d4a689d9d2848",
          "0b17dc85a4acf73833fab728f15abccac97cd09e57975bd996d3e1dd8b060f7b"
        ],
        [
          "408a3f1af2e77dfe94f8e225b40dfc146abb1002db7bcf15fde61c1a6cf1b93f",
          "4f01ec38854c15a879e7c7924f048e2ec951dcdf04a614088b68fbcc0954e1c8"
        ],
        [
          "07d2d9234970cdc9483e0a7c5ec52c49077c440e0a993a1e624f90b8fafbbf07",
          "6ac2190030c210ae3e07b9239f6ee7affba263866ee7831a564c511f703f2295"
        ],
        [
          "2982d553002082320aa899b9b6887e40dedf11868fa931689795d93d58452873",
          "215e16ca447978624cad0ea6bf45aada4eca914425ee275db2a26e980dc349b6"
        ],
        [
          "1d8649515cb49e136d2895b6276569e5c711fe1a343eeb5a3daaa8d0e7b42d1a",
          "5b21e2f2978f343a3e9ec3316cdc111af3b55f34afa5fc3fcbf6c26c1bb7fb6c"
        ],
        [
          "5460df4d607147939cdbc04dbdcbdffd37c5eafdd501b50a67213a23ee724a97",
          "69dfc7004263ccb52487d34ab134b80bb3030273999739cb9cdc16d71b9abcd8"
        ],
        [
          "24623476f0af9f42ca15a0697ad23abeaf5ed9dc4d2b44f7e8175486598125bb",
          "6aebe4a1a22d9e31194dcde6d33ff3af77dda15c22b2ecba9329849b8c042687"
        ],
        [
          "64e507a02bfd8a8413117bac253b17f94b2911681ebc07c92da0de6a651dd538",
          "513ac992d72b463da110afb612fbae36590248a0507d845ee95fab2d1caa03a4"
        ],
        [
          "47f3bd11324f6bee230a22a5bb06a3ccddbc0473b810689efaeef894a654bf0e",
          "7e05db9b3ff886bf32608dfc8d14eaa91e2e2ef230e7c75618060e4285c492be"
        ],
        [
          "4a6d22703a7045d02d656015ea2d168385d42963a739a895e4fd87b3e55c5e0f",
          "4c58d7a8c6ded0451798e51f16ffa5b637a87aa5defb119ba868d8cccf61776d"
        ],
        [
          "3e22af70a548097244d7798964598172a90391f84c59b04cea7af283ba368eb5",
          "689d8b7cda23b8dea197c5119fbbbd81dd4b59a36cc283dbe292b5b6519a2968"
        ],
        [
          "61a6ba2ca42d9d557b3a2ff0867c1b8bb8fc40192d31ff637431a302bc065a10",
          "63d805f5a79f845ea2915a25cf0a8cab2e0255212a1bd3c8852b25579b63721d"
        ],
        [
          "03d963eeae48556e88305f91c478efcfd2168c346b9ba185884ec8621e8cb414",
          "74b75cc839a944ad8c639719d20fd9d48d2099ef24c8633eabec7a9ec1e7e183"
        ],
        [
          "0f04da69e0202f7b44c58b103c88de09a0599951fedb17e7f2152d6b93a58ae9",
          "1fbc1c9cd03c4cfd46e8e90019debf86e8036587eade038346f91070c800b8c4"
        ],
        [
          "797899e488353ed0c6666aff11913b33be0190833766e809b2a68cbc671a9cfe",
          "5dd70a33ff94a84b3fe660f7070e6179e86b5c846689265bf985ce424b8909cc"
        ],
        [
          "735b64bb872606510e4e7d57833eb7ffdc4aa0dbaa242439806be68379f77cdd",
          "384aaaee3ca7ba2436fcb65910859ca5ec30c10af11df7d777d287bc1a2bce2c"
        ],
        [
          "6f6ea532a62cf4766f55a0a72a86b55e73fe9d3328ee94bfc271e122f99dc1ac",
          "61d8203ef6da5d0b584541c02331c7f58617cf8d4f26d11776236ce8b113ac10"
        ],
        [
          "5d99a2a3d4aed730b827b68ed836a9910dce4e7b93faf456981ad6cd85748773",
          "7eeacf5680fb6108a8b7edb45f7134644111b08e17c236469685af5a79474b9e"
        ],
        [
          "31d0b4bb57bd7b69363c064a49bf3c3b9d7635bcc287e7b3059d3d99fd8382e8",
          "1592e581034e13d47d02b8966f5359097e652391be8fb1e803f4219a22aba2c0"
        ],
        [
          "424cf5c498bbbe8fa7e5c3247049cc3f45946d0e5f38c44a36a6c84b60a84aa0",
          "34acd712d334a2315dc8fd00c5c9b7c5c9f29bca27380a018882a5ab4a0fcb43"
        ],
        [
          "33a6ae0522936ba774837aa7959972f9804e3ef02ae84c8039be6595598be247",
          "37022798cc08be9b4ded34c1c5062ab3a26081d375cadf517972fb48135a6602"
        ],
        [
          "5939635b72aeba595b5f6e376d11a3e07d4b1153ab4d0a7ab267b8bcc47cc3cb",
          "382162eb33db2322cbe01a38fa4d13720b6d8edfaf8116a628725ef4293a6c27"
        ],
        [
          "3649e78d2ae9fb0ee86b691c27386efce4f3e383790e3cfee2bd59c2e85c4036",
          "09b0d9e0dd82e697b9be9d61ce0d1410e281122b483125c48f7942b22f5d5be4"
        ],
        [
          "62c7585d1677b7619d8200175346ec99118416d8fdf0103730d165934e96a973",
          "5fef7955ee07304429995433a468d68dec4ecf6b08bbe8cd06869080094044de"
        ],
        [
          "0c94537d311e17f5b0c58989b5be7e40c88b978a8c074a1e9bb07a713f77f6d3",
          "6deaaa5001bcbbbe9ae436fe42f7042ce74fbf83c14058427fad4587ed33c4e2"
        ],
        [
          "6f5c6894a8d3877312e608c11809c15dffec3df551711095c8cfc810533e1b3e",
          "74eadab9389b40d6ac6cc0d6e333d628ced60a9ef7617751c20630d23477af7b"
        ],
        [
          "4e16e88e171f9a07e11f97bba65c0fe5483501f255343afb3335ed47fbcee08f",
          "41bcd7dd328871247cb7995bc6bd2e1961e94b0fb12e5fb2f264f9ad2cf47d4c"
        ],
        [
          "65d8484cef146e6c232fb262c2ac8200a52c63ccec26ff6f038aa5c74982c741",
          "67283346bbae9391952b141e57ca8e3a36f0363d3b81b1c0f2b3c30a92c74235"
        ],
        [
          "1c588485b64be8cb99bf97f065e75a82138ea2e035ba90b63745354e9cf729f8",
          "7c9a18d6ebf5465a197989cfb9b5b2a66a5402f46c4708ac04187c6b157a0d77"
        ],
        [
          "2c80c4ad0aebcafab7e9d2519a329f8a1c7df21cb6b1acec7403c0204d6dce71",
          "7f8e62983160756e35356df95d44467e621c7274372997ca74a9fb760b4db36f"
        ],
        [
          "1e1e5fc87fa2c49e2c44d5718e3d73c73a91a64ac1374652080bd9004291b9c6",
          "153828e90ed8d94c0f86e0eb54ccb31073cd29ed62c34cd9f2dbc5d98872e597"
        ],
        [
          "0ce0488a30ed446d445efb1bd21ba32ec3d05d538e6393bc0e58e0849ad57129",
          "7278074ac66ac779136f4d6a334b27633645dea0fc98d137e3dbd4015d12b5a1"
        ],
        [
          "01a6b81f7285f293f19ba019b009aed8280ce285af42fab91e87fb0bbfa6dea4",
          "60f910dc7c9a82e7836f36acfe7ec26b9babfa8bf26b2945b3c1a43b0c19b4dc"
        ],
        [
          "79b4ce3c6990023859646690c9ea800174902acfa1aad7ff34eca032dbde7150",
          "53a1053d3fc6c749bf8a928854f392d09fa851ba963ca661bffbe74f012ba45b"
        ],
        [
          "220ee355b5c39c1901ed34c0f50f7778ad1bedcd7259ae167c16514ffe333498",
          "05fd9374986e1e06035dbfada0117035b96b159354262f2b2695af1256d6aa2a"
        ],
        [
          "1e2f97d2cb4a19ca40403b364253da71f65d2d4665894267e3c6a9db8b4a3a18",
          "22804fb035acb519210ff99ed7a974a725d896a77933789b4dd45a37dea3466d"
        ],
        [
          "35b8699fa20987876ac3b3086965b05f8cc809d71cab45e017c68ac96e24ed5b",
          "155079de21981778dc438353bf2c6a65967a1a33ebb74c866fb42f4e3cce3e39"
        ],
        [
          "3cb40c55f5f19c52958e8c4ecd9c459b1d3268b3971b2286d3e58d1fc6b6a6bd",
          "379e1f1f59df05c74485615b87441ba6203f0cdddc6873a883d4cc6dd1b75921"
        ],
        [
          "6ad916290e0d003ce5c961679f77704dcd768589d7cb728c60f56852031803bf",
          "1e602b4a6725832a56944234f84c4f85f79911b55beef903549089925f2ccbea"
        ],
        [
          "7c0162492ae668160aa56a60e8bd43ec088555f750d2223cc37362dead5de123",
          "34e60b446eae100d4c3abc6cb02e4ca559457fb5a9030a290a2568fa4cbf118f"
        ],
        [
          "354c25bf7b3e83dd0c5e1f39b82e3567edeb5337634056c1091cd6a016caacdf",
          "7abb271ef121630f85a9a1049b3ad78d5b889f533b37a713b8801de46770fc3a"
        ],
        [
          "1e581a4bcf7504f33f4342b2097504d13f9b5a27f4790a6cdde1242209862850",
          "2164d56564360fd2b5dba2f2c6ef1045ab448c3b60b2f2196c2f74625fc39e07"
        ],
        [
          "533b56f18283ee79b9a180b887c298961bd9aaa6fa3ef97fcb0d5688e694bc3d",
          "6011366753812df2bce83634a92dbac18dd1cffdbf9a97fa1b1d5b49e0026764"
        ],
        [
          "4b508b94e6e2e6cd260a20664ea7d727ad20587b63ebe826032e0d20cdc6627b",
          "1e8ecd6ff5aabae78172a0214d07a5013992d133af58afa74049de726df2a6c4"
        ],
        [
          "3398c0c0219f5ac87a8c73fcd17b89311d120a53f5231cb761030c194fed4265",
          "025b234a1dc8662c068c4ba903939c2f79f3f7a3ae64e5edbf667b13599142d9"
        ],
        [
          "5941a17b04cd3465031cb6745cb94eed24e1ff8d38a6e832f1637ae8e89c78e6",
          "5309792c546b6cda458be331957763b5adb5d535d54a4a61023678faa2ee02ee"
        ],
        [
          "2cb490d2c0047fcbaffe1df26640bee73c158af6fec91343d606ce9d124a20c9",
          "2e2952ebf089200aebfa3947f241e2fe85797afebdc1ea06d9d26de1b446a964"
        ],
        [
          "79305236b583232a91c63c7d9ca3750be7ee21711e4d6d257c39ae398212bde1",
          "6f9ecdfa953e302c2014fd8512405e4be0d48302acd15e93936e8dba7d01053b"
        ],
        [
          "57d9fcb884b94664f35387fa6665cd9bc8136f90d804d77416ea99c3c653ee63",
          "14197e65f0a3599c0b9fcef75b5fbb93580d1b2457b59fb70ce7b9bac88d0fbc"
        ],
        [
          "6d99df2c28c9fa1e38acddefd3e0931109143d873f3330377a9926bdacdd6523",
          "2f21987905f397f092fc56c5ccd301a1e6afa3c4611627e25017b2e68d07c150"
        ],
        [
          "749d19591f1755bd481fa12a288166aac42911654c8c551395b265116269ceb9",
          "7ec145aa7558d0342cd87b1750933cb6f3717e727a86a1cc1f2b0c274213688d"
        ],
        [
          "340f7f5ae19292957902635a5786d14fa38036b324ae759da501e32b8c4073f1",
          "64e231a413f1379a26f4e8223ff91fe2ccd865549571d3c6c28871964b40a0ea"
        ],
        [
          "4aa33e00bf6e92cac4e84384e5dde0727394233afd5d24d357a8afeb94b08109",
          "3385bb4fbc441937ee01b671d506227a654fd6c1c532cf5221710c6c56ec7e21"
        ],
        [
          "34b2ffca05f01088de266306c5cc122661e9308eab16929774e58565afc0e4eb",
          "7662faf0f70e82c062c2b835fc6da3353d3cb20b80611ffa6ef2982cf62fa605"
        ],
        [
          "820fcb51326f1536ddb8dc1052aa198406c7e48f2c81e7664d15f8f9d3715e",
          "756574c23bb01170b97d9fa1663a8ff2f5b97eaa5cd53f34140c1bcec8c262d9"
        ],
        [
          "0861d7e84cec6d6e33641ff6c85202fc0e9160797809ddc2193802499caf05d3",
          "34936e0a5dc7e2a6217d475fbb8c1c607fb8b3565908a04fd5948abdd399c59f"
        ],
        [
          "5b4a1dc887ef684d7b4b165b70acb70842a2fa105935af15ecb4a097e33b8f2b",
          "54d21511c05805e5298a72372b8289e9d59c46dc8b5c368bbfda620b68aa652c"
        ],
        [
          "755493ed60b13f03f9c019362a5af73fb49842dd6916e2572b1b6a312cd20cfc",
          "0750bcbf7e449cec422b93ace1489e1b177d4dbbaa781d315c74d54bb444e9a9"
        ],
        [
          "5f1c341065b6a81ed2edb6bc38ba81b4c2e3fe2058e5baa13e1406eb2c5b4b4b",
          "6179ebfa7f8086f26820fc99ca2f94c1be19bca672d79cea5b02a836119e06ba"
        ],
        [
          "1915024ee86acfba3f61ced9707521197195166fb1c4639bf3b3fcf0bf0ded46",
          "5f2e0547032221d2b00937cf524590e3d90901ef0286ea0b032c1a81461b6d92"
        ],
        [
          "4e942d95930f38c8786ff4a8e576e7a29fb7627afe1fff91cda5006ba0624f5d",
          "45902f695d512d70ce4c1e0520c0060896b94e14d2960b2fcf2ed5e138e0217b"
        ],
        [
          "63e45f3d91ab915d412bbaa17d1d249e1a1445077fbfaa6be7d35041c5116a91",
          "46dad5a4ec2ad0b86938f5e09f1c03b53b660fc5137648b08527cd20708003da"
        ],
        [
          "5e2ddd2175417f72c9962c503ac5adf94ed11f28b9d41fccb6a4512886f3cc87",
          "3523b218478911145af1dc431feb7db0a04066eb6e2ade3c7b67d11bc55323aa"
        ],
        [
          "62ff30a6b179a26e7247a8312cb3af3289e5d722f76a29f203aa623889aa05ec",
          "562beb7999019346beaa80dfd5b95d614e1ff96c1cb1037f65c44997b797d066"
        ],
        [
          "14988b5d62084fb8335c2f261cdeddc1b634b09cedfce713ff5f0a0bb588a556",
          "447068731fb98e821b8e413b3b48f2d1c8bea308f05aac877006b0f4c3b0cab3"
        ],
        [
          "1ac777f708a5942cc434236920e82ccc6af920c0a0676712255aa7082b37a5b6",
          "52a6f88d92af1887c781501c6e3a88169a2831b74aefd416f22b47e8335ce317"
        ],
        [
          "5959792833b71bd5042b78e42212af671f5f87a08eafd8cdde2dcec8140e4bb3",
          "41ce94633eabb8a1b08fac66f762997ed8c9e2af3558e1f6586ad6a5bf5b7b64"
        ],
        [
          "4464a7962e6722b457336fe98c91765b1ff178f9e892e90129e65fa7688a0607",
          "3d1510b92fd33c501f058a7a86bddedf1b83f9b6e4f04829d321117013f891fe"
        ],
        [
          "62906d81e7f800e662519f4324ab4c8aac197661c729eed3e744d09efe721c08",
          "4b68efb5b1b709ab86e3253d70bee87ba07875c04a64ecf7e35cd8cdc6c0f7d8"
        ],
        [
          "4300ff025ac78ef36e58ee7d0d732cf76cd0929fe265b3a093a57f23fc326757",
          "2f92880570846ff2e90d91f16bce3705c9c3ca8011cc543091463b623e4b3c01"
        ],
        [
          "5427ba28d94652527a9b0c76f57a451e46bdc06cbc8a2481df17f66ffb1524e3",
          "547a97c4afc8d1f74a5d51f7e524f68472f589cc0b396b21368628721537d722"
        ],
        [
          "424c4493810bfd5e3ffa21776326d8ff62bf8fe74504d7a2db5d3f74e5ce1015",
          "74d0daa832d40405d01551a58b330ffc5abd5356230d6d7cabeb5b1a55046f32"
        ],
        [
          "54e10980d81b4ae8778896684295fa5c5475e8d68ec2a26e1b0a65383507b3cd",
          "6b1eb48da6886c4d88cea720e9dc8b0d8c51a8f0e1943afa31a40eeb553c0676"
        ],
        [
          "732eb9e9ebb556e9f024c5574166738f4707b0fd005f568212ab575c1db71ddb",
          "1fc6b00c89e48114d6b13d9920a0c78093994f2b08df147bdbb56bead2cea165"
        ],
        [
          "74029c04b34b7f314855fee42a04d0ddfdeb92ef3bf7cff629928a97733d96fb",
          "501f63a252dfbc090733b5a208bfe08f81c91419ce3d2d6c0de8cdc5a5625014"
        ],
        [
          "04524402ebb71a60bf1055001000203a6d4917f112e50dd766cdd7b718a6edd7",
          "71c9e2d15cdc47c565a696ffbe55277570930ed7ade13b9a254059365d5bf338"
        ],
        [
          "2555c620a50f2bbeeacac66228a96941fa733aa6070855331613578ed7c12794",
          "2b3c1bc5cda7f93242561dbf7572237ac43bf013553230633a5e18b7e71597e5"
        ],
        [
          "555ea607b0ad18afaf70d7450543d7ffb5b883a3cad3e2778826ca97bf3211a6",
          "6df903158f51aa530d411720a760f8ad0ce9904d54955fda74a349be58eddf5f"
        ],
        [
          "4db3cfa284207a250a9c83e1fec07e804d70065da586ff2c2a7d2bcb92e6fca6",
          "2a4fbf1c51dc0b2a7783db2be3bd35c2d6462470c88c8b73ae3ce8503fa07154"
        ],
        [
          "5174e33ffdf28a87184a4d6427d821cbaa3b88ac293a90ca7e1eeae8c5050b16",
          "315ca6bc8e35e4a3d06f89e1db1575b16197963ee8e64746fa998ccd403561cc"
        ]
      ]
    },
    doubles: {
      step: 4,
      points: [
        [
          "23a4860627e53aeeb8e22b1508249c9109578d33e7bf237459b2596d6c28f9f8",
          "709696f2827fc3729f980f2e3aad6e78b06a11ff8e079c27d87aab37c16727eb"
        ],
        [
          "5e7e07ed4e1decbfe6e9cbc126905449d4b578fbb561576d20b8bcdd0cc2a556",
          "0f55755c51f102796bf5ebaa81d3260e7d1b3d9ac127d9a80e142031566cf6c7"
        ],
        [
          "7d13c0248b891b47eb524f2692008e2f97b199bac426cb5902b9003a29ded6ea",
          "59a976ab2c01a81a91f1a56c75ccc77a9e1e9e878e9fe9c3952080a6805b20d5"
        ],
        [
          "5de7faa2ee4e70132f541f79ca07cd54a39fe1347a6844d19e9d678a8411a565",
          "2c9f23641e1c2e0aab8ea9926b432d92c0e8bc08901d6ff6df85e4cef854ec36"
        ],
        [
          "06b349eebfed4dad4a805b63a6ed2231a565cda752d9477ff427dd9a8c9ab5ed",
          "07a09289ff3e1f9aab68aa374c48df65f550c2323607b97744dee990608b64f8"
        ],
        [
          "0af367956af630266b1cc760154256ed79da960dddca9d72a1e8cf27d8d43a77",
          "21108d900134d3b3708dd28ace96b0b23dda9100e4b6a62a8131bd2f2ba408c5"
        ],
        [
          "1e45a60140a3b2dee9b8dc6ff307154a1b410bcd38e0e38fb10b2f6da1afbe2b",
          "0e730da473dffd60d2f3241a85e68acb47d26e5043ad047d893f072c8dda0a76"
        ],
        [
          "4d1e116d136158c5ddabd4276832800f2c081c1072de6f2d931797a46abc0cbb",
          "6d415be49d4e35b65cc51354b5008f8c43e84b7b5e8a4b84f44e1efb10c9b91a"
        ],
        [
          "2b6b892ae94b454b2c2d92bb947fc4d506d173d281779c2c153c001ded42d3d0",
          "7f1cf64e0e180fc4d6e12c1b5c5285f376e979616a52c94a0dea4d48c5880cd2"
        ],
        [
          "0f6c3a96e0032a9394337a02ffb2c83ba70efb8f566feab530fc90fa3b4710e5",
          "3d4e97e286378675038a4b58e84224ee515e1d6697ac79389f78479be167635a"
        ],
        [
          "52ee53b981dfbc41ddaa5ddc2754c4175f4811aa45f8e2b19a425657c238a83e",
          "7eb0a1be3400dec87b388cad51613957643cdf0595b891cc6f925fb36da7f1c3"
        ],
        [
          "52a837bc7a7bc9459bcc2ecf80f74d9ed99def0342e18cfbe8e799fbc504fd52",
          "50d6460185d8924e5485f23f36a98c86053514d163547adab6fe91478a411196"
        ],
        [
          "6b2bd5d00fab38ceca21a27d6aaec82626b14b555d859527718f8ca404eba4",
          "727340c27a15f6ab3d80547f0827c56ab1ba33bc30d1ef3909ea9a3af10c67e5"
        ],
        [
          "71dd75fe35761c01a48597ec730bc33237902fd4ad8612cbed1031eebdf40de4",
          "39674a4532078e34378667beae5cb55f814ead9bbaf7e01b3b69533e9f88a411"
        ],
        [
          "57426aefc21be9ccf162e23d25ac3002ba8534351e65613f870f690f2fd46cf5",
          "6b45b002fb4e8a6f59a6ffb006ed71f75434217333b266325204c7d1ac2e1f34"
        ],
        [
          "6222bd88bf2df9d5d44b60cfb4a08a960078db7ed51a35eb3e0b6b8ff4eda202",
          "0325bb42ea4ed025dd6bdaed261b7c4f5410b608ba902b068f1efa5782e45313"
        ],
        [
          "71ac99647b61b9eca6f0c23432a518f738aee708d5932d4ef0f172240250a226",
          "3a96c2c028ebe5f48913be30147e41bc5e1cab9595d5404138a9aa1b5574cf25"
        ],
        [
          "1f6a1fd8cc0e05b2742ba0fc0369b5247670543637dd033e64dbce90b2f23e9f",
          "779964401ee869a9b31c0ef874a86440ba85d25c2ce932bd31a0865869605e19"
        ],
        [
          "22e2c039067920c42980dcb3a905fc91601c2b34e819ce1532ada4a5fc39d5cc",
          "631cf9945a09bf26d7e595b3f8e3390696870512820df63c5418577089e1a8bb"
        ],
        [
          "608de273a9f6a534219d7aaede3cf65a81e4dc03d7a2765eced1d2b7be4610f4",
          "3b31d0113f98d81ab1312fb2837aa9c8dcc7960f84eb371358c6d841f67144fa"
        ],
        [
          "3f748617ca63ab3e44c6e34f63e7328ea56a2a146da34368a57dca181254fe02",
          "0fed89e6420fc47b3938a2891ba9acee4cbb2899ee4e9ca15a13dc527dc1641e"
        ],
        [
          "69d98b5ecc35d56c97c0bf312955d199befe116b417d70f5f57e2dfd0af81ce5",
          "3e26d487fbfe36ab44e0ca3b248fe94bce92a69b8154d50e2d5481f8259f4e8e"
        ],
        [
          "1e34443347f9e627b3531157faab6eaca1bc3114df4a1423cc12bf8417b5d622",
          "295955a5ed061eca7f87b9485666ba9489ec20a9c484224dc920350bb4a6fc79"
        ],
        [
          "51f4ff8c599b1c96da82941520a9f5abf4a31eb8b84fc95056145ceb3b5775d0",
          "35ac9588d46e41f3f6f99aee3852eeb4b12e807807d4bd1b7f8406b0d7863ac1"
        ],
        [
          "3faa2a093a19a02424f65a10955101f4dc015c43b2dfce8e001507abd741b845",
          "7a1de10dacfda389ca663b15574bdc8ae8c5b6e7cee647e77b11ddbfc6eb8edc"
        ],
        [
          "1924416956ea2c1269062588569b18178011ea7cba1a3266284f48aa01d5a90f",
          "0c8e28127b7dcdd206fb6fee96eb88cfc7db7319826ac8cdb8b1fb8adaf021de"
        ],
        [
          "49761c57ce3c8c4f1435d495903e2f536f3be3712e76af8d0b5a8b7d1ebc8fac",
          "3225035e1065094ef32d7f3e7a6f8ff2748025f96e0c0b44eb35576b61e150a8"
        ],
        [
          "4339fa86a23242851a16afc3ab05b352a7b4bf53599a49dd7e29d364fc3a757b",
          "6d07cc3462bae9160bbebb997510817040767faa9dbd13f158a5fe8a63a34b0e"
        ],
        [
          "6bda13918dcbaf8529d6326ae7a9c278b72417c2188c5ea4f062fc50639295fb",
          "2c3fa803b162ee887d0d97a6734866f992f846625f314117075da54bb6c20a36"
        ],
        [
          "4da4821314574d4fed4dcf692c8b15b99b73f13633210333ce7871359b6e6424",
          "314016034673d2d20529bc93a2dab6e462bcb5f66e1f4a6bf2170759a40a6e65"
        ],
        [
          "0b2cea0029ee963c0034b61bf19e384435f14554a7d297b5144838c38e375586",
          "47ea95da28d39aaade5edb8ed941c687603cfdd1508776e96d6683199e99daea"
        ],
        [
          "4c27afff3c45f32c952d3984e14e29a098e685c9c2e723e5fc8047ae60b7e824",
          "5f2c99e6526dc87d95f11eb626c29c3a90d0be1e51a4c49e5bbabd114bf5a66b"
        ],
        [
          "53e2a4ed1bbb48bd016c524a02f797654cfc969849f867681da94e341f377534",
          "5a2334fdda642732a3c9520ce06581aa7f0f082882554c37b8d390a25a9bd559"
        ],
        [
          "7b8d2c823baafe0d878a55e8af1db150dec85b1424a4901f9beffd3a6196e3d6",
          "1c45a557b3624f9b89ed15b3c3e1a065f1b453d948f7cf45d9494483f8af0c85"
        ],
        [
          "78877b5d8777410997dacaeea59400fc9db4421fac02c4282301c67d35fb7ffe",
          "0341b46c328333e4484ce8607619014d41775c408c88856d2f9e19812d90fbf5"
        ],
        [
          "2b556bbc070b5c4bae9e575836d1d68ee9fbe800448c0d2c233f78185eed3f91",
          "7ba01332807ebd892e00ddb368c0fa1b3f19b5b32efd90b178d984e1d7174d6f"
        ],
        [
          "0f72556998b0044799f0fd03210ded3d984e3843bbaf3c1d5d692bc94d43c4e7",
          "16c19c5037c103d447caef4efe6bd81a490e7c668f6870f1b080863b5315df5e"
        ],
        [
          "1cd96ef237b213cd446f13b3ec40d32ecc593bc6ea71e77efc284341a5f3da1a",
          "7a626aeb91efcb5f9777264f5e17ced8b411f68c713673ef0f184a5ccd60dbe3"
        ],
        [
          "31a75b21cb532622a7caf9e29e652ac4e47b1450edf6655acaf3797b55a7ca46",
          "77006e7cf104982f8865081a2ff8a6911546755e31c3586353b0bd0826c5d790"
        ],
        [
          "543d84cb04fb2bf787b7aa382eaab5cd8d050ad8ee52aa8a285b945652014031",
          "0358fdc5b63ed49e693d838f182b275846f42dd49a42ec2e6e932ba4de59ef20"
        ],
        [
          "0a2818f5f5d8937800c30ac6b847db2cdef655b864126302249144a5a15b205a",
          "187c76a49af10851bb049ba97c0fbbb14b2621522a4e8d9670ea46e56c9a1bd6"
        ],
        [
          "7efb45d3a2851109d7a8d50ddb08fe308bbf674c019b965cdad4570a141e648a",
          "0fe1198b11a1bf56867091c69d71f8b7792257dda321d43652e818acd0c28cda"
        ],
        [
          "472e960dd122a534f52377235350549df4a1dd7a08cfc580bff5fb4b0a70aa7b",
          "10585d04fc529fef4c0c0776154fc7ebbaedbae8a99937e47598d0578932b7cc"
        ],
        [
          "04892cfff7f94ff7f07c1241e3ac4945bc46ea9d6a3c1c3adbce109a9afceb6a",
          "3ae2aa25e2555135a7a3251c11a3f8eebe81758bc1c3e2cbc6e6ca461a543130"
        ],
        [
          "2401d311a3abfd2583f1c6aa519c1f18ff730a0abf730ddcc9c9739b04d8a85e",
          "653224f3488cae1ae19a414a9932035a2bf2c46803b5532bbb645e62387ee34d"
        ],
        [
          "0ea2c846a535a115972161612a192588d92d68a3c9050eae91b2817b94e68325",
          "3b82a8337b05f11bbac176a113be183a50a0331f3d3116f24b971b5a8b0d031b"
        ],
        [
          "0fb3f87c2c6c89c65b74299b77f3736546a8b9e41b19197476bff27354e1c128",
          "1034d42c15a2bfe3e682fad49dbc2812caadf0c584bc30b51625b85d74e9d5f7"
        ],
        [
          "1bc7af1e38185e7c2d8d04371c7e177d7a9ddee1b81d7d26db7ad644c7dad28d",
          "61d909d855661f2f7a5eef87795dc0491d027e12631b270fcaf2f65900314833"
        ],
        [
          "469d0960dbd0ef9c91c4597ccf7c209549b187ff63bd378b7dac577198d74a4d",
          "0b5f21c7f86832241f2157c288bdc9394f83f8d57457f6d9f6b345e4909478cb"
        ],
        [
          "5e9ac4ab2f4a3c3526e1317f913d69e3826fe862efd0c80d9310319170c5cbeb",
          "505f00fa8aee03ccbd2f33529ae1e4e4bcf2644fe673d0b0290ec32be5b51bab"
        ],
        [
          "11cd80e1fdcbc565efed81d17f3f54643ffeed1cff38f3825e115adbd82759f1",
          "43f11943f7ef3fa68b980fee45e98134f1df22263b2d14419d61ffe62822dbe0"
        ],
        [
          "3328bc121616a9477165ed282053d203c24f4826076c638a2c6723d42c9bfadb",
          "2bbf3f26c21b5cb273e5f4f0114c6718c5eb7291939b7697c74333cdfafac039"
        ],
        [
          "0ba774bb605dd804cae6887e81f6bd2c59e024fac8bf5f5c48a841a037c28398",
          "54ba013ad2d04dcdfb5a151b7347ee9a10067ddd0a3907e9bc337a77bf911321"
        ],
        [
          "1074ff0267662dc2b4ce65aaa0229c375a3d0d843ce9349233949581c869b64c",
          "299be0decb680ec28923da4d049770107d42c180b460da13a7b1efc7e6d5b022"
        ],
        [
          "25ed76d78c87c3bd64b4331902c5a853734283e25f19f320295667b80a340d35",
          "179b5f92f545c7b326b3a63fb0b32a0f52b4159988436d5af50c1d0d76373947"
        ],
        [
          "75d942c04210dcde5d1bd4fabfc732d3f95568e399382c0423c83c41cb05dc3f",
          "696cc14856cdc13c8fd7e2c5771731cbf38e3fad47a424679765c4874e35ab2d"
        ],
        [
          "5d9324f56975477d5945599eeeccec67708c996cd3f3f2818bf2591507e3502a",
          "10985a3cfd573205281aec24e2c8b41f5cd8cdfc9d7be34675cf306bbe1b4f6a"
        ],
        [
          "7511066c0e12105a7b937c7ecef367d5afe6e621e5cabf4e490b09b7ada7ee07",
          "604df365b8391cbca8848f88daa700b770da5bb136f70bfb0a3ea33ba386fcd5"
        ],
        [
          "2596e5b3cf5494e60d2a750d03c66abc2e0183af53620b893f9cf9fc3b76dc26",
          "68a0a7ac9a0cc093884a6b84f45a2cde595194e0f48dbd566fa78a3174b182fe"
        ],
        [
          "28bd38d44030dd9ca028b2a2f31a795f4c7a5e85a785df7847e3d525e99d4787",
          "552dd7405c4183733ad3c4e7ccb999b4fed81b7a4444aab499d41d6d78d5bbfc"
        ],
        [
          "59233a3346f61135f431f96cf0197e24ad38240b222c010a6ce538cf4c24347b",
          "3cce55908611d2b93f221613f09cfc4dbcd2e2b609233eea5439ad1908a10b20"
        ],
        [
          "5830f025f1078d408948f73096af97de1e9e70b3be85890acb21132c34ff961f",
          "67d451752c2433ffe66e47242e301e56db2b2f8203553cab9de717e25793d41e"
        ],
        [
          "6a0c8b194571e874b82d904da36d43096bbe36d512e24ff8dcb2b00b57ffd3ec",
          "5f85adb7749cc735ec838bcccfe7d4b52902c6132998d7ac8e032cad031c42b8"
        ],
        [
          "53b3f967bff8760948dec5e9282f35d1434a5503790b9012e17faefbe7c4d699",
          "404462283c8664a17daa5b4059dcd10e2699fd86d0140de9f3e8ad0566098ae5"
        ]
      ]
    }
  };
});

// node_modules/bcrypto/lib/js/x25519.js
var require_x25519 = __commonJS((exports2, module2) => {
  /*!
   * x25519.js - x25519 for bcrypto
   * Copyright (c) 2018-2019, Christopher Jeffrey (MIT License).
   * https://github.com/bcoin-org/bcrypto
   *
   * Resources:
   *   https://en.wikipedia.org/wiki/Curve25519
   *   https://cr.yp.to/ecdh/curve25519-20060209.pdf
   *   https://tools.ietf.org/html/rfc7748#section-5
   */
  "use strict";
  var ECDH = require_ecdh();
  var pre = require_ed255193();
  module2.exports = new ECDH("X25519", "ED25519", pre);
});

// node_modules/is-buffer/index.js
var require_is_buffer = __commonJS((exports2, module2) => {
  /*!
   * Determine if an object is a Buffer
   *
   * @author   Feross Aboukhadijeh <https://feross.org>
   * @license  MIT
   */
  module2.exports = function isBuffer(obj) {
    return obj != null && obj.constructor != null && typeof obj.constructor.isBuffer === "function" && obj.constructor.isBuffer(obj);
  };
});

// node_modules/it-pb-rpc/src/index.js
var require_src48 = __commonJS((exports2, module2) => {
  "use strict";
  var isBuffer = require_is_buffer();
  var Shake = require_src42();
  var lp = require_src37();
  module2.exports = (duplex, opts = {}) => {
    const shake = Shake(duplex);
    const lpReader = lp.decode.fromReader(shake.reader, opts);
    let isDone = false;
    const W = {
      read: async (bytes) => {
        const {value, done} = await shake.reader.next(bytes);
        if (done && value.length < bytes) {
          throw new Error("Couldn't read enough bytes");
        }
        isDone = done;
        if (!value) {
          throw new Error("Value is null");
        }
        return value;
      },
      readLP: async () => {
        const {value, done} = await lpReader.next();
        isDone = done;
        if (!value) {
          throw new Error("Value is null");
        }
        return value;
      },
      readPB: async (proto) => {
        const value = await W.readLP();
        if (!value) {
          throw new Error("Value is null");
        }
        const buf = isBuffer(value) ? value : value.slice();
        return proto.decode(buf);
      },
      write: (data) => {
        shake.writer.push(data);
      },
      writeLP: (data) => {
        W.write(lp.encode.single(data, opts));
      },
      writePB: (data, proto) => {
        W.writeLP(proto.encode(data));
      },
      pb: (proto) => {
        return {
          read: () => W.readPB(proto),
          write: (d) => W.writePB(d, proto)
        };
      },
      unwrap: () => {
        shake.rest();
        return shake.stream;
      }
    };
    return W;
  };
});

// node_modules/it-pair/index.js
var require_it_pair = __commonJS((exports2, module2) => {
  "use strict";
  var getIterator = require_get_iterator();
  module2.exports = function pair() {
    let _source, onSource;
    const sink = async (source2) => {
      if (_source)
        throw new Error("already piped");
      _source = getIterator(source2);
      if (onSource)
        onSource(_source);
    };
    const source = {
      [Symbol.asyncIterator]() {
        return this;
      },
      next() {
        if (_source)
          return _source.next();
        return new Promise((resolve) => {
          onSource = (source2) => {
            onSource = null;
            resolve(source2.next());
          };
        });
      }
    };
    return {sink, source};
  };
});

// node_modules/it-pair/duplex.js
var require_duplex3 = __commonJS((exports2, module2) => {
  var Pair = require_it_pair();
  module2.exports = function() {
    var a = Pair();
    var b = Pair();
    return [
      {
        source: a.source,
        sink: b.sink
      },
      {
        source: b.source,
        sink: a.sink
      }
    ];
  };
});

// node_modules/bcrypto/lib/js/hkdf.js
var require_hkdf = __commonJS((exports2) => {
  /*!
   * hkdf.js - hkdf for bcrypto
   * Copyright (c) 2014-2019, Christopher Jeffrey (MIT License).
   * https://github.com/bcoin-org/bcrypto
   *
   * Resources:
   *   https://en.wikipedia.org/wiki/HKDF
   *   https://tools.ietf.org/html/rfc5869
   */
  "use strict";
  var assert = require_assert2();
  function extract(hash, ikm, salt) {
    assert(hash && typeof hash.id === "string");
    if (ikm == null)
      ikm = Buffer.alloc(0);
    if (salt == null)
      salt = Buffer.alloc(hash.size, 0);
    return hash.mac(ikm, salt);
  }
  function expand(hash, prk, info, len) {
    if (info == null)
      info = Buffer.alloc(0);
    assert(hash && typeof hash.id === "string");
    assert(Buffer.isBuffer(prk));
    assert(Buffer.isBuffer(info));
    assert(len >>> 0 === len);
    if (prk.length !== hash.size)
      throw new RangeError("Invalid PRK length.");
    const blocks = Math.ceil(len / hash.size);
    if (blocks > 255)
      throw new RangeError("Invalid output length.");
    const out = Buffer.alloc(blocks * hash.size);
    const ctr = Buffer.from([0]);
    const mac = hash.hmac();
    let prev = Buffer.alloc(0);
    let pos = 0;
    for (let i = 0; i < blocks; i++) {
      ctr[0] += 1;
      mac.init(prk);
      mac.update(prev);
      mac.update(info);
      mac.update(ctr);
      prev = mac.final();
      pos += prev.copy(out, pos);
    }
    return out.slice(0, len);
  }
  function derive(hash, ikm, salt, info, len) {
    const prk = extract(hash, ikm, salt);
    return expand(hash, prk, info, len);
  }
  exports2.native = 0;
  exports2.extract = extract;
  exports2.expand = expand;
  exports2.derive = derive;
});

// node_modules/bcrypto/lib/hkdf-browser.js
var require_hkdf_browser = __commonJS((exports2, module2) => {
  /*!
   * hkdf.js - hkdf for bcrypto
   * Copyright (c) 2017-2019, Christopher Jeffrey (MIT License).
   * https://github.com/bcoin-org/bcrypto
   */
  "use strict";
  module2.exports = require_hkdf();
});

// node_modules/bcrypto/lib/internal/hmac.js
var require_hmac3 = __commonJS((exports2, module2) => {
  /*!
   * hmac.js - hmac for bcrypto
   * Copyright (c) 2016-2019, Christopher Jeffrey (MIT License).
   * https://github.com/bcoin-org/bcrypto
   *
   * Parts of this software are based on indutny/hash.js:
   *   Copyright (c) 2014, Fedor Indutny (MIT License).
   *   https://github.com/indutny/hash.js
   *
   * Resources:
   *   https://en.wikipedia.org/wiki/HMAC
   *   https://tools.ietf.org/html/rfc2104
   *   https://github.com/indutny/hash.js/blob/master/lib/hash/hmac.js
   */
  "use strict";
  var assert = require_assert2();
  var HMAC = class {
    constructor(Hash, size, x = [], y = []) {
      assert(typeof Hash === "function");
      assert(size >>> 0 === size);
      assert(Array.isArray(x));
      assert(Array.isArray(y));
      this.hash = Hash;
      this.size = size;
      this.x = x;
      this.y = y;
      this.inner = new Hash();
      this.outer = new Hash();
    }
    init(key) {
      assert(Buffer.isBuffer(key));
      if (key.length > this.size) {
        const Hash = this.hash;
        const h = new Hash();
        h.init(...this.x);
        h.update(key);
        key = h.final(...this.y);
        assert(key.length <= this.size);
      }
      const pad = Buffer.alloc(this.size);
      for (let i = 0; i < key.length; i++)
        pad[i] = key[i] ^ 54;
      for (let i = key.length; i < pad.length; i++)
        pad[i] = 54;
      this.inner.init(...this.x);
      this.inner.update(pad);
      for (let i = 0; i < key.length; i++)
        pad[i] = key[i] ^ 92;
      for (let i = key.length; i < pad.length; i++)
        pad[i] = 92;
      this.outer.init(...this.x);
      this.outer.update(pad);
      return this;
    }
    update(data) {
      this.inner.update(data);
      return this;
    }
    final() {
      this.outer.update(this.inner.final(...this.y));
      return this.outer.final(...this.y);
    }
  };
  module2.exports = HMAC;
});

// node_modules/bcrypto/lib/js/sha256.js
var require_sha2562 = __commonJS((exports2, module2) => {
  /*!
   * sha256.js - SHA256 implementation for bcrypto
   * Copyright (c) 2016-2019, Christopher Jeffrey (MIT License).
   * https://github.com/bcoin-org/bcrypto
   *
   * Parts of this software are based on indutny/hash.js:
   *   Copyright (c) 2014, Fedor Indutny (MIT License).
   *   https://github.com/indutny/hash.js
   *
   * Resources:
   *   https://en.wikipedia.org/wiki/SHA-2
   *   https://tools.ietf.org/html/rfc4634
   *   https://github.com/indutny/hash.js/blob/master/lib/hash/sha/256.js
   */
  "use strict";
  var assert = require_assert2();
  var HMAC = require_hmac3();
  var FINALIZED = -1;
  var DESC = Buffer.alloc(8, 0);
  var PADDING = Buffer.alloc(64, 0);
  PADDING[0] = 128;
  var K = new Uint32Array([
    1116352408,
    1899447441,
    3049323471,
    3921009573,
    961987163,
    1508970993,
    2453635748,
    2870763221,
    3624381080,
    310598401,
    607225278,
    1426881987,
    1925078388,
    2162078206,
    2614888103,
    3248222580,
    3835390401,
    4022224774,
    264347078,
    604807628,
    770255983,
    1249150122,
    1555081692,
    1996064986,
    2554220882,
    2821834349,
    2952996808,
    3210313671,
    3336571891,
    3584528711,
    113926993,
    338241895,
    666307205,
    773529912,
    1294757372,
    1396182291,
    1695183700,
    1986661051,
    2177026350,
    2456956037,
    2730485921,
    2820302411,
    3259730800,
    3345764771,
    3516065817,
    3600352804,
    4094571909,
    275423344,
    430227734,
    506948616,
    659060556,
    883997877,
    958139571,
    1322822218,
    1537002063,
    1747873779,
    1955562222,
    2024104815,
    2227730452,
    2361852424,
    2428436474,
    2756734187,
    3204031479,
    3329325298
  ]);
  var SHA256 = class {
    constructor() {
      this.state = new Uint32Array(8);
      this.msg = new Uint32Array(64);
      this.block = Buffer.alloc(64);
      this.size = FINALIZED;
    }
    init() {
      this.state[0] = 1779033703;
      this.state[1] = 3144134277;
      this.state[2] = 1013904242;
      this.state[3] = 2773480762;
      this.state[4] = 1359893119;
      this.state[5] = 2600822924;
      this.state[6] = 528734635;
      this.state[7] = 1541459225;
      this.size = 0;
      return this;
    }
    update(data) {
      assert(Buffer.isBuffer(data));
      this._update(data, data.length);
      return this;
    }
    final() {
      return this._final(Buffer.alloc(32));
    }
    _update(data, len) {
      assert(this.size !== FINALIZED, "Context is not initialized.");
      let pos = this.size & 63;
      let off = 0;
      this.size += len;
      if (pos > 0) {
        let want = 64 - pos;
        if (want > len)
          want = len;
        data.copy(this.block, pos, off, off + want);
        pos += want;
        len -= want;
        off += want;
        if (pos < 64)
          return;
        this._transform(this.block, 0);
      }
      while (len >= 64) {
        this._transform(data, off);
        off += 64;
        len -= 64;
      }
      if (len > 0)
        data.copy(this.block, 0, off, off + len);
    }
    _final(out) {
      assert(this.size !== FINALIZED, "Context is not initialized.");
      const pos = this.size & 63;
      const len = this.size * 8;
      writeU32(DESC, len * (1 / 4294967296) >>> 0, 0);
      writeU32(DESC, len >>> 0, 4);
      this._update(PADDING, 1 + (119 - pos & 63));
      this._update(DESC, 8);
      for (let i = 0; i < 8; i++) {
        writeU32(out, this.state[i], i * 4);
        this.state[i] = 0;
      }
      for (let i = 0; i < 64; i++)
        this.msg[i] = 0;
      for (let i = 0; i < 64; i++)
        this.block[i] = 0;
      this.size = FINALIZED;
      return out;
    }
    _transform(chunk, pos) {
      const W = this.msg;
      let a = this.state[0];
      let b = this.state[1];
      let c = this.state[2];
      let d = this.state[3];
      let e = this.state[4];
      let f = this.state[5];
      let g = this.state[6];
      let h = this.state[7];
      let i = 0;
      for (; i < 16; i++)
        W[i] = readU32(chunk, pos + i * 4);
      for (; i < 64; i++)
        W[i] = sigma1(W[i - 2]) + W[i - 7] + sigma0(W[i - 15]) + W[i - 16];
      for (i = 0; i < 64; i++) {
        const t1 = h + Sigma1(e) + Ch(e, f, g) + K[i] + W[i];
        const t2 = Sigma0(a) + Maj(a, b, c);
        h = g;
        g = f;
        f = e;
        e = d + t1 >>> 0;
        d = c;
        c = b;
        b = a;
        a = t1 + t2 >>> 0;
      }
      this.state[0] += a;
      this.state[1] += b;
      this.state[2] += c;
      this.state[3] += d;
      this.state[4] += e;
      this.state[5] += f;
      this.state[6] += g;
      this.state[7] += h;
    }
    static hash() {
      return new SHA256();
    }
    static hmac() {
      return new HMAC(SHA256, 64);
    }
    static digest(data) {
      return SHA256.ctx.init().update(data).final();
    }
    static root(left, right) {
      assert(Buffer.isBuffer(left) && left.length === 32);
      assert(Buffer.isBuffer(right) && right.length === 32);
      return SHA256.ctx.init().update(left).update(right).final();
    }
    static multi(x, y, z) {
      const {ctx} = SHA256;
      ctx.init();
      ctx.update(x);
      ctx.update(y);
      if (z)
        ctx.update(z);
      return ctx.final();
    }
    static mac(data, key) {
      return SHA256.hmac().init(key).update(data).final();
    }
  };
  SHA256.native = 0;
  SHA256.id = "SHA256";
  SHA256.size = 32;
  SHA256.bits = 256;
  SHA256.blockSize = 64;
  SHA256.zero = Buffer.alloc(32, 0);
  SHA256.ctx = new SHA256();
  function Sigma0(x) {
    return (x >>> 2 | x << 30) ^ (x >>> 13 | x << 19) ^ (x >>> 22 | x << 10);
  }
  function Sigma1(x) {
    return (x >>> 6 | x << 26) ^ (x >>> 11 | x << 21) ^ (x >>> 25 | x << 7);
  }
  function sigma0(x) {
    return (x >>> 7 | x << 25) ^ (x >>> 18 | x << 14) ^ x >>> 3;
  }
  function sigma1(x) {
    return (x >>> 17 | x << 15) ^ (x >>> 19 | x << 13) ^ x >>> 10;
  }
  function Ch(x, y, z) {
    return z ^ x & (y ^ z);
  }
  function Maj(x, y, z) {
    return x & y | z & (x | y);
  }
  function readU32(data, off) {
    return data[off++] * 16777216 + data[off++] * 65536 + data[off++] * 256 + data[off];
  }
  function writeU32(data, num, off) {
    data[off++] = num >>> 24;
    data[off++] = num >>> 16;
    data[off++] = num >>> 8;
    data[off++] = num;
    return off;
  }
  module2.exports = SHA256;
});

// node_modules/@protobufjs/aspromise/index.js
var require_aspromise = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = asPromise;
  function asPromise(fn, ctx) {
    var params = new Array(arguments.length - 1), offset = 0, index = 2, pending = true;
    while (index < arguments.length)
      params[offset++] = arguments[index++];
    return new Promise(function executor(resolve, reject) {
      params[offset] = function callback(err) {
        if (pending) {
          pending = false;
          if (err)
            reject(err);
          else {
            var params2 = new Array(arguments.length - 1), offset2 = 0;
            while (offset2 < params2.length)
              params2[offset2++] = arguments[offset2];
            resolve.apply(null, params2);
          }
        }
      };
      try {
        fn.apply(ctx || null, params);
      } catch (err) {
        if (pending) {
          pending = false;
          reject(err);
        }
      }
    });
  }
});

// node_modules/@protobufjs/base64/index.js
var require_base64 = __commonJS((exports2) => {
  "use strict";
  var base64 = exports2;
  base64.length = function length(string) {
    var p = string.length;
    if (!p)
      return 0;
    var n = 0;
    while (--p % 4 > 1 && string.charAt(p) === "=")
      ++n;
    return Math.ceil(string.length * 3) / 4 - n;
  };
  var b64 = new Array(64);
  var s64 = new Array(123);
  for (var i = 0; i < 64; )
    s64[b64[i] = i < 26 ? i + 65 : i < 52 ? i + 71 : i < 62 ? i - 4 : i - 59 | 43] = i++;
  base64.encode = function encode(buffer, start, end) {
    var parts = null, chunk = [];
    var i2 = 0, j = 0, t;
    while (start < end) {
      var b = buffer[start++];
      switch (j) {
        case 0:
          chunk[i2++] = b64[b >> 2];
          t = (b & 3) << 4;
          j = 1;
          break;
        case 1:
          chunk[i2++] = b64[t | b >> 4];
          t = (b & 15) << 2;
          j = 2;
          break;
        case 2:
          chunk[i2++] = b64[t | b >> 6];
          chunk[i2++] = b64[b & 63];
          j = 0;
          break;
      }
      if (i2 > 8191) {
        (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
        i2 = 0;
      }
    }
    if (j) {
      chunk[i2++] = b64[t];
      chunk[i2++] = 61;
      if (j === 1)
        chunk[i2++] = 61;
    }
    if (parts) {
      if (i2)
        parts.push(String.fromCharCode.apply(String, chunk.slice(0, i2)));
      return parts.join("");
    }
    return String.fromCharCode.apply(String, chunk.slice(0, i2));
  };
  var invalidEncoding = "invalid encoding";
  base64.decode = function decode(string, buffer, offset) {
    var start = offset;
    var j = 0, t;
    for (var i2 = 0; i2 < string.length; ) {
      var c = string.charCodeAt(i2++);
      if (c === 61 && j > 1)
        break;
      if ((c = s64[c]) === void 0)
        throw Error(invalidEncoding);
      switch (j) {
        case 0:
          t = c;
          j = 1;
          break;
        case 1:
          buffer[offset++] = t << 2 | (c & 48) >> 4;
          t = c;
          j = 2;
          break;
        case 2:
          buffer[offset++] = (t & 15) << 4 | (c & 60) >> 2;
          t = c;
          j = 3;
          break;
        case 3:
          buffer[offset++] = (t & 3) << 6 | c;
          j = 0;
          break;
      }
    }
    if (j === 1)
      throw Error(invalidEncoding);
    return offset - start;
  };
  base64.test = function test(string) {
    return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(string);
  };
});

// node_modules/@protobufjs/eventemitter/index.js
var require_eventemitter = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = EventEmitter;
  function EventEmitter() {
    this._listeners = {};
  }
  EventEmitter.prototype.on = function on(evt, fn, ctx) {
    (this._listeners[evt] || (this._listeners[evt] = [])).push({
      fn,
      ctx: ctx || this
    });
    return this;
  };
  EventEmitter.prototype.off = function off(evt, fn) {
    if (evt === void 0)
      this._listeners = {};
    else {
      if (fn === void 0)
        this._listeners[evt] = [];
      else {
        var listeners = this._listeners[evt];
        for (var i = 0; i < listeners.length; )
          if (listeners[i].fn === fn)
            listeners.splice(i, 1);
          else
            ++i;
      }
    }
    return this;
  };
  EventEmitter.prototype.emit = function emit(evt) {
    var listeners = this._listeners[evt];
    if (listeners) {
      var args = [], i = 1;
      for (; i < arguments.length; )
        args.push(arguments[i++]);
      for (i = 0; i < listeners.length; )
        listeners[i].fn.apply(listeners[i++].ctx, args);
    }
    return this;
  };
});

// node_modules/@protobufjs/float/index.js
var require_float2 = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = factory(factory);
  function factory(exports3) {
    if (typeof Float32Array !== "undefined")
      (function() {
        var f32 = new Float32Array([-0]), f8b = new Uint8Array(f32.buffer), le = f8b[3] === 128;
        function writeFloat_f32_cpy(val, buf, pos) {
          f32[0] = val;
          buf[pos] = f8b[0];
          buf[pos + 1] = f8b[1];
          buf[pos + 2] = f8b[2];
          buf[pos + 3] = f8b[3];
        }
        function writeFloat_f32_rev(val, buf, pos) {
          f32[0] = val;
          buf[pos] = f8b[3];
          buf[pos + 1] = f8b[2];
          buf[pos + 2] = f8b[1];
          buf[pos + 3] = f8b[0];
        }
        exports3.writeFloatLE = le ? writeFloat_f32_cpy : writeFloat_f32_rev;
        exports3.writeFloatBE = le ? writeFloat_f32_rev : writeFloat_f32_cpy;
        function readFloat_f32_cpy(buf, pos) {
          f8b[0] = buf[pos];
          f8b[1] = buf[pos + 1];
          f8b[2] = buf[pos + 2];
          f8b[3] = buf[pos + 3];
          return f32[0];
        }
        function readFloat_f32_rev(buf, pos) {
          f8b[3] = buf[pos];
          f8b[2] = buf[pos + 1];
          f8b[1] = buf[pos + 2];
          f8b[0] = buf[pos + 3];
          return f32[0];
        }
        exports3.readFloatLE = le ? readFloat_f32_cpy : readFloat_f32_rev;
        exports3.readFloatBE = le ? readFloat_f32_rev : readFloat_f32_cpy;
      })();
    else
      (function() {
        function writeFloat_ieee754(writeUint, val, buf, pos) {
          var sign = val < 0 ? 1 : 0;
          if (sign)
            val = -val;
          if (val === 0)
            writeUint(1 / val > 0 ? 0 : 2147483648, buf, pos);
          else if (isNaN(val))
            writeUint(2143289344, buf, pos);
          else if (val > 34028234663852886e22)
            writeUint((sign << 31 | 2139095040) >>> 0, buf, pos);
          else if (val < 11754943508222875e-54)
            writeUint((sign << 31 | Math.round(val / 1401298464324817e-60)) >>> 0, buf, pos);
          else {
            var exponent = Math.floor(Math.log(val) / Math.LN2), mantissa = Math.round(val * Math.pow(2, -exponent) * 8388608) & 8388607;
            writeUint((sign << 31 | exponent + 127 << 23 | mantissa) >>> 0, buf, pos);
          }
        }
        exports3.writeFloatLE = writeFloat_ieee754.bind(null, writeUintLE);
        exports3.writeFloatBE = writeFloat_ieee754.bind(null, writeUintBE);
        function readFloat_ieee754(readUint, buf, pos) {
          var uint = readUint(buf, pos), sign = (uint >> 31) * 2 + 1, exponent = uint >>> 23 & 255, mantissa = uint & 8388607;
          return exponent === 255 ? mantissa ? NaN : sign * Infinity : exponent === 0 ? sign * 1401298464324817e-60 * mantissa : sign * Math.pow(2, exponent - 150) * (mantissa + 8388608);
        }
        exports3.readFloatLE = readFloat_ieee754.bind(null, readUintLE);
        exports3.readFloatBE = readFloat_ieee754.bind(null, readUintBE);
      })();
    if (typeof Float64Array !== "undefined")
      (function() {
        var f64 = new Float64Array([-0]), f8b = new Uint8Array(f64.buffer), le = f8b[7] === 128;
        function writeDouble_f64_cpy(val, buf, pos) {
          f64[0] = val;
          buf[pos] = f8b[0];
          buf[pos + 1] = f8b[1];
          buf[pos + 2] = f8b[2];
          buf[pos + 3] = f8b[3];
          buf[pos + 4] = f8b[4];
          buf[pos + 5] = f8b[5];
          buf[pos + 6] = f8b[6];
          buf[pos + 7] = f8b[7];
        }
        function writeDouble_f64_rev(val, buf, pos) {
          f64[0] = val;
          buf[pos] = f8b[7];
          buf[pos + 1] = f8b[6];
          buf[pos + 2] = f8b[5];
          buf[pos + 3] = f8b[4];
          buf[pos + 4] = f8b[3];
          buf[pos + 5] = f8b[2];
          buf[pos + 6] = f8b[1];
          buf[pos + 7] = f8b[0];
        }
        exports3.writeDoubleLE = le ? writeDouble_f64_cpy : writeDouble_f64_rev;
        exports3.writeDoubleBE = le ? writeDouble_f64_rev : writeDouble_f64_cpy;
        function readDouble_f64_cpy(buf, pos) {
          f8b[0] = buf[pos];
          f8b[1] = buf[pos + 1];
          f8b[2] = buf[pos + 2];
          f8b[3] = buf[pos + 3];
          f8b[4] = buf[pos + 4];
          f8b[5] = buf[pos + 5];
          f8b[6] = buf[pos + 6];
          f8b[7] = buf[pos + 7];
          return f64[0];
        }
        function readDouble_f64_rev(buf, pos) {
          f8b[7] = buf[pos];
          f8b[6] = buf[pos + 1];
          f8b[5] = buf[pos + 2];
          f8b[4] = buf[pos + 3];
          f8b[3] = buf[pos + 4];
          f8b[2] = buf[pos + 5];
          f8b[1] = buf[pos + 6];
          f8b[0] = buf[pos + 7];
          return f64[0];
        }
        exports3.readDoubleLE = le ? readDouble_f64_cpy : readDouble_f64_rev;
        exports3.readDoubleBE = le ? readDouble_f64_rev : readDouble_f64_cpy;
      })();
    else
      (function() {
        function writeDouble_ieee754(writeUint, off0, off1, val, buf, pos) {
          var sign = val < 0 ? 1 : 0;
          if (sign)
            val = -val;
          if (val === 0) {
            writeUint(0, buf, pos + off0);
            writeUint(1 / val > 0 ? 0 : 2147483648, buf, pos + off1);
          } else if (isNaN(val)) {
            writeUint(0, buf, pos + off0);
            writeUint(2146959360, buf, pos + off1);
          } else if (val > 17976931348623157e292) {
            writeUint(0, buf, pos + off0);
            writeUint((sign << 31 | 2146435072) >>> 0, buf, pos + off1);
          } else {
            var mantissa;
            if (val < 22250738585072014e-324) {
              mantissa = val / 5e-324;
              writeUint(mantissa >>> 0, buf, pos + off0);
              writeUint((sign << 31 | mantissa / 4294967296) >>> 0, buf, pos + off1);
            } else {
              var exponent = Math.floor(Math.log(val) / Math.LN2);
              if (exponent === 1024)
                exponent = 1023;
              mantissa = val * Math.pow(2, -exponent);
              writeUint(mantissa * 4503599627370496 >>> 0, buf, pos + off0);
              writeUint((sign << 31 | exponent + 1023 << 20 | mantissa * 1048576 & 1048575) >>> 0, buf, pos + off1);
            }
          }
        }
        exports3.writeDoubleLE = writeDouble_ieee754.bind(null, writeUintLE, 0, 4);
        exports3.writeDoubleBE = writeDouble_ieee754.bind(null, writeUintBE, 4, 0);
        function readDouble_ieee754(readUint, off0, off1, buf, pos) {
          var lo = readUint(buf, pos + off0), hi = readUint(buf, pos + off1);
          var sign = (hi >> 31) * 2 + 1, exponent = hi >>> 20 & 2047, mantissa = 4294967296 * (hi & 1048575) + lo;
          return exponent === 2047 ? mantissa ? NaN : sign * Infinity : exponent === 0 ? sign * 5e-324 * mantissa : sign * Math.pow(2, exponent - 1075) * (mantissa + 4503599627370496);
        }
        exports3.readDoubleLE = readDouble_ieee754.bind(null, readUintLE, 0, 4);
        exports3.readDoubleBE = readDouble_ieee754.bind(null, readUintBE, 4, 0);
      })();
    return exports3;
  }
  function writeUintLE(val, buf, pos) {
    buf[pos] = val & 255;
    buf[pos + 1] = val >>> 8 & 255;
    buf[pos + 2] = val >>> 16 & 255;
    buf[pos + 3] = val >>> 24;
  }
  function writeUintBE(val, buf, pos) {
    buf[pos] = val >>> 24;
    buf[pos + 1] = val >>> 16 & 255;
    buf[pos + 2] = val >>> 8 & 255;
    buf[pos + 3] = val & 255;
  }
  function readUintLE(buf, pos) {
    return (buf[pos] | buf[pos + 1] << 8 | buf[pos + 2] << 16 | buf[pos + 3] << 24) >>> 0;
  }
  function readUintBE(buf, pos) {
    return (buf[pos] << 24 | buf[pos + 1] << 16 | buf[pos + 2] << 8 | buf[pos + 3]) >>> 0;
  }
});

// node_modules/@protobufjs/inquire/index.js
var require_inquire = __commonJS((exports, module) => {
  "use strict";
  module.exports = inquire;
  function inquire(moduleName) {
    try {
      var mod = eval("quire".replace(/^/, "re"))(moduleName);
      if (mod && (mod.length || Object.keys(mod).length))
        return mod;
    } catch (e) {
    }
    return null;
  }
});

// node_modules/@protobufjs/utf8/index.js
var require_utf8 = __commonJS((exports2) => {
  "use strict";
  var utf8 = exports2;
  utf8.length = function utf8_length(string) {
    var len = 0, c = 0;
    for (var i = 0; i < string.length; ++i) {
      c = string.charCodeAt(i);
      if (c < 128)
        len += 1;
      else if (c < 2048)
        len += 2;
      else if ((c & 64512) === 55296 && (string.charCodeAt(i + 1) & 64512) === 56320) {
        ++i;
        len += 4;
      } else
        len += 3;
    }
    return len;
  };
  utf8.read = function utf8_read(buffer, start, end) {
    var len = end - start;
    if (len < 1)
      return "";
    var parts = null, chunk = [], i = 0, t;
    while (start < end) {
      t = buffer[start++];
      if (t < 128)
        chunk[i++] = t;
      else if (t > 191 && t < 224)
        chunk[i++] = (t & 31) << 6 | buffer[start++] & 63;
      else if (t > 239 && t < 365) {
        t = ((t & 7) << 18 | (buffer[start++] & 63) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63) - 65536;
        chunk[i++] = 55296 + (t >> 10);
        chunk[i++] = 56320 + (t & 1023);
      } else
        chunk[i++] = (t & 15) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63;
      if (i > 8191) {
        (parts || (parts = [])).push(String.fromCharCode.apply(String, chunk));
        i = 0;
      }
    }
    if (parts) {
      if (i)
        parts.push(String.fromCharCode.apply(String, chunk.slice(0, i)));
      return parts.join("");
    }
    return String.fromCharCode.apply(String, chunk.slice(0, i));
  };
  utf8.write = function utf8_write(string, buffer, offset) {
    var start = offset, c1, c2;
    for (var i = 0; i < string.length; ++i) {
      c1 = string.charCodeAt(i);
      if (c1 < 128) {
        buffer[offset++] = c1;
      } else if (c1 < 2048) {
        buffer[offset++] = c1 >> 6 | 192;
        buffer[offset++] = c1 & 63 | 128;
      } else if ((c1 & 64512) === 55296 && ((c2 = string.charCodeAt(i + 1)) & 64512) === 56320) {
        c1 = 65536 + ((c1 & 1023) << 10) + (c2 & 1023);
        ++i;
        buffer[offset++] = c1 >> 18 | 240;
        buffer[offset++] = c1 >> 12 & 63 | 128;
        buffer[offset++] = c1 >> 6 & 63 | 128;
        buffer[offset++] = c1 & 63 | 128;
      } else {
        buffer[offset++] = c1 >> 12 | 224;
        buffer[offset++] = c1 >> 6 & 63 | 128;
        buffer[offset++] = c1 & 63 | 128;
      }
    }
    return offset - start;
  };
});

// node_modules/@protobufjs/pool/index.js
var require_pool = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = pool;
  function pool(alloc, slice, size) {
    var SIZE = size || 8192;
    var MAX = SIZE >>> 1;
    var slab = null;
    var offset = SIZE;
    return function pool_alloc(size2) {
      if (size2 < 1 || size2 > MAX)
        return alloc(size2);
      if (offset + size2 > SIZE) {
        slab = alloc(SIZE);
        offset = 0;
      }
      var buf = slice.call(slab, offset, offset += size2);
      if (offset & 7)
        offset = (offset | 7) + 1;
      return buf;
    };
  }
});

// node_modules/protobufjs/src/util/longbits.js
var require_longbits = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = LongBits;
  var util = require_minimal();
  function LongBits(lo, hi) {
    this.lo = lo >>> 0;
    this.hi = hi >>> 0;
  }
  var zero = LongBits.zero = new LongBits(0, 0);
  zero.toNumber = function() {
    return 0;
  };
  zero.zzEncode = zero.zzDecode = function() {
    return this;
  };
  zero.length = function() {
    return 1;
  };
  var zeroHash = LongBits.zeroHash = "\0\0\0\0\0\0\0\0";
  LongBits.fromNumber = function fromNumber(value) {
    if (value === 0)
      return zero;
    var sign = value < 0;
    if (sign)
      value = -value;
    var lo = value >>> 0, hi = (value - lo) / 4294967296 >>> 0;
    if (sign) {
      hi = ~hi >>> 0;
      lo = ~lo >>> 0;
      if (++lo > 4294967295) {
        lo = 0;
        if (++hi > 4294967295)
          hi = 0;
      }
    }
    return new LongBits(lo, hi);
  };
  LongBits.from = function from(value) {
    if (typeof value === "number")
      return LongBits.fromNumber(value);
    if (util.isString(value)) {
      if (util.Long)
        value = util.Long.fromString(value);
      else
        return LongBits.fromNumber(parseInt(value, 10));
    }
    return value.low || value.high ? new LongBits(value.low >>> 0, value.high >>> 0) : zero;
  };
  LongBits.prototype.toNumber = function toNumber(unsigned) {
    if (!unsigned && this.hi >>> 31) {
      var lo = ~this.lo + 1 >>> 0, hi = ~this.hi >>> 0;
      if (!lo)
        hi = hi + 1 >>> 0;
      return -(lo + hi * 4294967296);
    }
    return this.lo + this.hi * 4294967296;
  };
  LongBits.prototype.toLong = function toLong(unsigned) {
    return util.Long ? new util.Long(this.lo | 0, this.hi | 0, Boolean(unsigned)) : {low: this.lo | 0, high: this.hi | 0, unsigned: Boolean(unsigned)};
  };
  var charCodeAt = String.prototype.charCodeAt;
  LongBits.fromHash = function fromHash(hash) {
    if (hash === zeroHash)
      return zero;
    return new LongBits((charCodeAt.call(hash, 0) | charCodeAt.call(hash, 1) << 8 | charCodeAt.call(hash, 2) << 16 | charCodeAt.call(hash, 3) << 24) >>> 0, (charCodeAt.call(hash, 4) | charCodeAt.call(hash, 5) << 8 | charCodeAt.call(hash, 6) << 16 | charCodeAt.call(hash, 7) << 24) >>> 0);
  };
  LongBits.prototype.toHash = function toHash() {
    return String.fromCharCode(this.lo & 255, this.lo >>> 8 & 255, this.lo >>> 16 & 255, this.lo >>> 24, this.hi & 255, this.hi >>> 8 & 255, this.hi >>> 16 & 255, this.hi >>> 24);
  };
  LongBits.prototype.zzEncode = function zzEncode() {
    var mask = this.hi >> 31;
    this.hi = ((this.hi << 1 | this.lo >>> 31) ^ mask) >>> 0;
    this.lo = (this.lo << 1 ^ mask) >>> 0;
    return this;
  };
  LongBits.prototype.zzDecode = function zzDecode() {
    var mask = -(this.lo & 1);
    this.lo = ((this.lo >>> 1 | this.hi << 31) ^ mask) >>> 0;
    this.hi = (this.hi >>> 1 ^ mask) >>> 0;
    return this;
  };
  LongBits.prototype.length = function length() {
    var part0 = this.lo, part1 = (this.lo >>> 28 | this.hi << 4) >>> 0, part2 = this.hi >>> 24;
    return part2 === 0 ? part1 === 0 ? part0 < 16384 ? part0 < 128 ? 1 : 2 : part0 < 2097152 ? 3 : 4 : part1 < 16384 ? part1 < 128 ? 5 : 6 : part1 < 2097152 ? 7 : 8 : part2 < 128 ? 9 : 10;
  };
});

// node_modules/protobufjs/src/util/minimal.js
var require_minimal = __commonJS((exports2) => {
  "use strict";
  var util = exports2;
  util.asPromise = require_aspromise();
  util.base64 = require_base64();
  util.EventEmitter = require_eventemitter();
  util.float = require_float2();
  util.inquire = require_inquire();
  util.utf8 = require_utf8();
  util.pool = require_pool();
  util.LongBits = require_longbits();
  util.isNode = Boolean(typeof global !== "undefined" && global && global.process && global.process.versions && global.process.versions.node);
  util.global = util.isNode && global || typeof window !== "undefined" && window || typeof self !== "undefined" && self || exports2;
  util.emptyArray = Object.freeze ? Object.freeze([]) : [];
  util.emptyObject = Object.freeze ? Object.freeze({}) : {};
  util.isInteger = Number.isInteger || function isInteger(value) {
    return typeof value === "number" && isFinite(value) && Math.floor(value) === value;
  };
  util.isString = function isString(value) {
    return typeof value === "string" || value instanceof String;
  };
  util.isObject = function isObject(value) {
    return value && typeof value === "object";
  };
  util.isset = util.isSet = function isSet(obj, prop) {
    var value = obj[prop];
    if (value != null && obj.hasOwnProperty(prop))
      return typeof value !== "object" || (Array.isArray(value) ? value.length : Object.keys(value).length) > 0;
    return false;
  };
  util.Buffer = function() {
    try {
      var Buffer2 = util.inquire("buffer").Buffer;
      return Buffer2.prototype.utf8Write ? Buffer2 : null;
    } catch (e) {
      return null;
    }
  }();
  util._Buffer_from = null;
  util._Buffer_allocUnsafe = null;
  util.newBuffer = function newBuffer(sizeOrArray) {
    return typeof sizeOrArray === "number" ? util.Buffer ? util._Buffer_allocUnsafe(sizeOrArray) : new util.Array(sizeOrArray) : util.Buffer ? util._Buffer_from(sizeOrArray) : typeof Uint8Array === "undefined" ? sizeOrArray : new Uint8Array(sizeOrArray);
  };
  util.Array = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
  util.Long = util.global.dcodeIO && util.global.dcodeIO.Long || util.global.Long || util.inquire("long");
  util.key2Re = /^true|false|0|1$/;
  util.key32Re = /^-?(?:0|[1-9][0-9]*)$/;
  util.key64Re = /^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/;
  util.longToHash = function longToHash(value) {
    return value ? util.LongBits.from(value).toHash() : util.LongBits.zeroHash;
  };
  util.longFromHash = function longFromHash(hash, unsigned) {
    var bits = util.LongBits.fromHash(hash);
    if (util.Long)
      return util.Long.fromBits(bits.lo, bits.hi, unsigned);
    return bits.toNumber(Boolean(unsigned));
  };
  function merge(dst, src, ifNotSet) {
    for (var keys = Object.keys(src), i = 0; i < keys.length; ++i)
      if (dst[keys[i]] === void 0 || !ifNotSet)
        dst[keys[i]] = src[keys[i]];
    return dst;
  }
  util.merge = merge;
  util.lcFirst = function lcFirst(str) {
    return str.charAt(0).toLowerCase() + str.substring(1);
  };
  function newError(name) {
    function CustomError(message, properties) {
      if (!(this instanceof CustomError))
        return new CustomError(message, properties);
      Object.defineProperty(this, "message", {get: function() {
        return message;
      }});
      if (Error.captureStackTrace)
        Error.captureStackTrace(this, CustomError);
      else
        Object.defineProperty(this, "stack", {value: new Error().stack || ""});
      if (properties)
        merge(this, properties);
    }
    (CustomError.prototype = Object.create(Error.prototype)).constructor = CustomError;
    Object.defineProperty(CustomError.prototype, "name", {get: function() {
      return name;
    }});
    CustomError.prototype.toString = function toString() {
      return this.name + ": " + this.message;
    };
    return CustomError;
  }
  util.newError = newError;
  util.ProtocolError = newError("ProtocolError");
  util.oneOfGetter = function getOneOf(fieldNames) {
    var fieldMap = {};
    for (var i = 0; i < fieldNames.length; ++i)
      fieldMap[fieldNames[i]] = 1;
    return function() {
      for (var keys = Object.keys(this), i2 = keys.length - 1; i2 > -1; --i2)
        if (fieldMap[keys[i2]] === 1 && this[keys[i2]] !== void 0 && this[keys[i2]] !== null)
          return keys[i2];
    };
  };
  util.oneOfSetter = function setOneOf(fieldNames) {
    return function(name) {
      for (var i = 0; i < fieldNames.length; ++i)
        if (fieldNames[i] !== name)
          delete this[fieldNames[i]];
    };
  };
  util.toJSONOptions = {
    longs: String,
    enums: String,
    bytes: String,
    json: true
  };
  util._configure = function() {
    var Buffer2 = util.Buffer;
    if (!Buffer2) {
      util._Buffer_from = util._Buffer_allocUnsafe = null;
      return;
    }
    util._Buffer_from = Buffer2.from !== Uint8Array.from && Buffer2.from || function Buffer_from(value, encoding) {
      return new Buffer2(value, encoding);
    };
    util._Buffer_allocUnsafe = Buffer2.allocUnsafe || function Buffer_allocUnsafe(size) {
      return new Buffer2(size);
    };
  };
});

// node_modules/protobufjs/src/writer.js
var require_writer = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = Writer;
  var util = require_minimal();
  var BufferWriter;
  var LongBits = util.LongBits;
  var base64 = util.base64;
  var utf8 = util.utf8;
  function Op(fn, len, val) {
    this.fn = fn;
    this.len = len;
    this.next = void 0;
    this.val = val;
  }
  function noop() {
  }
  function State(writer) {
    this.head = writer.head;
    this.tail = writer.tail;
    this.len = writer.len;
    this.next = writer.states;
  }
  function Writer() {
    this.len = 0;
    this.head = new Op(noop, 0, 0);
    this.tail = this.head;
    this.states = null;
  }
  var create = function create2() {
    return util.Buffer ? function create_buffer_setup() {
      return (Writer.create = function create_buffer() {
        return new BufferWriter();
      })();
    } : function create_array() {
      return new Writer();
    };
  };
  Writer.create = create();
  Writer.alloc = function alloc(size) {
    return new util.Array(size);
  };
  if (util.Array !== Array)
    Writer.alloc = util.pool(Writer.alloc, util.Array.prototype.subarray);
  Writer.prototype._push = function push(fn, len, val) {
    this.tail = this.tail.next = new Op(fn, len, val);
    this.len += len;
    return this;
  };
  function writeByte(val, buf, pos) {
    buf[pos] = val & 255;
  }
  function writeVarint32(val, buf, pos) {
    while (val > 127) {
      buf[pos++] = val & 127 | 128;
      val >>>= 7;
    }
    buf[pos] = val;
  }
  function VarintOp(len, val) {
    this.len = len;
    this.next = void 0;
    this.val = val;
  }
  VarintOp.prototype = Object.create(Op.prototype);
  VarintOp.prototype.fn = writeVarint32;
  Writer.prototype.uint32 = function write_uint32(value) {
    this.len += (this.tail = this.tail.next = new VarintOp((value = value >>> 0) < 128 ? 1 : value < 16384 ? 2 : value < 2097152 ? 3 : value < 268435456 ? 4 : 5, value)).len;
    return this;
  };
  Writer.prototype.int32 = function write_int32(value) {
    return value < 0 ? this._push(writeVarint64, 10, LongBits.fromNumber(value)) : this.uint32(value);
  };
  Writer.prototype.sint32 = function write_sint32(value) {
    return this.uint32((value << 1 ^ value >> 31) >>> 0);
  };
  function writeVarint64(val, buf, pos) {
    while (val.hi) {
      buf[pos++] = val.lo & 127 | 128;
      val.lo = (val.lo >>> 7 | val.hi << 25) >>> 0;
      val.hi >>>= 7;
    }
    while (val.lo > 127) {
      buf[pos++] = val.lo & 127 | 128;
      val.lo = val.lo >>> 7;
    }
    buf[pos++] = val.lo;
  }
  Writer.prototype.uint64 = function write_uint64(value) {
    var bits = LongBits.from(value);
    return this._push(writeVarint64, bits.length(), bits);
  };
  Writer.prototype.int64 = Writer.prototype.uint64;
  Writer.prototype.sint64 = function write_sint64(value) {
    var bits = LongBits.from(value).zzEncode();
    return this._push(writeVarint64, bits.length(), bits);
  };
  Writer.prototype.bool = function write_bool(value) {
    return this._push(writeByte, 1, value ? 1 : 0);
  };
  function writeFixed32(val, buf, pos) {
    buf[pos] = val & 255;
    buf[pos + 1] = val >>> 8 & 255;
    buf[pos + 2] = val >>> 16 & 255;
    buf[pos + 3] = val >>> 24;
  }
  Writer.prototype.fixed32 = function write_fixed32(value) {
    return this._push(writeFixed32, 4, value >>> 0);
  };
  Writer.prototype.sfixed32 = Writer.prototype.fixed32;
  Writer.prototype.fixed64 = function write_fixed64(value) {
    var bits = LongBits.from(value);
    return this._push(writeFixed32, 4, bits.lo)._push(writeFixed32, 4, bits.hi);
  };
  Writer.prototype.sfixed64 = Writer.prototype.fixed64;
  Writer.prototype.float = function write_float(value) {
    return this._push(util.float.writeFloatLE, 4, value);
  };
  Writer.prototype.double = function write_double(value) {
    return this._push(util.float.writeDoubleLE, 8, value);
  };
  var writeBytes = util.Array.prototype.set ? function writeBytes_set(val, buf, pos) {
    buf.set(val, pos);
  } : function writeBytes_for(val, buf, pos) {
    for (var i = 0; i < val.length; ++i)
      buf[pos + i] = val[i];
  };
  Writer.prototype.bytes = function write_bytes(value) {
    var len = value.length >>> 0;
    if (!len)
      return this._push(writeByte, 1, 0);
    if (util.isString(value)) {
      var buf = Writer.alloc(len = base64.length(value));
      base64.decode(value, buf, 0);
      value = buf;
    }
    return this.uint32(len)._push(writeBytes, len, value);
  };
  Writer.prototype.string = function write_string(value) {
    var len = utf8.length(value);
    return len ? this.uint32(len)._push(utf8.write, len, value) : this._push(writeByte, 1, 0);
  };
  Writer.prototype.fork = function fork() {
    this.states = new State(this);
    this.head = this.tail = new Op(noop, 0, 0);
    this.len = 0;
    return this;
  };
  Writer.prototype.reset = function reset() {
    if (this.states) {
      this.head = this.states.head;
      this.tail = this.states.tail;
      this.len = this.states.len;
      this.states = this.states.next;
    } else {
      this.head = this.tail = new Op(noop, 0, 0);
      this.len = 0;
    }
    return this;
  };
  Writer.prototype.ldelim = function ldelim() {
    var head = this.head, tail = this.tail, len = this.len;
    this.reset().uint32(len);
    if (len) {
      this.tail.next = head.next;
      this.tail = tail;
      this.len += len;
    }
    return this;
  };
  Writer.prototype.finish = function finish() {
    var head = this.head.next, buf = this.constructor.alloc(this.len), pos = 0;
    while (head) {
      head.fn(head.val, buf, pos);
      pos += head.len;
      head = head.next;
    }
    return buf;
  };
  Writer._configure = function(BufferWriter_) {
    BufferWriter = BufferWriter_;
    Writer.create = create();
    BufferWriter._configure();
  };
});

// node_modules/protobufjs/src/writer_buffer.js
var require_writer_buffer = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = BufferWriter;
  var Writer = require_writer();
  (BufferWriter.prototype = Object.create(Writer.prototype)).constructor = BufferWriter;
  var util = require_minimal();
  function BufferWriter() {
    Writer.call(this);
  }
  BufferWriter._configure = function() {
    BufferWriter.alloc = util._Buffer_allocUnsafe;
    BufferWriter.writeBytesBuffer = util.Buffer && util.Buffer.prototype instanceof Uint8Array && util.Buffer.prototype.set.name === "set" ? function writeBytesBuffer_set(val, buf, pos) {
      buf.set(val, pos);
    } : function writeBytesBuffer_copy(val, buf, pos) {
      if (val.copy)
        val.copy(buf, pos, 0, val.length);
      else
        for (var i = 0; i < val.length; )
          buf[pos++] = val[i++];
    };
  };
  BufferWriter.prototype.bytes = function write_bytes_buffer(value) {
    if (util.isString(value))
      value = util._Buffer_from(value, "base64");
    var len = value.length >>> 0;
    this.uint32(len);
    if (len)
      this._push(BufferWriter.writeBytesBuffer, len, value);
    return this;
  };
  function writeStringBuffer(val, buf, pos) {
    if (val.length < 40)
      util.utf8.write(val, buf, pos);
    else if (buf.utf8Write)
      buf.utf8Write(val, pos);
    else
      buf.write(val, pos);
  }
  BufferWriter.prototype.string = function write_string_buffer(value) {
    var len = util.Buffer.byteLength(value);
    this.uint32(len);
    if (len)
      this._push(writeStringBuffer, len, value);
    return this;
  };
  BufferWriter._configure();
});

// node_modules/protobufjs/src/reader.js
var require_reader = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = Reader;
  var util = require_minimal();
  var BufferReader;
  var LongBits = util.LongBits;
  var utf8 = util.utf8;
  function indexOutOfRange(reader, writeLength) {
    return RangeError("index out of range: " + reader.pos + " + " + (writeLength || 1) + " > " + reader.len);
  }
  function Reader(buffer) {
    this.buf = buffer;
    this.pos = 0;
    this.len = buffer.length;
  }
  var create_array = typeof Uint8Array !== "undefined" ? function create_typed_array(buffer) {
    if (buffer instanceof Uint8Array || Array.isArray(buffer))
      return new Reader(buffer);
    throw Error("illegal buffer");
  } : function create_array2(buffer) {
    if (Array.isArray(buffer))
      return new Reader(buffer);
    throw Error("illegal buffer");
  };
  var create = function create2() {
    return util.Buffer ? function create_buffer_setup(buffer) {
      return (Reader.create = function create_buffer(buffer2) {
        return util.Buffer.isBuffer(buffer2) ? new BufferReader(buffer2) : create_array(buffer2);
      })(buffer);
    } : create_array;
  };
  Reader.create = create();
  Reader.prototype._slice = util.Array.prototype.subarray || util.Array.prototype.slice;
  Reader.prototype.uint32 = function read_uint32_setup() {
    var value = 4294967295;
    return function read_uint32() {
      value = (this.buf[this.pos] & 127) >>> 0;
      if (this.buf[this.pos++] < 128)
        return value;
      value = (value | (this.buf[this.pos] & 127) << 7) >>> 0;
      if (this.buf[this.pos++] < 128)
        return value;
      value = (value | (this.buf[this.pos] & 127) << 14) >>> 0;
      if (this.buf[this.pos++] < 128)
        return value;
      value = (value | (this.buf[this.pos] & 127) << 21) >>> 0;
      if (this.buf[this.pos++] < 128)
        return value;
      value = (value | (this.buf[this.pos] & 15) << 28) >>> 0;
      if (this.buf[this.pos++] < 128)
        return value;
      if ((this.pos += 5) > this.len) {
        this.pos = this.len;
        throw indexOutOfRange(this, 10);
      }
      return value;
    };
  }();
  Reader.prototype.int32 = function read_int32() {
    return this.uint32() | 0;
  };
  Reader.prototype.sint32 = function read_sint32() {
    var value = this.uint32();
    return value >>> 1 ^ -(value & 1) | 0;
  };
  function readLongVarint() {
    var bits = new LongBits(0, 0);
    var i = 0;
    if (this.len - this.pos > 4) {
      for (; i < 4; ++i) {
        bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
        if (this.buf[this.pos++] < 128)
          return bits;
      }
      bits.lo = (bits.lo | (this.buf[this.pos] & 127) << 28) >>> 0;
      bits.hi = (bits.hi | (this.buf[this.pos] & 127) >> 4) >>> 0;
      if (this.buf[this.pos++] < 128)
        return bits;
      i = 0;
    } else {
      for (; i < 3; ++i) {
        if (this.pos >= this.len)
          throw indexOutOfRange(this);
        bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
        if (this.buf[this.pos++] < 128)
          return bits;
      }
      bits.lo = (bits.lo | (this.buf[this.pos++] & 127) << i * 7) >>> 0;
      return bits;
    }
    if (this.len - this.pos > 4) {
      for (; i < 5; ++i) {
        bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
        if (this.buf[this.pos++] < 128)
          return bits;
      }
    } else {
      for (; i < 5; ++i) {
        if (this.pos >= this.len)
          throw indexOutOfRange(this);
        bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
        if (this.buf[this.pos++] < 128)
          return bits;
      }
    }
    throw Error("invalid varint encoding");
  }
  Reader.prototype.bool = function read_bool() {
    return this.uint32() !== 0;
  };
  function readFixed32_end(buf, end) {
    return (buf[end - 4] | buf[end - 3] << 8 | buf[end - 2] << 16 | buf[end - 1] << 24) >>> 0;
  }
  Reader.prototype.fixed32 = function read_fixed32() {
    if (this.pos + 4 > this.len)
      throw indexOutOfRange(this, 4);
    return readFixed32_end(this.buf, this.pos += 4);
  };
  Reader.prototype.sfixed32 = function read_sfixed32() {
    if (this.pos + 4 > this.len)
      throw indexOutOfRange(this, 4);
    return readFixed32_end(this.buf, this.pos += 4) | 0;
  };
  function readFixed64() {
    if (this.pos + 8 > this.len)
      throw indexOutOfRange(this, 8);
    return new LongBits(readFixed32_end(this.buf, this.pos += 4), readFixed32_end(this.buf, this.pos += 4));
  }
  Reader.prototype.float = function read_float() {
    if (this.pos + 4 > this.len)
      throw indexOutOfRange(this, 4);
    var value = util.float.readFloatLE(this.buf, this.pos);
    this.pos += 4;
    return value;
  };
  Reader.prototype.double = function read_double() {
    if (this.pos + 8 > this.len)
      throw indexOutOfRange(this, 4);
    var value = util.float.readDoubleLE(this.buf, this.pos);
    this.pos += 8;
    return value;
  };
  Reader.prototype.bytes = function read_bytes() {
    var length = this.uint32(), start = this.pos, end = this.pos + length;
    if (end > this.len)
      throw indexOutOfRange(this, length);
    this.pos += length;
    if (Array.isArray(this.buf))
      return this.buf.slice(start, end);
    return start === end ? new this.buf.constructor(0) : this._slice.call(this.buf, start, end);
  };
  Reader.prototype.string = function read_string() {
    var bytes = this.bytes();
    return utf8.read(bytes, 0, bytes.length);
  };
  Reader.prototype.skip = function skip(length) {
    if (typeof length === "number") {
      if (this.pos + length > this.len)
        throw indexOutOfRange(this, length);
      this.pos += length;
    } else {
      do {
        if (this.pos >= this.len)
          throw indexOutOfRange(this);
      } while (this.buf[this.pos++] & 128);
    }
    return this;
  };
  Reader.prototype.skipType = function(wireType) {
    switch (wireType) {
      case 0:
        this.skip();
        break;
      case 1:
        this.skip(8);
        break;
      case 2:
        this.skip(this.uint32());
        break;
      case 3:
        while ((wireType = this.uint32() & 7) !== 4) {
          this.skipType(wireType);
        }
        break;
      case 5:
        this.skip(4);
        break;
      default:
        throw Error("invalid wire type " + wireType + " at offset " + this.pos);
    }
    return this;
  };
  Reader._configure = function(BufferReader_) {
    BufferReader = BufferReader_;
    Reader.create = create();
    BufferReader._configure();
    var fn = util.Long ? "toLong" : "toNumber";
    util.merge(Reader.prototype, {
      int64: function read_int64() {
        return readLongVarint.call(this)[fn](false);
      },
      uint64: function read_uint64() {
        return readLongVarint.call(this)[fn](true);
      },
      sint64: function read_sint64() {
        return readLongVarint.call(this).zzDecode()[fn](false);
      },
      fixed64: function read_fixed64() {
        return readFixed64.call(this)[fn](true);
      },
      sfixed64: function read_sfixed64() {
        return readFixed64.call(this)[fn](false);
      }
    });
  };
});

// node_modules/protobufjs/src/reader_buffer.js
var require_reader_buffer = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = BufferReader;
  var Reader = require_reader();
  (BufferReader.prototype = Object.create(Reader.prototype)).constructor = BufferReader;
  var util = require_minimal();
  function BufferReader(buffer) {
    Reader.call(this, buffer);
  }
  BufferReader._configure = function() {
    if (util.Buffer)
      BufferReader.prototype._slice = util.Buffer.prototype.slice;
  };
  BufferReader.prototype.string = function read_string_buffer() {
    var len = this.uint32();
    return this.buf.utf8Slice ? this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + len, this.len)) : this.buf.toString("utf-8", this.pos, this.pos = Math.min(this.pos + len, this.len));
  };
  BufferReader._configure();
});

// node_modules/protobufjs/src/rpc/service.js
var require_service2 = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = Service;
  var util = require_minimal();
  (Service.prototype = Object.create(util.EventEmitter.prototype)).constructor = Service;
  function Service(rpcImpl, requestDelimited, responseDelimited) {
    if (typeof rpcImpl !== "function")
      throw TypeError("rpcImpl must be a function");
    util.EventEmitter.call(this);
    this.rpcImpl = rpcImpl;
    this.requestDelimited = Boolean(requestDelimited);
    this.responseDelimited = Boolean(responseDelimited);
  }
  Service.prototype.rpcCall = function rpcCall(method, requestCtor, responseCtor, request, callback) {
    if (!request)
      throw TypeError("request must be specified");
    var self2 = this;
    if (!callback)
      return util.asPromise(rpcCall, self2, method, requestCtor, responseCtor, request);
    if (!self2.rpcImpl) {
      setTimeout(function() {
        callback(Error("already ended"));
      }, 0);
      return void 0;
    }
    try {
      return self2.rpcImpl(method, requestCtor[self2.requestDelimited ? "encodeDelimited" : "encode"](request).finish(), function rpcCallback(err, response) {
        if (err) {
          self2.emit("error", err, method);
          return callback(err);
        }
        if (response === null) {
          self2.end(true);
          return void 0;
        }
        if (!(response instanceof responseCtor)) {
          try {
            response = responseCtor[self2.responseDelimited ? "decodeDelimited" : "decode"](response);
          } catch (err2) {
            self2.emit("error", err2, method);
            return callback(err2);
          }
        }
        self2.emit("data", response, method);
        return callback(null, response);
      });
    } catch (err) {
      self2.emit("error", err, method);
      setTimeout(function() {
        callback(err);
      }, 0);
      return void 0;
    }
  };
  Service.prototype.end = function end(endedByRPC) {
    if (this.rpcImpl) {
      if (!endedByRPC)
        this.rpcImpl(null, null, null);
      this.rpcImpl = null;
      this.emit("end").off();
    }
    return this;
  };
});

// node_modules/protobufjs/src/rpc.js
var require_rpc = __commonJS((exports2) => {
  "use strict";
  var rpc = exports2;
  rpc.Service = require_service2();
});

// node_modules/protobufjs/src/roots.js
var require_roots = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = {};
});

// node_modules/protobufjs/src/index-minimal.js
var require_index_minimal = __commonJS((exports2) => {
  "use strict";
  var protobuf = exports2;
  protobuf.build = "minimal";
  protobuf.Writer = require_writer();
  protobuf.BufferWriter = require_writer_buffer();
  protobuf.Reader = require_reader();
  protobuf.BufferReader = require_reader_buffer();
  protobuf.util = require_minimal();
  protobuf.rpc = require_rpc();
  protobuf.roots = require_roots();
  protobuf.configure = configure;
  function configure() {
    protobuf.util._configure();
    protobuf.Writer._configure(protobuf.BufferWriter);
    protobuf.Reader._configure(protobuf.BufferReader);
  }
  configure();
});

// node_modules/protobufjs/minimal.js
var require_minimal2 = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = require_index_minimal();
});

// node_modules/libp2p-noise/dist/src/proto/payload.js
var require_payload = __commonJS((exports2, module2) => {
  "use strict";
  (function(global2, factory) {
    if (typeof define === "function" && define.amd) {
      define(["protobufjs/minimal"], factory);
    } else if (typeof module2 === "object" && module2 && module2.exports) {
      module2.exports = factory(require_minimal2());
    }
  })(exports2, function($protobuf) {
    var $Reader = $protobuf.Reader;
    var $Writer = $protobuf.Writer;
    var $util = $protobuf.util;
    var $root = $protobuf.roots.default || ($protobuf.roots.default = {});
    $root.pb = function() {
      var pb = {};
      pb.NoiseHandshakePayload = function() {
        function NoiseHandshakePayload(properties) {
          if (properties) {
            for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) {
              if (properties[keys[i]] != null) {
                this[keys[i]] = properties[keys[i]];
              }
            }
          }
        }
        NoiseHandshakePayload.prototype.identityKey = $util.newBuffer([]);
        NoiseHandshakePayload.prototype.identitySig = $util.newBuffer([]);
        NoiseHandshakePayload.prototype.data = $util.newBuffer([]);
        NoiseHandshakePayload.create = function create(properties) {
          return new NoiseHandshakePayload(properties);
        };
        NoiseHandshakePayload.encode = function encode(message, writer) {
          if (!writer) {
            writer = $Writer.create();
          }
          if (message.identityKey != null && message.hasOwnProperty("identityKey")) {
            writer.uint32(10).bytes(message.identityKey);
          }
          if (message.identitySig != null && message.hasOwnProperty("identitySig")) {
            writer.uint32(18).bytes(message.identitySig);
          }
          if (message.data != null && message.hasOwnProperty("data")) {
            writer.uint32(26).bytes(message.data);
          }
          return writer;
        };
        NoiseHandshakePayload.encodeDelimited = function encodeDelimited(message, writer) {
          return this.encode(message, writer).ldelim();
        };
        NoiseHandshakePayload.decode = function decode(reader, length) {
          if (!(reader instanceof $Reader)) {
            reader = $Reader.create(reader);
          }
          var end = length === void 0 ? reader.len : reader.pos + length;
          var message = new $root.pb.NoiseHandshakePayload();
          while (reader.pos < end) {
            var tag = reader.uint32();
            switch (tag >>> 3) {
              case 1:
                message.identityKey = reader.bytes();
                break;
              case 2:
                message.identitySig = reader.bytes();
                break;
              case 3:
                message.data = reader.bytes();
                break;
              default:
                reader.skipType(tag & 7);
                break;
            }
          }
          return message;
        };
        NoiseHandshakePayload.decodeDelimited = function decodeDelimited(reader) {
          if (!(reader instanceof $Reader)) {
            reader = new $Reader(reader);
          }
          return this.decode(reader, reader.uint32());
        };
        NoiseHandshakePayload.verify = function verify(message) {
          if (typeof message !== "object" || message === null) {
            return "object expected";
          }
          if (message.identityKey != null && message.hasOwnProperty("identityKey")) {
            if (!(message.identityKey && typeof message.identityKey.length === "number" || $util.isString(message.identityKey))) {
              return "identityKey: buffer expected";
            }
          }
          if (message.identitySig != null && message.hasOwnProperty("identitySig")) {
            if (!(message.identitySig && typeof message.identitySig.length === "number" || $util.isString(message.identitySig))) {
              return "identitySig: buffer expected";
            }
          }
          if (message.data != null && message.hasOwnProperty("data")) {
            if (!(message.data && typeof message.data.length === "number" || $util.isString(message.data))) {
              return "data: buffer expected";
            }
          }
          return null;
        };
        NoiseHandshakePayload.fromObject = function fromObject(object) {
          if (object instanceof $root.pb.NoiseHandshakePayload) {
            return object;
          }
          var message = new $root.pb.NoiseHandshakePayload();
          if (object.identityKey != null) {
            if (typeof object.identityKey === "string") {
              $util.base64.decode(object.identityKey, message.identityKey = $util.newBuffer($util.base64.length(object.identityKey)), 0);
            } else if (object.identityKey.length) {
              message.identityKey = object.identityKey;
            }
          }
          if (object.identitySig != null) {
            if (typeof object.identitySig === "string") {
              $util.base64.decode(object.identitySig, message.identitySig = $util.newBuffer($util.base64.length(object.identitySig)), 0);
            } else if (object.identitySig.length) {
              message.identitySig = object.identitySig;
            }
          }
          if (object.data != null) {
            if (typeof object.data === "string") {
              $util.base64.decode(object.data, message.data = $util.newBuffer($util.base64.length(object.data)), 0);
            } else if (object.data.length) {
              message.data = object.data;
            }
          }
          return message;
        };
        NoiseHandshakePayload.toObject = function toObject(message, options) {
          if (!options) {
            options = {};
          }
          var object = {};
          if (options.defaults) {
            if (options.bytes === String) {
              object.identityKey = "";
            } else {
              object.identityKey = [];
              if (options.bytes !== Array) {
                object.identityKey = $util.newBuffer(object.identityKey);
              }
            }
            if (options.bytes === String) {
              object.identitySig = "";
            } else {
              object.identitySig = [];
              if (options.bytes !== Array) {
                object.identitySig = $util.newBuffer(object.identitySig);
              }
            }
            if (options.bytes === String) {
              object.data = "";
            } else {
              object.data = [];
              if (options.bytes !== Array) {
                object.data = $util.newBuffer(object.data);
              }
            }
          }
          if (message.identityKey != null && message.hasOwnProperty("identityKey")) {
            object.identityKey = options.bytes === String ? $util.base64.encode(message.identityKey, 0, message.identityKey.length) : options.bytes === Array ? Array.prototype.slice.call(message.identityKey) : message.identityKey;
          }
          if (message.identitySig != null && message.hasOwnProperty("identitySig")) {
            object.identitySig = options.bytes === String ? $util.base64.encode(message.identitySig, 0, message.identitySig.length) : options.bytes === Array ? Array.prototype.slice.call(message.identitySig) : message.identitySig;
          }
          if (message.data != null && message.hasOwnProperty("data")) {
            object.data = options.bytes === String ? $util.base64.encode(message.data, 0, message.data.length) : options.bytes === Array ? Array.prototype.slice.call(message.data) : message.data;
          }
          return object;
        };
        NoiseHandshakePayload.prototype.toJSON = function toJSON() {
          return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };
        return NoiseHandshakePayload;
      }();
      return pb;
    }();
    return $root;
  });
});

// node_modules/libp2p-noise/node_modules/uint8arrays/equals.js
var require_equals5 = __commonJS((exports2, module2) => {
  "use strict";
  function equals(a, b) {
    if (a === b) {
      return true;
    }
    if (a.byteLength !== b.byteLength) {
      return false;
    }
    for (let i = 0; i < a.byteLength; i++) {
      if (a[i] !== b[i]) {
        return false;
      }
    }
    return true;
  }
  module2.exports = equals;
});

// node_modules/libp2p-noise/dist/src/utils.js
var require_utils31 = __commonJS((exports2) => {
  "use strict";
  var __importDefault = exports2 && exports2.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {default: mod};
  };
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.isValidPublicKey = exports2.getHkdf = exports2.verifySignedPayload = exports2.getHandshakePayload = exports2.decodePayload = exports2.getPeerIdFromPayload = exports2.signPayload = exports2.createHandshakePayload = exports2.getPayload = exports2.generateKeypair = void 0;
  var hkdf_1 = __importDefault(require_hkdf_browser());
  var x25519_1 = __importDefault(require_x25519());
  var sha256_1 = __importDefault(require_sha2562());
  var buffer_1 = require_buffer();
  var peer_id_1 = __importDefault(require_src9());
  var libp2p_crypto_1 = require_src10();
  var payload_1 = require_payload();
  var equals_1 = __importDefault(require_equals5());
  var NoiseHandshakePayloadProto = payload_1.pb.NoiseHandshakePayload;
  function generateKeypair() {
    const privateKey = x25519_1.default.privateKeyGenerate();
    const publicKey = x25519_1.default.publicKeyCreate(privateKey);
    return {
      publicKey,
      privateKey
    };
  }
  exports2.generateKeypair = generateKeypair;
  async function getPayload(localPeer, staticPublicKey, earlyData) {
    const signedPayload = await signPayload(localPeer, getHandshakePayload(staticPublicKey));
    const earlyDataPayload = earlyData || buffer_1.Buffer.alloc(0);
    return await createHandshakePayload(localPeer.marshalPubKey(), signedPayload, earlyDataPayload);
  }
  exports2.getPayload = getPayload;
  function createHandshakePayload(libp2pPublicKey, signedPayload, earlyData) {
    const payloadInit = NoiseHandshakePayloadProto.create({
      identityKey: buffer_1.Buffer.from(libp2pPublicKey),
      identitySig: signedPayload,
      data: earlyData || null
    });
    return buffer_1.Buffer.from(NoiseHandshakePayloadProto.encode(payloadInit).finish());
  }
  exports2.createHandshakePayload = createHandshakePayload;
  async function signPayload(peerId, payload) {
    return buffer_1.Buffer.from(await peerId.privKey.sign(payload));
  }
  exports2.signPayload = signPayload;
  async function getPeerIdFromPayload(payload) {
    return await peer_id_1.default.createFromPubKey(buffer_1.Buffer.from(payload.identityKey));
  }
  exports2.getPeerIdFromPayload = getPeerIdFromPayload;
  function decodePayload(payload) {
    return NoiseHandshakePayloadProto.toObject(NoiseHandshakePayloadProto.decode(buffer_1.Buffer.from(payload)));
  }
  exports2.decodePayload = decodePayload;
  function getHandshakePayload(publicKey) {
    return buffer_1.Buffer.concat([buffer_1.Buffer.from("noise-libp2p-static-key:"), publicKey]);
  }
  exports2.getHandshakePayload = getHandshakePayload;
  async function isValidPeerId(peerId, publicKeyProtobuf) {
    const generatedPeerId = await peer_id_1.default.createFromPubKey(publicKeyProtobuf);
    return equals_1.default(generatedPeerId.id, peerId);
  }
  async function verifySignedPayload(noiseStaticKey, payload, remotePeer) {
    const identityKey = buffer_1.Buffer.from(payload.identityKey);
    if (!await isValidPeerId(remotePeer.id, identityKey)) {
      throw new Error("Peer ID doesn't match libp2p public key.");
    }
    const generatedPayload = getHandshakePayload(noiseStaticKey);
    const publicKey = libp2p_crypto_1.keys.unmarshalPublicKey(identityKey);
    if (!payload.identitySig || !publicKey.verify(generatedPayload, buffer_1.Buffer.from(payload.identitySig))) {
      throw new Error("Static key doesn't match to peer that signed payload!");
    }
    return peer_id_1.default.createFromPubKey(identityKey);
  }
  exports2.verifySignedPayload = verifySignedPayload;
  function getHkdf(ck, ikm) {
    const info = buffer_1.Buffer.alloc(0);
    const prk = hkdf_1.default.extract(sha256_1.default, ikm, ck);
    const okm = hkdf_1.default.expand(sha256_1.default, prk, info, 96);
    const k1 = okm.slice(0, 32);
    const k2 = okm.slice(32, 64);
    const k3 = okm.slice(64, 96);
    return [k1, k2, k3];
  }
  exports2.getHkdf = getHkdf;
  function isValidPublicKey(pk) {
    return x25519_1.default.publicKeyVerify(pk.slice(0, 32));
  }
  exports2.isValidPublicKey = isValidPublicKey;
});

// node_modules/bcrypto/lib/js/chacha20.js
var require_chacha20 = __commonJS((exports2, module2) => {
  /*!
   * chacha20.js - chacha20 for bcrypto
   * Copyright (c) 2016-2019, Christopher Jeffrey (MIT License).
   * https://github.com/bcoin-org/bcrypto
   *
   * Resources
   *   https://en.wikipedia.org/wiki/Chacha20
   *   https://tools.ietf.org/html/rfc7539#section-2
   *   https://cr.yp.to/chacha.html
   */
  "use strict";
  var assert = require_assert2();
  var BIG_ENDIAN = new Int8Array(new Int16Array([1]).buffer)[0] === 0;
  var ChaCha20 = class {
    constructor() {
      this.state = new Uint32Array(16);
      this.stream = new Uint32Array(16);
      this.bytes = new Uint8Array(this.stream.buffer);
      this.pos = -1;
      if (BIG_ENDIAN)
        this.bytes = Buffer.alloc(64);
    }
    init(key, nonce, counter) {
      if (counter == null)
        counter = 0;
      assert(Buffer.isBuffer(key));
      assert(Buffer.isBuffer(nonce));
      assert(Number.isSafeInteger(counter));
      if (key.length !== 16 && key.length !== 32)
        throw new RangeError("Invalid key size.");
      if (nonce.length >= 24) {
        key = ChaCha20.derive(key, nonce.slice(0, 16));
        nonce = nonce.slice(16);
      }
      this.state[0] = 1634760805;
      this.state[1] = key.length < 32 ? 824206446 : 857760878;
      this.state[2] = key.length < 32 ? 2036477238 : 2036477234;
      this.state[3] = 1797285236;
      this.state[4] = readU32(key, 0);
      this.state[5] = readU32(key, 4);
      this.state[6] = readU32(key, 8);
      this.state[7] = readU32(key, 12);
      this.state[8] = readU32(key, 16 % key.length);
      this.state[9] = readU32(key, 20 % key.length);
      this.state[10] = readU32(key, 24 % key.length);
      this.state[11] = readU32(key, 28 % key.length);
      this.state[12] = counter >>> 0;
      if (nonce.length === 8) {
        this.state[13] = counter / 4294967296 >>> 0;
        this.state[14] = readU32(nonce, 0);
        this.state[15] = readU32(nonce, 4);
      } else if (nonce.length === 12) {
        this.state[13] = readU32(nonce, 0);
        this.state[14] = readU32(nonce, 4);
        this.state[15] = readU32(nonce, 8);
      } else if (nonce.length === 16) {
        this.state[12] = readU32(nonce, 0);
        this.state[13] = readU32(nonce, 4);
        this.state[14] = readU32(nonce, 8);
        this.state[15] = readU32(nonce, 12);
      } else {
        throw new RangeError("Invalid nonce size.");
      }
      this.pos = 0;
      return this;
    }
    encrypt(data) {
      assert(Buffer.isBuffer(data));
      if (this.pos === -1)
        throw new Error("Context is not initialized.");
      for (let i = 0; i < data.length; i++) {
        if ((this.pos & 63) === 0) {
          this._block();
          this.pos = 0;
        }
        data[i] ^= this.bytes[this.pos++];
      }
      return data;
    }
    _block() {
      for (let i = 0; i < 16; i++)
        this.stream[i] = this.state[i];
      for (let i = 0; i < 10; i++) {
        qround(this.stream, 0, 4, 8, 12);
        qround(this.stream, 1, 5, 9, 13);
        qround(this.stream, 2, 6, 10, 14);
        qround(this.stream, 3, 7, 11, 15);
        qround(this.stream, 0, 5, 10, 15);
        qround(this.stream, 1, 6, 11, 12);
        qround(this.stream, 2, 7, 8, 13);
        qround(this.stream, 3, 4, 9, 14);
      }
      for (let i = 0; i < 16; i++)
        this.stream[i] += this.state[i];
      if (BIG_ENDIAN) {
        for (let i = 0; i < 16; i++)
          writeU32(this.bytes, this.stream[i], i * 4);
      }
      this.state[12] += 1;
      if (this.state[12] === 0)
        this.state[13] += 1;
    }
    destroy() {
      for (let i = 0; i < 16; i++) {
        this.state[i] = 0;
        this.stream[i] = 0;
      }
      if (BIG_ENDIAN) {
        for (let i = 0; i < 64; i++)
          this.bytes[i] = 0;
      }
      this.pos = -1;
      return this;
    }
    static derive(key, nonce) {
      assert(Buffer.isBuffer(key));
      assert(Buffer.isBuffer(nonce));
      if (key.length !== 16 && key.length !== 32)
        throw new RangeError("Invalid key size.");
      if (nonce.length !== 16)
        throw new RangeError("Invalid nonce size.");
      const state = new Uint32Array(16);
      state[0] = 1634760805;
      state[1] = key.length < 32 ? 824206446 : 857760878;
      state[2] = key.length < 32 ? 2036477238 : 2036477234;
      state[3] = 1797285236;
      state[4] = readU32(key, 0);
      state[5] = readU32(key, 4);
      state[6] = readU32(key, 8);
      state[7] = readU32(key, 12);
      state[8] = readU32(key, 16 % key.length);
      state[9] = readU32(key, 20 % key.length);
      state[10] = readU32(key, 24 % key.length);
      state[11] = readU32(key, 28 % key.length);
      state[12] = readU32(nonce, 0);
      state[13] = readU32(nonce, 4);
      state[14] = readU32(nonce, 8);
      state[15] = readU32(nonce, 12);
      for (let i = 0; i < 10; i++) {
        qround(state, 0, 4, 8, 12);
        qround(state, 1, 5, 9, 13);
        qround(state, 2, 6, 10, 14);
        qround(state, 3, 7, 11, 15);
        qround(state, 0, 5, 10, 15);
        qround(state, 1, 6, 11, 12);
        qround(state, 2, 7, 8, 13);
        qround(state, 3, 4, 9, 14);
      }
      const out = Buffer.alloc(32);
      writeU32(out, state[0], 0);
      writeU32(out, state[1], 4);
      writeU32(out, state[2], 8);
      writeU32(out, state[3], 12);
      writeU32(out, state[12], 16);
      writeU32(out, state[13], 20);
      writeU32(out, state[14], 24);
      writeU32(out, state[15], 28);
      return out;
    }
  };
  ChaCha20.native = 0;
  function qround(x, a, b, c, d) {
    x[a] += x[b];
    x[d] = rotl32(x[d] ^ x[a], 16);
    x[c] += x[d];
    x[b] = rotl32(x[b] ^ x[c], 12);
    x[a] += x[b];
    x[d] = rotl32(x[d] ^ x[a], 8);
    x[c] += x[d];
    x[b] = rotl32(x[b] ^ x[c], 7);
  }
  function rotl32(w, b) {
    return w << b | w >>> 32 - b;
  }
  function readU32(data, off) {
    return data[off++] + data[off++] * 256 + data[off++] * 65536 + data[off] * 16777216;
  }
  function writeU32(dst, num, off) {
    dst[off++] = num;
    num >>>= 8;
    dst[off++] = num;
    num >>>= 8;
    dst[off++] = num;
    num >>>= 8;
    dst[off++] = num;
    return off;
  }
  module2.exports = ChaCha20;
});

// node_modules/bcrypto/lib/js/poly1305.js
var require_poly1305 = __commonJS((exports2, module2) => {
  /*!
   * poly1305.js - poly1305 for bcrypto
   * Copyright (c) 2016-2019, Christopher Jeffrey (MIT License).
   * https://github.com/bcoin-org/bcrypto
   *
   * Parts of this software are based on floodyberry/poly1305-donna:
   *   Placed into the public domain by Andrew Moon.
   *   https://github.com/floodyberry/poly1305-donna
   *
   * Resources:
   *   https://en.wikipedia.org/wiki/Poly1305
   *   https://cr.yp.to/mac.html
   *   https://tools.ietf.org/html/rfc7539#section-2.5
   *   https://github.com/floodyberry/poly1305-donna/blob/master/poly1305-donna-16.h
   */
  "use strict";
  var assert = require_assert2();
  var Poly1305 = class {
    constructor() {
      this.r = new Uint16Array(10);
      this.h = new Uint16Array(10);
      this.pad = new Uint16Array(8);
      this.buffer = Buffer.alloc(16);
      this.fin = -1;
      this.leftover = 0;
    }
    init(key) {
      assert(Buffer.isBuffer(key) && key.length >= 32);
      const t0 = readU16(key, 0);
      const t1 = readU16(key, 2);
      const t2 = readU16(key, 4);
      const t3 = readU16(key, 6);
      const t4 = readU16(key, 8);
      const t5 = readU16(key, 10);
      const t6 = readU16(key, 12);
      const t7 = readU16(key, 14);
      this.r[0] = t0 & 8191;
      this.r[1] = (t0 >>> 13 | t1 << 3) & 8191;
      this.r[2] = (t1 >>> 10 | t2 << 6) & 7939;
      this.r[3] = (t2 >>> 7 | t3 << 9) & 8191;
      this.r[4] = (t3 >>> 4 | t4 << 12) & 255;
      this.r[5] = t4 >>> 1 & 8190;
      this.r[6] = (t4 >>> 14 | t5 << 2) & 8191;
      this.r[7] = (t5 >>> 11 | t6 << 5) & 8065;
      this.r[8] = (t6 >>> 8 | t7 << 8) & 8191;
      this.r[9] = t7 >>> 5 & 127;
      for (let i = 0; i < 10; i++)
        this.h[i] = 0;
      for (let i = 0; i < 8; i++)
        this.pad[i] = readU16(key, 16 + 2 * i);
      this.fin = 0;
      this.leftover = 0;
      return this;
    }
    _blocks(data, bytes, m) {
      const hibit = this.fin ? 0 : 1 << 11;
      const d = new Uint32Array(10);
      while (bytes >= 16) {
        const t0 = readU16(data, m + 0);
        const t1 = readU16(data, m + 2);
        const t2 = readU16(data, m + 4);
        const t3 = readU16(data, m + 6);
        const t4 = readU16(data, m + 8);
        const t5 = readU16(data, m + 10);
        const t6 = readU16(data, m + 12);
        const t7 = readU16(data, m + 14);
        this.h[0] += t0 & 8191;
        this.h[1] += (t0 >>> 13 | t1 << 3) & 8191;
        this.h[2] += (t1 >>> 10 | t2 << 6) & 8191;
        this.h[3] += (t2 >>> 7 | t3 << 9) & 8191;
        this.h[4] += (t3 >>> 4 | t4 << 12) & 8191;
        this.h[5] += t4 >>> 1 & 8191;
        this.h[6] += (t4 >>> 14 | t5 << 2) & 8191;
        this.h[7] += (t5 >>> 11 | t6 << 5) & 8191;
        this.h[8] += (t6 >>> 8 | t7 << 8) & 8191;
        this.h[9] += t7 >>> 5 | hibit;
        let c = 0;
        for (let i = 0; i < 10; i++) {
          d[i] = c;
          for (let j = 0; j < 10; j++) {
            let a = this.h[j];
            if (j <= i)
              a *= this.r[i - j];
            else
              a *= 5 * this.r[i + 10 - j];
            d[i] += a;
            if (j === 4) {
              c = d[i] >>> 13;
              d[i] &= 8191;
            }
          }
          c += d[i] >>> 13;
          d[i] &= 8191;
        }
        c = (c << 2) + c;
        c += d[0];
        d[0] = c & 8191;
        c = c >>> 13;
        d[1] += c;
        for (let i = 0; i < 10; i++)
          this.h[i] = d[i];
        m += 16;
        bytes -= 16;
      }
    }
    update(data) {
      assert(Buffer.isBuffer(data));
      if (this.fin === -1)
        throw new Error("Context is not initialized.");
      let bytes = data.length;
      let m = 0;
      if (this.leftover) {
        let want = 16 - this.leftover;
        if (want > bytes)
          want = bytes;
        for (let i = 0; i < want; i++)
          this.buffer[this.leftover + i] = data[m + i];
        bytes -= want;
        m += want;
        this.leftover += want;
        if (this.leftover < 16)
          return this;
        this._blocks(this.buffer, 16, 0);
        this.leftover = 0;
      }
      if (bytes >= 16) {
        const want = bytes & ~(16 - 1);
        this._blocks(data, want, m);
        m += want;
        bytes -= want;
      }
      if (bytes) {
        for (let i = 0; i < bytes; i++)
          this.buffer[this.leftover + i] = data[m + i];
        this.leftover += bytes;
      }
      return this;
    }
    final() {
      if (this.fin === -1)
        throw new Error("Context is not initialized.");
      const mac = Buffer.alloc(16);
      const g = new Uint16Array(10);
      if (this.leftover) {
        let i = this.leftover;
        this.buffer[i++] = 1;
        for (; i < 16; i++)
          this.buffer[i] = 0;
        this.fin = 1;
        this._blocks(this.buffer, 16, 0);
      }
      let c = this.h[1] >>> 13;
      this.h[1] &= 8191;
      for (let i = 2; i < 10; i++) {
        this.h[i] += c;
        c = this.h[i] >>> 13;
        this.h[i] &= 8191;
      }
      this.h[0] += c * 5;
      c = this.h[0] >>> 13;
      this.h[0] &= 8191;
      this.h[1] += c;
      c = this.h[1] >>> 13;
      this.h[1] &= 8191;
      this.h[2] += c;
      g[0] = this.h[0] + 5;
      c = g[0] >>> 13;
      g[0] &= 8191;
      for (let i = 1; i < 10; i++) {
        g[i] = this.h[i] + c;
        c = g[i] >>> 13;
        g[i] &= 8191;
      }
      let mask = (c ^ 1) - 1;
      for (let i = 0; i < 10; i++)
        g[i] &= mask;
      mask = ~mask;
      for (let i = 0; i < 10; i++)
        this.h[i] = this.h[i] & mask | g[i];
      this.h[0] = (this.h[0] | this.h[1] << 13) & 65535;
      this.h[1] = (this.h[1] >>> 3 | this.h[2] << 10) & 65535;
      this.h[2] = (this.h[2] >>> 6 | this.h[3] << 7) & 65535;
      this.h[3] = (this.h[3] >>> 9 | this.h[4] << 4) & 65535;
      this.h[4] = (this.h[4] >>> 12 | this.h[5] << 1 | this.h[6] << 14) & 65535;
      this.h[5] = (this.h[6] >>> 2 | this.h[7] << 11) & 65535;
      this.h[6] = (this.h[7] >>> 5 | this.h[8] << 8) & 65535;
      this.h[7] = (this.h[8] >>> 8 | this.h[9] << 5) & 65535;
      let f = this.h[0] + this.pad[0];
      this.h[0] = f;
      for (let i = 1; i < 8; i++) {
        f = this.h[i] + this.pad[i] + (f >>> 16);
        this.h[i] = f;
      }
      for (let i = 0; i < 8; i++)
        writeU16(mac, this.h[i], i * 2);
      this.destroy();
      return mac;
    }
    destroy() {
      for (let i = 0; i < 10; i++) {
        this.r[i] = 0;
        this.h[i] = 0;
      }
      for (let i = 0; i < 8; i++)
        this.pad[i] = 0;
      for (let i = 0; i < 16; i++)
        this.buffer[i] = 0;
      this.fin = -1;
      this.leftover = 0;
    }
    verify(tag) {
      assert(Buffer.isBuffer(tag));
      assert(tag.length === 16);
      const mac = this.final();
      let z = 0;
      for (let i = 0; i < 16; i++)
        z |= mac[i] ^ tag[i];
      return z - 1 >>> 31 !== 0;
    }
  };
  Poly1305.native = 0;
  function readU16(data, off) {
    return data[off++] + data[off] * 256;
  }
  function writeU16(dst, num, off) {
    dst[off++] = num;
    dst[off++] = num >>> 8;
    return off;
  }
  module2.exports = Poly1305;
});

// node_modules/bcrypto/lib/js/aead.js
var require_aead = __commonJS((exports2, module2) => {
  /*!
   * aead.js - aead for bcrypto
   * Copyright (c) 2016-2019, Christopher Jeffrey (MIT License).
   * https://github.com/bcoin-org/bcrypto
   *
   * Resources:
   *   https://tools.ietf.org/html/rfc7539#section-2.8
   *   https://github.com/openssh/openssh-portable
   */
  "use strict";
  var assert = require_assert2();
  var ChaCha20 = require_chacha20();
  var Poly1305 = require_poly1305();
  var zero16 = Buffer.alloc(16, 0);
  var AEAD = class {
    constructor() {
      this.chacha = new ChaCha20();
      this.poly = new Poly1305();
      this.key = Buffer.alloc(64);
      this.mode = -1;
      this.aadLen = 0;
      this.cipherLen = 0;
    }
    init(key, iv) {
      assert(Buffer.isBuffer(key));
      assert(Buffer.isBuffer(iv));
      this.key.fill(0);
      this.chacha.init(key, iv, 0);
      this.chacha.encrypt(this.key);
      this.poly.init(this.key);
      this.mode = 0;
      this.aadLen = 0;
      this.cipherLen = 0;
      return this;
    }
    aad(data) {
      if (this.mode === -1)
        throw new Error("Context is not initialized.");
      if (this.mode !== 0)
        throw new Error("Invalid state for aad.");
      this.poly.update(data);
      this.aadLen += data.length;
      return this;
    }
    encrypt(data) {
      if (this.mode === -1)
        throw new Error("Context is not initialized.");
      if (this.mode !== 0 && this.mode !== 1)
        throw new Error("Invalid state for encrypt.");
      if (this.mode === 0) {
        this._pad16(this.aadLen);
        this.mode = 1;
      }
      this.chacha.encrypt(data);
      this.poly.update(data);
      this.cipherLen += data.length;
      return data;
    }
    decrypt(data) {
      assert(Buffer.isBuffer(data));
      if (this.mode === -1)
        throw new Error("Context is not initialized.");
      if (this.mode !== 0 && this.mode !== 2)
        throw new Error("Invalid state for decrypt.");
      if (this.mode === 0) {
        this._pad16(this.aadLen);
        this.mode = 2;
      }
      this.cipherLen += data.length;
      this.poly.update(data);
      this.chacha.encrypt(data);
      return data;
    }
    auth(data) {
      assert(Buffer.isBuffer(data));
      if (this.mode === -1)
        throw new Error("Context is not initialized.");
      if (this.mode !== 0 && this.mode !== 3)
        throw new Error("Invalid state for auth.");
      if (this.mode === 0) {
        this._pad16(this.aadLen);
        this.mode = 3;
      }
      this.cipherLen += data.length;
      this.poly.update(data);
      return data;
    }
    final() {
      if (this.mode === -1)
        throw new Error("Context is not initialized.");
      const len = Buffer.alloc(16);
      writeU64(len, this.aadLen, 0);
      writeU64(len, this.cipherLen, 8);
      if (this.mode === 0)
        this._pad16(this.aadLen);
      this._pad16(this.cipherLen);
      this.poly.update(len);
      const mac = this.poly.final();
      this.destroy();
      return mac;
    }
    destroy() {
      this.chacha.destroy();
      this.poly.destroy();
      for (let i = 0; i < 64; i++)
        this.key[i] = 0;
      this.mode = -1;
      this.aadLen = 0;
      this.cipherLen = 0;
      return this;
    }
    verify(tag) {
      assert(Buffer.isBuffer(tag));
      assert(tag.length === 16);
      const mac = this.final();
      let z = 0;
      for (let i = 0; i < 16; i++)
        z |= mac[i] ^ tag[i];
      return z - 1 >>> 31 !== 0;
    }
    _pad16(size) {
      const pos = size & 15;
      if (pos > 0)
        this.poly.update(zero16.slice(0, 16 - pos));
    }
    static encrypt(key, iv, msg, aad) {
      const aead = new AEAD();
      aead.init(key, iv);
      if (aad)
        aead.aad(aad);
      aead.encrypt(msg);
      return aead.final();
    }
    static decrypt(key, iv, msg, tag, aad) {
      const aead = new AEAD();
      aead.init(key, iv);
      if (aad)
        aead.aad(aad);
      aead.decrypt(msg);
      return aead.verify(tag);
    }
    static auth(key, iv, msg, tag, aad) {
      const aead = new AEAD();
      aead.init(key, iv);
      if (aad)
        aead.aad(aad);
      aead.auth(msg);
      return aead.verify(tag);
    }
  };
  AEAD.native = ChaCha20.native;
  function writeU32(dst, num, off) {
    dst[off++] = num;
    num >>>= 8;
    dst[off++] = num;
    num >>>= 8;
    dst[off++] = num;
    num >>>= 8;
    dst[off++] = num;
    return off;
  }
  function writeU64(dst, num, off) {
    const hi = num * (1 / 4294967296) >>> 0;
    const lo = num >>> 0;
    writeU32(dst, lo, off + 0);
    writeU32(dst, hi, off + 4);
    return off + 8;
  }
  module2.exports = AEAD;
});

// node_modules/libp2p-noise/dist/src/constants.js
var require_constants18 = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.DUMP_SESSION_KEYS = exports2.NOISE_MSG_MAX_LENGTH_BYTES_WITHOUT_TAG = exports2.NOISE_MSG_MAX_LENGTH_BYTES = void 0;
  exports2.NOISE_MSG_MAX_LENGTH_BYTES = 65535;
  exports2.NOISE_MSG_MAX_LENGTH_BYTES_WITHOUT_TAG = exports2.NOISE_MSG_MAX_LENGTH_BYTES - 16;
  exports2.DUMP_SESSION_KEYS = process.env.DUMP_SESSION_KEYS;
});

// node_modules/libp2p-noise/dist/src/logger.js
var require_logger = __commonJS((exports2) => {
  "use strict";
  var __importDefault = exports2 && exports2.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {default: mod};
  };
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.logCipherState = exports2.logRemoteEphemeralKey = exports2.logRemoteStaticKey = exports2.logLocalEphemeralKeys = exports2.logLocalStaticKeys = exports2.logger = void 0;
  var debug_1 = __importDefault(require_browser4());
  var constants_1 = require_constants18();
  exports2.logger = debug_1.default("libp2p:noise");
  var keyLogger;
  if (constants_1.DUMP_SESSION_KEYS) {
    keyLogger = exports2.logger;
  } else {
    keyLogger = () => {
    };
  }
  function logLocalStaticKeys(s) {
    keyLogger(`LOCAL_STATIC_PUBLIC_KEY ${s.publicKey.toString("hex")}`);
    keyLogger(`LOCAL_STATIC_PRIVATE_KEY ${s.privateKey.toString("hex")}`);
  }
  exports2.logLocalStaticKeys = logLocalStaticKeys;
  function logLocalEphemeralKeys(e) {
    if (e) {
      keyLogger(`LOCAL_PUBLIC_EPHEMERAL_KEY ${e.publicKey.toString("hex")}`);
      keyLogger(`LOCAL_PRIVATE_EPHEMERAL_KEY ${e.privateKey.toString("hex")}`);
    } else {
      keyLogger("Missing local ephemeral keys.");
    }
  }
  exports2.logLocalEphemeralKeys = logLocalEphemeralKeys;
  function logRemoteStaticKey(rs) {
    keyLogger(`REMOTE_STATIC_PUBLIC_KEY ${rs.toString("hex")}`);
  }
  exports2.logRemoteStaticKey = logRemoteStaticKey;
  function logRemoteEphemeralKey(re) {
    keyLogger(`REMOTE_EPHEMERAL_PUBLIC_KEY ${re.toString("hex")}`);
  }
  exports2.logRemoteEphemeralKey = logRemoteEphemeralKey;
  function logCipherState(session) {
    if (session.cs1 && session.cs2) {
      keyLogger(`CIPHER_STATE_1 ${session.cs1.n} ${session.cs1.k.toString("hex")}`);
      keyLogger(`CIPHER_STATE_2 ${session.cs2.n} ${session.cs2.k.toString("hex")}`);
    } else {
      keyLogger("Missing cipher state.");
    }
  }
  exports2.logCipherState = logCipherState;
});

// node_modules/libp2p-noise/dist/src/handshakes/abstract-handshake.js
var require_abstract_handshake = __commonJS((exports2) => {
  "use strict";
  var __importDefault = exports2 && exports2.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {default: mod};
  };
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.AbstractHandshake = exports2.MIN_NONCE = void 0;
  var buffer_1 = require_buffer();
  var aead_1 = __importDefault(require_aead());
  var x25519_1 = __importDefault(require_x25519());
  var sha256_1 = __importDefault(require_sha2562());
  var utils_1 = require_utils31();
  var logger_1 = require_logger();
  exports2.MIN_NONCE = 0;
  var AbstractHandshake = class {
    encryptWithAd(cs, ad, plaintext) {
      const e = this.encrypt(cs.k, cs.n, ad, plaintext);
      this.setNonce(cs, this.incrementNonce(cs.n));
      return e;
    }
    decryptWithAd(cs, ad, ciphertext) {
      const {plaintext, valid} = this.decrypt(cs.k, cs.n, ad, ciphertext);
      this.setNonce(cs, this.incrementNonce(cs.n));
      return {plaintext, valid};
    }
    hasKey(cs) {
      return !this.isEmptyKey(cs.k);
    }
    setNonce(cs, nonce) {
      cs.n = nonce;
    }
    createEmptyKey() {
      return buffer_1.Buffer.alloc(32);
    }
    isEmptyKey(k) {
      const emptyKey = this.createEmptyKey();
      return emptyKey.equals(k);
    }
    incrementNonce(n) {
      return n + 1;
    }
    nonceToBytes(n) {
      const nonce = buffer_1.Buffer.alloc(12);
      nonce.writeUInt32LE(n, 4);
      return nonce;
    }
    encrypt(k, n, ad, plaintext) {
      const nonce = this.nonceToBytes(n);
      const ctx = new aead_1.default();
      plaintext = buffer_1.Buffer.from(plaintext);
      ctx.init(k, nonce);
      ctx.aad(ad);
      ctx.encrypt(plaintext);
      return buffer_1.Buffer.concat([plaintext, ctx.final()]);
    }
    encryptAndHash(ss, plaintext) {
      let ciphertext;
      if (this.hasKey(ss.cs)) {
        ciphertext = this.encryptWithAd(ss.cs, ss.h, plaintext);
      } else {
        ciphertext = plaintext;
      }
      this.mixHash(ss, ciphertext);
      return ciphertext;
    }
    decrypt(k, n, ad, ciphertext) {
      const nonce = this.nonceToBytes(n);
      const ctx = new aead_1.default();
      ciphertext = buffer_1.Buffer.from(ciphertext);
      const tag = ciphertext.slice(ciphertext.length - 16);
      ciphertext = ciphertext.slice(0, ciphertext.length - 16);
      ctx.init(k, nonce);
      ctx.aad(ad);
      ctx.decrypt(ciphertext);
      return {plaintext: ciphertext, valid: ctx.verify(tag)};
    }
    decryptAndHash(ss, ciphertext) {
      let plaintext;
      let valid = true;
      if (this.hasKey(ss.cs)) {
        ({plaintext, valid} = this.decryptWithAd(ss.cs, ss.h, ciphertext));
      } else {
        plaintext = ciphertext;
      }
      this.mixHash(ss, ciphertext);
      return {plaintext, valid};
    }
    dh(privateKey, publicKey) {
      try {
        const derived = x25519_1.default.derive(publicKey, privateKey);
        const result = buffer_1.Buffer.alloc(32);
        derived.copy(result);
        return result;
      } catch (e) {
        logger_1.logger(e.message);
        return buffer_1.Buffer.alloc(32);
      }
    }
    mixHash(ss, data) {
      ss.h = this.getHash(ss.h, data);
    }
    getHash(a, b) {
      return sha256_1.default.digest(buffer_1.Buffer.from([...a, ...b]));
    }
    mixKey(ss, ikm) {
      const [ck, tempK] = utils_1.getHkdf(ss.ck, ikm);
      ss.cs = this.initializeKey(tempK);
      ss.ck = ck;
    }
    initializeKey(k) {
      const n = exports2.MIN_NONCE;
      return {k, n};
    }
    initializeSymmetric(protocolName) {
      const protocolNameBytes = buffer_1.Buffer.from(protocolName, "utf-8");
      const h = this.hashProtocolName(protocolNameBytes);
      const ck = h;
      const key = this.createEmptyKey();
      const cs = this.initializeKey(key);
      return {cs, ck, h};
    }
    hashProtocolName(protocolName) {
      if (protocolName.length <= 32) {
        const h = buffer_1.Buffer.alloc(32);
        protocolName.copy(h);
        return h;
      } else {
        return this.getHash(protocolName, buffer_1.Buffer.alloc(0));
      }
    }
    split(ss) {
      const [tempk1, tempk2] = utils_1.getHkdf(ss.ck, buffer_1.Buffer.alloc(0));
      const cs1 = this.initializeKey(tempk1);
      const cs2 = this.initializeKey(tempk2);
      return {cs1, cs2};
    }
    writeMessageRegular(cs, payload) {
      const ciphertext = this.encryptWithAd(cs, buffer_1.Buffer.alloc(0), payload);
      const ne = this.createEmptyKey();
      const ns = buffer_1.Buffer.alloc(0);
      return {ne, ns, ciphertext};
    }
    readMessageRegular(cs, message) {
      return this.decryptWithAd(cs, buffer_1.Buffer.alloc(0), message.ciphertext);
    }
  };
  exports2.AbstractHandshake = AbstractHandshake;
});

// node_modules/libp2p-noise/dist/src/handshakes/xx.js
var require_xx = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.XX = void 0;
  var buffer_1 = require_buffer();
  var utils_1 = require_utils31();
  var abstract_handshake_1 = require_abstract_handshake();
  var XX = class extends abstract_handshake_1.AbstractHandshake {
    initializeInitiator(prologue, s, rs, psk) {
      const name = "Noise_XX_25519_ChaChaPoly_SHA256";
      const ss = this.initializeSymmetric(name);
      this.mixHash(ss, prologue);
      const re = buffer_1.Buffer.alloc(32);
      return {ss, s, rs, psk, re};
    }
    initializeResponder(prologue, s, rs, psk) {
      const name = "Noise_XX_25519_ChaChaPoly_SHA256";
      const ss = this.initializeSymmetric(name);
      this.mixHash(ss, prologue);
      const re = buffer_1.Buffer.alloc(32);
      return {ss, s, rs, psk, re};
    }
    writeMessageA(hs, payload, e) {
      const ns = buffer_1.Buffer.alloc(0);
      if (e) {
        hs.e = e;
      } else {
        hs.e = utils_1.generateKeypair();
      }
      const ne = hs.e.publicKey;
      this.mixHash(hs.ss, ne);
      const ciphertext = this.encryptAndHash(hs.ss, payload);
      return {ne, ns, ciphertext};
    }
    writeMessageB(hs, payload) {
      hs.e = utils_1.generateKeypair();
      const ne = hs.e.publicKey;
      this.mixHash(hs.ss, ne);
      this.mixKey(hs.ss, this.dh(hs.e.privateKey, hs.re));
      const spk = buffer_1.Buffer.from(hs.s.publicKey);
      const ns = this.encryptAndHash(hs.ss, spk);
      this.mixKey(hs.ss, this.dh(hs.s.privateKey, hs.re));
      const ciphertext = this.encryptAndHash(hs.ss, payload);
      return {ne, ns, ciphertext};
    }
    writeMessageC(hs, payload) {
      const spk = buffer_1.Buffer.from(hs.s.publicKey);
      const ns = this.encryptAndHash(hs.ss, spk);
      this.mixKey(hs.ss, this.dh(hs.s.privateKey, hs.re));
      const ciphertext = this.encryptAndHash(hs.ss, payload);
      const ne = this.createEmptyKey();
      const messageBuffer = {ne, ns, ciphertext};
      const {cs1, cs2} = this.split(hs.ss);
      return {h: hs.ss.h, messageBuffer, cs1, cs2};
    }
    readMessageA(hs, message) {
      if (utils_1.isValidPublicKey(message.ne)) {
        hs.re = message.ne;
      }
      this.mixHash(hs.ss, hs.re);
      return this.decryptAndHash(hs.ss, message.ciphertext);
    }
    readMessageB(hs, message) {
      if (utils_1.isValidPublicKey(message.ne)) {
        hs.re = message.ne;
      }
      this.mixHash(hs.ss, hs.re);
      if (!hs.e) {
        throw new Error("Handshake state `e` param is missing.");
      }
      this.mixKey(hs.ss, this.dh(hs.e.privateKey, hs.re));
      const {plaintext: ns, valid: valid1} = this.decryptAndHash(hs.ss, message.ns);
      if (valid1 && ns.length === 32 && utils_1.isValidPublicKey(ns)) {
        hs.rs = ns;
      }
      this.mixKey(hs.ss, this.dh(hs.e.privateKey, hs.rs));
      const {plaintext, valid: valid2} = this.decryptAndHash(hs.ss, message.ciphertext);
      return {plaintext, valid: valid1 && valid2};
    }
    readMessageC(hs, message) {
      const {plaintext: ns, valid: valid1} = this.decryptAndHash(hs.ss, message.ns);
      if (valid1 && ns.length === 32 && utils_1.isValidPublicKey(ns)) {
        hs.rs = ns;
      }
      if (!hs.e) {
        throw new Error("Handshake state `e` param is missing.");
      }
      this.mixKey(hs.ss, this.dh(hs.e.privateKey, hs.rs));
      const {plaintext, valid: valid2} = this.decryptAndHash(hs.ss, message.ciphertext);
      const {cs1, cs2} = this.split(hs.ss);
      return {h: hs.ss.h, plaintext, valid: valid1 && valid2, cs1, cs2};
    }
    initSession(initiator, prologue, s) {
      const psk = this.createEmptyKey();
      const rs = buffer_1.Buffer.alloc(32);
      let hs;
      if (initiator) {
        hs = this.initializeInitiator(prologue, s, rs, psk);
      } else {
        hs = this.initializeResponder(prologue, s, rs, psk);
      }
      return {
        hs,
        i: initiator,
        mc: 0
      };
    }
    sendMessage(session, message, ephemeral) {
      let messageBuffer;
      if (session.mc === 0) {
        messageBuffer = this.writeMessageA(session.hs, message, ephemeral);
      } else if (session.mc === 1) {
        messageBuffer = this.writeMessageB(session.hs, message);
      } else if (session.mc === 2) {
        const {h, messageBuffer: resultingBuffer, cs1, cs2} = this.writeMessageC(session.hs, message);
        messageBuffer = resultingBuffer;
        session.h = h;
        session.cs1 = cs1;
        session.cs2 = cs2;
      } else if (session.mc > 2) {
        if (session.i) {
          if (!session.cs1) {
            throw new Error("CS1 (cipher state) is not defined");
          }
          messageBuffer = this.writeMessageRegular(session.cs1, message);
        } else {
          if (!session.cs2) {
            throw new Error("CS2 (cipher state) is not defined");
          }
          messageBuffer = this.writeMessageRegular(session.cs2, message);
        }
      } else {
        throw new Error("Session invalid.");
      }
      session.mc++;
      return messageBuffer;
    }
    recvMessage(session, message) {
      let plaintext = buffer_1.Buffer.alloc(0);
      let valid = false;
      if (session.mc === 0) {
        ({plaintext, valid} = this.readMessageA(session.hs, message));
      } else if (session.mc === 1) {
        ({plaintext, valid} = this.readMessageB(session.hs, message));
      } else if (session.mc === 2) {
        const {h, plaintext: resultingPlaintext, valid: resultingValid, cs1, cs2} = this.readMessageC(session.hs, message);
        plaintext = resultingPlaintext;
        valid = resultingValid;
        session.h = h;
        session.cs1 = cs1;
        session.cs2 = cs2;
      }
      session.mc++;
      return {plaintext, valid};
    }
  };
  exports2.XX = XX;
});

// node_modules/libp2p-noise/dist/src/encoder.js
var require_encoder4 = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.decode2 = exports2.decode1 = exports2.decode0 = exports2.encode2 = exports2.encode1 = exports2.encode0 = exports2.uint16BEDecode = exports2.uint16BEEncode = void 0;
  var buffer_1 = require_buffer();
  var uint16BEEncode = (value, target, offset) => {
    target = target || buffer_1.Buffer.allocUnsafe(2);
    target.writeUInt16BE(value, offset);
    return target;
  };
  exports2.uint16BEEncode = uint16BEEncode;
  exports2.uint16BEEncode.bytes = 2;
  var uint16BEDecode = (data) => {
    if (data.length < 2)
      throw RangeError("Could not decode int16BE");
    return data.readUInt16BE(0);
  };
  exports2.uint16BEDecode = uint16BEDecode;
  exports2.uint16BEDecode.bytes = 2;
  function encode0(message) {
    return buffer_1.Buffer.concat([message.ne, message.ciphertext]);
  }
  exports2.encode0 = encode0;
  function encode1(message) {
    return buffer_1.Buffer.concat([message.ne, message.ns, message.ciphertext]);
  }
  exports2.encode1 = encode1;
  function encode2(message) {
    return buffer_1.Buffer.concat([message.ns, message.ciphertext]);
  }
  exports2.encode2 = encode2;
  function decode0(input) {
    if (input.length < 32) {
      throw new Error("Cannot decode stage 0 MessageBuffer: length less than 32 bytes.");
    }
    return {
      ne: input.slice(0, 32),
      ciphertext: input.slice(32, input.length),
      ns: buffer_1.Buffer.alloc(0)
    };
  }
  exports2.decode0 = decode0;
  function decode1(input) {
    if (input.length < 80) {
      throw new Error("Cannot decode stage 1 MessageBuffer: length less than 80 bytes.");
    }
    return {
      ne: input.slice(0, 32),
      ns: input.slice(32, 80),
      ciphertext: input.slice(80, input.length)
    };
  }
  exports2.decode1 = decode1;
  function decode2(input) {
    if (input.length < 48) {
      throw new Error("Cannot decode stage 2 MessageBuffer: length less than 48 bytes.");
    }
    return {
      ne: buffer_1.Buffer.alloc(0),
      ns: input.slice(0, 48),
      ciphertext: input.slice(48, input.length)
    };
  }
  exports2.decode2 = decode2;
});

// node_modules/libp2p-noise/dist/src/handshake-xx.js
var require_handshake_xx = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.XXHandshake = void 0;
  var buffer_1 = require_buffer();
  var xx_1 = require_xx();
  var utils_1 = require_utils31();
  var logger_1 = require_logger();
  var encoder_1 = require_encoder4();
  var XXHandshake = class {
    constructor(isInitiator, payload, prologue, staticKeypair, connection, remotePeer, handshake) {
      this.isInitiator = isInitiator;
      this.payload = payload;
      this.prologue = prologue;
      this.staticKeypair = staticKeypair;
      this.connection = connection;
      if (remotePeer) {
        this.remotePeer = remotePeer;
      }
      this.xx = handshake || new xx_1.XX();
      this.session = this.xx.initSession(this.isInitiator, this.prologue, this.staticKeypair);
      this.remoteEarlyData = buffer_1.Buffer.alloc(0);
    }
    async propose() {
      logger_1.logLocalStaticKeys(this.session.hs.s);
      if (this.isInitiator) {
        logger_1.logger("Stage 0 - Initiator starting to send first message.");
        const messageBuffer = this.xx.sendMessage(this.session, buffer_1.Buffer.alloc(0));
        this.connection.writeLP(encoder_1.encode0(messageBuffer));
        logger_1.logger("Stage 0 - Initiator finished sending first message.");
        logger_1.logLocalEphemeralKeys(this.session.hs.e);
      } else {
        logger_1.logger("Stage 0 - Responder waiting to receive first message...");
        const receivedMessageBuffer = encoder_1.decode0((await this.connection.readLP()).slice());
        const {valid} = this.xx.recvMessage(this.session, receivedMessageBuffer);
        if (!valid) {
          throw new Error("xx handshake stage 0 validation fail");
        }
        logger_1.logger("Stage 0 - Responder received first message.");
        logger_1.logRemoteEphemeralKey(this.session.hs.re);
      }
    }
    async exchange() {
      if (this.isInitiator) {
        logger_1.logger("Stage 1 - Initiator waiting to receive first message from responder...");
        const receivedMessageBuffer = encoder_1.decode1((await this.connection.readLP()).slice());
        const {plaintext, valid} = this.xx.recvMessage(this.session, receivedMessageBuffer);
        if (!valid) {
          throw new Error("xx handshake stage 1 validation fail");
        }
        logger_1.logger("Stage 1 - Initiator received the message.");
        logger_1.logRemoteEphemeralKey(this.session.hs.re);
        logger_1.logRemoteStaticKey(this.session.hs.rs);
        logger_1.logger("Initiator going to check remote's signature...");
        try {
          const decodedPayload = await utils_1.decodePayload(plaintext);
          this.remotePeer = this.remotePeer || await utils_1.getPeerIdFromPayload(decodedPayload);
          this.remotePeer = await utils_1.verifySignedPayload(receivedMessageBuffer.ns, decodedPayload, this.remotePeer);
          this.setRemoteEarlyData(decodedPayload.data);
        } catch (e) {
          throw new Error(`Error occurred while verifying signed payload: ${e.message}`);
        }
        logger_1.logger("All good with the signature!");
      } else {
        logger_1.logger("Stage 1 - Responder sending out first message with signed payload and static key.");
        const messageBuffer = this.xx.sendMessage(this.session, this.payload);
        this.connection.writeLP(encoder_1.encode1(messageBuffer));
        logger_1.logger("Stage 1 - Responder sent the second handshake message with signed payload.");
        logger_1.logLocalEphemeralKeys(this.session.hs.e);
      }
    }
    async finish() {
      if (this.isInitiator) {
        logger_1.logger("Stage 2 - Initiator sending third handshake message.");
        const messageBuffer = this.xx.sendMessage(this.session, this.payload);
        this.connection.writeLP(encoder_1.encode2(messageBuffer));
        logger_1.logger("Stage 2 - Initiator sent message with signed payload.");
      } else {
        logger_1.logger("Stage 2 - Responder waiting for third handshake message...");
        const receivedMessageBuffer = encoder_1.decode2((await this.connection.readLP()).slice());
        const {plaintext, valid} = this.xx.recvMessage(this.session, receivedMessageBuffer);
        if (!valid) {
          throw new Error("xx handshake stage 2 validation fail");
        }
        logger_1.logger("Stage 2 - Responder received the message, finished handshake.");
        try {
          const decodedPayload = await utils_1.decodePayload(plaintext);
          this.remotePeer = this.remotePeer || await utils_1.getPeerIdFromPayload(decodedPayload);
          await utils_1.verifySignedPayload(this.session.hs.rs, decodedPayload, this.remotePeer);
          this.setRemoteEarlyData(decodedPayload.data);
        } catch (e) {
          throw new Error(`Error occurred while verifying signed payload: ${e.message}`);
        }
      }
      logger_1.logCipherState(this.session);
    }
    encrypt(plaintext, session) {
      const cs = this.getCS(session);
      return this.xx.encryptWithAd(cs, buffer_1.Buffer.alloc(0), plaintext);
    }
    decrypt(ciphertext, session) {
      const cs = this.getCS(session, false);
      return this.xx.decryptWithAd(cs, buffer_1.Buffer.alloc(0), ciphertext);
    }
    getRemoteStaticKey() {
      return this.session.hs.rs;
    }
    getCS(session, encryption = true) {
      if (!session.cs1 || !session.cs2) {
        throw new Error("Handshake not completed properly, cipher state does not exist.");
      }
      if (this.isInitiator) {
        return encryption ? session.cs1 : session.cs2;
      } else {
        return encryption ? session.cs2 : session.cs1;
      }
    }
    setRemoteEarlyData(data) {
      if (data) {
        this.remoteEarlyData = buffer_1.Buffer.from(data.buffer, data.byteOffset, data.length);
      }
    }
  };
  exports2.XXHandshake = XXHandshake;
});

// node_modules/libp2p-noise/dist/src/handshakes/ik.js
var require_ik = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.IK = void 0;
  var buffer_1 = require_buffer();
  var utils_1 = require_utils31();
  var abstract_handshake_1 = require_abstract_handshake();
  var IK = class extends abstract_handshake_1.AbstractHandshake {
    initSession(initiator, prologue, s, rs) {
      const psk = this.createEmptyKey();
      let hs;
      if (initiator) {
        hs = this.initializeInitiator(prologue, s, rs, psk);
      } else {
        hs = this.initializeResponder(prologue, s, rs, psk);
      }
      return {
        hs,
        i: initiator,
        mc: 0
      };
    }
    sendMessage(session, message) {
      let messageBuffer;
      if (session.mc === 0) {
        messageBuffer = this.writeMessageA(session.hs, message);
      } else if (session.mc === 1) {
        const {messageBuffer: mb, h, cs1, cs2} = this.writeMessageB(session.hs, message);
        messageBuffer = mb;
        session.h = h;
        session.cs1 = cs1;
        session.cs2 = cs2;
      } else if (session.mc > 1) {
        if (session.i) {
          if (!session.cs1) {
            throw new Error("CS1 (cipher state) is not defined");
          }
          messageBuffer = this.writeMessageRegular(session.cs1, message);
        } else {
          if (!session.cs2) {
            throw new Error("CS2 (cipher state) is not defined");
          }
          messageBuffer = this.writeMessageRegular(session.cs2, message);
        }
      } else {
        throw new Error("Session invalid.");
      }
      session.mc++;
      return messageBuffer;
    }
    recvMessage(session, message) {
      let plaintext = buffer_1.Buffer.alloc(0);
      let valid = false;
      if (session.mc === 0) {
        ({plaintext, valid} = this.readMessageA(session.hs, message));
      }
      if (session.mc === 1) {
        const {plaintext: pt, valid: v, h, cs1, cs2} = this.readMessageB(session.hs, message);
        plaintext = pt;
        valid = v;
        session.h = h;
        session.cs1 = cs1;
        session.cs2 = cs2;
      }
      session.mc++;
      return {plaintext, valid};
    }
    writeMessageA(hs, payload) {
      hs.e = utils_1.generateKeypair();
      const ne = hs.e.publicKey;
      this.mixHash(hs.ss, ne);
      this.mixKey(hs.ss, this.dh(hs.e.privateKey, hs.rs));
      const spk = buffer_1.Buffer.from(hs.s.publicKey);
      const ns = this.encryptAndHash(hs.ss, spk);
      this.mixKey(hs.ss, this.dh(hs.s.privateKey, hs.rs));
      const ciphertext = this.encryptAndHash(hs.ss, payload);
      return {ne, ns, ciphertext};
    }
    writeMessageB(hs, payload) {
      hs.e = utils_1.generateKeypair();
      const ne = hs.e.publicKey;
      this.mixHash(hs.ss, ne);
      this.mixKey(hs.ss, this.dh(hs.e.privateKey, hs.re));
      this.mixKey(hs.ss, this.dh(hs.e.privateKey, hs.rs));
      const ciphertext = this.encryptAndHash(hs.ss, payload);
      const ns = this.createEmptyKey();
      const messageBuffer = {ne, ns, ciphertext};
      const {cs1, cs2} = this.split(hs.ss);
      return {messageBuffer, cs1, cs2, h: hs.ss.h};
    }
    readMessageA(hs, message) {
      if (utils_1.isValidPublicKey(message.ne)) {
        hs.re = message.ne;
      }
      this.mixHash(hs.ss, hs.re);
      this.mixKey(hs.ss, this.dh(hs.s.privateKey, hs.re));
      const {plaintext: ns, valid: valid1} = this.decryptAndHash(hs.ss, message.ns);
      if (valid1 && ns.length === 32 && utils_1.isValidPublicKey(ns)) {
        hs.rs = ns;
      }
      this.mixKey(hs.ss, this.dh(hs.s.privateKey, hs.rs));
      const {plaintext, valid: valid2} = this.decryptAndHash(hs.ss, message.ciphertext);
      return {plaintext, valid: valid1 && valid2};
    }
    readMessageB(hs, message) {
      if (utils_1.isValidPublicKey(message.ne)) {
        hs.re = message.ne;
      }
      this.mixHash(hs.ss, hs.re);
      if (!hs.e) {
        throw new Error("Handshake state should contain ephemeral key by now.");
      }
      this.mixKey(hs.ss, this.dh(hs.e.privateKey, hs.re));
      this.mixKey(hs.ss, this.dh(hs.s.privateKey, hs.re));
      const {plaintext, valid} = this.decryptAndHash(hs.ss, message.ciphertext);
      const {cs1, cs2} = this.split(hs.ss);
      return {h: hs.ss.h, valid, plaintext, cs1, cs2};
    }
    initializeInitiator(prologue, s, rs, psk) {
      const name = "Noise_IK_25519_ChaChaPoly_SHA256";
      const ss = this.initializeSymmetric(name);
      this.mixHash(ss, prologue);
      this.mixHash(ss, rs);
      const re = buffer_1.Buffer.alloc(32);
      return {ss, s, rs, re, psk};
    }
    initializeResponder(prologue, s, rs, psk) {
      const name = "Noise_IK_25519_ChaChaPoly_SHA256";
      const ss = this.initializeSymmetric(name);
      this.mixHash(ss, prologue);
      this.mixHash(ss, s.publicKey);
      const re = buffer_1.Buffer.alloc(32);
      return {ss, s, rs, re, psk};
    }
  };
  exports2.IK = IK;
});

// node_modules/libp2p-noise/dist/src/errors.js
var require_errors13 = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.FailedIKError = void 0;
  var FailedIKError = class extends Error {
    constructor(initialMsg, message) {
      super(message);
      this.initialMsg = initialMsg;
      this.name = "FailedIKhandshake";
    }
  };
  exports2.FailedIKError = FailedIKError;
});

// node_modules/libp2p-noise/dist/src/handshake-ik.js
var require_handshake_ik = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.IKHandshake = void 0;
  var ik_1 = require_ik();
  var buffer_1 = require_buffer();
  var encoder_1 = require_encoder4();
  var utils_1 = require_utils31();
  var errors_1 = require_errors13();
  var logger_1 = require_logger();
  var IKHandshake = class {
    constructor(isInitiator, payload, prologue, staticKeypair, connection, remoteStaticKey, remotePeer, handshake) {
      this.isInitiator = isInitiator;
      this.payload = buffer_1.Buffer.from(payload);
      this.prologue = prologue;
      this.staticKeypair = staticKeypair;
      this.connection = connection;
      if (remotePeer) {
        this.remotePeer = remotePeer;
      }
      this.ik = handshake || new ik_1.IK();
      this.session = this.ik.initSession(this.isInitiator, this.prologue, this.staticKeypair, remoteStaticKey);
      this.remoteEarlyData = buffer_1.Buffer.alloc(0);
    }
    async stage0() {
      logger_1.logLocalStaticKeys(this.session.hs.s);
      logger_1.logRemoteStaticKey(this.session.hs.rs);
      if (this.isInitiator) {
        logger_1.logger("IK Stage 0 - Initiator sending message...");
        const messageBuffer = this.ik.sendMessage(this.session, this.payload);
        this.connection.writeLP(encoder_1.encode1(messageBuffer));
        logger_1.logger("IK Stage 0 - Initiator sent message.");
        logger_1.logLocalEphemeralKeys(this.session.hs.e);
      } else {
        logger_1.logger("IK Stage 0 - Responder receiving message...");
        const receivedMsg = await this.connection.readLP();
        try {
          const receivedMessageBuffer = encoder_1.decode1(receivedMsg.slice());
          const {plaintext, valid} = this.ik.recvMessage(this.session, receivedMessageBuffer);
          if (!valid) {
            throw new Error("ik handshake stage 0 decryption validation fail");
          }
          logger_1.logger("IK Stage 0 - Responder got message, going to verify payload.");
          const decodedPayload = await utils_1.decodePayload(plaintext);
          this.remotePeer = this.remotePeer || await utils_1.getPeerIdFromPayload(decodedPayload);
          await utils_1.verifySignedPayload(this.session.hs.rs, decodedPayload, this.remotePeer);
          this.setRemoteEarlyData(decodedPayload.data);
          logger_1.logger("IK Stage 0 - Responder successfully verified payload!");
          logger_1.logRemoteEphemeralKey(this.session.hs.re);
        } catch (e) {
          logger_1.logger("Responder breaking up with IK handshake in stage 0.");
          throw new errors_1.FailedIKError(receivedMsg, `Error occurred while verifying initiator's signed payload: ${e.message}`);
        }
      }
    }
    async stage1() {
      if (this.isInitiator) {
        logger_1.logger("IK Stage 1 - Initiator receiving message...");
        const receivedMsg = (await this.connection.readLP()).slice();
        const receivedMessageBuffer = encoder_1.decode0(buffer_1.Buffer.from(receivedMsg));
        const {plaintext, valid} = this.ik.recvMessage(this.session, receivedMessageBuffer);
        logger_1.logger("IK Stage 1 - Initiator got message, going to verify payload.");
        try {
          if (!valid) {
            throw new Error("ik stage 1 decryption validation fail");
          }
          const decodedPayload = await utils_1.decodePayload(plaintext);
          this.remotePeer = this.remotePeer || await utils_1.getPeerIdFromPayload(decodedPayload);
          await utils_1.verifySignedPayload(receivedMessageBuffer.ns.slice(0, 32), decodedPayload, this.remotePeer);
          this.setRemoteEarlyData(decodedPayload.data);
          logger_1.logger("IK Stage 1 - Initiator successfully verified payload!");
          logger_1.logRemoteEphemeralKey(this.session.hs.re);
        } catch (e) {
          logger_1.logger("Initiator breaking up with IK handshake in stage 1.");
          throw new errors_1.FailedIKError(receivedMsg, `Error occurred while verifying responder's signed payload: ${e.message}`);
        }
      } else {
        logger_1.logger("IK Stage 1 - Responder sending message...");
        const messageBuffer = this.ik.sendMessage(this.session, this.payload);
        this.connection.writeLP(encoder_1.encode0(messageBuffer));
        logger_1.logger("IK Stage 1 - Responder sent message...");
        logger_1.logLocalEphemeralKeys(this.session.hs.e);
      }
      logger_1.logCipherState(this.session);
    }
    decrypt(ciphertext, session) {
      const cs = this.getCS(session, false);
      return this.ik.decryptWithAd(cs, buffer_1.Buffer.alloc(0), ciphertext);
    }
    encrypt(plaintext, session) {
      const cs = this.getCS(session);
      return this.ik.encryptWithAd(cs, buffer_1.Buffer.alloc(0), plaintext);
    }
    getLocalEphemeralKeys() {
      if (!this.session.hs.e) {
        throw new Error("Ephemeral keys do not exist.");
      }
      return this.session.hs.e;
    }
    getCS(session, encryption = true) {
      if (!session.cs1 || !session.cs2) {
        throw new Error("Handshake not completed properly, cipher state does not exist.");
      }
      if (this.isInitiator) {
        return encryption ? session.cs1 : session.cs2;
      } else {
        return encryption ? session.cs2 : session.cs1;
      }
    }
    setRemoteEarlyData(data) {
      if (data) {
        this.remoteEarlyData = buffer_1.Buffer.from(data.buffer, data.byteOffset, data.length);
      }
    }
  };
  exports2.IKHandshake = IKHandshake;
});

// node_modules/libp2p-noise/dist/src/handshake-xx-fallback.js
var require_handshake_xx_fallback = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.XXFallbackHandshake = void 0;
  var buffer_1 = require_buffer();
  var handshake_xx_1 = require_handshake_xx();
  var utils_1 = require_utils31();
  var logger_1 = require_logger();
  var encoder_1 = require_encoder4();
  var XXFallbackHandshake = class extends handshake_xx_1.XXHandshake {
    constructor(isInitiator, payload, prologue, staticKeypair, connection, initialMsg, remotePeer, ephemeralKeys, handshake) {
      super(isInitiator, payload, prologue, staticKeypair, connection, remotePeer, handshake);
      if (ephemeralKeys) {
        this.ephemeralKeys = ephemeralKeys;
      }
      this.initialMsg = initialMsg;
    }
    async propose() {
      if (this.isInitiator) {
        this.xx.sendMessage(this.session, buffer_1.Buffer.alloc(0), this.ephemeralKeys);
        logger_1.logger("XX Fallback Stage 0 - Initialized state as the first message was sent by initiator.");
        logger_1.logLocalEphemeralKeys(this.session.hs.e);
      } else {
        logger_1.logger("XX Fallback Stage 0 - Responder decoding initial msg from IK.");
        const receivedMessageBuffer = encoder_1.decode0(this.initialMsg);
        const {valid} = this.xx.recvMessage(this.session, {
          ne: receivedMessageBuffer.ne,
          ns: buffer_1.Buffer.alloc(0),
          ciphertext: buffer_1.Buffer.alloc(0)
        });
        if (!valid) {
          throw new Error("xx fallback stage 0 decryption validation fail");
        }
        logger_1.logger("XX Fallback Stage 0 - Responder used received message from IK.");
        logger_1.logRemoteEphemeralKey(this.session.hs.re);
      }
    }
    async exchange() {
      if (this.isInitiator) {
        const receivedMessageBuffer = encoder_1.decode1(this.initialMsg);
        const {plaintext, valid} = this.xx.recvMessage(this.session, receivedMessageBuffer);
        if (!valid) {
          throw new Error("xx fallback stage 1 decryption validation fail");
        }
        logger_1.logger("XX Fallback Stage 1 - Initiator used received message from IK.");
        logger_1.logRemoteEphemeralKey(this.session.hs.re);
        logger_1.logRemoteStaticKey(this.session.hs.rs);
        logger_1.logger("Initiator going to check remote's signature...");
        try {
          const decodedPayload = await utils_1.decodePayload(plaintext);
          this.remotePeer = this.remotePeer || await utils_1.getPeerIdFromPayload(decodedPayload);
          await utils_1.verifySignedPayload(this.session.hs.rs, decodedPayload, this.remotePeer);
          this.setRemoteEarlyData(decodedPayload.data);
        } catch (e) {
          throw new Error(`Error occurred while verifying signed payload from responder: ${e.message}`);
        }
        logger_1.logger("All good with the signature!");
      } else {
        logger_1.logger("XX Fallback Stage 1 - Responder start");
        await super.exchange();
        logger_1.logger("XX Fallback Stage 1 - Responder end");
      }
    }
  };
  exports2.XXFallbackHandshake = XXFallbackHandshake;
});

// node_modules/libp2p-noise/dist/src/crypto.js
var require_crypto3 = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.decryptStream = exports2.encryptStream = void 0;
  var buffer_1 = require_buffer();
  var constants_1 = require_constants18();
  function encryptStream(handshake) {
    return async function* (source) {
      for await (const chunk of source) {
        const chunkBuffer = buffer_1.Buffer.from(chunk.buffer, chunk.byteOffset, chunk.length);
        for (let i = 0; i < chunkBuffer.length; i += constants_1.NOISE_MSG_MAX_LENGTH_BYTES_WITHOUT_TAG) {
          let end = i + constants_1.NOISE_MSG_MAX_LENGTH_BYTES_WITHOUT_TAG;
          if (end > chunkBuffer.length) {
            end = chunkBuffer.length;
          }
          const data = handshake.encrypt(chunkBuffer.slice(i, end), handshake.session);
          yield data;
        }
      }
    };
  }
  exports2.encryptStream = encryptStream;
  function decryptStream(handshake) {
    return async function* (source) {
      for await (const chunk of source) {
        const chunkBuffer = buffer_1.Buffer.from(chunk.buffer, chunk.byteOffset, chunk.length);
        for (let i = 0; i < chunkBuffer.length; i += constants_1.NOISE_MSG_MAX_LENGTH_BYTES) {
          let end = i + constants_1.NOISE_MSG_MAX_LENGTH_BYTES;
          if (end > chunkBuffer.length) {
            end = chunkBuffer.length;
          }
          const chunk2 = chunkBuffer.slice(i, end);
          const {plaintext: decrypted, valid} = await handshake.decrypt(chunk2, handshake.session);
          if (!valid) {
            throw new Error("Failed to validate decrypted chunk");
          }
          yield decrypted;
        }
      }
    };
  }
  exports2.decryptStream = decryptStream;
});

// node_modules/libp2p-noise/dist/src/keycache.js
var require_keycache = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.KeyCache = void 0;
  var Keycache = class {
    constructor() {
      this.storage = new Map();
    }
    store(peerId, key) {
      this.storage.set(peerId.id, key);
    }
    load(peerId) {
      if (!peerId) {
        return null;
      }
      return this.storage.get(peerId.id) || null;
    }
    resetStorage() {
      this.storage.clear();
    }
  };
  var KeyCache = new Keycache();
  exports2.KeyCache = KeyCache;
});

// node_modules/libp2p-noise/dist/src/noise.js
var require_noise = __commonJS((exports2) => {
  "use strict";
  var __importDefault = exports2 && exports2.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : {default: mod};
  };
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.Noise = void 0;
  var x25519_1 = __importDefault(require_x25519());
  var buffer_1 = require_buffer();
  var it_pb_rpc_1 = __importDefault(require_src48());
  var duplex_1 = __importDefault(require_duplex3());
  var it_buffer_1 = __importDefault(require_it_buffer());
  var it_pipe_1 = __importDefault(require_it_pipe());
  var it_length_prefixed_1 = require_src37();
  var handshake_xx_1 = require_handshake_xx();
  var handshake_ik_1 = require_handshake_ik();
  var handshake_xx_fallback_1 = require_handshake_xx_fallback();
  var utils_1 = require_utils31();
  var encoder_1 = require_encoder4();
  var crypto_1 = require_crypto3();
  var keycache_1 = require_keycache();
  var logger_1 = require_logger();
  var constants_1 = require_constants18();
  var Noise = class {
    constructor(staticNoiseKey, earlyData) {
      this.protocol = "/noise";
      this.prologue = buffer_1.Buffer.alloc(0);
      this.earlyData = earlyData || buffer_1.Buffer.alloc(0);
      this.useNoisePipes = false;
      if (staticNoiseKey) {
        const publicKey = x25519_1.default.publicKeyCreate(staticNoiseKey);
        this.staticKeys = {
          privateKey: staticNoiseKey,
          publicKey
        };
      } else {
        this.staticKeys = utils_1.generateKeypair();
      }
    }
    async secureOutbound(localPeer, connection, remotePeer) {
      const wrappedConnection = it_pb_rpc_1.default(connection, {
        lengthEncoder: encoder_1.uint16BEEncode,
        lengthDecoder: encoder_1.uint16BEDecode,
        maxDataLength: constants_1.NOISE_MSG_MAX_LENGTH_BYTES
      });
      const handshake = await this.performHandshake({
        connection: wrappedConnection,
        isInitiator: true,
        localPeer,
        remotePeer
      });
      const conn = await this.createSecureConnection(wrappedConnection, handshake);
      return {
        conn,
        remoteEarlyData: handshake.remoteEarlyData,
        remotePeer: handshake.remotePeer
      };
    }
    async secureInbound(localPeer, connection, remotePeer) {
      const wrappedConnection = it_pb_rpc_1.default(connection, {
        lengthEncoder: encoder_1.uint16BEEncode,
        lengthDecoder: encoder_1.uint16BEDecode,
        maxDataLength: constants_1.NOISE_MSG_MAX_LENGTH_BYTES
      });
      const handshake = await this.performHandshake({
        connection: wrappedConnection,
        isInitiator: false,
        localPeer,
        remotePeer
      });
      const conn = await this.createSecureConnection(wrappedConnection, handshake);
      return {
        conn,
        remoteEarlyData: handshake.remoteEarlyData,
        remotePeer: handshake.remotePeer
      };
    }
    async performHandshake(params) {
      const payload = await utils_1.getPayload(params.localPeer, this.staticKeys.publicKey, this.earlyData);
      let tryIK = this.useNoisePipes;
      if (params.isInitiator && keycache_1.KeyCache.load(params.remotePeer) === null) {
        tryIK = false;
      }
      if (tryIK) {
        const {remotePeer, connection, isInitiator} = params;
        const ikHandshake = new handshake_ik_1.IKHandshake(isInitiator, payload, this.prologue, this.staticKeys, connection, keycache_1.KeyCache.load(params.remotePeer) || buffer_1.Buffer.alloc(32), remotePeer);
        try {
          return await this.performIKHandshake(ikHandshake);
        } catch (e) {
          let ephemeralKeys;
          if (params.isInitiator) {
            ephemeralKeys = ikHandshake.getLocalEphemeralKeys();
          }
          return await this.performXXFallbackHandshake(params, payload, e.initialMsg, ephemeralKeys);
        }
      } else {
        return await this.performXXHandshake(params, payload);
      }
    }
    async performXXFallbackHandshake(params, payload, initialMsg, ephemeralKeys) {
      const {isInitiator, remotePeer, connection} = params;
      const handshake = new handshake_xx_fallback_1.XXFallbackHandshake(isInitiator, payload, this.prologue, this.staticKeys, connection, initialMsg, remotePeer, ephemeralKeys);
      try {
        await handshake.propose();
        await handshake.exchange();
        await handshake.finish();
      } catch (e) {
        logger_1.logger(e);
        throw new Error(`Error occurred during XX Fallback handshake: ${e.message}`);
      }
      return handshake;
    }
    async performXXHandshake(params, payload) {
      const {isInitiator, remotePeer, connection} = params;
      const handshake = new handshake_xx_1.XXHandshake(isInitiator, payload, this.prologue, this.staticKeys, connection, remotePeer);
      try {
        await handshake.propose();
        await handshake.exchange();
        await handshake.finish();
        if (this.useNoisePipes && handshake.remotePeer) {
          keycache_1.KeyCache.store(handshake.remotePeer, handshake.getRemoteStaticKey());
        }
      } catch (e) {
        throw new Error(`Error occurred during XX handshake: ${e.message}`);
      }
      return handshake;
    }
    async performIKHandshake(handshake) {
      await handshake.stage0();
      await handshake.stage1();
      return handshake;
    }
    async createSecureConnection(connection, handshake) {
      const [secure, user] = duplex_1.default();
      const network = connection.unwrap();
      await it_pipe_1.default(secure, it_buffer_1.default, crypto_1.encryptStream(handshake), it_length_prefixed_1.encode({lengthEncoder: encoder_1.uint16BEEncode}), network, it_length_prefixed_1.decode({lengthDecoder: encoder_1.uint16BEDecode}), it_buffer_1.default, crypto_1.decryptStream(handshake), secure);
      return user;
    }
  };
  exports2.Noise = Noise;
});

// node_modules/libp2p-noise/dist/src/index.js
var require_src49 = __commonJS((exports2) => {
  "use strict";
  var __createBinding = exports2 && exports2.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    Object.defineProperty(o, k2, {enumerable: true, get: function() {
      return m[k];
    }});
  } : function(o, m, k, k2) {
    if (k2 === void 0)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p))
        __createBinding(exports3, m, p);
  };
  Object.defineProperty(exports2, "__esModule", {value: true});
  exports2.NOISE = void 0;
  var noise_1 = require_noise();
  __exportStar(require_noise(), exports2);
  exports2.NOISE = new noise_1.Noise();
});

// node_modules/libp2p-kad-dht/node_modules/uint8arrays/equals.js
var require_equals6 = __commonJS((exports2, module2) => {
  "use strict";
  function equals(a, b) {
    if (a === b) {
      return true;
    }
    if (a.byteLength !== b.byteLength) {
      return false;
    }
    for (let i = 0; i < a.byteLength; i++) {
      if (a[i] !== b[i]) {
        return false;
      }
    }
    return true;
  }
  module2.exports = equals;
});

// node_modules/k-bucket/index.js
var require_k_bucket = __commonJS((exports2, module2) => {
  "use strict";
  var randomBytes = require_browser11();
  var {EventEmitter} = require_events();
  function arrayEquals(array1, array2) {
    if (array1 === array2) {
      return true;
    }
    if (array1.length !== array2.length) {
      return false;
    }
    for (let i = 0, length = array1.length; i < length; ++i) {
      if (array1[i] !== array2[i]) {
        return false;
      }
    }
    return true;
  }
  function createNode() {
    return {contacts: [], dontSplit: false, left: null, right: null};
  }
  function ensureInt8(name, val) {
    if (!(val instanceof Uint8Array)) {
      throw new TypeError(name + " is not a Uint8Array");
    }
  }
  var KBucket = class extends EventEmitter {
    constructor(options = {}) {
      super();
      this.localNodeId = options.localNodeId || randomBytes(20);
      this.numberOfNodesPerKBucket = options.numberOfNodesPerKBucket || 20;
      this.numberOfNodesToPing = options.numberOfNodesToPing || 3;
      this.distance = options.distance || KBucket.distance;
      this.arbiter = options.arbiter || KBucket.arbiter;
      this.metadata = Object.assign({}, options.metadata);
      ensureInt8("option.localNodeId as parameter 1", this.localNodeId);
      this.root = createNode();
    }
    static arbiter(incumbent, candidate) {
      return incumbent.vectorClock > candidate.vectorClock ? incumbent : candidate;
    }
    static distance(firstId, secondId) {
      let distance = 0;
      let i = 0;
      const min = Math.min(firstId.length, secondId.length);
      const max = Math.max(firstId.length, secondId.length);
      for (; i < min; ++i) {
        distance = distance * 256 + (firstId[i] ^ secondId[i]);
      }
      for (; i < max; ++i)
        distance = distance * 256 + 255;
      return distance;
    }
    add(contact) {
      ensureInt8("contact.id", (contact || {}).id);
      let bitIndex = 0;
      let node = this.root;
      while (node.contacts === null) {
        node = this._determineNode(node, contact.id, bitIndex++);
      }
      const index = this._indexOf(node, contact.id);
      if (index >= 0) {
        this._update(node, index, contact);
        return this;
      }
      if (node.contacts.length < this.numberOfNodesPerKBucket) {
        node.contacts.push(contact);
        this.emit("added", contact);
        return this;
      }
      if (node.dontSplit) {
        this.emit("ping", node.contacts.slice(0, this.numberOfNodesToPing), contact);
        return this;
      }
      this._split(node, bitIndex);
      return this.add(contact);
    }
    closest(id, n = Infinity) {
      ensureInt8("id", id);
      if (!Number.isInteger(n) && n !== Infinity || n <= 0) {
        throw new TypeError("n is not positive number");
      }
      let contacts = [];
      for (let nodes = [this.root], bitIndex = 0; nodes.length > 0 && contacts.length < n; ) {
        const node = nodes.pop();
        if (node.contacts === null) {
          const detNode = this._determineNode(node, id, bitIndex++);
          nodes.push(node.left === detNode ? node.right : node.left);
          nodes.push(detNode);
        } else {
          contacts = contacts.concat(node.contacts);
        }
      }
      return contacts.map((a) => [this.distance(a.id, id), a]).sort((a, b) => a[0] - b[0]).slice(0, n).map((a) => a[1]);
    }
    count() {
      let count = 0;
      for (const nodes = [this.root]; nodes.length > 0; ) {
        const node = nodes.pop();
        if (node.contacts === null)
          nodes.push(node.right, node.left);
        else
          count += node.contacts.length;
      }
      return count;
    }
    _determineNode(node, id, bitIndex) {
      const bytesDescribedByBitIndex = bitIndex >> 3;
      const bitIndexWithinByte = bitIndex % 8;
      if (id.length <= bytesDescribedByBitIndex && bitIndexWithinByte !== 0) {
        return node.left;
      }
      const byteUnderConsideration = id[bytesDescribedByBitIndex];
      if (byteUnderConsideration & 1 << 7 - bitIndexWithinByte) {
        return node.right;
      }
      return node.left;
    }
    get(id) {
      ensureInt8("id", id);
      let bitIndex = 0;
      let node = this.root;
      while (node.contacts === null) {
        node = this._determineNode(node, id, bitIndex++);
      }
      const index = this._indexOf(node, id);
      return index >= 0 ? node.contacts[index] : null;
    }
    _indexOf(node, id) {
      for (let i = 0; i < node.contacts.length; ++i) {
        if (arrayEquals(node.contacts[i].id, id))
          return i;
      }
      return -1;
    }
    remove(id) {
      ensureInt8("the id as parameter 1", id);
      let bitIndex = 0;
      let node = this.root;
      while (node.contacts === null) {
        node = this._determineNode(node, id, bitIndex++);
      }
      const index = this._indexOf(node, id);
      if (index >= 0) {
        const contact = node.contacts.splice(index, 1)[0];
        this.emit("removed", contact);
      }
      return this;
    }
    _split(node, bitIndex) {
      node.left = createNode();
      node.right = createNode();
      for (const contact of node.contacts) {
        this._determineNode(node, contact.id, bitIndex).contacts.push(contact);
      }
      node.contacts = null;
      const detNode = this._determineNode(node, this.localNodeId, bitIndex);
      const otherNode = node.left === detNode ? node.right : node.left;
      otherNode.dontSplit = true;
    }
    toArray() {
      let result = [];
      for (const nodes = [this.root]; nodes.length > 0; ) {
        const node = nodes.pop();
        if (node.contacts === null)
          nodes.push(node.right, node.left);
        else
          result = result.concat(node.contacts);
      }
      return result;
    }
    _update(node, index, contact) {
      if (!arrayEquals(node.contacts[index].id, contact.id)) {
        throw new Error("wrong index for _update");
      }
      const incumbent = node.contacts[index];
      const selection = this.arbiter(incumbent, contact);
      if (selection === incumbent && incumbent !== contact)
        return;
      node.contacts.splice(index, 1);
      node.contacts.push(selection);
      this.emit("updated", incumbent, selection);
    }
  };
  module2.exports = KBucket;
});

// node_modules/base32.js/base32.js
var require_base32 = __commonJS((exports2) => {
  "use strict";
  var charmap = function(alphabet, mappings) {
    mappings || (mappings = {});
    alphabet.split("").forEach(function(c, i) {
      if (!(c in mappings))
        mappings[c] = i;
    });
    return mappings;
  };
  var rfc4648 = {
    alphabet: "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567",
    charmap: {
      0: 14,
      1: 8
    }
  };
  rfc4648.charmap = charmap(rfc4648.alphabet, rfc4648.charmap);
  var crockford = {
    alphabet: "0123456789ABCDEFGHJKMNPQRSTVWXYZ",
    charmap: {
      O: 0,
      I: 1,
      L: 1
    }
  };
  crockford.charmap = charmap(crockford.alphabet, crockford.charmap);
  var base32hex = {
    alphabet: "0123456789ABCDEFGHIJKLMNOPQRSTUV",
    charmap: {}
  };
  base32hex.charmap = charmap(base32hex.alphabet, base32hex.charmap);
  function Decoder(options) {
    this.buf = [];
    this.shift = 8;
    this.carry = 0;
    if (options) {
      switch (options.type) {
        case "rfc4648":
          this.charmap = exports2.rfc4648.charmap;
          break;
        case "crockford":
          this.charmap = exports2.crockford.charmap;
          break;
        case "base32hex":
          this.charmap = exports2.base32hex.charmap;
          break;
        default:
          throw new Error("invalid type");
      }
      if (options.charmap)
        this.charmap = options.charmap;
    }
  }
  Decoder.prototype.charmap = rfc4648.charmap;
  Decoder.prototype.write = function(str) {
    var charmap2 = this.charmap;
    var buf = this.buf;
    var shift = this.shift;
    var carry = this.carry;
    str.toUpperCase().split("").forEach(function(char) {
      if (char == "=")
        return;
      var symbol = charmap2[char] & 255;
      shift -= 5;
      if (shift > 0) {
        carry |= symbol << shift;
      } else if (shift < 0) {
        buf.push(carry | symbol >> -shift);
        shift += 8;
        carry = symbol << shift & 255;
      } else {
        buf.push(carry | symbol);
        shift = 8;
        carry = 0;
      }
    });
    this.shift = shift;
    this.carry = carry;
    return this;
  };
  Decoder.prototype.finalize = function(str) {
    if (str) {
      this.write(str);
    }
    if (this.shift !== 8 && this.carry !== 0) {
      this.buf.push(this.carry);
      this.shift = 8;
      this.carry = 0;
    }
    return this.buf;
  };
  function Encoder(options) {
    this.buf = "";
    this.shift = 3;
    this.carry = 0;
    if (options) {
      switch (options.type) {
        case "rfc4648":
          this.alphabet = exports2.rfc4648.alphabet;
          break;
        case "crockford":
          this.alphabet = exports2.crockford.alphabet;
          break;
        case "base32hex":
          this.alphabet = exports2.base32hex.alphabet;
          break;
        default:
          throw new Error("invalid type");
      }
      if (options.alphabet)
        this.alphabet = options.alphabet;
      else if (options.lc)
        this.alphabet = this.alphabet.toLowerCase();
    }
  }
  Encoder.prototype.alphabet = rfc4648.alphabet;
  Encoder.prototype.write = function(buf) {
    var shift = this.shift;
    var carry = this.carry;
    var symbol;
    var byte;
    var i;
    for (i = 0; i < buf.length; i++) {
      byte = buf[i];
      symbol = carry | byte >> shift;
      this.buf += this.alphabet[symbol & 31];
      if (shift > 5) {
        shift -= 5;
        symbol = byte >> shift;
        this.buf += this.alphabet[symbol & 31];
      }
      shift = 5 - shift;
      carry = byte << shift;
      shift = 8 - shift;
    }
    this.shift = shift;
    this.carry = carry;
    return this;
  };
  Encoder.prototype.finalize = function(buf) {
    if (buf) {
      this.write(buf);
    }
    if (this.shift !== 3) {
      this.buf += this.alphabet[this.carry & 31];
      this.shift = 3;
      this.carry = 0;
    }
    return this.buf;
  };
  exports2.encode = function(buf, options) {
    return new Encoder(options).finalize(buf);
  };
  exports2.decode = function(str, options) {
    return new Decoder(options).finalize(str);
  };
  exports2.Decoder = Decoder;
  exports2.Encoder = Encoder;
  exports2.charmap = charmap;
  exports2.crockford = crockford;
  exports2.rfc4648 = rfc4648;
  exports2.base32hex = base32hex;
});

// node_modules/xor-distance/index.js
var require_xor_distance = __commonJS((exports2, module2) => {
  module2.exports = dist;
  function dist(a, b) {
    if (a.length !== b.length)
      throw new Error("Inputs should have the same length");
    var result = Buffer.allocUnsafe(a.length);
    for (var i = 0; i < a.length; i++)
      result[i] = a[i] ^ b[i];
    return result;
  }
  dist.compare = function compare(a, b) {
    if (a.length !== b.length)
      throw new Error("Inputs should have the same length");
    for (var i = 0; i < a.length; i++) {
      if (a[i] === b[i])
        continue;
      return a[i] < b[i] ? -1 : 1;
    }
    return 0;
  };
  dist.gt = function gt(a, b) {
    return dist.compare(a, b) === 1;
  };
  dist.lt = function lt(a, b) {
    return dist.compare(a, b) === -1;
  };
  dist.eq = function eq(a, b) {
    return dist.compare(a, b) === 0;
  };
});

// node_modules/p-map/index.js
var require_p_map = __commonJS((exports2, module2) => {
  "use strict";
  var AggregateError2 = require_aggregate_error();
  module2.exports = async (iterable, mapper, {
    concurrency = Infinity,
    stopOnError = true
  } = {}) => {
    return new Promise((resolve, reject) => {
      if (typeof mapper !== "function") {
        throw new TypeError("Mapper function is required");
      }
      if (!((Number.isSafeInteger(concurrency) || concurrency === Infinity) && concurrency >= 1)) {
        throw new TypeError(`Expected \`concurrency\` to be an integer from 1 and up or \`Infinity\`, got \`${concurrency}\` (${typeof concurrency})`);
      }
      const result = [];
      const errors = [];
      const iterator = iterable[Symbol.iterator]();
      let isRejected = false;
      let isIterableDone = false;
      let resolvingCount = 0;
      let currentIndex = 0;
      const next = () => {
        if (isRejected) {
          return;
        }
        const nextItem = iterator.next();
        const index = currentIndex;
        currentIndex++;
        if (nextItem.done) {
          isIterableDone = true;
          if (resolvingCount === 0) {
            if (!stopOnError && errors.length !== 0) {
              reject(new AggregateError2(errors));
            } else {
              resolve(result);
            }
          }
          return;
        }
        resolvingCount++;
        (async () => {
          try {
            const element = await nextItem.value;
            result[index] = await mapper(element, index);
            resolvingCount--;
            next();
          } catch (error) {
            if (stopOnError) {
              isRejected = true;
              reject(error);
            } else {
              errors.push(error);
              resolvingCount--;
              next();
            }
          }
        })();
      };
      for (let i = 0; i < concurrency; i++) {
        next();
        if (isIterableDone) {
          break;
        }
      }
    });
  };
});

// node_modules/libp2p-kad-dht/node_modules/uint8arrays/concat.js
var require_concat8 = __commonJS((exports2, module2) => {
  "use strict";
  function concat(arrays, length) {
    if (!length) {
      length = arrays.reduce((acc, curr) => acc + curr.length, 0);
    }
    const output = new Uint8Array(length);
    let offset = 0;
    for (const arr of arrays) {
      output.set(arr, offset);
      offset += arr.length;
    }
    return output;
  }
  module2.exports = concat;
});

// node_modules/libp2p-kad-dht/node_modules/uint8arrays/from-string.js
var require_from_string11 = __commonJS((exports2, module2) => {
  "use strict";
  var {encoding: getCodec} = require_src4();
  var {TextEncoder: TextEncoder2} = require_lib_browser();
  var utf8Encoder = new TextEncoder2();
  function asciiStringToUint8Array(string) {
    const array = new Uint8Array(string.length);
    for (let i = 0; i < string.length; i++) {
      array[i] = string.charCodeAt(i);
    }
    return array;
  }
  function fromString(string, encoding = "utf8") {
    if (encoding === "utf8" || encoding === "utf-8") {
      return utf8Encoder.encode(string);
    }
    if (encoding === "ascii") {
      return asciiStringToUint8Array(string);
    }
    return getCodec(encoding).decode(string);
  }
  module2.exports = fromString;
});

// node_modules/libp2p-kad-dht/node_modules/uint8arrays/to-string.js
var require_to_string11 = __commonJS((exports2, module2) => {
  "use strict";
  var {encoding: getCodec} = require_src4();
  var {TextDecoder: TextDecoder2} = require_lib_browser();
  var utf8Decoder = new TextDecoder2("utf8");
  function uint8ArrayToAsciiString(array) {
    let string = "";
    for (let i = 0; i < array.length; i++) {
      string += String.fromCharCode(array[i]);
    }
    return string;
  }
  function toString(array, encoding = "utf8") {
    if (encoding === "utf8" || encoding === "utf-8") {
      return utf8Decoder.decode(array);
    }
    if (encoding === "ascii") {
      return uint8ArrayToAsciiString(array);
    }
    return getCodec(encoding).encode(array);
  }
  module2.exports = toString;
});

// node_modules/libp2p-kad-dht/src/utils.js
var require_utils32 = __commonJS((exports2) => {
  "use strict";
  var debug = require_browser4();
  var multihashing = require_src14();
  var mh = multihashing.multihash;
  var {Key} = require_src15();
  var base32 = require_base32();
  var distance = require_xor_distance();
  var pMap = require_p_map();
  var {Record} = require_src25();
  var PeerId = require_src9();
  var errcode = require_err_code();
  var uint8ArrayConcat = require_concat8();
  var uint8ArrayFromString = require_from_string11();
  var uint8ArrayToString = require_to_string11();
  exports2.convertBuffer = (buf) => {
    return multihashing.digest(buf, "sha2-256");
  };
  exports2.convertPeerId = (peer) => {
    return multihashing.digest(peer.id, "sha2-256");
  };
  exports2.bufferToKey = (buf) => {
    return new Key("/" + exports2.encodeBase32(buf), false);
  };
  exports2.keyForPublicKey = (peer) => {
    return uint8ArrayConcat([
      uint8ArrayFromString("/pk/"),
      peer.id
    ]);
  };
  exports2.isPublicKeyKey = (key) => {
    return uint8ArrayToString(key.slice(0, 4)) === "/pk/";
  };
  exports2.fromPublicKeyKey = (key) => {
    return new PeerId(key.slice(4));
  };
  exports2.now = () => {
    return Date.now();
  };
  exports2.encodeBase32 = (buf) => {
    const enc = new base32.Encoder();
    return enc.write(buf).finalize();
  };
  exports2.decodeBase32 = (raw) => {
    const dec = new base32.Decoder();
    return Uint8Array.from(dec.write(raw).finalize());
  };
  exports2.sortClosestPeers = async (peers, target) => {
    const distances = await pMap(peers, async (peer) => {
      const id = await exports2.convertPeerId(peer);
      return {
        peer,
        distance: distance(id, target)
      };
    });
    return distances.sort(exports2.xorCompare).map((d) => d.peer);
  };
  exports2.xorCompare = (a, b) => {
    return distance.compare(a.distance, b.distance);
  };
  exports2.pathSize = (resultsWanted, numPaths) => {
    return Math.ceil(resultsWanted / numPaths);
  };
  exports2.createPutRecord = (key, value) => {
    const timeReceived = new Date();
    const rec = new Record(key, value, timeReceived);
    return rec.serialize();
  };
  exports2.logger = (id, subsystem) => {
    const name = ["libp2p", "dht"];
    if (subsystem) {
      name.push(subsystem);
    }
    if (id) {
      name.push(`${id.toB58String().slice(0, 8)}`);
    }
    debug.formatters.b = (v) => {
      return mh.toB58String(v);
    };
    const logger = debug(name.join(":"));
    logger.error = debug(name.concat(["error"]).join(":"));
    return logger;
  };
  exports2.TimeoutError = class TimeoutError extends Error {
    get code() {
      return "ETIMEDOUT";
    }
  };
  exports2.withTimeout = (asyncFn, time) => {
    return async (...args) => {
      return Promise.race([
        asyncFn(...args),
        new Promise((resolve, reject) => {
          setTimeout(() => {
            reject(errcode(new Error("Async function did not complete before timeout"), "ETIMEDOUT"));
          }, time);
        })
      ]);
    };
  };
  exports2.mapParallel = async function(asyncIterator, asyncFn) {
    const tasks = [];
    for await (const item of asyncIterator) {
      tasks.push(asyncFn(item));
    }
    return Promise.all(tasks);
  };
});

// node_modules/libp2p-kad-dht/src/routing.js
var require_routing = __commonJS((exports2, module2) => {
  "use strict";
  var KBucket = require_k_bucket();
  var utils = require_utils32();
  var RoutingTable = class {
    constructor(self2, kBucketSize) {
      this.self = self2;
      this._onPing = this._onPing.bind(this);
      this._onInit(kBucketSize);
    }
    async _onInit(kBucketSize) {
      const selfKey = await utils.convertPeerId(this.self);
      this.kb = new KBucket({
        localNodeId: selfKey,
        numberOfNodesPerKBucket: kBucketSize,
        numberOfNodesToPing: 1
      });
      this.kb.on("ping", this._onPing);
    }
    _onPing(oldContacts, newContact) {
      const oldest = oldContacts[0];
      this.kb.remove(oldest.id);
      this.kb.add(newContact);
    }
    get size() {
      return this.kb.count();
    }
    async find(peer) {
      const key = await utils.convertPeerId(peer);
      const closest = this.closestPeer(key);
      if (closest && closest.isEqual(peer)) {
        return closest;
      }
    }
    closestPeer(key) {
      const res = this.closestPeers(key, 1);
      if (res.length > 0) {
        return res[0];
      }
    }
    closestPeers(key, count) {
      return this.kb.closest(key, count).map((p) => p.peer);
    }
    async add(peer) {
      const id = await utils.convertPeerId(peer);
      this.kb.add({id, peer});
    }
    async remove(peer) {
      const id = await utils.convertPeerId(peer);
      this.kb.remove(id);
    }
  };
  module2.exports = RoutingTable;
});

// node_modules/libp2p-kad-dht/src/constants.js
var require_constants19 = __commonJS((exports2) => {
  "use strict";
  var second = exports2.second = 1e3;
  var minute = exports2.minute = 60 * second;
  var hour = exports2.hour = 60 * minute;
  exports2.MAX_RECORD_AGE = 36 * hour;
  exports2.PROTOCOL_DHT = "/kad/1.0.0";
  exports2.PROVIDERS_KEY_PREFIX = "/providers/";
  exports2.PROVIDERS_LRU_CACHE_SIZE = 256;
  exports2.PROVIDERS_VALIDITY = 24 * hour;
  exports2.PROVIDERS_CLEANUP_INTERVAL = hour;
  exports2.READ_MESSAGE_TIMEOUT = 10 * second;
  exports2.GET_MANY_RECORD_COUNT = 16;
  exports2.K = 20;
  exports2.ALPHA = 3;
  exports2.defaultRandomWalk = {
    enabled: true,
    queriesPerPeriod: 1,
    interval: 5 * minute,
    timeout: 10 * second,
    delay: 10 * second
  };
});

// node_modules/libp2p-kad-dht/node_modules/p-timeout/index.js
var require_p_timeout2 = __commonJS((exports2, module2) => {
  "use strict";
  var TimeoutError = class extends Error {
    constructor(message) {
      super(message);
      this.name = "TimeoutError";
    }
  };
  var pTimeout = (promise, milliseconds, fallback, options) => {
    let timer;
    const cancelablePromise = new Promise((resolve, reject) => {
      if (typeof milliseconds !== "number" || milliseconds < 0) {
        throw new TypeError("Expected `milliseconds` to be a positive number");
      }
      if (milliseconds === Infinity) {
        resolve(promise);
        return;
      }
      options = {
        customTimers: {setTimeout, clearTimeout},
        ...options
      };
      timer = options.customTimers.setTimeout.call(void 0, () => {
        if (typeof fallback === "function") {
          try {
            resolve(fallback());
          } catch (error) {
            reject(error);
          }
          return;
        }
        const message = typeof fallback === "string" ? fallback : `Promise timed out after ${milliseconds} milliseconds`;
        const timeoutError = fallback instanceof Error ? fallback : new TimeoutError(message);
        if (typeof promise.cancel === "function") {
          promise.cancel();
        }
        reject(timeoutError);
      }, milliseconds);
      (async () => {
        try {
          resolve(await promise);
        } catch (error) {
          reject(error);
        } finally {
          options.customTimers.clearTimeout.call(void 0, timer);
        }
      })();
    });
    cancelablePromise.clear = () => {
      clearTimeout(timer);
      timer = void 0;
    };
    return cancelablePromise;
  };
  module2.exports = pTimeout;
  module2.exports.default = pTimeout;
  module2.exports.TimeoutError = TimeoutError;
});

// node_modules/libp2p-kad-dht/src/message/dht.proto.js
var require_dht_proto = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = `// can't use, because protocol-buffers doesn't support imports
// so we have to duplicate for now :(
// import "record.proto";

message Record {
  // adjusted for javascript
  optional bytes key = 1;
  optional bytes value = 2;
  optional bytes author = 3;
  optional bytes signature = 4;
  optional string timeReceived = 5;
}

message Message {
  enum MessageType {
    PUT_VALUE = 0;
    GET_VALUE = 1;
    ADD_PROVIDER = 2;
    GET_PROVIDERS = 3;
    FIND_NODE = 4;
    PING = 5;
  }

  enum ConnectionType {
    // sender does not have a connection to peer, and no extra information (default)
    NOT_CONNECTED = 0;

    // sender has a live connection to peer
    CONNECTED = 1;

    // sender recently connected to peer
    CAN_CONNECT = 2;

    // sender recently tried to connect to peer repeatedly but failed to connect
    // ("try" here is loose, but this should signal "made strong effort, failed")
    CANNOT_CONNECT = 3;
  }

  message Peer {
    // ID of a given peer.
    optional bytes id = 1;

    // multiaddrs for a given peer
    repeated bytes addrs = 2;

    // used to signal the sender's connection capabilities to the peer
    optional ConnectionType connection = 3;
  }

  // defines what type of message it is.
  optional MessageType type = 1;

  // defines what coral cluster level this query/response belongs to.
  // in case we want to implement coral's cluster rings in the future.
  optional int32 clusterLevelRaw = 10;

  // Used to specify the key associated with this message.
  // PUT_VALUE, GET_VALUE, ADD_PROVIDER, GET_PROVIDERS
  // adjusted for javascript
  optional bytes key = 2;

  // Used to return a value
  // PUT_VALUE, GET_VALUE
  // adjusted Record to bytes for js
  optional bytes record = 3;

  // Used to return peers closer to a key in a query
  // GET_VALUE, GET_PROVIDERS, FIND_NODE
  repeated Peer closerPeers = 8;

  // Used to return Providers
  // GET_VALUE, ADD_PROVIDER, GET_PROVIDERS
  repeated Peer providerPeers = 9;
}`;
});

// node_modules/libp2p-kad-dht/src/message/index.js
var require_message4 = __commonJS((exports2, module2) => {
  "use strict";
  var PeerId = require_src9();
  var multiaddr = require_src11();
  var protons = require_src8();
  var {Record} = require_src25();
  var pbm = protons(require_dht_proto());
  var MESSAGE_TYPE = pbm.Message.MessageType;
  var CONNECTION_TYPE = pbm.Message.ConnectionType;
  var Message = class {
    constructor(type, key, level) {
      if (key && !(key instanceof Uint8Array)) {
        throw new Error("Key must be a Uint8Array");
      }
      this.type = type;
      this.key = key;
      this._clusterLevelRaw = level;
      this.closerPeers = [];
      this.providerPeers = [];
      this.record = null;
    }
    get clusterLevel() {
      const level = this._clusterLevelRaw - 1;
      if (level < 0) {
        return 0;
      }
      return level;
    }
    set clusterLevel(level) {
      this._clusterLevelRaw = level;
    }
    serialize() {
      const obj = {
        key: this.key,
        type: this.type,
        clusterLevelRaw: this._clusterLevelRaw,
        closerPeers: this.closerPeers.map(toPbPeer),
        providerPeers: this.providerPeers.map(toPbPeer)
      };
      if (this.record) {
        if (this.record instanceof Uint8Array) {
          obj.record = this.record;
        } else {
          obj.record = this.record.serialize();
        }
      }
      return pbm.Message.encode(obj);
    }
    static deserialize(raw) {
      const dec = pbm.Message.decode(raw);
      const msg = new Message(dec.type, dec.key, dec.clusterLevelRaw);
      msg.closerPeers = dec.closerPeers.map(fromPbPeer);
      msg.providerPeers = dec.providerPeers.map(fromPbPeer);
      if (dec.record) {
        msg.record = Record.deserialize(dec.record);
      }
      return msg;
    }
  };
  Message.TYPES = MESSAGE_TYPE;
  Message.CONNECTION_TYPES = CONNECTION_TYPE;
  function toPbPeer(peer) {
    return {
      id: peer.id.id,
      addrs: (peer.multiaddrs || []).map((m) => m.bytes),
      connection: CONNECTION_TYPE.CONNECTED
    };
  }
  function fromPbPeer(peer) {
    return {
      id: new PeerId(peer.id),
      multiaddrs: peer.addrs.map((a) => multiaddr(a))
    };
  }
  module2.exports = Message;
});

// node_modules/libp2p-kad-dht/src/rpc/handlers/get-value.js
var require_get_value = __commonJS((exports2, module2) => {
  "use strict";
  var {Record} = require_src25();
  var errcode = require_err_code();
  var Message = require_message4();
  var utils = require_utils32();
  module2.exports = (dht) => {
    const log = utils.logger(dht.peerId, "rpc:get-value");
    return async function getValue(peerId, msg) {
      const key = msg.key;
      log("key: %b", key);
      if (!key || key.length === 0) {
        throw errcode(new Error("Invalid key"), "ERR_INVALID_KEY");
      }
      const response = new Message(Message.TYPES.GET_VALUE, key, msg.clusterLevel);
      if (utils.isPublicKeyKey(key)) {
        log("is public key");
        const idFromKey = utils.fromPublicKeyKey(key);
        let id;
        if (dht._isSelf(idFromKey)) {
          id = dht.peerId;
        } else {
          const peerData = dht.peerStore.get(idFromKey);
          id = peerData && peerData.id;
        }
        if (id && id.pubKey) {
          log("returning found public key");
          response.record = new Record(key, id.pubKey.bytes);
          return response;
        }
      }
      const [record, closer] = await Promise.all([
        dht._checkLocalDatastore(key),
        dht._betterPeersToQuery(msg, peerId)
      ]);
      if (record) {
        log("got record");
        response.record = record;
      }
      if (closer.length > 0) {
        log("got closer %s", closer.length);
        response.closerPeers = closer;
      }
      return response;
    };
  };
});

// node_modules/libp2p-kad-dht/src/rpc/handlers/put-value.js
var require_put_value = __commonJS((exports2, module2) => {
  "use strict";
  var utils = require_utils32();
  var errcode = require_err_code();
  module2.exports = (dht) => {
    const log = utils.logger(dht.peerId, "rpc:put-value");
    return async function putValue(peerId, msg) {
      const key = msg.key;
      log("key: %b", key);
      const record = msg.record;
      if (!record) {
        const errMsg = `Empty record from: ${peerId.toB58String()}`;
        log.error(errMsg);
        throw errcode(new Error(errMsg), "ERR_EMPTY_RECORD");
      }
      await dht._verifyRecordLocally(record);
      record.timeReceived = new Date();
      const recordKey = utils.bufferToKey(record.key);
      await dht.datastore.put(recordKey, record.serialize());
      dht.onPut(record, peerId);
      return msg;
    };
  };
});

// node_modules/libp2p-kad-dht/src/rpc/handlers/find-node.js
var require_find_node = __commonJS((exports2, module2) => {
  "use strict";
  var uint8ArrayEquals = require_equals6();
  var Message = require_message4();
  var utils = require_utils32();
  module2.exports = (dht) => {
    const log = utils.logger(dht.peerId, "rpc:find-node");
    return async function findNode(peerId, msg) {
      log("start");
      let closer;
      if (uint8ArrayEquals(msg.key, dht.peerId.id)) {
        closer = [{
          id: dht.peerId
        }];
      } else {
        closer = await dht._betterPeersToQuery(msg, peerId);
      }
      const response = new Message(msg.type, new Uint8Array(0), msg.clusterLevel);
      if (closer.length > 0) {
        response.closerPeers = closer;
      } else {
        log("handle FindNode %s: could not find anything", peerId.toB58String());
      }
      return response;
    };
  };
});

// node_modules/libp2p-kad-dht/src/rpc/handlers/add-provider.js
var require_add_provider = __commonJS((exports2, module2) => {
  "use strict";
  var CID = require_src7();
  var errcode = require_err_code();
  var utils = require_utils32();
  module2.exports = (dht) => {
    const log = utils.logger(dht.peerId, "rpc:add-provider");
    return async function addProvider(peerId, msg) {
      log("start");
      if (!msg.key || msg.key.length === 0) {
        throw errcode(new Error("Missing key"), "ERR_MISSING_KEY");
      }
      let cid;
      try {
        cid = new CID(msg.key);
      } catch (err) {
        const errMsg = `Invalid CID: ${err.message}`;
        throw errcode(new Error(errMsg), "ERR_INVALID_CID");
      }
      msg.providerPeers.forEach((pi) => {
        if (!pi.id.isEqual(peerId)) {
          log("invalid provider peer %s from %s", pi.id.toB58String(), peerId.toB58String());
          return;
        }
        if (pi.multiaddrs.length < 1) {
          log("no valid addresses for provider %s. Ignore", peerId.toB58String());
          return;
        }
        log("received provider %s for %s (addrs %s)", peerId.toB58String(), cid.toBaseEncodedString(), pi.multiaddrs.map((m) => m.toString()));
        if (!dht._isSelf(pi.id)) {
          dht.peerStore.addressBook.add(pi.id, pi.multiaddrs);
          return dht.providers.addProvider(cid, pi.id);
        }
      });
      return dht.providers.addProvider(cid, peerId);
    };
  };
});

// node_modules/libp2p-kad-dht/src/rpc/handlers/get-providers.js
var require_get_providers = __commonJS((exports2, module2) => {
  "use strict";
  var CID = require_src7();
  var errcode = require_err_code();
  var Message = require_message4();
  var utils = require_utils32();
  module2.exports = (dht) => {
    const log = utils.logger(dht.peerId, "rpc:get-providers");
    return async function getProviders(peerId, msg) {
      let cid;
      try {
        cid = new CID(msg.key);
      } catch (err) {
        throw errcode(new Error(`Invalid CID: ${err.message}`), "ERR_INVALID_CID");
      }
      log("%s", cid.toBaseEncodedString());
      const dsKey = utils.bufferToKey(cid.bytes);
      const [has, peers, closer] = await Promise.all([
        dht.datastore.has(dsKey),
        dht.providers.getProviders(cid),
        dht._betterPeersToQuery(msg, peerId)
      ]);
      const providerPeers = peers.map((peerId2) => ({id: peerId2}));
      const closerPeers = closer.map((c) => ({id: c.id}));
      if (has) {
        providerPeers.push({
          id: dht.peerId
        });
      }
      const response = new Message(msg.type, msg.key, msg.clusterLevel);
      if (providerPeers.length > 0) {
        response.providerPeers = providerPeers;
      }
      if (closerPeers.length > 0) {
        response.closerPeers = closerPeers;
      }
      log("got %s providers %s closerPeers", providerPeers.length, closerPeers.length);
      return response;
    };
  };
});

// node_modules/libp2p-kad-dht/src/rpc/handlers/ping.js
var require_ping2 = __commonJS((exports2, module2) => {
  "use strict";
  var utils = require_utils32();
  module2.exports = (dht) => {
    const log = utils.logger(dht.peerId, "rpc:ping");
    return function ping(peerId, msg) {
      log("from %s", peerId.toB58String());
      return msg;
    };
  };
});

// node_modules/libp2p-kad-dht/src/rpc/handlers/index.js
var require_handlers = __commonJS((exports2, module2) => {
  "use strict";
  var T = require_message4().TYPES;
  module2.exports = (dht) => {
    const handlers = {
      [T.GET_VALUE]: require_get_value()(dht),
      [T.PUT_VALUE]: require_put_value()(dht),
      [T.FIND_NODE]: require_find_node()(dht),
      [T.ADD_PROVIDER]: require_add_provider()(dht),
      [T.GET_PROVIDERS]: require_get_providers()(dht),
      [T.PING]: require_ping2()(dht)
    };
    return function getMessageHandler(type) {
      return handlers[type];
    };
  };
});

// node_modules/libp2p-kad-dht/src/rpc/index.js
var require_rpc2 = __commonJS((exports2, module2) => {
  "use strict";
  var pipe = require_it_pipe();
  var lp = require_src37();
  var Message = require_message4();
  var handlers = require_handlers();
  var utils = require_utils32();
  module2.exports = (dht) => {
    const log = utils.logger(dht.peerId, "rpc");
    const getMessageHandler = handlers(dht);
    async function handleMessage(peerId, msg) {
      const handler = getMessageHandler(msg.type);
      try {
        await dht._add(peerId);
      } catch (err) {
        log.error("Failed to update the kbucket store", err);
      }
      if (!handler) {
        log.error(`no handler found for message type: ${msg.type}`);
        return;
      }
      return handler(peerId, msg);
    }
    return async function onIncomingStream({stream, connection}) {
      const peerId = connection.remotePeer;
      try {
        await dht._add(peerId);
      } catch (err) {
        log.error(err);
      }
      const idB58Str = peerId.toB58String();
      log("from: %s", idB58Str);
      await pipe(stream.source, lp.decode(), (source) => async function* () {
        for await (const msg of source) {
          const desMessage = Message.deserialize(msg.slice());
          const res = await handleMessage(peerId, desMessage);
          if (res) {
            yield res.serialize();
          }
        }
      }(), lp.encode(), stream.sink);
    };
  };
});

// node_modules/libp2p-kad-dht/src/network.js
var require_network = __commonJS((exports2, module2) => {
  "use strict";
  var errcode = require_err_code();
  var pipe = require_it_pipe();
  var lp = require_src37();
  var pTimeout = require_p_timeout2();
  var {consume} = require_dist2();
  var MulticodecTopology = require_multicodec_topology();
  var rpc = require_rpc2();
  var c = require_constants19();
  var Message = require_message4();
  var utils = require_utils32();
  var Network = class {
    constructor(self2) {
      this.dht = self2;
      this.readMessageTimeout = c.READ_MESSAGE_TIMEOUT;
      this._log = utils.logger(this.dht.peerId, "net");
      this._rpc = rpc(this.dht);
      this._onPeerConnected = this._onPeerConnected.bind(this);
      this._running = false;
    }
    async start() {
      if (this._running) {
        return;
      }
      if (!this.dht.isStarted) {
        throw errcode(new Error("Can not start network"), "ERR_CANNOT_START_NETWORK");
      }
      this._running = true;
      if (this.dht._clientMode === false) {
        this.dht.registrar.handle(this.dht.protocol, this._rpc);
      }
      const topology = new MulticodecTopology({
        multicodecs: [this.dht.protocol],
        handlers: {
          onConnect: this._onPeerConnected,
          onDisconnect: () => {
          }
        }
      });
      this._registrarId = await this.dht.registrar.register(topology);
    }
    async stop() {
      if (!this.dht.isStarted && !this.isStarted) {
        return;
      }
      this._running = false;
      await this.dht.registrar.unregister(this._registrarId);
    }
    get isStarted() {
      return this._running;
    }
    get isConnected() {
      return this.dht.isStarted && this.isStarted;
    }
    async _onPeerConnected(peerId) {
      await this.dht._add(peerId);
      this._log("added to the routing table: %s", peerId.toB58String());
    }
    async sendRequest(to, msg) {
      if (!this.isConnected) {
        throw errcode(new Error("Network is offline"), "ERR_NETWORK_OFFLINE");
      }
      const id = to.toB58String();
      this._log("sending to: %s", id);
      let conn = this.dht.registrar.connectionManager.get(to);
      if (!conn) {
        conn = await this.dht.dialer.connectToPeer(to);
      }
      const {stream} = await conn.newStream(this.dht.protocol);
      return this._writeReadMessage(stream, msg.serialize());
    }
    async sendMessage(to, msg) {
      if (!this.isConnected) {
        throw errcode(new Error("Network is offline"), "ERR_NETWORK_OFFLINE");
      }
      const id = to.toB58String();
      this._log("sending to: %s", id);
      let conn = this.dht.registrar.connectionManager.get(to);
      if (!conn) {
        conn = await this.dht.dialer.connectToPeer(to);
      }
      const {stream} = await conn.newStream(this.dht.protocol);
      return this._writeMessage(stream, msg.serialize());
    }
    async _writeReadMessage(stream, msg) {
      return pTimeout(writeReadMessage(stream, msg), this.readMessageTimeout);
    }
    _writeMessage(stream, msg) {
      return pipe([msg], lp.encode(), stream, consume);
    }
  };
  async function writeReadMessage(stream, msg) {
    const res = await pipe([msg], lp.encode(), stream, lp.decode(), async (source) => {
      for await (const chunk of source) {
        return chunk.slice();
      }
    });
    if (res.length === 0) {
      throw errcode(new Error("No message received"), "ERR_NO_MESSAGE_RECEIVED");
    }
    return Message.deserialize(res);
  }
  module2.exports = Network;
});

// node_modules/libp2p-kad-dht/src/peer-list/peer-distance-list.js
var require_peer_distance_list = __commonJS((exports2, module2) => {
  "use strict";
  var distance = require_xor_distance();
  var utils = require_utils32();
  var pMap = require_p_map();
  var uint8ArrayEquals = require_equals6();
  var PeerDistanceList = class {
    constructor(originDhtKey, capacity) {
      this.originDhtKey = originDhtKey;
      this.capacity = capacity;
      this.peerDistances = [];
    }
    get length() {
      return this.peerDistances.length;
    }
    get peers() {
      return this.peerDistances.map((pd) => pd.peerId);
    }
    async add(peerId) {
      if (this.peerDistances.find((pd) => uint8ArrayEquals(pd.peerId.id, peerId.id))) {
        return;
      }
      const dhtKey = await utils.convertPeerId(peerId);
      const el = {
        peerId,
        distance: distance(this.originDhtKey, dhtKey)
      };
      this.peerDistances.push(el);
      this.peerDistances.sort((a, b) => distance.compare(a.distance, b.distance));
      this.peerDistances = this.peerDistances.slice(0, this.capacity);
    }
    async anyCloser(peerIds) {
      if (!peerIds.length) {
        return false;
      }
      if (!this.length) {
        return true;
      }
      const dhtKeys = await pMap(peerIds, (peerId) => utils.convertPeerId(peerId));
      const furthestDistance = this.peerDistances[this.peerDistances.length - 1].distance;
      for (const dhtKey of dhtKeys) {
        const keyDistance = distance(this.originDhtKey, dhtKey);
        if (distance.compare(keyDistance, furthestDistance) < 0) {
          return true;
        }
      }
      return false;
    }
  };
  module2.exports = PeerDistanceList;
});

// node_modules/heap/lib/heap.js
var require_heap = __commonJS((exports2, module2) => {
  (function() {
    var Heap, defaultCmp, floor, heapify, heappop, heappush, heappushpop, heapreplace, insort, min, nlargest, nsmallest, updateItem, _siftdown, _siftup;
    floor = Math.floor, min = Math.min;
    defaultCmp = function(x, y) {
      if (x < y) {
        return -1;
      }
      if (x > y) {
        return 1;
      }
      return 0;
    };
    insort = function(a, x, lo, hi, cmp) {
      var mid;
      if (lo == null) {
        lo = 0;
      }
      if (cmp == null) {
        cmp = defaultCmp;
      }
      if (lo < 0) {
        throw new Error("lo must be non-negative");
      }
      if (hi == null) {
        hi = a.length;
      }
      while (lo < hi) {
        mid = floor((lo + hi) / 2);
        if (cmp(x, a[mid]) < 0) {
          hi = mid;
        } else {
          lo = mid + 1;
        }
      }
      return [].splice.apply(a, [lo, lo - lo].concat(x)), x;
    };
    heappush = function(array, item, cmp) {
      if (cmp == null) {
        cmp = defaultCmp;
      }
      array.push(item);
      return _siftdown(array, 0, array.length - 1, cmp);
    };
    heappop = function(array, cmp) {
      var lastelt, returnitem;
      if (cmp == null) {
        cmp = defaultCmp;
      }
      lastelt = array.pop();
      if (array.length) {
        returnitem = array[0];
        array[0] = lastelt;
        _siftup(array, 0, cmp);
      } else {
        returnitem = lastelt;
      }
      return returnitem;
    };
    heapreplace = function(array, item, cmp) {
      var returnitem;
      if (cmp == null) {
        cmp = defaultCmp;
      }
      returnitem = array[0];
      array[0] = item;
      _siftup(array, 0, cmp);
      return returnitem;
    };
    heappushpop = function(array, item, cmp) {
      var _ref;
      if (cmp == null) {
        cmp = defaultCmp;
      }
      if (array.length && cmp(array[0], item) < 0) {
        _ref = [array[0], item], item = _ref[0], array[0] = _ref[1];
        _siftup(array, 0, cmp);
      }
      return item;
    };
    heapify = function(array, cmp) {
      var i, _i, _j, _len, _ref, _ref1, _results, _results1;
      if (cmp == null) {
        cmp = defaultCmp;
      }
      _ref1 = function() {
        _results1 = [];
        for (var _j2 = 0, _ref2 = floor(array.length / 2); 0 <= _ref2 ? _j2 < _ref2 : _j2 > _ref2; 0 <= _ref2 ? _j2++ : _j2--) {
          _results1.push(_j2);
        }
        return _results1;
      }.apply(this).reverse();
      _results = [];
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        i = _ref1[_i];
        _results.push(_siftup(array, i, cmp));
      }
      return _results;
    };
    updateItem = function(array, item, cmp) {
      var pos;
      if (cmp == null) {
        cmp = defaultCmp;
      }
      pos = array.indexOf(item);
      if (pos === -1) {
        return;
      }
      _siftdown(array, 0, pos, cmp);
      return _siftup(array, pos, cmp);
    };
    nlargest = function(array, n, cmp) {
      var elem, result, _i, _len, _ref;
      if (cmp == null) {
        cmp = defaultCmp;
      }
      result = array.slice(0, n);
      if (!result.length) {
        return result;
      }
      heapify(result, cmp);
      _ref = array.slice(n);
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        elem = _ref[_i];
        heappushpop(result, elem, cmp);
      }
      return result.sort(cmp).reverse();
    };
    nsmallest = function(array, n, cmp) {
      var elem, i, los, result, _i, _j, _len, _ref, _ref1, _results;
      if (cmp == null) {
        cmp = defaultCmp;
      }
      if (n * 10 <= array.length) {
        result = array.slice(0, n).sort(cmp);
        if (!result.length) {
          return result;
        }
        los = result[result.length - 1];
        _ref = array.slice(n);
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          elem = _ref[_i];
          if (cmp(elem, los) < 0) {
            insort(result, elem, 0, null, cmp);
            result.pop();
            los = result[result.length - 1];
          }
        }
        return result;
      }
      heapify(array, cmp);
      _results = [];
      for (i = _j = 0, _ref1 = min(n, array.length); 0 <= _ref1 ? _j < _ref1 : _j > _ref1; i = 0 <= _ref1 ? ++_j : --_j) {
        _results.push(heappop(array, cmp));
      }
      return _results;
    };
    _siftdown = function(array, startpos, pos, cmp) {
      var newitem, parent, parentpos;
      if (cmp == null) {
        cmp = defaultCmp;
      }
      newitem = array[pos];
      while (pos > startpos) {
        parentpos = pos - 1 >> 1;
        parent = array[parentpos];
        if (cmp(newitem, parent) < 0) {
          array[pos] = parent;
          pos = parentpos;
          continue;
        }
        break;
      }
      return array[pos] = newitem;
    };
    _siftup = function(array, pos, cmp) {
      var childpos, endpos, newitem, rightpos, startpos;
      if (cmp == null) {
        cmp = defaultCmp;
      }
      endpos = array.length;
      startpos = pos;
      newitem = array[pos];
      childpos = 2 * pos + 1;
      while (childpos < endpos) {
        rightpos = childpos + 1;
        if (rightpos < endpos && !(cmp(array[childpos], array[rightpos]) < 0)) {
          childpos = rightpos;
        }
        array[pos] = array[childpos];
        pos = childpos;
        childpos = 2 * pos + 1;
      }
      array[pos] = newitem;
      return _siftdown(array, startpos, pos, cmp);
    };
    Heap = function() {
      Heap2.push = heappush;
      Heap2.pop = heappop;
      Heap2.replace = heapreplace;
      Heap2.pushpop = heappushpop;
      Heap2.heapify = heapify;
      Heap2.updateItem = updateItem;
      Heap2.nlargest = nlargest;
      Heap2.nsmallest = nsmallest;
      function Heap2(cmp) {
        this.cmp = cmp != null ? cmp : defaultCmp;
        this.nodes = [];
      }
      Heap2.prototype.push = function(x) {
        return heappush(this.nodes, x, this.cmp);
      };
      Heap2.prototype.pop = function() {
        return heappop(this.nodes, this.cmp);
      };
      Heap2.prototype.peek = function() {
        return this.nodes[0];
      };
      Heap2.prototype.contains = function(x) {
        return this.nodes.indexOf(x) !== -1;
      };
      Heap2.prototype.replace = function(x) {
        return heapreplace(this.nodes, x, this.cmp);
      };
      Heap2.prototype.pushpop = function(x) {
        return heappushpop(this.nodes, x, this.cmp);
      };
      Heap2.prototype.heapify = function() {
        return heapify(this.nodes, this.cmp);
      };
      Heap2.prototype.updateItem = function(x) {
        return updateItem(this.nodes, x, this.cmp);
      };
      Heap2.prototype.clear = function() {
        return this.nodes = [];
      };
      Heap2.prototype.empty = function() {
        return this.nodes.length === 0;
      };
      Heap2.prototype.size = function() {
        return this.nodes.length;
      };
      Heap2.prototype.clone = function() {
        var heap;
        heap = new Heap2();
        heap.nodes = this.nodes.slice(0);
        return heap;
      };
      Heap2.prototype.toArray = function() {
        return this.nodes.slice(0);
      };
      Heap2.prototype.insert = Heap2.prototype.push;
      Heap2.prototype.top = Heap2.prototype.peek;
      Heap2.prototype.front = Heap2.prototype.peek;
      Heap2.prototype.has = Heap2.prototype.contains;
      Heap2.prototype.copy = Heap2.prototype.clone;
      return Heap2;
    }();
    (function(root, factory) {
      if (typeof define === "function" && define.amd) {
        return define([], factory);
      } else if (typeof exports2 === "object") {
        return module2.exports = factory();
      } else {
        return root.Heap = factory();
      }
    })(this, function() {
      return Heap;
    });
  }).call(exports2);
});

// node_modules/heap/index.js
var require_heap2 = __commonJS((exports2, module2) => {
  module2.exports = require_heap();
});

// node_modules/libp2p-kad-dht/src/peer-list/peer-queue.js
var require_peer_queue = __commonJS((exports2, module2) => {
  "use strict";
  var Heap = require_heap2();
  var distance = require_xor_distance();
  var debug = require_browser4();
  var utils = require_utils32();
  var log = debug("libp2p:dht:peer-queue");
  var PeerQueue = class {
    static async fromPeerId(id) {
      const key = await utils.convertPeerId(id);
      return new PeerQueue(key);
    }
    static async fromKey(keyBuffer) {
      const key = await utils.convertBuffer(keyBuffer);
      return new PeerQueue(key);
    }
    constructor(from) {
      log("create: %b", from);
      this.from = from;
      this.heap = new Heap(utils.xorCompare);
    }
    async enqueue(id) {
      log("enqueue %s", id.toB58String());
      const key = await utils.convertPeerId(id);
      const el = {
        id,
        distance: distance(this.from, key)
      };
      this.heap.push(el);
    }
    dequeue() {
      const el = this.heap.pop();
      log("dequeue %s", el.id.toB58String());
      return el.id;
    }
    get length() {
      return this.heap.size();
    }
  };
  module2.exports = PeerQueue;
});

// node_modules/libp2p-kad-dht/src/query/path.js
var require_path = __commonJS((exports2, module2) => {
  "use strict";
  var PeerQueue = require_peer_queue();
  var utils = require_utils32();
  var QUERY_FUNC_TIMEOUT = 3e4;
  var Path = class {
    constructor(run, queryFunc) {
      this.run = run;
      this.queryFunc = utils.withTimeout(queryFunc, QUERY_FUNC_TIMEOUT);
      if (!this.queryFunc)
        throw new Error("Path requires a `queryFn` to be specified");
      if (typeof this.queryFunc !== "function")
        throw new Error("Path expected `queryFn` to be a function. Got " + typeof this.queryFunc);
      this.initialPeers = [];
      this.peersToQuery = null;
    }
    addInitialPeer(peer) {
      this.initialPeers.push(peer);
    }
    async execute() {
      const queue = await PeerQueue.fromKey(this.run.query.key);
      this.peersToQuery = queue;
      await Promise.all(this.initialPeers.map((peer) => this.addPeerToQuery(peer)));
      await this.run.workerQueue(this);
    }
    async addPeerToQuery(peer) {
      if (this.run.query.dht._isSelf(peer)) {
        return;
      }
      if (this.run.peersSeen.has(peer.toB58String())) {
        return;
      }
      await this.peersToQuery.enqueue(peer);
    }
  };
  module2.exports = Path;
});

// node_modules/lodash/_baseFindIndex.js
var require_baseFindIndex = __commonJS((exports2, module2) => {
  function baseFindIndex(array, predicate, fromIndex, fromRight) {
    var length = array.length, index = fromIndex + (fromRight ? 1 : -1);
    while (fromRight ? index-- : ++index < length) {
      if (predicate(array[index], index, array)) {
        return index;
      }
    }
    return -1;
  }
  module2.exports = baseFindIndex;
});

// node_modules/lodash/_baseIsNaN.js
var require_baseIsNaN = __commonJS((exports2, module2) => {
  function baseIsNaN(value) {
    return value !== value;
  }
  module2.exports = baseIsNaN;
});

// node_modules/lodash/_strictIndexOf.js
var require_strictIndexOf = __commonJS((exports2, module2) => {
  function strictIndexOf(array, value, fromIndex) {
    var index = fromIndex - 1, length = array.length;
    while (++index < length) {
      if (array[index] === value) {
        return index;
      }
    }
    return -1;
  }
  module2.exports = strictIndexOf;
});

// node_modules/lodash/_baseIndexOf.js
var require_baseIndexOf = __commonJS((exports2, module2) => {
  var baseFindIndex = require_baseFindIndex();
  var baseIsNaN = require_baseIsNaN();
  var strictIndexOf = require_strictIndexOf();
  function baseIndexOf(array, value, fromIndex) {
    return value === value ? strictIndexOf(array, value, fromIndex) : baseFindIndex(array, baseIsNaN, fromIndex);
  }
  module2.exports = baseIndexOf;
});

// node_modules/lodash/isArray.js
var require_isArray = __commonJS((exports2, module2) => {
  var isArray = Array.isArray;
  module2.exports = isArray;
});

// node_modules/lodash/noop.js
var require_noop = __commonJS((exports2, module2) => {
  function noop() {
  }
  module2.exports = noop;
});

// node_modules/async/internal/onlyOnce.js
var require_onlyOnce = __commonJS((exports2, module2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = onlyOnce;
  function onlyOnce(fn) {
    return function() {
      if (fn === null)
        throw new Error("Callback was already called.");
      var callFn = fn;
      fn = null;
      callFn.apply(this, arguments);
    };
  }
  module2.exports = exports2["default"];
});

// node_modules/async/internal/slice.js
var require_slice = __commonJS((exports2, module2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = slice;
  function slice(arrayLike, start) {
    start = start | 0;
    var newLen = Math.max(arrayLike.length - start, 0);
    var newArr = Array(newLen);
    for (var idx = 0; idx < newLen; idx++) {
      newArr[idx] = arrayLike[start + idx];
    }
    return newArr;
  }
  module2.exports = exports2["default"];
});

// node_modules/async/internal/setImmediate.js
var require_setImmediate = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.hasNextTick = exports2.hasSetImmediate = void 0;
  exports2.fallback = fallback;
  exports2.wrap = wrap;
  var _slice = require_slice();
  var _slice2 = _interopRequireDefault(_slice);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {default: obj};
  }
  var hasSetImmediate = exports2.hasSetImmediate = typeof setImmediate === "function" && setImmediate;
  var hasNextTick = exports2.hasNextTick = typeof process === "object" && typeof process.nextTick === "function";
  function fallback(fn) {
    setTimeout(fn, 0);
  }
  function wrap(defer) {
    return function(fn) {
      var args = (0, _slice2.default)(arguments, 1);
      defer(function() {
        fn.apply(null, args);
      });
    };
  }
  var _defer;
  if (hasSetImmediate) {
    _defer = setImmediate;
  } else if (hasNextTick) {
    _defer = process.nextTick;
  } else {
    _defer = fallback;
  }
  exports2.default = wrap(_defer);
});

// node_modules/async/internal/DoublyLinkedList.js
var require_DoublyLinkedList = __commonJS((exports2, module2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = DLL;
  function DLL() {
    this.head = this.tail = null;
    this.length = 0;
  }
  function setInitial(dll, node) {
    dll.length = 1;
    dll.head = dll.tail = node;
  }
  DLL.prototype.removeLink = function(node) {
    if (node.prev)
      node.prev.next = node.next;
    else
      this.head = node.next;
    if (node.next)
      node.next.prev = node.prev;
    else
      this.tail = node.prev;
    node.prev = node.next = null;
    this.length -= 1;
    return node;
  };
  DLL.prototype.empty = function() {
    while (this.head)
      this.shift();
    return this;
  };
  DLL.prototype.insertAfter = function(node, newNode) {
    newNode.prev = node;
    newNode.next = node.next;
    if (node.next)
      node.next.prev = newNode;
    else
      this.tail = newNode;
    node.next = newNode;
    this.length += 1;
  };
  DLL.prototype.insertBefore = function(node, newNode) {
    newNode.prev = node.prev;
    newNode.next = node;
    if (node.prev)
      node.prev.next = newNode;
    else
      this.head = newNode;
    node.prev = newNode;
    this.length += 1;
  };
  DLL.prototype.unshift = function(node) {
    if (this.head)
      this.insertBefore(this.head, node);
    else
      setInitial(this, node);
  };
  DLL.prototype.push = function(node) {
    if (this.tail)
      this.insertAfter(this.tail, node);
    else
      setInitial(this, node);
  };
  DLL.prototype.shift = function() {
    return this.head && this.removeLink(this.head);
  };
  DLL.prototype.pop = function() {
    return this.tail && this.removeLink(this.tail);
  };
  DLL.prototype.toArray = function() {
    var arr = Array(this.length);
    var curr = this.head;
    for (var idx = 0; idx < this.length; idx++) {
      arr[idx] = curr.data;
      curr = curr.next;
    }
    return arr;
  };
  DLL.prototype.remove = function(testFn) {
    var curr = this.head;
    while (!!curr) {
      var next = curr.next;
      if (testFn(curr)) {
        this.removeLink(curr);
      }
      curr = next;
    }
    return this;
  };
  module2.exports = exports2["default"];
});

// node_modules/lodash/isObject.js
var require_isObject = __commonJS((exports2, module2) => {
  function isObject(value) {
    var type = typeof value;
    return value != null && (type == "object" || type == "function");
  }
  module2.exports = isObject;
});

// node_modules/async/internal/initialParams.js
var require_initialParams = __commonJS((exports2, module2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = function(fn) {
    return function() {
      var args = (0, _slice2.default)(arguments);
      var callback = args.pop();
      fn.call(this, args, callback);
    };
  };
  var _slice = require_slice();
  var _slice2 = _interopRequireDefault(_slice);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {default: obj};
  }
  module2.exports = exports2["default"];
});

// node_modules/async/asyncify.js
var require_asyncify = __commonJS((exports2, module2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = asyncify;
  var _isObject = require_isObject();
  var _isObject2 = _interopRequireDefault(_isObject);
  var _initialParams = require_initialParams();
  var _initialParams2 = _interopRequireDefault(_initialParams);
  var _setImmediate = require_setImmediate();
  var _setImmediate2 = _interopRequireDefault(_setImmediate);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {default: obj};
  }
  function asyncify(func) {
    return (0, _initialParams2.default)(function(args, callback) {
      var result;
      try {
        result = func.apply(this, args);
      } catch (e) {
        return callback(e);
      }
      if ((0, _isObject2.default)(result) && typeof result.then === "function") {
        result.then(function(value) {
          invokeCallback(callback, null, value);
        }, function(err) {
          invokeCallback(callback, err.message ? err : new Error(err));
        });
      } else {
        callback(null, result);
      }
    });
  }
  function invokeCallback(callback, error, value) {
    try {
      callback(error, value);
    } catch (e) {
      (0, _setImmediate2.default)(rethrow, e);
    }
  }
  function rethrow(error) {
    throw error;
  }
  module2.exports = exports2["default"];
});

// node_modules/async/internal/wrapAsync.js
var require_wrapAsync = __commonJS((exports2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.isAsync = void 0;
  var _asyncify = require_asyncify();
  var _asyncify2 = _interopRequireDefault(_asyncify);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {default: obj};
  }
  var supportsSymbol = typeof Symbol === "function";
  function isAsync(fn) {
    return supportsSymbol && fn[Symbol.toStringTag] === "AsyncFunction";
  }
  function wrapAsync(asyncFn) {
    return isAsync(asyncFn) ? (0, _asyncify2.default)(asyncFn) : asyncFn;
  }
  exports2.default = wrapAsync;
  exports2.isAsync = isAsync;
});

// node_modules/async/internal/queue.js
var require_queue = __commonJS((exports2, module2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = queue;
  var _baseIndexOf = require_baseIndexOf();
  var _baseIndexOf2 = _interopRequireDefault(_baseIndexOf);
  var _isArray = require_isArray();
  var _isArray2 = _interopRequireDefault(_isArray);
  var _noop = require_noop();
  var _noop2 = _interopRequireDefault(_noop);
  var _onlyOnce = require_onlyOnce();
  var _onlyOnce2 = _interopRequireDefault(_onlyOnce);
  var _setImmediate = require_setImmediate();
  var _setImmediate2 = _interopRequireDefault(_setImmediate);
  var _DoublyLinkedList = require_DoublyLinkedList();
  var _DoublyLinkedList2 = _interopRequireDefault(_DoublyLinkedList);
  var _wrapAsync = require_wrapAsync();
  var _wrapAsync2 = _interopRequireDefault(_wrapAsync);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {default: obj};
  }
  function queue(worker, concurrency, payload) {
    if (concurrency == null) {
      concurrency = 1;
    } else if (concurrency === 0) {
      throw new Error("Concurrency must not be zero");
    }
    var _worker = (0, _wrapAsync2.default)(worker);
    var numRunning = 0;
    var workersList = [];
    var processingScheduled = false;
    function _insert(data, insertAtFront, callback) {
      if (callback != null && typeof callback !== "function") {
        throw new Error("task callback must be a function");
      }
      q.started = true;
      if (!(0, _isArray2.default)(data)) {
        data = [data];
      }
      if (data.length === 0 && q.idle()) {
        return (0, _setImmediate2.default)(function() {
          q.drain();
        });
      }
      for (var i = 0, l = data.length; i < l; i++) {
        var item = {
          data: data[i],
          callback: callback || _noop2.default
        };
        if (insertAtFront) {
          q._tasks.unshift(item);
        } else {
          q._tasks.push(item);
        }
      }
      if (!processingScheduled) {
        processingScheduled = true;
        (0, _setImmediate2.default)(function() {
          processingScheduled = false;
          q.process();
        });
      }
    }
    function _next(tasks) {
      return function(err) {
        numRunning -= 1;
        for (var i = 0, l = tasks.length; i < l; i++) {
          var task = tasks[i];
          var index = (0, _baseIndexOf2.default)(workersList, task, 0);
          if (index === 0) {
            workersList.shift();
          } else if (index > 0) {
            workersList.splice(index, 1);
          }
          task.callback.apply(task, arguments);
          if (err != null) {
            q.error(err, task.data);
          }
        }
        if (numRunning <= q.concurrency - q.buffer) {
          q.unsaturated();
        }
        if (q.idle()) {
          q.drain();
        }
        q.process();
      };
    }
    var isProcessing = false;
    var q = {
      _tasks: new _DoublyLinkedList2.default(),
      concurrency,
      payload,
      saturated: _noop2.default,
      unsaturated: _noop2.default,
      buffer: concurrency / 4,
      empty: _noop2.default,
      drain: _noop2.default,
      error: _noop2.default,
      started: false,
      paused: false,
      push: function(data, callback) {
        _insert(data, false, callback);
      },
      kill: function() {
        q.drain = _noop2.default;
        q._tasks.empty();
      },
      unshift: function(data, callback) {
        _insert(data, true, callback);
      },
      remove: function(testFn) {
        q._tasks.remove(testFn);
      },
      process: function() {
        if (isProcessing) {
          return;
        }
        isProcessing = true;
        while (!q.paused && numRunning < q.concurrency && q._tasks.length) {
          var tasks = [], data = [];
          var l = q._tasks.length;
          if (q.payload)
            l = Math.min(l, q.payload);
          for (var i = 0; i < l; i++) {
            var node = q._tasks.shift();
            tasks.push(node);
            workersList.push(node);
            data.push(node.data);
          }
          numRunning += 1;
          if (q._tasks.length === 0) {
            q.empty();
          }
          if (numRunning === q.concurrency) {
            q.saturated();
          }
          var cb = (0, _onlyOnce2.default)(_next(tasks));
          _worker(data, cb);
        }
        isProcessing = false;
      },
      length: function() {
        return q._tasks.length;
      },
      running: function() {
        return numRunning;
      },
      workersList: function() {
        return workersList;
      },
      idle: function() {
        return q._tasks.length + numRunning === 0;
      },
      pause: function() {
        q.paused = true;
      },
      resume: function() {
        if (q.paused === false) {
          return;
        }
        q.paused = false;
        (0, _setImmediate2.default)(q.process);
      }
    };
    return q;
  }
  module2.exports = exports2["default"];
});

// node_modules/async/queue.js
var require_queue2 = __commonJS((exports2, module2) => {
  "use strict";
  Object.defineProperty(exports2, "__esModule", {
    value: true
  });
  exports2.default = function(worker, concurrency) {
    var _worker = (0, _wrapAsync2.default)(worker);
    return (0, _queue2.default)(function(items, cb) {
      _worker(items[0], cb);
    }, concurrency, 1);
  };
  var _queue = require_queue();
  var _queue2 = _interopRequireDefault(_queue);
  var _wrapAsync = require_wrapAsync();
  var _wrapAsync2 = _interopRequireDefault(_wrapAsync);
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {default: obj};
  }
  module2.exports = exports2["default"];
});

// node_modules/is-fn/index.js
var require_is_fn = __commonJS((exports2, module2) => {
  "use strict";
  var toString = Object.prototype.toString;
  module2.exports = function(x) {
    return toString.call(x) === "[object Function]";
  };
});

// node_modules/set-immediate-shim/index.js
var require_set_immediate_shim = __commonJS((exports2, module2) => {
  "use strict";
  module2.exports = typeof setImmediate === "function" ? setImmediate : function setImmediate2() {
    var args = [].slice.apply(arguments);
    args.splice(1, 0, 0);
    setTimeout.apply(null, args);
  };
});

// node_modules/promise-to-callback/index.js
var require_promise_to_callback = __commonJS((exports2, module2) => {
  "use strict";
  var isFn = require_is_fn();
  var setImmediate2 = require_set_immediate_shim();
  module2.exports = function(promise) {
    if (!isFn(promise.then)) {
      throw new TypeError("Expected a promise");
    }
    return function(cb) {
      promise.then(function(data) {
        setImmediate2(cb, null, data);
      }, function(err) {
        setImmediate2(cb, err);
      });
    };
  };
});

// node_modules/libp2p-kad-dht/src/query/workerQueue.js
var require_workerQueue = __commonJS((exports2, module2) => {
  "use strict";
  var queue = require_queue2();
  var promiseToCallback = require_promise_to_callback();
  var WorkerQueue = class {
    constructor(dht, run, path, log) {
      this.dht = dht;
      this.run = run;
      this.path = path;
      this.log = log;
      this.concurrency = this.dht.concurrency;
      this.queue = this.setupQueue();
      this.execution = null;
    }
    setupQueue() {
      const q = queue((peer, cb) => {
        promiseToCallback(this.processNext(peer))(cb);
      }, this.concurrency);
      q.error = (err) => {
        this.log.error("queue", err);
        this.stop(err);
      };
      q.drain = () => {
        this.log("queue:drain");
        this.stop();
      };
      q.unsaturated = () => {
        if (this.running) {
          this.fill();
        }
      };
      q.buffer = 0;
      return q;
    }
    stop(err) {
      if (!this.running) {
        return;
      }
      this.running = false;
      this.queue.kill();
      this.log("worker:stop, %d workers still running", this.run.workers.filter((w) => w.running).length);
      if (err) {
        this.execution.reject(err);
      } else {
        this.execution.resolve();
      }
    }
    async execute() {
      this.running = true;
      this.execution = {};
      const execPromise = new Promise((resolve, reject) => Object.assign(this.execution, {resolve, reject}));
      this.fill();
      await execPromise;
    }
    fill() {
      while (this.queue.running() + this.queue.length() < this.concurrency && this.path.peersToQuery.length > 0) {
        this.queue.push(this.path.peersToQuery.dequeue());
      }
    }
    async processNext(peer) {
      if (!this.running) {
        return;
      }
      if (this.run.peersSeen.has(peer.toB58String())) {
        return;
      }
      let continueQuerying, continueQueryingError;
      try {
        continueQuerying = await this.run.continueQuerying(this);
      } catch (err) {
        continueQueryingError = err;
      }
      if (!this.running) {
        return;
      }
      if (continueQueryingError) {
        throw continueQueryingError;
      }
      if (!continueQuerying) {
        this.stop();
        return;
      }
      if (this.run.peersSeen.has(peer.toB58String())) {
        return;
      }
      this.run.peersSeen.add(peer.toB58String());
      this.log("queue:work");
      let state, execError;
      try {
        state = await this.execQuery(peer);
      } catch (err) {
        execError = err;
      }
      if (!this.running) {
        return;
      }
      this.log("queue:work:done", execError, state);
      if (execError) {
        throw execError;
      }
      if (state && state.queryComplete) {
        this.log("query:complete");
        this.run.stop();
        return;
      }
      if (state && state.pathComplete) {
        this.stop();
      }
    }
    async execQuery(peer) {
      let res, queryError;
      try {
        res = await this.path.queryFunc(peer);
      } catch (err) {
        queryError = err;
      }
      if (!this.running) {
        return;
      }
      if (queryError) {
        this.run.errors.push(queryError);
        return;
      }
      await this.run.peersQueried.add(peer);
      if (res.pathComplete || res.queryComplete) {
        this.path.res = res;
        return {
          pathComplete: res.pathComplete,
          queryComplete: res.queryComplete
        };
      }
      if (res.closerPeers && res.closerPeers.length > 0) {
        await Promise.all(res.closerPeers.map(async (closer) => {
          if (this.dht._isSelf(closer.id)) {
            return;
          }
          this.dht._peerDiscovered(closer.id, closer.multiaddrs);
          await this.path.addPeerToQuery(closer.id);
        }));
      }
    }
  };
  module2.exports = WorkerQueue;
});

// node_modules/libp2p-kad-dht/src/query/run.js
var require_run = __commonJS((exports2, module2) => {
  "use strict";
  var PeerDistanceList = require_peer_distance_list();
  var EventEmitter = require_events();
  var Path = require_path();
  var WorkerQueue = require_workerQueue();
  var utils = require_utils32();
  var Run = class extends EventEmitter {
    constructor(query) {
      super();
      this.query = query;
      this.running = false;
      this.workers = [];
      this.peersSeen = new Set();
      this.errors = [];
      this.peersQueried = null;
    }
    stop() {
      if (!this.running) {
        return;
      }
      this.running = false;
      for (const worker of this.workers) {
        worker.stop();
      }
    }
    async execute(peers) {
      const paths = [];
      const numPaths = Math.min(this.query.dht.disjointPaths, peers.length);
      for (let i = 0; i < numPaths; i++) {
        paths.push(new Path(this, this.query.makePath(i, numPaths)));
      }
      peers.forEach((peer, i) => {
        paths[i % numPaths].addInitialPeer(peer);
      });
      await this.executePaths(paths);
      const res = {
        finalSet: new Set(this.peersQueried.peers),
        paths: []
      };
      for (const path of paths) {
        if (path.res && (path.res.pathComplete || path.res.queryComplete)) {
          path.res.success = true;
          res.paths.push(path.res);
        }
      }
      return res;
    }
    async executePaths(paths) {
      this.running = true;
      this.emit("start");
      try {
        await Promise.all(paths.map((path) => path.execute()));
      } finally {
        this.stop();
        this.emit("complete");
      }
      if (this.errors.length === this.peersSeen.size) {
        throw this.errors[0];
      }
    }
    async workerQueue(path) {
      await this.init();
      await this.startWorker(path);
    }
    async startWorker(path) {
      const worker = new WorkerQueue(this.query.dht, this, path, this.query._log);
      this.workers.push(worker);
      await worker.execute();
    }
    async init() {
      if (this.peersQueried) {
        return;
      }
      if (this.peersQueriedPromise) {
        await this.peersQueriedPromise;
        return;
      }
      this.peersQueriedPromise = (async () => {
        const dhtKey = await utils.convertBuffer(this.query.key);
        this.peersQueried = new PeerDistanceList(dhtKey, this.query.dht.kBucketSize);
      })();
      await this.peersQueriedPromise;
      delete this.peersQueriedPromise;
    }
    async continueQuerying(worker) {
      if (this.peersQueried.length < this.peersQueried.capacity) {
        return true;
      }
      const running = worker.queue.workersList().map((i) => i.data);
      const someCloser = await this.peersQueried.anyCloser(running);
      if (someCloser) {
        return true;
      }
      return false;
    }
  };
  module2.exports = Run;
});

// node_modules/libp2p-kad-dht/src/query/index.js
var require_query = __commonJS((exports2, module2) => {
  "use strict";
  var mh = require_src14().multihash;
  var utils = require_utils32();
  var Run = require_run();
  var Query = class {
    constructor(dht, key, makePath) {
      this.dht = dht;
      this.key = key;
      this.makePath = makePath;
      this._log = utils.logger(this.dht.peerId, "query:" + mh.toB58String(key));
      this.running = false;
      this._onStart = this._onStart.bind(this);
      this._onComplete = this._onComplete.bind(this);
    }
    async run(peers) {
      if (!this.dht._queryManager.running) {
        this._log.error("Attempt to run query after shutdown");
        return {finalSet: new Set(), paths: []};
      }
      if (peers.length === 0) {
        this._log.error("Running query with no peers");
        return {finalSet: new Set(), paths: []};
      }
      this._run = new Run(this);
      this._log(`query running with K=${this.dht.kBucketSize}, A=${this.dht.concurrency}, D=${Math.min(this.dht.disjointPaths, peers.length)}`);
      this._run.once("start", this._onStart);
      this._run.once("complete", this._onComplete);
      return this._run.execute(peers);
    }
    _onStart() {
      this.running = true;
      this._startTime = Date.now();
      this._log("query:start");
      this.dht._queryManager.queryStarted(this);
    }
    _onComplete() {
      this.stop();
    }
    stop() {
      this._log(`query:done in ${Date.now() - this._startTime}ms`);
      if (this._run) {
        this._log(`${this._run.errors.length} of ${this._run.peersSeen.size} peers errored (${this._run.errors.length / this._run.peersSeen.size * 100}% fail rate)`);
      }
      if (!this.running) {
        return;
      }
      this._run.removeListener("start", this._onStart);
      this._run.removeListener("complete", this._onComplete);
      this.running = false;
      this._run && this._run.stop();
      this.dht._queryManager.queryCompleted(this);
    }
  };
  module2.exports = Query;
});

// node_modules/libp2p-kad-dht/src/content-fetching/index.js
var require_content_fetching = __commonJS((exports2, module2) => {
  "use strict";
  var errcode = require_err_code();
  var pTimeout = require_p_timeout2();
  var uint8ArrayEquals = require_equals6();
  var libp2pRecord = require_src25();
  var c = require_constants19();
  var Query = require_query();
  var utils = require_utils32();
  var Record = libp2pRecord.Record;
  module2.exports = (dht) => {
    const putLocal = async (key, rec) => {
      return dht.datastore.put(utils.bufferToKey(key), rec);
    };
    const getLocal = async (key) => {
      dht._log("getLocal %b", key);
      const raw = await dht.datastore.get(utils.bufferToKey(key));
      dht._log("found %b in local datastore", key);
      const rec = Record.deserialize(raw);
      await dht._verifyRecordLocally(rec);
      return rec;
    };
    const sendCorrectionRecord = async (key, vals, best) => {
      const fixupRec = await utils.createPutRecord(key, best);
      return Promise.all(vals.map(async (v) => {
        if (uint8ArrayEquals(v.val, best)) {
          return;
        }
        if (dht._isSelf(v.from)) {
          try {
            await dht._putLocal(key, fixupRec);
          } catch (err) {
            dht._log.error("Failed error correcting self", err);
          }
          return;
        }
        try {
          await dht._putValueToPeer(key, fixupRec, v.from);
        } catch (err) {
          dht._log.error("Failed error correcting entry", err);
        }
      }));
    };
    return {
      async _putLocal(key, rec) {
        return putLocal(key, rec);
      },
      async put(key, value, options = {}) {
        dht._log("PutValue %b", key);
        const record = await utils.createPutRecord(key, value);
        await putLocal(key, record);
        let counterAll = 0;
        let counterSuccess = 0;
        await utils.mapParallel(dht.getClosestPeers(key, {shallow: true}), async (peer) => {
          try {
            counterAll += 1;
            await dht._putValueToPeer(key, record, peer);
            counterSuccess += 1;
          } catch (err) {
            dht._log.error("Failed to put to peer (%b): %s", peer.id, err);
          }
        });
        const minPeers = options.minPeers || counterAll;
        if (minPeers > counterSuccess) {
          const error = errcode(new Error(`Failed to put value to enough peers: ${counterSuccess}/${minPeers}`), "ERR_NOT_ENOUGH_PUT_PEERS");
          dht._log.error(error);
          throw error;
        }
      },
      async get(key, options = {}) {
        options.timeout = options.timeout || c.minute;
        dht._log("_get %b", key);
        const vals = await dht.getMany(key, c.GET_MANY_RECORD_COUNT, options);
        const recs = vals.map((v) => v.val);
        let i = 0;
        try {
          i = libp2pRecord.selection.bestRecord(dht.selectors, key, recs);
        } catch (err) {
          if (err.code !== "ERR_NO_SELECTOR_FUNCTION_FOR_RECORD_KEY") {
            throw err;
          }
        }
        const best = recs[i];
        dht._log("GetValue %b %s", key, best);
        if (!best) {
          throw errcode(new Error("best value was not found"), "ERR_NOT_FOUND");
        }
        await sendCorrectionRecord(key, vals, best);
        return best;
      },
      async getMany(key, nvals, options = {}) {
        options.timeout = options.timeout || c.minute;
        dht._log("getMany %b (%s)", key, nvals);
        let vals = [];
        let localRec;
        try {
          localRec = await getLocal(key);
        } catch (err) {
          if (nvals === 0) {
            throw err;
          }
        }
        if (localRec) {
          vals.push({
            val: localRec.value,
            from: dht.peerId
          });
        }
        if (vals.length >= nvals) {
          return vals;
        }
        const paths = [];
        const id = await utils.convertBuffer(key);
        const rtp = dht.routingTable.closestPeers(id, this.kBucketSize);
        dht._log("peers in rt: %d", rtp.length);
        if (rtp.length === 0) {
          const errMsg = "Failed to lookup key! No peers from routing table!";
          dht._log.error(errMsg);
          if (vals.length === 0) {
            throw errcode(new Error(errMsg), "ERR_NO_PEERS_IN_ROUTING_TABLE");
          }
          return vals;
        }
        const query = new Query(dht, key, (pathIndex, numPaths) => {
          const pathSize = utils.pathSize(nvals - vals.length, numPaths);
          const pathVals = [];
          paths.push(pathVals);
          return async (peer) => {
            let rec, peers, lookupErr;
            try {
              const results = await dht._getValueOrPeers(peer, key);
              rec = results.record;
              peers = results.peers;
            } catch (err) {
              if (err.code !== "ERR_INVALID_RECORD") {
                throw err;
              }
              lookupErr = err;
            }
            const res = {closerPeers: peers};
            if (rec && rec.value || lookupErr) {
              pathVals.push({
                val: rec && rec.value,
                from: peer
              });
            }
            if (pathVals.length >= pathSize) {
              res.pathComplete = true;
            }
            return res;
          };
        });
        let error;
        try {
          await pTimeout(query.run(rtp), options.timeout);
        } catch (err) {
          error = err;
        }
        query.stop();
        vals = [].concat.apply(vals, paths).slice(0, nvals);
        if (error && vals.length === 0) {
          throw error;
        }
        return vals;
      }
    };
  };
});

// node_modules/libp2p-kad-dht/src/peer-list/index.js
var require_peer_list = __commonJS((exports2, module2) => {
  "use strict";
  var PeerList = class {
    constructor() {
      this.list = [];
    }
    push(peerData) {
      if (!this.has(peerData.id)) {
        this.list.push(peerData);
        return true;
      }
      return false;
    }
    has(peerId) {
      const match = this.list.find((i) => i.id.isEqual(peerId));
      return Boolean(match);
    }
    toArray() {
      return this.list.slice();
    }
    pop() {
      return this.list.pop();
    }
    get length() {
      return this.list.length;
    }
  };
  module2.exports = PeerList;
});

// node_modules/libp2p-kad-dht/src/peer-list/limited-peer-list.js
var require_limited_peer_list = __commonJS((exports2, module2) => {
  "use strict";
  var PeerList = require_peer_list();
  var LimitedPeerList = class extends PeerList {
    constructor(limit) {
      super();
      this.limit = limit;
    }
    push(peerData) {
      if (this.length < this.limit) {
        return super.push(peerData);
      }
      return false;
    }
  };
  module2.exports = LimitedPeerList;
});

// node_modules/libp2p-kad-dht/src/content-routing/index.js
var require_content_routing2 = __commonJS((exports2, module2) => {
  "use strict";
  var errcode = require_err_code();
  var pTimeout = require_p_timeout2();
  var c = require_constants19();
  var LimitedPeerList = require_limited_peer_list();
  var Message = require_message4();
  var Query = require_query();
  var utils = require_utils32();
  module2.exports = (dht) => {
    const findProvidersSingle = async (peer, key) => {
      const msg = new Message(Message.TYPES.GET_PROVIDERS, key.bytes, 0);
      return dht.network.sendRequest(peer, msg);
    };
    return {
      async provide(key) {
        dht._log("provide: %s", key.toBaseEncodedString());
        const errors = [];
        await dht.providers.addProvider(key, dht.peerId);
        const multiaddrs = dht.libp2p ? dht.libp2p.multiaddrs : [];
        const msg = new Message(Message.TYPES.ADD_PROVIDER, key.bytes, 0);
        msg.providerPeers = [{
          id: dht.peerId,
          multiaddrs
        }];
        await utils.mapParallel(dht.getClosestPeers(key.bytes), async (peer) => {
          dht._log("putProvider %s to %s", key.toBaseEncodedString(), peer.toB58String());
          try {
            await dht.network.sendMessage(peer, msg);
          } catch (err) {
            errors.push(err);
          }
        });
        if (errors.length) {
          throw errcode(new Error(`Failed to provide to ${errors.length} of ${dht.kBucketSize} peers`, "ERR_SOME_PROVIDES_FAILED"), {errors});
        }
      },
      async *findProviders(key, options = {}) {
        const providerTimeout = options.timeout || c.minute;
        const n = options.maxNumProviders || c.K;
        dht._log("findProviders %s", key.toBaseEncodedString());
        const out = new LimitedPeerList(n);
        const provs = await dht.providers.getProviders(key);
        provs.forEach((id) => {
          const peerData = dht.peerStore.get(id) || {};
          out.push({
            id: peerData.id || id,
            multiaddrs: (peerData.addresses || []).map((address) => address.multiaddr)
          });
        });
        if (out.length >= n) {
          for (const pData of out.toArray()) {
            yield pData;
          }
          return;
        }
        const paths = [];
        const query = new Query(dht, key.bytes, (pathIndex, numPaths) => {
          const pathSize = utils.pathSize(n - out.length, numPaths);
          const pathProviders = new LimitedPeerList(pathSize);
          paths.push(pathProviders);
          return async (peer) => {
            const msg = await findProvidersSingle(peer, key);
            const provs2 = msg.providerPeers;
            dht._log("(%s) found %s provider entries", dht.peerId.toB58String(), provs2.length);
            provs2.forEach((prov) => {
              pathProviders.push({id: prov.id});
            });
            if (pathProviders.length >= pathSize) {
              return {pathComplete: true};
            }
            return {closerPeers: msg.closerPeers};
          };
        });
        const peers = dht.routingTable.closestPeers(key.bytes, dht.kBucketSize);
        try {
          await pTimeout(query.run(peers), providerTimeout);
        } catch (err) {
          if (err.name !== pTimeout.TimeoutError.name) {
            throw err;
          }
        } finally {
          query.stop();
        }
        paths.forEach((path) => {
          path.toArray().forEach((peer) => {
            out.push(peer);
          });
        });
        for (const pData of out.toArray()) {
          yield pData;
        }
      }
    };
  };
});

// node_modules/libp2p-kad-dht/src/peer-routing/index.js
var require_peer_routing2 = __commonJS((exports2, module2) => {
  "use strict";
  var errcode = require_err_code();
  var pTimeout = require_p_timeout2();
  var PeerId = require_src9();
  var crypto2 = require_src10();
  var c = require_constants19();
  var Message = require_message4();
  var Query = require_query();
  var utils = require_utils32();
  module2.exports = (dht) => {
    const findPeerLocal = async (peer) => {
      dht._log("findPeerLocal %s", peer.toB58String());
      const p = await dht.routingTable.find(peer);
      const peerData = p && dht.peerStore.get(p);
      if (peerData) {
        return {
          id: peerData.id,
          multiaddrs: peerData.addresses.map((address) => address.multiaddr)
        };
      }
    };
    const getValueSingle = async (peer, key) => {
      const msg = new Message(Message.TYPES.GET_VALUE, key, 0);
      return dht.network.sendRequest(peer, msg);
    };
    const closerPeersSingle = async (key, peer) => {
      dht._log("closerPeersSingle %b from %s", key, peer.toB58String());
      const msg = await dht.peerRouting._findPeerSingle(peer, new PeerId(key));
      return msg.closerPeers.filter((peerData) => !dht._isSelf(peerData.id)).map((peerData) => {
        dht.peerStore.addressBook.add(peerData.id, peerData.multiaddrs);
        return peerData;
      });
    };
    const getPublicKeyFromNode = async (peer) => {
      const pkKey = utils.keyForPublicKey(peer);
      const msg = await getValueSingle(peer, pkKey);
      if (!msg.record || !msg.record.value) {
        throw errcode(`Node not responding with its public key: ${peer.toB58String()}`, "ERR_INVALID_RECORD");
      }
      const recPeer = PeerId.createFromPubKey(msg.record.value);
      if (!recPeer.isEqual(peer)) {
        throw errcode("public key does not match id", "ERR_PUBLIC_KEY_DOES_NOT_MATCH_ID");
      }
      return recPeer.pubKey;
    };
    return {
      async _findPeerSingle(peer, target) {
        dht._log("findPeerSingle %s", peer.toB58String());
        const msg = new Message(Message.TYPES.FIND_NODE, target.id, 0);
        return dht.network.sendRequest(peer, msg);
      },
      async findPeer(id, options = {}) {
        options.timeout = options.timeout || c.minute;
        dht._log("findPeer %s", id.toB58String());
        const pi = await findPeerLocal(id);
        if (pi != null) {
          dht._log("found local");
          return pi;
        }
        const key = await utils.convertPeerId(id);
        const peers = dht.routingTable.closestPeers(key, dht.kBucketSize);
        if (peers.length === 0) {
          throw errcode(new Error("Peer lookup failed"), "ERR_LOOKUP_FAILED");
        }
        const match = peers.find((p) => p.isEqual(id));
        if (match) {
          const peer = dht.peerStore.get(id);
          if (peer) {
            dht._log("found in peerStore");
            return {
              id: peer.id,
              multiaddrs: peer.addresses.map((address) => address.multiaddr)
            };
          }
        }
        const query = new Query(dht, id.id, () => {
          return async (peer) => {
            const msg = await this._findPeerSingle(peer, id);
            const match2 = msg.closerPeers.find((p) => p.id.isEqual(id));
            if (match2) {
              return {
                peer: match2,
                queryComplete: true
              };
            }
            return {
              closerPeers: msg.closerPeers
            };
          };
        });
        let error, result;
        try {
          result = await pTimeout(query.run(peers), options.timeout);
        } catch (err) {
          error = err;
        }
        query.stop();
        if (error)
          throw error;
        let success = false;
        result.paths.forEach((result2) => {
          if (result2.success) {
            success = true;
            dht.peerStore.addressBook.add(result2.peer.id, result2.peer.multiaddrs);
          }
        });
        dht._log("findPeer %s: %s", id.toB58String(), success);
        if (!success) {
          throw errcode(new Error("No peer found"), "ERR_NOT_FOUND");
        }
        const peerData = dht.peerStore.get(id);
        return {
          id: peerData.id,
          multiaddrs: peerData.addresses.map((address) => address.multiaddr)
        };
      },
      async *getClosestPeers(key, options = {shallow: false}) {
        dht._log("getClosestPeers to %b", key);
        const id = await utils.convertBuffer(key);
        const tablePeers = dht.routingTable.closestPeers(id, dht.kBucketSize);
        const q = new Query(dht, key, () => {
          return async (peer) => {
            const closer = await closerPeersSingle(key, peer);
            return {
              closerPeers: closer,
              pathComplete: options.shallow ? true : void 0
            };
          };
        });
        const res = await q.run(tablePeers);
        if (!res || !res.finalSet) {
          return [];
        }
        const sorted = await utils.sortClosestPeers(Array.from(res.finalSet), id);
        for (const pId of sorted.slice(0, dht.kBucketSize)) {
          yield pId;
        }
      },
      async getPublicKey(peer) {
        dht._log("getPublicKey %s", peer.toB58String());
        const peerData = dht.peerStore.get(peer);
        if (peerData && peerData.id.pubKey) {
          dht._log("getPublicKey: found local copy");
          return peerData.id.pubKey;
        }
        let pk;
        try {
          pk = await getPublicKeyFromNode(peer);
        } catch (err) {
          const pkKey = utils.keyForPublicKey(peer);
          const value = await dht.get(pkKey);
          pk = crypto2.keys.unmarshalPublicKey(value);
        }
        peerData.id = new PeerId(peer.id, null, pk);
        const addrs = peerData.addresses.map((address) => address.multiaddr);
        dht.peerStore.addressBook.add(peerData.id, addrs);
        dht.peerStore.keyBook.set(peerData.id, pk);
        return pk;
      }
    };
  };
});

// node_modules/libp2p-kad-dht/src/providers.js
var require_providers = __commonJS((exports2, module2) => {
  "use strict";
  var cache = require_hashlru();
  var varint = require_varint3();
  var PeerId = require_src9();
  var {Key} = require_src15();
  var {default: Queue} = require_dist();
  var c = require_constants19();
  var utils = require_utils32();
  var Providers = class {
    constructor(datastore, self2, cacheSize) {
      this.datastore = datastore;
      this._log = utils.logger(self2, "providers");
      this.cleanupInterval = c.PROVIDERS_CLEANUP_INTERVAL;
      this.provideValidity = c.PROVIDERS_VALIDITY;
      this.lruCacheSize = cacheSize || c.PROVIDERS_LRU_CACHE_SIZE;
      this.providers = cache(this.lruCacheSize);
      this.syncQueue = new Queue({concurrency: 1});
    }
    start() {
      this._cleaner = setInterval(() => this._cleanup(), this.cleanupInterval);
    }
    stop() {
      clearInterval(this._cleaner);
      this._cleaner = null;
    }
    _cleanup() {
      return this.syncQueue.add(async () => {
        this._log("start cleanup");
        const start = Date.now();
        let count = 0;
        let deleteCount = 0;
        const deleted = new Map();
        const batch = this.datastore.batch();
        const query = this.datastore.query({prefix: c.PROVIDERS_KEY_PREFIX});
        for await (const entry of query) {
          try {
            const {cid, peerId} = parseProviderKey(entry.key);
            const time = readTime(entry.value);
            const now = Date.now();
            const delta = now - time;
            const expired = delta > this.provideValidity;
            this._log("comparing: %d - %d = %d > %d %s", now, time, delta, this.provideValidity, expired ? "(expired)" : "");
            if (expired) {
              deleteCount++;
              batch.delete(entry.key);
              const peers = deleted.get(cid) || new Set();
              peers.add(peerId);
              deleted.set(cid, peers);
            }
            count++;
          } catch (err) {
            this._log.error(err.message);
          }
        }
        this._log("deleting %d / %d entries", deleteCount, count);
        if (deleted.size) {
          await batch.commit();
        }
        for (const [cid, peers] of deleted) {
          const key = makeProviderKey(cid);
          const provs = this.providers.get(key);
          if (provs) {
            for (const peerId of peers) {
              provs.delete(peerId);
            }
            if (provs.size === 0) {
              this.providers.remove(key);
            } else {
              this.providers.set(key, provs);
            }
          }
        }
        this._log("Cleanup successful (%dms)", Date.now() - start);
      });
    }
    async _getProvidersMap(cid) {
      const cacheKey = makeProviderKey(cid);
      let provs = this.providers.get(cacheKey);
      if (!provs) {
        provs = await loadProviders(this.datastore, cid);
        this.providers.set(cacheKey, provs);
      }
      return provs;
    }
    async addProvider(cid, provider) {
      return this.syncQueue.add(async () => {
        this._log("addProvider %s", cid.toBaseEncodedString());
        const provs = await this._getProvidersMap(cid);
        this._log("loaded %s provs", provs.size);
        const now = Date.now();
        provs.set(utils.encodeBase32(provider.id), now);
        const dsKey = makeProviderKey(cid);
        this.providers.set(dsKey, provs);
        return writeProviderEntry(this.datastore, cid, provider, now);
      });
    }
    async getProviders(cid) {
      return this.syncQueue.add(async () => {
        this._log("getProviders %s", cid.toBaseEncodedString());
        const provs = await this._getProvidersMap(cid);
        return [...provs.keys()].map((base32PeerId) => {
          return new PeerId(utils.decodeBase32(base32PeerId));
        });
      });
    }
  };
  function makeProviderKey(cid) {
    cid = typeof cid === "string" ? cid : utils.encodeBase32(cid.bytes);
    return c.PROVIDERS_KEY_PREFIX + cid;
  }
  async function writeProviderEntry(store, cid, peer, time) {
    const dsKey = [
      makeProviderKey(cid),
      "/",
      utils.encodeBase32(peer.id)
    ].join("");
    const key = new Key(dsKey);
    const buffer = Uint8Array.from(varint.encode(time));
    return store.put(key, buffer);
  }
  function parseProviderKey(key) {
    const parts = key.toString().split("/");
    if (parts.length !== 4) {
      throw new Error("incorrectly formatted provider entry key in datastore: " + key);
    }
    return {
      cid: parts[2],
      peerId: parts[3]
    };
  }
  async function loadProviders(store, cid) {
    const providers = new Map();
    const query = store.query({prefix: makeProviderKey(cid)});
    for await (const entry of query) {
      const {peerId} = parseProviderKey(entry.key);
      providers.set(peerId, readTime(entry.value));
    }
    return providers;
  }
  function readTime(buf) {
    return varint.decode(buf);
  }
  module2.exports = Providers;
});

// node_modules/p-times/index.js
var require_p_times = __commonJS((exports2, module2) => {
  "use strict";
  var pMap = require_p_map();
  var pTimes = async (count, mapper, options) => pMap(new Array(count).fill(), (element, index) => mapper(index), options);
  module2.exports = pTimes;
  module2.exports.default = pTimes;
});

// node_modules/libp2p-kad-dht/src/random-walk.js
var require_random_walk = __commonJS((exports2, module2) => {
  "use strict";
  var crypto2 = require_src10();
  var multihashing = require_src14();
  var PeerId = require_src9();
  var AbortController = require_browser3();
  var errcode = require_err_code();
  var times = require_p_times();
  var c = require_constants19();
  var {logger} = require_utils32();
  var RandomWalk = class {
    constructor(dht, options) {
      if (!dht) {
        throw new Error("Random Walk needs an instance of the Kademlia DHT");
      }
      this._kadDHT = dht;
      this._options = {
        ...c.defaultRandomWalk,
        ...options
      };
      this.log = logger(dht.peerId, "random-walk");
      this._timeoutId = void 0;
    }
    start() {
      if (this._timeoutId || !this._options.enabled) {
        return;
      }
      this._timeoutId = setTimeout(() => {
        this._runPeriodically();
      }, this._options.delay);
    }
    stop() {
      if (this._timeoutId) {
        clearTimeout(this._timeoutId);
        this._timeoutId = void 0;
      }
      this._controller && this._controller.abort();
    }
    async _runPeriodically() {
      while (this._timeoutId) {
        try {
          await this._walk(this._options.queriesPerPeriod, this._options.timeout);
        } catch (err) {
          this._kadDHT._log.error("random-walk:error", err);
        }
        await new Promise((resolve) => {
          this._timeoutId = setTimeout(resolve, this._options.interval);
        });
      }
    }
    async _walk(queries, walkTimeout) {
      this.log("start");
      this._controller = new AbortController();
      try {
        await times(queries, async (index) => {
          this.log("running query %d", index);
          try {
            const id = await this._randomPeerId();
            if (!this._controller)
              return;
            await this._query(id, {
              timeout: walkTimeout,
              signal: this._controller.signal
            });
          } catch (err) {
            if (err && err.code !== "ETIMEDOUT") {
              this.log.error("query %d finished with error", index, err);
              throw err;
            }
          }
          this.log("finished query %d", index);
        });
      } finally {
        this._controller = null;
        this.log("finished queries");
      }
    }
    async _query(id, options) {
      this.log("query:%s", id.toB58String());
      let peer;
      try {
        peer = await this._kadDHT.findPeer(id, options);
      } catch (err) {
        if (err && err.code === "ERR_NOT_FOUND") {
          return;
        }
        throw err;
      }
      this.log("query:found", peer);
      throw errcode(`random-walk: ACTUALLY FOUND PEER: ${peer}, ${id.toB58String()}`, "ERR_FOUND_RANDOM_PEER");
    }
    async _randomPeerId() {
      const digest = await multihashing(crypto2.randomBytes(16), "sha2-256");
      return new PeerId(digest);
    }
  };
  module2.exports = RandomWalk;
});

// node_modules/libp2p-kad-dht/src/query-manager.js
var require_query_manager = __commonJS((exports2, module2) => {
  "use strict";
  var QueryManager = class {
    constructor() {
      this.queries = new Set();
      this.running = false;
    }
    queryStarted(query) {
      this.queries.add(query);
    }
    queryCompleted(query) {
      this.queries.delete(query);
    }
    start() {
      this.running = true;
    }
    stop() {
      this.running = false;
      for (const query of this.queries) {
        query.stop();
      }
      this.queries.clear();
    }
  };
  module2.exports = QueryManager;
});

// node_modules/libp2p-kad-dht/src/index.js
var require_src50 = __commonJS((exports2, module2) => {
  "use strict";
  var {EventEmitter} = require_events();
  var errcode = require_err_code();
  var libp2pRecord = require_src25();
  var {MemoryDatastore} = require_src15();
  var uint8ArrayEquals = require_equals6();
  var RoutingTable = require_routing();
  var utils = require_utils32();
  var c = require_constants19();
  var Network = require_network();
  var contentFetching = require_content_fetching();
  var contentRouting = require_content_routing2();
  var peerRouting = require_peer_routing2();
  var Message = require_message4();
  var Providers = require_providers();
  var RandomWalk = require_random_walk();
  var QueryManager = require_query_manager();
  var Record = libp2pRecord.Record;
  var KadDHT = class extends EventEmitter {
    constructor({
      libp2p,
      dialer,
      peerId,
      peerStore,
      registrar,
      protocolPrefix = "/ipfs",
      forceProtocolLegacy = false,
      datastore = new MemoryDatastore(),
      kBucketSize = c.K,
      clientMode = false,
      concurrency = c.ALPHA,
      validators = {},
      selectors = {},
      randomWalk = {},
      onPut = () => {
      },
      onRemove = () => {
      }
    }) {
      super();
      if (!dialer) {
        throw new Error("libp2p-kad-dht requires an instance of Dialer");
      }
      this.libp2p = libp2p;
      this.dialer = dialer;
      this.peerId = peerId;
      this.peerStore = peerStore;
      this.registrar = registrar;
      this.protocol = protocolPrefix + (forceProtocolLegacy ? "" : c.PROTOCOL_DHT);
      this.kBucketSize = kBucketSize;
      this._clientMode = clientMode;
      this.concurrency = concurrency;
      this.disjointPaths = Math.ceil(this.kBucketSize / 2);
      this.routingTable = new RoutingTable(this.peerId, this.kBucketSize);
      this.datastore = datastore;
      this.providers = new Providers(this.datastore, this.peerId);
      this.validators = {
        pk: libp2pRecord.validator.validators.pk,
        ...validators
      };
      this.selectors = {
        pk: libp2pRecord.selection.selectors.pk,
        ...selectors
      };
      this.network = new Network(this);
      this._log = utils.logger(this.peerId);
      this.randomWalk = new RandomWalk(this, randomWalk);
      this._queryManager = new QueryManager();
      this._running = false;
      this.contentFetching = contentFetching(this);
      this.contentRouting = contentRouting(this);
      this.peerRouting = peerRouting(this);
      this.onPut = onPut;
      this.onRemove = onRemove;
    }
    get isStarted() {
      return this._running;
    }
    async start() {
      this._running = true;
      this.providers.start();
      this._queryManager.start();
      await this.network.start();
      this.randomWalk.start();
    }
    stop() {
      this._running = false;
      this.randomWalk.stop();
      this.providers.stop();
      this._queryManager.stop();
      return this.network.stop();
    }
    async put(key, value, options = {}) {
      return this.contentFetching.put(key, value, options);
    }
    async get(key, options = {}) {
      return this.contentFetching.get(key, options);
    }
    async getMany(key, nvals, options = {}) {
      return this.contentFetching.getMany(key, nvals, options);
    }
    async removeLocal(key) {
      this._log("removeLocal: %b", key);
      const dsKey = utils.bufferToKey(key);
      try {
        await this.datastore.delete(dsKey);
      } catch (err) {
        if (err.code === "ERR_NOT_FOUND") {
          return void 0;
        }
        throw err;
      }
    }
    async provide(key) {
      return this.contentRouting.provide(key);
    }
    async *findProviders(key, options = {}) {
      for await (const peerData of this.contentRouting.findProviders(key, options)) {
        yield peerData;
      }
    }
    async findPeer(id, options = {}) {
      return this.peerRouting.findPeer(id, options);
    }
    async *getClosestPeers(key, options = {shallow: false}) {
      for await (const pId of this.peerRouting.getClosestPeers(key, options)) {
        yield pId;
      }
    }
    async getPublicKey(peer) {
      return this.peerRouting.getPublicKey(peer);
    }
    _peerDiscovered(peerId, multiaddrs) {
      this.emit("peer", {
        id: peerId,
        multiaddrs
      });
    }
    async _nearestPeersToQuery(msg) {
      const key = await utils.convertBuffer(msg.key);
      const ids = this.routingTable.closestPeers(key, this.kBucketSize);
      return ids.map((p) => {
        const peer = this.peerStore.get(p);
        return {
          id: p,
          multiaddrs: peer ? peer.addresses.map((address) => address.multiaddr) : []
        };
      });
    }
    async _betterPeersToQuery(msg, peerId) {
      this._log("betterPeersToQuery");
      const closer = await this._nearestPeersToQuery(msg);
      return closer.filter((closer2) => {
        if (this._isSelf(closer2.id)) {
          this._log.error("trying to return self as closer");
          return false;
        }
        return !closer2.id.isEqual(peerId);
      });
    }
    async _checkLocalDatastore(key) {
      this._log("checkLocalDatastore: %b", key);
      const dsKey = utils.bufferToKey(key);
      let rawRecord;
      try {
        rawRecord = await this.datastore.get(dsKey);
      } catch (err) {
        if (err.code === "ERR_NOT_FOUND") {
          return void 0;
        }
        throw err;
      }
      const record = Record.deserialize(rawRecord);
      if (!record) {
        throw errcode("Invalid record", "ERR_INVALID_RECORD");
      }
      if (record.timeReceived == null || utils.now() - record.timeReceived > c.MAX_RECORD_AGE) {
        await this.datastore.delete(dsKey);
        this.onRemove(record);
        return void 0;
      }
      return record;
    }
    async _add(peerId) {
      await this.routingTable.add(peerId);
    }
    async _verifyRecordLocally(record) {
      this._log("verifyRecordLocally");
      await libp2pRecord.validator.verifyRecord(this.validators, record);
    }
    _isSelf(other) {
      return other && uint8ArrayEquals(this.peerId.id, other.id);
    }
    async _putValueToPeer(key, rec, target) {
      const msg = new Message(Message.TYPES.PUT_VALUE, key, 0);
      msg.record = rec;
      const resp = await this.network.sendRequest(target, msg);
      if (!resp.record.value.equals(Record.deserialize(rec).value)) {
        throw errcode(new Error("value not put correctly"), "ERR_PUT_VALUE_INVALID");
      }
    }
    async _getValueOrPeers(peer, key) {
      const msg = await this._getValueSingle(peer, key);
      const peers = msg.closerPeers;
      const record = msg.record;
      if (record) {
        try {
          await this._verifyRecordOnline(record);
        } catch (err) {
          const errMsg = "invalid record received, discarded";
          this._log(errMsg);
          throw errcode(new Error(errMsg), "ERR_INVALID_RECORD");
        }
        return {record, peers};
      }
      if (peers.length > 0) {
        return {peers};
      }
      throw errcode(new Error("Not found"), "ERR_NOT_FOUND");
    }
    async _getValueSingle(peer, key) {
      const msg = new Message(Message.TYPES.GET_VALUE, key, 0);
      return this.network.sendRequest(peer, msg);
    }
    async _verifyRecordOnline(record) {
      await libp2pRecord.validator.verifyRecord(this.validators, record);
    }
  };
  module2.exports = KadDHT;
  module2.exports.multicodec = "/ipfs" + c.PROTOCOL_DHT;
});

// node_modules/ipfs-core/src/runtime/libp2p-browser.js
var require_libp2p_browser = __commonJS((exports2, module2) => {
  "use strict";
  var WS = require_src45();
  var WebRTCStar = require_src46();
  var Multiplex = require_src47();
  var {NOISE} = require_src49();
  var KadDHT = require_src50();
  var GossipSub = require_src39();
  var ipnsUtils = require_utils14();
  module2.exports = () => {
    return {
      dialer: {
        maxParallelDials: 150,
        maxDialsPerPeer: 4,
        dialTimeout: 1e4
      },
      modules: {
        transport: [
          WS,
          WebRTCStar
        ],
        streamMuxer: [
          Multiplex
        ],
        connEncryption: [
          NOISE
        ],
        peerDiscovery: [],
        dht: KadDHT,
        pubsub: GossipSub
      },
      config: {
        peerDiscovery: {
          autoDial: true,
          bootstrap: {
            enabled: true
          },
          webRTCStar: {
            enabled: true
          }
        },
        dht: {
          kBucketSize: 20,
          enabled: false,
          clientMode: true,
          randomWalk: {
            enabled: false
          },
          validators: {
            ipns: ipnsUtils.validator
          },
          selectors: {
            ipns: ipnsUtils.selector
          }
        },
        pubsub: {
          enabled: true,
          emitSelf: true
        },
        nat: {
          enabled: false
        }
      },
      metrics: {
        enabled: true
      },
      peerStore: {
        persistence: true,
        threshold: 1
      }
    };
  };
});

// node_modules/libp2p-bootstrap/src/index.js
var require_src51 = __commonJS((exports2, module2) => {
  "use strict";
  var PeerId = require_src9();
  var multiaddr = require_src11();
  var mafmt = require_src12();
  var {EventEmitter} = require_events();
  var debug = require_browser4();
  var log = debug("libp2p:bootstrap");
  log.error = debug("libp2p:bootstrap:error");
  var Bootstrap = class extends EventEmitter {
    constructor(options = {}) {
      if (!options.list || !options.list.length) {
        throw new Error("Bootstrap requires a list of peer addresses");
      }
      super();
      this._list = options.list;
      this._interval = options.interval || 1e4;
      this._timer = null;
    }
    start() {
      if (this._timer) {
        return;
      }
      this._timer = setInterval(() => this._discoverBootstrapPeers(), this._interval);
      this._discoverBootstrapPeers();
    }
    _discoverBootstrapPeers() {
      if (!this._timer) {
        return;
      }
      this._list.forEach((candidate) => {
        if (!mafmt.P2P.matches(candidate)) {
          return log.error("Invalid multiaddr");
        }
        const ma = multiaddr(candidate);
        const peerId = PeerId.createFromB58String(ma.getPeerId());
        try {
          this.emit("peer", {
            id: peerId,
            multiaddrs: [ma]
          });
        } catch (err) {
          log.error("Invalid bootstrap peer id", err);
        }
      });
    }
    stop() {
      clearInterval(this._timer);
      this._timer = null;
    }
  };
  exports2 = module2.exports = Bootstrap;
  exports2.tag = "bootstrap";
});

// node_modules/ipfs-core/src/components/libp2p.js
var require_libp2p = __commonJS((exports2, module2) => {
  "use strict";
  var get = require_dlv_umd();
  var mergeOptions = require_merge_options();
  var errCode = require_err_code();
  var PubsubRouters = require_libp2p_pubsub_routers_browser();
  module2.exports = ({
    options = {},
    peerId,
    multiaddrs = [],
    repo,
    keychainConfig = {},
    config = {}
  }) => {
    const {datastore, keys} = repo;
    const libp2pOptions = getLibp2pOptions({
      options,
      config,
      datastore,
      keys,
      keychainConfig,
      peerId,
      multiaddrs
    });
    if (typeof options.libp2p === "function") {
      return options.libp2p({libp2pOptions, options, config, datastore, peerId});
    }
    const Libp2p = require_src44();
    return new Libp2p(libp2pOptions);
  };
  function getLibp2pOptions({options, config, datastore, keys, keychainConfig, peerId, multiaddrs}) {
    const getPubsubRouter = () => {
      const router = get(config, "Pubsub.Router") || "gossipsub";
      if (!PubsubRouters[router]) {
        throw errCode(new Error(`Router unavailable. Configure libp2p.modules.pubsub to use the ${router} router.`), "ERR_NOT_SUPPORTED");
      }
      return PubsubRouters[router];
    };
    const libp2pDefaults = {
      datastore,
      peerId,
      modules: {}
    };
    const libp2pOptions = {
      modules: {
        pubsub: getPubsubRouter()
      },
      config: {
        peerDiscovery: {
          mdns: {
            enabled: get(options, "config.Discovery.MDNS.Enabled", get(config, "Discovery.MDNS.Enabled", true))
          },
          webRTCStar: {
            enabled: get(options, "config.Discovery.webRTCStar.Enabled", get(config, "Discovery.webRTCStar.Enabled", true))
          },
          bootstrap: {
            list: get(options, "config.Bootstrap", get(config, "Bootstrap", []))
          }
        },
        relay: {
          enabled: get(options, "relay.enabled", get(config, "relay.enabled", true)),
          hop: {
            enabled: get(options, "relay.hop.enabled", get(config, "relay.hop.enabled", false)),
            active: get(options, "relay.hop.active", get(config, "relay.hop.active", false))
          }
        },
        dht: {
          enabled: get(config, "Routing.Type", "none") !== "none",
          clientMode: get(config, "Routing.Type", "dht") !== "dhtserver",
          kBucketSize: get(options, "dht.kBucketSize", 20)
        },
        pubsub: {
          enabled: get(options, "config.Pubsub.Enabled", get(config, "Pubsub.Enabled", true))
        },
        nat: {
          enabled: get(options, "nat.enabled", !get(config, "Swarm.DisableNatPortMap", false)),
          ttl: get(options, "nat.ttl", 7200),
          autoUpdate: get(options, "nat.autoUpdate", true),
          gateway: get(options, "nat.gateway"),
          externalIp: get(options, "nat.externalIp"),
          pmp: {
            enabled: get(options, "nat.pmp.enabled", false)
          }
        }
      },
      addresses: {
        listen: multiaddrs,
        announce: get(options, "addresses.announce", get(config, "Addresses.Announce", []))
      },
      connectionManager: get(options, "connectionManager", {
        maxConnections: get(options, "config.Swarm.ConnMgr.HighWater", get(config, "Swarm.ConnMgr.HighWater")),
        minConnections: get(options, "config.Swarm.ConnMgr.LowWater", get(config, "Swarm.ConnMgr.LowWater"))
      }),
      keychain: {
        datastore: keys,
        ...keychainConfig
      }
    };
    const getEnvLibp2pOptions = require_libp2p_browser();
    let constructorOptions = get(options, "libp2p", {});
    if (typeof constructorOptions === "function") {
      constructorOptions = {};
    }
    const libp2pConfig = mergeOptions(libp2pDefaults, getEnvLibp2pOptions(), libp2pOptions, constructorOptions);
    const bootstrapList = get(libp2pConfig, "config.peerDiscovery.bootstrap.list", []);
    if (bootstrapList.length > 0) {
      libp2pConfig.modules.peerDiscovery.push(require_src51());
    }
    return libp2pConfig;
  }
});

// node_modules/ipfs-core/src/components/storage.js
var require_storage = __commonJS((exports2, module2) => {
  "use strict";
  var log = require_browser4()("ipfs:components:peer:storage");
  var createRepo = require_repo_browser();
  var getDefaultConfig = require_config_browser();
  var {ERR_REPO_NOT_INITIALIZED} = require_src33().errors;
  var uint8ArrayFromString = require_from_string6();
  var uint8ArrayToString = require_to_string5();
  var PeerId = require_src9();
  var {mergeOptions} = require_utils7();
  var configService = require_config2();
  var {NotEnabledError} = require_errors3();
  var createLibP2P = require_libp2p();
  var Storage = class {
    constructor(peerId, keychain, repo, print, isNew) {
      this.print = print;
      this.peerId = peerId;
      this.keychain = keychain;
      this.repo = repo;
      this.print = print;
      this.isNew = isNew;
    }
    static async start(options) {
      const {repoAutoMigrate: autoMigrate, repo: inputRepo, print, silent} = options;
      const repo = typeof inputRepo === "string" || inputRepo == null ? createRepo({path: inputRepo, autoMigrate, silent}) : inputRepo;
      const {peerId, keychain, isNew} = await loadRepo(repo, options);
      return new Storage(peerId, keychain, repo, print, isNew);
    }
  };
  module2.exports = Storage;
  var loadRepo = async (repo, options) => {
    const openError = await openRepo(repo);
    if (openError == null) {
      return {...await configureRepo(repo, options), isNew: false};
    } else if (openError.code === ERR_REPO_NOT_INITIALIZED) {
      if (options.allowNew === false) {
        throw new NotEnabledError("Initialization of new repos disabled by config, pass `config.init.isNew: true` to enable it");
      } else {
        return {...await initRepo(repo, options), isNew: true};
      }
    } else {
      throw openError;
    }
  };
  var openRepo = async (repo) => {
    if (repo.closed) {
      try {
        await repo.open();
        return null;
      } catch (error) {
        return error;
      }
    } else {
      return null;
    }
  };
  var initRepo = async (repo, options) => {
    const exists = await repo.exists();
    log("repo exists?", exists);
    if (exists === true) {
      throw new Error("repo already exists");
    }
    const peerId = options.privateKey ? await decodePeerId(options.privateKey) : await initPeerId(options);
    const identity = peerIdToIdentity(peerId);
    log("peer identity: %s", identity.PeerID);
    const config = {
      ...mergeOptions(applyProfiles(getDefaultConfig(), options.profiles), options.config),
      Identity: identity
    };
    await repo.init(config);
    await repo.open();
    log("repo opened");
    const libp2p = createLibP2P({
      options: void 0,
      multiaddrs: void 0,
      peerId,
      repo,
      config,
      keychainConfig: {
        pass: options.pass
      }
    });
    if (libp2p.keychain && libp2p.keychain.opts) {
      await libp2p.loadKeychain();
      await repo.config.set("Keychain", {
        dek: libp2p.keychain.opts.dek
      });
    }
    return {peerId, keychain: libp2p.keychain};
  };
  var decodePeerId = (peerId) => {
    log("using user-supplied private-key");
    return typeof peerId === "object" ? peerId : PeerId.createFromPrivKey(uint8ArrayFromString(peerId, "base64pad"));
  };
  var initPeerId = ({print, algorithm = "RSA", bits = 2048}) => {
    print("generating %s-bit (rsa only) %s keypair...", bits, algorithm);
    return PeerId.create({keyType: algorithm, bits});
  };
  var peerIdToIdentity = (peerId) => ({
    PeerID: peerId.toB58String(),
    PrivKey: uint8ArrayToString(peerId.privKey.bytes, "base64pad")
  });
  var configureRepo = async (repo, {config, profiles, pass}) => {
    const original = await repo.config.getAll();
    const changed = mergeConfigs(applyProfiles(original, profiles), config);
    if (original !== changed) {
      await repo.config.replace(changed);
    }
    const peerId = await PeerId.createFromPrivKey(changed.Identity.PrivKey);
    const libp2p = createLibP2P({
      options: void 0,
      multiaddrs: void 0,
      peerId,
      repo,
      config: changed,
      keychainConfig: {
        pass,
        ...changed.Keychain
      }
    });
    if (libp2p.keychain) {
      await libp2p.loadKeychain();
    }
    return {peerId, keychain: libp2p.keychain};
  };
  var mergeConfigs = (config, changes) => changes ? mergeOptions(config, changes) : config;
  var applyProfiles = (config, profiles) => {
    return (profiles || []).reduce((config2, name) => {
      const profile = configService.profiles[name];
      if (!profile) {
        throw new Error(`Could not find profile with name '${name}'`);
      }
      log("applying profile %s", name);
      return profile.transform(config2);
    }, config);
  };
});

// node_modules/varint-decoder/src/index.js
var require_src52 = __commonJS((exports2, module2) => {
  "use strict";
  var varint = require_varint3();
  module2.exports = (buf) => {
    if (!(buf instanceof Uint8Array)) {
      throw new Error("arg needs to be a Uint8Array");
    }
    const result = [];
    while (buf.length > 0) {
      const num = varint.decode(buf);
      result.push(num);
      buf = buf.slice(varint.decode.bytes);
    }
    return result;
  };
});

// node_modules/ipfs-bitswap/node_modules/uint8arrays/equals.js
var require_equals7 = __commonJS((exports2, module2) => {
  "use strict";
  function equals(a, b) {
    if (a === b) {
      return true;
    }
    if (a.byteLength !== b.byteLength) {
      return false;
    }
    for (let i = 0; i < a.byteLength; i++) {
      if (a[i] !== b[i]) {
        return false;
      }
    }
    return true;
  }
  module2.exports = equals;
});

// node_modules/ipfs-bitswap/src/utils/index.js
var require_utils33 = __commonJS((exports2, module2) => {
  "use strict";
  var debug = require_browser4();
  var uint8ArrayEquals = require_equals7();
  var logger = (id, subsystem) => {
    const name = ["bitswap"];
    if (subsystem) {
      name.push(subsystem);
    }
    if (id) {
      name.push(`${id.toB58String().slice(0, 8)}`);
    }
    const logger2 = debug(name.join(":"));
    logger2.error = debug(name.concat(["error"]).join(":"));
    return logger2;
  };
  var includesWith = (pred, x, list) => {
    let idx = 0;
    const len = list.length;
    while (idx < len) {
      if (pred(x, list[idx])) {
        return true;
      }
      idx += 1;
    }
    return false;
  };
  var uniqWith = (pred, list) => {
    let idx = 0;
    const len = list.length;
    const result = [];
    let item;
    while (idx < len) {
      item = list[idx];
      if (!includesWith(pred, item, result)) {
        result[result.length] = item;
      }
      idx += 1;
    }
    return result;
  };
  var groupBy = (pred, list) => {
    return list.reduce((acc, v) => {
      const k = pred(v);
      if (acc[k]) {
        acc[k].push(v);
      } else {
        acc[k] = [v];
      }
      return acc;
    }, {});
  };
  var pullAllWith = (pred, list, values) => {
    return list.filter((i) => {
      return !includesWith(pred, i, values);
    });
  };
  var sortBy = (fn, list) => {
    return Array.prototype.slice.call(list, 0).sort((a, b) => {
      const aa = fn(a);
      const bb = fn(b);
      return aa < bb ? -1 : aa > bb ? 1 : 0;
    });
  };
  var isMapEqual = (a, b) => {
    if (a.size !== b.size) {
      return false;
    }
    for (const [key, valueA] of a) {
      if (!b.has(key)) {
        return false;
      }
      const valueB = b.get(key);
      if (typeof valueA.equals === "function" && !valueA.equals(valueB)) {
        return false;
      }
      if (valueA._data && !uint8ArrayEquals(valueA._data, valueB._data)) {
        return false;
      }
    }
    return true;
  };
  module2.exports = {
    logger,
    includesWith,
    uniqWith,
    groupBy,
    pullAllWith,
    sortBy,
    isMapEqual
  };
});

// node_modules/ipfs-bitswap/src/types/message/message.proto.js
var require_message_proto = __commonJS((exports2, module2) => {
  "use strict";
  var protons = require_src8();
  module2.exports = protons(`
  message Message {
    message Wantlist {
      enum WantType {
        Block = 0;
        Have = 1;
      }

      message Entry {
        // changed from string to bytes, it makes a difference in JavaScript
        optional bytes block = 1;      // the block cid (cidV0 in bitswap 1.0.0, cidV1 in bitswap 1.1.0)
        optional int32 priority = 2;    // the priority (normalized). default to 1
        optional bool cancel = 3;       // whether this revokes an entry
        WantType wantType = 4;         // Note: defaults to enum 0, ie Block
        bool sendDontHave = 5;        // Note: defaults to false
      }

      repeated Entry entries = 1;       // a list of wantlist entries
      optional bool full = 2;           // whether this is the full wantlist. default to false
    }

    message Block {
      optional bytes prefix = 1;        // CID prefix (cid version, multicodec and multihash prefix (type + length)
      optional bytes data = 2;
    }

    enum BlockPresenceType {
      Have = 0;
      DontHave = 1;
    }
    message BlockPresence {
      bytes cid = 1;
      BlockPresenceType type = 2;
    }

    optional Wantlist wantlist = 1;
    repeated bytes blocks = 2;          // used to send Blocks in bitswap 1.0.0
    repeated Block payload = 3;         // used to send Blocks in bitswap 1.1.0
    repeated BlockPresence blockPresences = 4;
    int32 pendingBytes = 5;
  }
`);
});

// node_modules/ipfs-bitswap/src/types/wantlist/entry.js
var require_entry = __commonJS((exports2, module2) => {
  "use strict";
  var WantListEntry = class {
    constructor(cid, priority, wantType) {
      this._refCounter = 1;
      this.cid = cid;
      this.priority = priority || 1;
      this.wantType = wantType;
    }
    inc() {
      this._refCounter += 1;
    }
    dec() {
      this._refCounter = Math.max(0, this._refCounter - 1);
    }
    hasRefs() {
      return this._refCounter > 0;
    }
    get [Symbol.toStringTag]() {
      const cidStr = this.cid.toString("base58btc");
      return `WantlistEntry <key: ${cidStr}, priority: ${this.priority}, refs: ${this._refCounter}>`;
    }
    equals(other) {
      return this._refCounter === other._refCounter && this.cid.equals(other.cid) && this.priority === other.priority && this.wantType === other.wantType;
    }
  };
  module2.exports = WantListEntry;
});

// node_modules/ipfs-bitswap/src/types/wantlist/index.js
var require_wantlist2 = __commonJS((exports2, module2) => {
  "use strict";
  var {sortBy} = require_utils33();
  var Entry = require_entry();
  var Wantlist = class {
    constructor(stats) {
      this.set = new Map();
      this._stats = stats;
    }
    get length() {
      return this.set.size;
    }
    add(cid, priority, wantType) {
      const Message = require_message5();
      const cidStr = cid.toString("base58btc");
      const entry = this.set.get(cidStr);
      if (entry) {
        entry.inc();
        entry.priority = priority;
        if (entry.wantType === Message.WantType.Have && wantType === Message.WantType.Block) {
          entry.wantType = wantType;
        }
      } else {
        this.set.set(cidStr, new Entry(cid, priority, wantType));
        if (this._stats) {
          this._stats.push(null, "wantListSize", 1);
        }
      }
    }
    remove(cid) {
      const cidStr = cid.toString("base58btc");
      const entry = this.set.get(cidStr);
      if (!entry) {
        return;
      }
      entry.dec();
      if (entry.hasRefs()) {
        return;
      }
      this.set.delete(cidStr);
      if (this._stats) {
        this._stats.push(null, "wantListSize", -1);
      }
    }
    removeForce(cidStr) {
      if (this.set.has(cidStr)) {
        this.set.delete(cidStr);
      }
    }
    forEach(fn) {
      return this.set.forEach(fn);
    }
    entries() {
      return this.set.entries();
    }
    sortedEntries() {
      return new Map(sortBy((o) => o[1].key, Array.from(this.set.entries())));
    }
    contains(cid) {
      const cidStr = cid.toString("base58btc");
      return this.set.get(cidStr);
    }
  };
  Wantlist.Entry = Entry;
  module2.exports = Wantlist;
});

// node_modules/ipfs-bitswap/src/types/message/entry.js
var require_entry2 = __commonJS((exports2, module2) => {
  "use strict";
  var WantlistEntry = require_wantlist2().Entry;
  module2.exports = class BitswapMessageEntry {
    constructor(cid, priority, wantType, cancel, sendDontHave) {
      this.entry = new WantlistEntry(cid, priority, wantType);
      this.cancel = Boolean(cancel);
      this.sendDontHave = Boolean(sendDontHave);
    }
    get cid() {
      return this.entry.cid;
    }
    set cid(cid) {
      this.entry.cid = cid;
    }
    get priority() {
      return this.entry.priority;
    }
    set priority(val) {
      this.entry.priority = val;
    }
    get wantType() {
      return this.entry.wantType;
    }
    set wantType(val) {
      this.entry.wantType = val;
    }
    get [Symbol.toStringTag]() {
      const cidStr = this.cid.toString("base58btc");
      return `BitswapMessageEntry ${cidStr} <cancel: ${this.cancel}, priority: ${this.priority}>`;
    }
    equals(other) {
      return this.cancel === other.cancel && this.sendDontHave === other.sendDontHave && this.wantType === other.wantType && this.entry.equals(other.entry);
    }
  };
});

// node_modules/ipfs-bitswap/src/types/message/index.js
var require_message5 = __commonJS((exports2, module2) => {
  "use strict";
  var Block = require_src26();
  var CID = require_src7();
  var {getName} = require_src6();
  var vd = require_src52();
  var multihashing = require_src14();
  var {isMapEqual} = require_utils33();
  var {Message} = require_message_proto();
  var Entry = require_entry2();
  var BitswapMessage = class {
    constructor(full) {
      this.full = full;
      this.wantlist = new Map();
      this.blocks = new Map();
      this.blockPresences = new Map();
      this.pendingBytes = 0;
    }
    get empty() {
      return this.blocks.size === 0 && this.wantlist.size === 0 && this.blockPresences.size === 0;
    }
    addEntry(cid, priority, wantType, cancel, sendDontHave) {
      if (wantType == null) {
        wantType = BitswapMessage.WantType.Block;
      }
      const cidStr = cid.toString("base58btc");
      const entry = this.wantlist.get(cidStr);
      if (entry) {
        if (entry.wantType === wantType) {
          entry.priority = priority;
        }
        if (cancel) {
          entry.cancel = Boolean(cancel);
        }
        if (sendDontHave) {
          entry.sendDontHave = Boolean(sendDontHave);
        }
        if (wantType === BitswapMessage.WantType.Block && entry.wantType === BitswapMessage.WantType.Have) {
          entry.wantType = wantType;
        }
      } else {
        this.wantlist.set(cidStr, new Entry(cid, priority, wantType, cancel, sendDontHave));
      }
    }
    addBlock(block) {
      const cidStr = block.cid.toString("base58btc");
      this.blocks.set(cidStr, block);
    }
    addHave(cid) {
      const cidStr = cid.toString("base58btc");
      if (!this.blockPresences.has(cidStr)) {
        this.blockPresences.set(cidStr, BitswapMessage.BlockPresenceType.Have);
      }
    }
    addDontHave(cid) {
      const cidStr = cid.toString("base58btc");
      if (!this.blockPresences.has(cidStr)) {
        this.blockPresences.set(cidStr, BitswapMessage.BlockPresenceType.DontHave);
      }
    }
    cancel(cid) {
      const cidStr = cid.toString("base58btc");
      this.wantlist.delete(cidStr);
      this.addEntry(cid, 0, BitswapMessage.WantType.Block, true, false);
    }
    setPendingBytes(size) {
      this.pendingBytes = size;
    }
    serializeToBitswap100() {
      const msg = {
        wantlist: {
          entries: Array.from(this.wantlist.values()).map((entry) => {
            return {
              block: entry.cid.bytes,
              priority: Number(entry.priority),
              cancel: Boolean(entry.cancel)
            };
          })
        },
        blocks: Array.from(this.blocks.values()).map((block) => block.data)
      };
      if (this.full) {
        msg.wantlist.full = true;
      }
      return Message.encode(msg);
    }
    serializeToBitswap110() {
      const msg = {
        wantlist: {
          entries: Array.from(this.wantlist.values()).map((entry) => {
            return {
              block: entry.cid.bytes,
              priority: Number(entry.priority),
              wantType: entry.wantType,
              cancel: Boolean(entry.cancel),
              sendDontHave: Boolean(entry.sendDontHave)
            };
          })
        },
        blockPresences: [],
        payload: []
      };
      if (this.full) {
        msg.wantlist.full = true;
      }
      this.blocks.forEach((block) => {
        msg.payload.push({
          prefix: block.cid.prefix,
          data: block.data
        });
      });
      for (const [cidStr, bpType] of this.blockPresences) {
        msg.blockPresences.push({
          cid: new CID(cidStr).bytes,
          type: bpType
        });
      }
      if (this.pendingBytes > 0) {
        msg.pendingBytes = this.pendingBytes;
      }
      return Message.encode(msg);
    }
    equals(other) {
      if (this.full !== other.full || this.pendingBytes !== other.pendingBytes || !isMapEqual(this.wantlist, other.wantlist) || !isMapEqual(this.blocks, other.blocks) || !isMapEqual(this.blockPresences, other.blockPresences)) {
        return false;
      }
      return true;
    }
    get [Symbol.toStringTag]() {
      const list = Array.from(this.wantlist.keys());
      const blocks = Array.from(this.blocks.keys());
      return `BitswapMessage <full: ${this.full}, list: ${list}, blocks: ${blocks}>`;
    }
  };
  BitswapMessage.deserialize = async (raw) => {
    const decoded = Message.decode(raw);
    const isFull = decoded.wantlist && decoded.wantlist.full || false;
    const msg = new BitswapMessage(isFull);
    if (decoded.wantlist) {
      decoded.wantlist.entries.forEach((entry) => {
        const cid = new CID(entry.block);
        msg.addEntry(cid, entry.priority, entry.wantType, entry.cancel, entry.sendDontHave);
      });
    }
    if (decoded.blockPresences) {
      decoded.blockPresences.forEach((blockPresence) => {
        const cid = new CID(blockPresence.cid);
        if (blockPresence.type === BitswapMessage.BlockPresenceType.Have) {
          msg.addHave(cid);
        } else {
          msg.addDontHave(cid);
        }
      });
    }
    if (decoded.blocks.length > 0) {
      await Promise.all(decoded.blocks.map(async (b) => {
        const hash = await multihashing(b, "sha2-256");
        const cid = new CID(hash);
        msg.addBlock(new Block(b, cid));
      }));
      return msg;
    }
    if (decoded.payload.length > 0) {
      await Promise.all(decoded.payload.map(async (p) => {
        if (!p.prefix || !p.data) {
          return;
        }
        const values = vd(p.prefix);
        const cidVersion = values[0];
        const multicodec = values[1];
        const hashAlg = values[2];
        const hash = await multihashing(p.data, hashAlg);
        const cid = new CID(cidVersion, getName(multicodec), hash);
        msg.addBlock(new Block(p.data, cid));
      }));
      msg.setPendingBytes(decoded.pendingBytes);
      return msg;
    }
    return msg;
  };
  BitswapMessage.blockPresenceSize = (cid) => {
    return cid.bytes.length + 1;
  };
  BitswapMessage.Entry = Entry;
  BitswapMessage.WantType = {
    Block: Message.Wantlist.WantType.Block,
    Have: Message.Wantlist.WantType.Have
  };
  BitswapMessage.BlockPresenceType = {
    Have: Message.BlockPresenceType.Have,
    DontHave: Message.BlockPresenceType.DontHave
  };
  module2.exports = BitswapMessage;
});

// node_modules/ipfs-bitswap/src/constants.js
var require_constants20 = __commonJS((exports2, module2) => {
  "use strict";
  var SECOND = 1e3;
  module2.exports = {
    maxProvidersPerRequest: 3,
    providerRequestTimeout: 10 * SECOND,
    hasBlockTimeout: 15 * SECOND,
    provideTimeout: 15 * SECOND,
    kMaxPriority: Math.pow(2, 31) - 1,
    maxListeners: 1e3,
    wantlistSendDebounceMs: 1
  };
});

// node_modules/just-debounce-it/index.js
var require_just_debounce_it = __commonJS((exports2, module2) => {
  module2.exports = debounce;
  function debounce(fn, wait, callFirst) {
    var timeout;
    return function() {
      if (!wait) {
        return fn.apply(this, arguments);
      }
      var context = this;
      var args = arguments;
      var callNow = callFirst && !timeout;
      clearTimeout(timeout);
      timeout = setTimeout(function() {
        timeout = null;
        if (!callNow) {
          return fn.apply(context, args);
        }
      }, wait);
      if (callNow) {
        return fn.apply(this, arguments);
      }
    };
  }
});

// node_modules/ipfs-bitswap/src/want-manager/msg-queue.js
var require_msg_queue = __commonJS((exports2, module2) => {
  "use strict";
  var debounce = require_just_debounce_it();
  var Message = require_message5();
  var logger = require_utils33().logger;
  var {wantlistSendDebounceMs} = require_constants20();
  module2.exports = class MsgQueue {
    constructor(selfPeerId, otherPeerId, network) {
      this.peerId = otherPeerId;
      this.network = network;
      this.refcnt = 1;
      this._entries = [];
      this._log = logger(selfPeerId, "msgqueue", otherPeerId.toB58String().slice(0, 8));
      this.sendEntries = debounce(this._sendEntries.bind(this), wantlistSendDebounceMs);
    }
    addMessage(msg) {
      if (msg.empty) {
        return;
      }
      this.send(msg);
    }
    addEntries(entries) {
      this._entries = this._entries.concat(entries);
      this.sendEntries();
    }
    _sendEntries() {
      if (!this._entries.length) {
        return;
      }
      const msg = new Message(false);
      this._entries.forEach((entry) => {
        if (entry.cancel) {
          msg.cancel(entry.cid);
        } else {
          msg.addEntry(entry.cid, entry.priority);
        }
      });
      this._entries = [];
      this.addMessage(msg);
    }
    async send(msg) {
      try {
        await this.network.connectTo(this.peerId);
      } catch (err) {
        this._log.error("cant connect to peer %s: %s", this.peerId.toB58String(), err.message);
        return;
      }
      this._log("sending message to peer %s", this.peerId.toB58String());
      this.network.sendMessage(this.peerId, msg).catch((err) => {
        this._log.error("send error: %s", err.message);
      });
    }
  };
});

// node_modules/ipfs-bitswap/src/want-manager/index.js
var require_want_manager = __commonJS((exports2, module2) => {
  "use strict";
  var Message = require_message5();
  var Wantlist = require_wantlist2();
  var CONSTANTS = require_constants20();
  var MsgQueue = require_msg_queue();
  var logger = require_utils33().logger;
  module2.exports = class WantManager {
    constructor(peerId, network, stats) {
      this.peers = new Map();
      this.wantlist = new Wantlist(stats);
      this.network = network;
      this._stats = stats;
      this._peerId = peerId;
      this._log = logger(peerId, "want");
    }
    _addEntries(cids, cancel, force) {
      const entries = cids.map((cid, i) => {
        return new Message.Entry(cid, CONSTANTS.kMaxPriority - i, Message.WantType.Block, cancel);
      });
      entries.forEach((e) => {
        if (e.cancel) {
          if (force) {
            this.wantlist.removeForce(e.cid);
          } else {
            this.wantlist.remove(e.cid);
          }
        } else {
          this._log("adding to wl");
          this.wantlist.add(e.cid, e.priority);
        }
      });
      for (const p of this.peers.values()) {
        p.addEntries(entries);
      }
    }
    _startPeerHandler(peerId) {
      let mq = this.peers.get(peerId.toB58String());
      if (mq) {
        mq.refcnt++;
        return;
      }
      mq = new MsgQueue(this._peerId, peerId, this.network);
      const fullwantlist = new Message(true);
      for (const entry of this.wantlist.entries()) {
        fullwantlist.addEntry(entry[1].cid, entry[1].priority);
      }
      mq.addMessage(fullwantlist);
      this.peers.set(peerId.toB58String(), mq);
      return mq;
    }
    _stopPeerHandler(peerId) {
      const mq = this.peers.get(peerId.toB58String());
      if (!mq) {
        return;
      }
      mq.refcnt--;
      if (mq.refcnt > 0) {
        return;
      }
      this.peers.delete(peerId.toB58String());
    }
    wantBlocks(cids, options = {}) {
      this._addEntries(cids, false);
      if (options && options.signal) {
        options.signal.addEventListener("abort", () => {
          this.cancelWants(cids);
        });
      }
    }
    unwantBlocks(cids) {
      this._log("unwant blocks: %s", cids.length);
      this._addEntries(cids, true, true);
    }
    cancelWants(cids) {
      this._log("cancel wants: %s", cids.length);
      this._addEntries(cids, true);
    }
    connectedPeers() {
      return Array.from(this.peers.keys());
    }
    connected(peerId) {
      this._startPeerHandler(peerId);
    }
    disconnected(peerId) {
      this._stopPeerHandler(peerId);
    }
    start() {
    }
    stop() {
      this.peers.forEach((mq) => this.disconnected(mq.peerId));
      clearInterval(this.timer);
    }
  };
});

// node_modules/ipfs-bitswap/src/network.js
var require_network2 = __commonJS((exports2, module2) => {
  "use strict";
  var lp = require_src37();
  var pipe = require_it_pipe();
  var MulticodecTopology = require_multicodec_topology();
  var Message = require_message5();
  var CONSTANTS = require_constants20();
  var logger = require_utils33().logger;
  var BITSWAP100 = "/ipfs/bitswap/1.0.0";
  var BITSWAP110 = "/ipfs/bitswap/1.1.0";
  var BITSWAP120 = "/ipfs/bitswap/1.2.0";
  var Network = class {
    constructor(libp2p, bitswap, options, stats) {
      this._log = logger(libp2p.peerId, "network");
      options = options || {};
      this.libp2p = libp2p;
      this.bitswap = bitswap;
      this.protocols = [BITSWAP100];
      if (!options.b100Only) {
        this.protocols.unshift(BITSWAP110);
        this.protocols.unshift(BITSWAP120);
      }
      this._stats = stats;
      this._running = false;
      this._onPeerConnect = this._onPeerConnect.bind(this);
      this._onPeerDisconnect = this._onPeerDisconnect.bind(this);
      this._onConnection = this._onConnection.bind(this);
    }
    start() {
      this._running = true;
      this.libp2p.handle(this.protocols, this._onConnection);
      const topology = new MulticodecTopology({
        multicodecs: this.protocols,
        handlers: {
          onConnect: this._onPeerConnect,
          onDisconnect: this._onPeerDisconnect
        }
      });
      this._registrarId = this.libp2p.registrar.register(topology);
      for (const peer of this.libp2p.peerStore.peers.values()) {
        const conn = this.libp2p.connectionManager.get(peer.id);
        conn && this._onPeerConnect(conn.remotePeer);
      }
    }
    stop() {
      this._running = false;
      this.libp2p.unhandle(this.protocols);
      this.libp2p.registrar.unregister(this._registrarId);
    }
    async _onConnection({protocol, stream, connection}) {
      if (!this._running) {
        return;
      }
      this._log("incoming new bitswap %s connection from %s", protocol, connection.remotePeer.toB58String());
      try {
        await pipe(stream, lp.decode(), async (source) => {
          for await (const data of source) {
            try {
              const message = await Message.deserialize(data.slice());
              await this.bitswap._receiveMessage(connection.remotePeer, message);
            } catch (err) {
              this.bitswap._receiveError(err);
              break;
            }
          }
        });
      } catch (err) {
        this._log(err);
      }
    }
    _onPeerConnect(peerId) {
      this.bitswap._onPeerConnected(peerId);
    }
    _onPeerDisconnect(peerId) {
      this.bitswap._onPeerDisconnected(peerId);
    }
    findProviders(cid, maxProviders, options = {}) {
      return this.libp2p.contentRouting.findProviders(cid, {
        maxTimeout: CONSTANTS.providerRequestTimeout,
        maxNumProviders: maxProviders,
        signal: options.signal
      });
    }
    async findAndConnect(cid, options) {
      const connectAttempts = [];
      for await (const provider of this.findProviders(cid, CONSTANTS.maxProvidersPerRequest, options)) {
        this._log(`connecting to provider ${provider.id}`);
        connectAttempts.push(this.connectTo(provider.id, options));
      }
      await Promise.all(connectAttempts);
    }
    async provide(cid, options) {
      await this.libp2p.contentRouting.provide(cid, options);
    }
    async sendMessage(peer, msg) {
      if (!this._running)
        throw new Error("network isn't running");
      const stringId = peer.toB58String();
      this._log("sendMessage to %s", stringId, msg);
      const {stream, protocol} = await this._dialPeer(peer);
      let serialized;
      switch (protocol) {
        case BITSWAP100:
          serialized = msg.serializeToBitswap100();
          break;
        case BITSWAP110:
        case BITSWAP120:
          serialized = msg.serializeToBitswap110();
          break;
        default:
          throw new Error("Unknown protocol: " + protocol);
      }
      writeMessage(stream, serialized, this._log);
      this._updateSentStats(peer, msg.blocks);
    }
    async connectTo(peer, options) {
      if (!this._running) {
        throw new Error("network isn't running");
      }
      return this.libp2p.dial(peer, options);
    }
    _dialPeer(peer) {
      return this.libp2p.dialProtocol(peer, [BITSWAP120, BITSWAP110, BITSWAP100]);
    }
    _updateSentStats(peer, blocks) {
      const peerId = peer.toB58String();
      if (this._stats) {
        blocks.forEach((block) => this._stats.push(peerId, "dataSent", block.data.length));
        this._stats.push(peerId, "blocksSent", blocks.size);
      }
    }
  };
  async function writeMessage(stream, msg, log) {
    try {
      await pipe([msg], lp.encode(), stream);
    } catch (err) {
      log(err);
    }
  }
  module2.exports = Network;
});

// node_modules/ipfs-bitswap/src/decision-engine/ledger.js
var require_ledger = __commonJS((exports2, module2) => {
  "use strict";
  var Wantlist = require_wantlist2();
  var Ledger = class {
    constructor(peerId) {
      this.partner = peerId;
      this.wantlist = new Wantlist();
      this.exchangeCount = 0;
      this.sentToPeer = new Map();
      this.accounting = {
        bytesSent: 0,
        bytesRecv: 0
      };
    }
    sentBytes(n) {
      this.exchangeCount++;
      this.lastExchange = new Date().getTime();
      this.accounting.bytesSent += n;
    }
    receivedBytes(n) {
      this.exchangeCount++;
      this.lastExchange = new Date().getTime();
      this.accounting.bytesRecv += n;
    }
    wants(cid, priority, wantType) {
      this.wantlist.add(cid, priority, wantType);
    }
    cancelWant(cid) {
      this.wantlist.remove(cid);
    }
    wantlistContains(cid) {
      return this.wantlist.contains(cid);
    }
    debtRatio() {
      return this.accounting.bytesSent / (this.accounting.bytesRecv + 1);
    }
  };
  module2.exports = Ledger;
});

// node_modules/ipfs-bitswap/src/utils/sorted-map.js
var require_sorted_map = __commonJS((exports2, module2) => {
  "use strict";
  var SortedMap = class extends Map {
    constructor(entries, cmp) {
      super();
      this._cmp = cmp || this._defaultSort;
      this._keys = [];
      for (const [k, v] of entries || []) {
        this.set(k, v);
      }
    }
    update(i) {
      if (i < 0 || i >= this._keys.length) {
        return;
      }
      const k = this._keys[i];
      this._keys.splice(i, 1);
      const newIdx = this._find(k);
      this._keys.splice(newIdx, 0, k);
    }
    set(k, v) {
      if (this.has(k)) {
        const i2 = this.indexOf(k);
        this._keys.splice(i2, 1);
      }
      super.set(k, v);
      const i = this._find(k);
      this._keys.splice(i, 0, k);
    }
    clear() {
      super.clear();
      this._keys = [];
    }
    delete(k) {
      if (!this.has(k)) {
        return;
      }
      const i = this.indexOf(k);
      this._keys.splice(i, 1);
      super.delete(k);
    }
    indexOf(k) {
      if (!this.has(k)) {
        return -1;
      }
      const i = this._find(k);
      if (this._keys[i] === k) {
        return i;
      }
      for (let j = 1; j < this._keys.length; j++) {
        if (this._keys[i + j] === k)
          return i + j;
        if (this._keys[i - j] === k)
          return i - j;
      }
      return -1;
    }
    _find(k) {
      let lower = 0;
      let upper = this._keys.length;
      while (lower < upper) {
        const pivot = lower + upper >>> 1;
        const cmp = this._kCmp(this._keys[pivot], k);
        if (cmp < 0) {
          lower = pivot + 1;
        } else if (cmp > 0) {
          upper = pivot;
        } else {
          return pivot;
        }
      }
      return lower;
    }
    *keys() {
      for (const k of this._keys) {
        yield k;
      }
    }
    *values() {
      for (const k of this._keys) {
        yield this.get(k);
      }
    }
    *entries() {
      for (const k of this._keys) {
        yield [k, this.get(k)];
      }
    }
    *[Symbol.iterator]() {
      yield* this.entries();
    }
    forEach(cb, thisArg) {
      if (!cb) {
        return;
      }
      for (const k of this._keys) {
        cb.apply(thisArg, [[k, this.get(k)]]);
      }
    }
    _defaultSort(a, b) {
      if (a[0] < b[0])
        return -1;
      if (b[0] < a[0])
        return 1;
      return 0;
    }
    _kCmp(a, b) {
      return this._cmp([a, this.get(a)], [b, this.get(b)]);
    }
  };
  module2.exports = SortedMap;
});

// node_modules/ipfs-bitswap/src/decision-engine/req-queue.js
var require_req_queue = __commonJS((exports2, module2) => {
  "use strict";
  var SortedMap = require_sorted_map();
  var DefaultTaskMerger = {
    hasNewInfo() {
      return false;
    },
    merge() {
    }
  };
  var RequestQueue = class {
    constructor(taskMerger) {
      this._taskMerger = taskMerger || DefaultTaskMerger;
      this._byPeer = new SortedMap([], PeerTasks.compare, true);
    }
    pushTasks(peerId, tasks) {
      let peerTasks = this._byPeer.get(peerId.toB58String());
      if (!peerTasks) {
        peerTasks = new PeerTasks(peerId, this._taskMerger);
      }
      peerTasks.pushTasks(tasks);
      this._byPeer.set(peerId.toB58String(), peerTasks);
    }
    popTasks(targetMinBytes) {
      if (this._byPeer.size === 0) {
        return {tasks: [], pendingSize: 0};
      }
      const peerTasks = this._head();
      const {tasks, pendingSize} = peerTasks.popTasks(targetMinBytes);
      if (tasks.length === 0) {
        return {tasks, pendingSize};
      }
      const peerId = peerTasks.peerId;
      if (peerTasks.isIdle()) {
        this._byPeer.delete(peerId.toB58String());
      } else {
        this._byPeer.update(0);
      }
      return {
        peerId,
        tasks,
        pendingSize
      };
    }
    _head() {
      for (const [, v] of this._byPeer) {
        return v;
      }
      return void 0;
    }
    remove(topic, peerId) {
      const peerTasks = this._byPeer.get(peerId.toB58String());
      peerTasks && peerTasks.remove(topic);
    }
    tasksDone(peerId, tasks) {
      const peerTasks = this._byPeer.get(peerId.toB58String());
      if (!peerTasks) {
        return;
      }
      const i = this._byPeer.indexOf(peerId.toB58String());
      for (const task of tasks) {
        peerTasks.taskDone(task);
      }
      this._byPeer.update(i);
    }
  };
  var PeerTasks = class {
    constructor(peerId, taskMerger) {
      this.peerId = peerId;
      this._taskMerger = taskMerger;
      this._activeTotalSize = 0;
      this._pending = new PendingTasks();
      this._active = new Set();
    }
    pushTasks(tasks) {
      for (const t of tasks) {
        this._pushTask(t);
      }
    }
    _pushTask(task) {
      if (!this._taskHasMoreInfoThanActiveTasks(task)) {
        return;
      }
      const existingTask = this._pending.get(task.topic);
      if (existingTask) {
        if (task.priority > existingTask.priority) {
          this._pending.updatePriority(task.topic, task.priority);
        }
        this._taskMerger.merge(task, existingTask);
        return;
      }
      this._pending.add(task);
    }
    _taskHasMoreInfoThanActiveTasks(task) {
      const tasksWithTopic = [];
      for (const activeTask of this._active) {
        if (activeTask.topic === task.topic) {
          tasksWithTopic.push(activeTask);
        }
      }
      if (tasksWithTopic.length === 0) {
        return true;
      }
      return this._taskMerger.hasNewInfo(task, tasksWithTopic);
    }
    popTasks(targetMinBytes) {
      let size = 0;
      const tasks = [];
      const pendingTasks = this._pending.tasks();
      for (let i = 0; i < pendingTasks.length && size < targetMinBytes; i++) {
        const task = pendingTasks[i];
        tasks.push(task);
        size += task.size;
        this._pending.delete(task.topic);
        this._activeTotalSize += task.size;
        this._active.add(task);
      }
      return {
        tasks,
        pendingSize: this._pending.totalSize
      };
    }
    taskDone(task) {
      if (this._active.has(task)) {
        this._activeTotalSize -= task.size;
        this._active.delete(task);
      }
    }
    remove(topic) {
      this._pending.delete(topic);
    }
    isIdle() {
      return this._pending.length === 0 && this._active.length === 0;
    }
    static compare(a, b) {
      if (a[1]._pending.length === 0) {
        return 1;
      }
      if (b[1]._pending.length === 0) {
        return -1;
      }
      if (a[1]._activeTotalSize === b[1]._activeTotalSize) {
        return b[1]._pending.length - a[1]._pending.length;
      }
      return a[1]._activeTotalSize - b[1]._activeTotalSize;
    }
  };
  var PendingTasks = class {
    constructor() {
      this._tasks = new SortedMap([], this._compare);
    }
    get length() {
      return this._tasks.size;
    }
    get totalSize() {
      return [...this._tasks.values()].reduce((a, t) => a + t.task.size, 0);
    }
    get(topic) {
      return (this._tasks.get(topic) || {}).task;
    }
    add(task) {
      this._tasks.set(task.topic, {
        created: Date.now(),
        task
      });
    }
    delete(topic) {
      this._tasks.delete(topic);
    }
    tasks() {
      return [...this._tasks.values()].map((i) => i.task);
    }
    updatePriority(topic, priority) {
      const obj = this._tasks.get(topic);
      if (!obj) {
        return;
      }
      const i = this._tasks.indexOf(topic);
      obj.task.priority = priority;
      this._tasks.update(i);
    }
    _compare(a, b) {
      if (a[1].task.priority === b[1].task.priority) {
        return a[1].created - b[1].created;
      }
      return b[1].task.priority - a[1].task.priority;
    }
  };
  module2.exports = RequestQueue;
});

// node_modules/ipfs-bitswap/src/decision-engine/task-merger.js
var require_task_merger = __commonJS((exports2, module2) => {
  "use strict";
  var TaskMerger = {
    hasNewInfo(task, tasksWithTopic) {
      let haveBlock = false;
      let isWantBlock = false;
      for (const existing of tasksWithTopic) {
        if (existing.data.haveBlock) {
          haveBlock = true;
        }
        if (existing.data.isWantBlock) {
          isWantBlock = true;
        }
      }
      if (!isWantBlock && task.data.isWantBlock) {
        return true;
      }
      if (!haveBlock && task.data.haveBlock) {
        return true;
      }
      return false;
    },
    merge(newTask, existingTask) {
      const taskData = newTask.data;
      const existingData = existingTask.data;
      if (!existingData.haveBlock && taskData.haveBlock) {
        existingData.haveBlock = taskData.haveBlock;
        existingData.blockSize = taskData.blockSize;
      }
      if (!existingData.isWantBlock && taskData.isWantBlock) {
        existingData.isWantBlock = true;
        if (!existingData.haveBlock || taskData.haveBlock) {
          existingData.haveBlock = taskData.haveBlock;
          existingTask.size = newTask.size;
        }
      }
      if (existingData.isWantBlock && existingData.haveBlock) {
        existingTask.size = existingData.blockSize;
      }
    }
  };
  module2.exports = TaskMerger;
});

// node_modules/ipfs-bitswap/src/decision-engine/index.js
var require_decision_engine = __commonJS((exports2, module2) => {
  "use strict";
  var CID = require_src7();
  var Message = require_message5();
  var WantType = Message.WantType;
  var Wantlist = require_wantlist2();
  var Ledger = require_ledger();
  var RequestQueue = require_req_queue();
  var TaskMerger = require_task_merger();
  var {logger} = require_utils33();
  var TARGET_MESSAGE_SIZE = 16 * 1024;
  var MAX_SIZE_REPLACE_HAS_WITH_BLOCK = 1024;
  var DecisionEngine = class {
    constructor(peerId, blockstore, network, stats, opts) {
      this._log = logger(peerId, "engine");
      this.blockstore = blockstore;
      this.network = network;
      this._stats = stats;
      this._opts = this._processOpts(opts);
      this.ledgerMap = new Map();
      this._running = false;
      this._requestQueue = new RequestQueue(TaskMerger);
    }
    _processOpts(opts) {
      return {
        maxSizeReplaceHasWithBlock: MAX_SIZE_REPLACE_HAS_WITH_BLOCK,
        targetMessageSize: TARGET_MESSAGE_SIZE,
        ...opts
      };
    }
    _scheduleProcessTasks() {
      setTimeout(() => {
        this._processTasks();
      });
    }
    async _processTasks() {
      if (!this._running) {
        return;
      }
      const {peerId, tasks, pendingSize} = this._requestQueue.popTasks(this._opts.targetMessageSize);
      if (tasks.length === 0) {
        return;
      }
      const msg = new Message(false);
      msg.setPendingBytes(pendingSize);
      const blockCids = [];
      const blockTasks = new Map();
      for (const task of tasks) {
        const cid = new CID(task.topic);
        if (task.data.haveBlock) {
          if (task.data.isWantBlock) {
            blockCids.push(cid);
            blockTasks.set(task.topic, task.data);
          } else {
            msg.addHave(cid);
          }
        } else {
          msg.addDontHave(cid);
        }
      }
      const blocks = await this._getBlocks(blockCids);
      for (const [topic, taskData] of blockTasks) {
        const blk = blocks.get(topic);
        if (blk) {
          msg.addBlock(blk);
        } else {
          if (taskData.sendDontHave) {
            const cid = new CID(topic);
            msg.addDontHave(cid);
          }
        }
      }
      if (msg.empty) {
        this._requestQueue.tasksDone(peerId, tasks);
        this._scheduleProcessTasks();
        return;
      }
      try {
        await this.network.sendMessage(peerId, msg);
        for (const block of blocks.values()) {
          this.messageSent(peerId, block);
        }
      } catch (err) {
        this._log.error(err);
      }
      this._requestQueue.tasksDone(peerId, tasks);
      this._scheduleProcessTasks();
    }
    wantlistForPeer(peerId) {
      const peerIdStr = peerId.toB58String();
      if (!this.ledgerMap.has(peerIdStr)) {
        return new Map();
      }
      return this.ledgerMap.get(peerIdStr).wantlist.sortedEntries();
    }
    ledgerForPeer(peerId) {
      const peerIdStr = peerId.toB58String();
      const ledger = this.ledgerMap.get(peerIdStr);
      if (!ledger) {
        return null;
      }
      return {
        peer: ledger.partner.toPrint(),
        value: ledger.debtRatio(),
        sent: ledger.accounting.bytesSent,
        recv: ledger.accounting.bytesRecv,
        exchanged: ledger.exchangeCount
      };
    }
    peers() {
      return Array.from(this.ledgerMap.values()).map((l) => l.partner);
    }
    receivedBlocks(blocks) {
      if (!blocks.length) {
        return;
      }
      this.ledgerMap.forEach((ledger) => {
        blocks.forEach((block) => {
          const want = ledger.wantlistContains(block.cid);
          if (!want) {
            return;
          }
          const blockSize = block.data.length;
          const isWantBlock = this._sendAsBlock(want.wantType, blockSize);
          let entrySize = blockSize;
          if (!isWantBlock) {
            entrySize = Message.blockPresenceSize(want.cid);
          }
          this._requestQueue.pushTasks(ledger.partner, [{
            topic: want.cid.toString(),
            priority: want.priority,
            size: entrySize,
            data: {
              blockSize,
              isWantBlock,
              haveBlock: true,
              sendDontHave: false
            }
          }]);
        });
      });
      this._scheduleProcessTasks();
    }
    async messageReceived(peerId, msg) {
      const ledger = this._findOrCreate(peerId);
      if (msg.empty) {
        return;
      }
      if (msg.full) {
        ledger.wantlist = new Wantlist();
      }
      this._updateBlockAccounting(msg.blocks, ledger);
      if (msg.wantlist.size === 0) {
        this._scheduleProcessTasks();
        return;
      }
      const cancels = [];
      const wants = [];
      msg.wantlist.forEach((entry) => {
        if (entry.cancel) {
          ledger.cancelWant(entry.cid);
          cancels.push(entry.cid);
        } else {
          ledger.wants(entry.cid, entry.priority, entry.wantType);
          wants.push(entry);
        }
      });
      this._cancelWants(peerId, cancels);
      await this._addWants(peerId, wants);
      this._scheduleProcessTasks();
    }
    _cancelWants(peerId, cids) {
      for (const c of cids) {
        this._requestQueue.remove(c.toString(), peerId);
      }
    }
    async _addWants(peerId, wants) {
      const blockSizes = await this._getBlockSizes(wants.map((w) => w.cid));
      const tasks = [];
      for (const want of wants) {
        const id = want.cid.toString();
        const blockSize = blockSizes.get(id);
        if (blockSize == null) {
          if (want.sendDontHave) {
            tasks.push({
              topic: id,
              priority: want.priority,
              size: Message.blockPresenceSize(want.cid),
              data: {
                isWantBlock: want.wantType === WantType.Block,
                blockSize: 0,
                haveBlock: false,
                sendDontHave: want.sendDontHave
              }
            });
          }
        } else {
          const isWantBlock = this._sendAsBlock(want.wantType, blockSize);
          let entrySize = blockSize;
          if (!isWantBlock) {
            entrySize = Message.blockPresenceSize(want.cid);
          }
          tasks.push({
            topic: id,
            priority: want.priority,
            size: entrySize,
            data: {
              isWantBlock,
              blockSize,
              haveBlock: true,
              sendDontHave: want.sendDontHave
            }
          });
        }
        this._requestQueue.pushTasks(peerId, tasks);
      }
    }
    _sendAsBlock(wantType, blockSize) {
      return wantType === WantType.Block || blockSize <= this._opts.maxSizeReplaceHasWithBlock;
    }
    async _getBlockSizes(cids) {
      const blocks = await this._getBlocks(cids);
      return new Map([...blocks].map(([k, v]) => [k, v.data.length]));
    }
    async _getBlocks(cids) {
      const res = new Map();
      await Promise.all(cids.map(async (cid) => {
        try {
          const block = await this.blockstore.get(cid);
          res.set(cid.toString(), block);
        } catch (e) {
          if (e.code !== "ERR_NOT_FOUND") {
            this._log.error("failed to query blockstore for %s: %s", cid, e);
          }
        }
      }));
      return res;
    }
    _updateBlockAccounting(blocksMap, ledger) {
      blocksMap.forEach((b) => {
        this._log("got block (%s bytes)", b.data.length);
        ledger.receivedBytes(b.data.length);
      });
    }
    messageSent(peerId, block) {
      const ledger = this._findOrCreate(peerId);
      ledger.sentBytes(block ? block.data.length : 0);
      if (block && block.cid) {
        ledger.wantlist.remove(block.cid);
      }
    }
    numBytesSentTo(peerId) {
      return this._findOrCreate(peerId).accounting.bytesSent;
    }
    numBytesReceivedFrom(peerId) {
      return this._findOrCreate(peerId).accounting.bytesRecv;
    }
    peerDisconnected(peerId) {
    }
    _findOrCreate(peerId) {
      const peerIdStr = peerId.toB58String();
      if (this.ledgerMap.has(peerIdStr)) {
        return this.ledgerMap.get(peerIdStr);
      }
      const l = new Ledger(peerId);
      this.ledgerMap.set(peerIdStr, l);
      if (this._stats) {
        this._stats.push(peerIdStr, "peerCount", 1);
      }
      return l;
    }
    start() {
      this._running = true;
    }
    stop() {
      this._running = false;
    }
  };
  module2.exports = DecisionEngine;
});

// node_modules/ipfs-bitswap/node_modules/uint8arrays/to-string.js
var require_to_string12 = __commonJS((exports2, module2) => {
  "use strict";
  var {encoding: getCodec} = require_src4();
  var {TextDecoder: TextDecoder2} = require_lib_browser();
  var utf8Decoder = new TextDecoder2("utf8");
  function uint8ArrayToAsciiString(array) {
    let string = "";
    for (let i = 0; i < array.length; i++) {
      string += String.fromCharCode(array[i]);
    }
    return string;
  }
  function toString(array, encoding = "utf8") {
    if (encoding === "utf8" || encoding === "utf-8") {
      return utf8Decoder.decode(array);
    }
    if (encoding === "ascii") {
      return uint8ArrayToAsciiString(array);
    }
    return getCodec(encoding).encode(array);
  }
  module2.exports = toString;
});

// node_modules/ipfs-bitswap/src/notifications.js
var require_notifications = __commonJS((exports2, module2) => {
  "use strict";
  var EventEmitter = require_events().EventEmitter;
  var Block = require_src26();
  var uint8ArrayEquals = require_equals7();
  var uint8ArrayToString = require_to_string12();
  var CONSTANTS = require_constants20();
  var logger = require_utils33().logger;
  var unwantEvent = (cid) => `unwant:${uint8ArrayToString(cid.multihash, "base64")}`;
  var blockEvent = (cid) => `block:${uint8ArrayToString(cid.multihash, "base64")}`;
  var Notifications = class extends EventEmitter {
    constructor(peerId) {
      super();
      this.setMaxListeners(CONSTANTS.maxListeners);
      this._log = logger(peerId, "notif");
    }
    hasBlock(block) {
      const event = blockEvent(block.cid);
      this._log(event);
      this.emit(event, block);
    }
    wantBlock(cid, options = {}) {
      if (!cid) {
        throw new Error("Not a valid cid");
      }
      const blockEvt = blockEvent(cid);
      const unwantEvt = unwantEvent(cid);
      this._log(`wantBlock:${cid}`);
      return new Promise((resolve, reject) => {
        const onUnwant = () => {
          this.removeListener(blockEvt, onBlock);
          reject(new Error(`Block for ${cid} unwanted`));
        };
        const onBlock = (block) => {
          this.removeListener(unwantEvt, onUnwant);
          if (!uint8ArrayEquals(cid.multihash, block.cid.multihash)) {
            return reject(new Error(`Incorrect block received for ${cid}`));
          } else if (cid.version !== block.cid.version || cid.codec !== block.cid.codec) {
            block = new Block(block.data, cid);
          }
          resolve(block);
        };
        this.once(unwantEvt, onUnwant);
        this.once(blockEvt, onBlock);
        if (options && options.signal) {
          options.signal.addEventListener("abort", () => {
            this.removeListener(blockEvt, onBlock);
            this.removeListener(unwantEvt, onUnwant);
            reject(new Error(`Want for ${cid} aborted`));
          });
        }
      });
    }
    unwantBlock(cid) {
      const event = unwantEvent(cid);
      this._log(event);
      this.emit(event);
    }
  };
  module2.exports = Notifications;
});

// node_modules/ipfs-bitswap/src/stats/stat.js
var require_stat6 = __commonJS((exports2, module2) => {
  "use strict";
  var EventEmitter = require_events();
  var Big = require_bignumber();
  var MovingAverage = require_moving_average();
  var Stats = class extends EventEmitter {
    constructor(initialCounters, options) {
      super();
      this._options = options;
      this._queue = [];
      this._stats = {};
      this._frequencyLastTime = Date.now();
      this._frequencyAccumulators = {};
      this._movingAverages = {};
      this._update = this._update.bind(this);
      initialCounters.forEach((key) => {
        this._stats[key] = Big(0);
        this._movingAverages[key] = {};
        this._options.movingAverageIntervals.forEach((interval) => {
          const ma = this._movingAverages[key][interval] = MovingAverage(interval);
          ma.push(this._frequencyLastTime, 0);
        });
      });
      this._enabled = this._options.enabled;
    }
    enable() {
      this._enabled = true;
    }
    disable() {
      this._disabled = true;
    }
    stop() {
      if (this._timeout) {
        clearTimeout(this._timeout);
      }
    }
    get snapshot() {
      return Object.assign({}, this._stats);
    }
    get movingAverages() {
      return Object.assign({}, this._movingAverages);
    }
    push(counter, inc) {
      if (this._enabled) {
        this._queue.push([counter, inc, Date.now()]);
        this._resetComputeTimeout();
      }
    }
    _resetComputeTimeout() {
      if (this._timeout) {
        clearTimeout(this._timeout);
      }
      this._timeout = setTimeout(this._update, this._nextTimeout());
    }
    _nextTimeout() {
      const urgency = this._queue.length / this._options.computeThrottleMaxQueueSize;
      return Math.max(this._options.computeThrottleTimeout * (1 - urgency), 0);
    }
    _update() {
      this._timeout = null;
      if (this._queue.length) {
        let last;
        while (this._queue.length) {
          const op = last = this._queue.shift();
          this._applyOp(op);
        }
        this._updateFrequency(last[2]);
        this.emit("update", this._stats);
      }
    }
    _updateFrequency(latestTime) {
      const timeDiff = latestTime - this._frequencyLastTime;
      if (timeDiff) {
        Object.keys(this._stats).forEach((key) => {
          this._updateFrequencyFor(key, timeDiff, latestTime);
        });
      }
      this._frequencyLastTime = latestTime;
    }
    _updateFrequencyFor(key, timeDiffMS, latestTime) {
      const count = this._frequencyAccumulators[key] || 0;
      this._frequencyAccumulators[key] = 0;
      const hz = count / timeDiffMS * 1e3;
      let movingAverages = this._movingAverages[key];
      if (!movingAverages) {
        movingAverages = this._movingAverages[key] = {};
      }
      this._options.movingAverageIntervals.forEach((movingAverageInterval) => {
        let movingAverage = movingAverages[movingAverageInterval];
        if (!movingAverage) {
          movingAverage = movingAverages[movingAverageInterval] = MovingAverage(movingAverageInterval);
        }
        movingAverage.push(latestTime, hz);
      });
    }
    _applyOp(op) {
      const key = op[0];
      const inc = op[1];
      if (typeof inc !== "number") {
        throw new Error("invalid increment number:", inc);
      }
      let n;
      if (!Object.prototype.hasOwnProperty.call(this._stats, key)) {
        n = this._stats[key] = Big(0);
      } else {
        n = this._stats[key];
      }
      this._stats[key] = n.plus(inc);
      if (!this._frequencyAccumulators[key]) {
        this._frequencyAccumulators[key] = 0;
      }
      this._frequencyAccumulators[key] += inc;
    }
  };
  module2.exports = Stats;
});

// node_modules/ipfs-bitswap/src/stats/index.js
var require_stats3 = __commonJS((exports2, module2) => {
  "use strict";
  var EventEmitter = require_events();
  var Stat = require_stat6();
  var defaultOptions = {
    movingAverageIntervals: [
      60 * 1e3,
      5 * 60 * 1e3,
      15 * 60 * 1e3
    ]
  };
  var Stats = class extends EventEmitter {
    constructor(initialCounters, _options) {
      super();
      const options = Object.assign({}, defaultOptions, _options);
      if (typeof options.computeThrottleTimeout !== "number") {
        throw new Error("need computeThrottleTimeout");
      }
      if (typeof options.computeThrottleMaxQueueSize !== "number") {
        throw new Error("need computeThrottleMaxQueueSize");
      }
      this._initialCounters = initialCounters;
      this._options = options;
      this._enabled = this._options.enabled;
      this._global = new Stat(initialCounters, options);
      this._global.on("update", (stats) => this.emit("update", stats));
      this._peers = new Map();
    }
    enable() {
      this._enabled = true;
      this._options.enabled = true;
      this._global.enable();
    }
    disable() {
      this._enabled = false;
      this._options.enabled = false;
      this._global.disable();
    }
    stop() {
      this._enabled = false;
      this._global.stop();
      for (const peerStat of this._peers) {
        peerStat[1].stop();
      }
    }
    get snapshot() {
      return this._global.snapshot;
    }
    get movingAverages() {
      return this._global.movingAverages;
    }
    forPeer(peerId) {
      if (peerId.toB58String) {
        peerId = peerId.toB58String();
      }
      return this._peers.get(peerId);
    }
    push(peer, counter, inc) {
      if (this._enabled) {
        this._global.push(counter, inc);
        if (peer) {
          let peerStats = this._peers.get(peer);
          if (!peerStats) {
            peerStats = new Stat(this._initialCounters, this._options);
            this._peers.set(peer, peerStats);
          }
          peerStats.push(counter, inc);
        }
      }
    }
    disconnected(peer) {
      const peerId = peer.toB58String();
      const peerStats = this._peers.get(peerId);
      if (peerStats) {
        peerStats.stop();
        this._peers.delete(peerId);
      }
    }
  };
  module2.exports = Stats;
});

// node_modules/ipfs-bitswap/src/index.js
var require_src53 = __commonJS((exports2, module2) => {
  "use strict";
  var WantManager = require_want_manager();
  var Network = require_network2();
  var DecisionEngine = require_decision_engine();
  var Notifications = require_notifications();
  var logger = require_utils33().logger;
  var Stats = require_stats3();
  var AbortController = require_browser3();
  var anySignal = require_any_signal();
  var defaultOptions = {
    statsEnabled: false,
    statsComputeThrottleTimeout: 1e3,
    statsComputeThrottleMaxQueueSize: 1e3
  };
  var statsKeys = [
    "blocksReceived",
    "dataReceived",
    "dupBlksReceived",
    "dupDataReceived",
    "blocksSent",
    "dataSent",
    "providesBufferLength",
    "wantListLength",
    "peerCount"
  ];
  var Bitswap = class {
    constructor(libp2p, blockstore, options) {
      this._libp2p = libp2p;
      this._log = logger(this.peerId);
      this._options = Object.assign({}, defaultOptions, options);
      this._stats = new Stats(statsKeys, {
        enabled: this._options.statsEnabled,
        computeThrottleTimeout: this._options.statsComputeThrottleTimeout,
        computeThrottleMaxQueueSize: this._options.statsComputeThrottleMaxQueueSize
      });
      this.network = new Network(libp2p, this, {}, this._stats);
      this.blockstore = blockstore;
      this.engine = new DecisionEngine(this.peerId, blockstore, this.network, this._stats);
      this.wm = new WantManager(this.peerId, this.network, this._stats);
      this.notifications = new Notifications(this.peerId);
    }
    get peerId() {
      return this._libp2p.peerId;
    }
    async _receiveMessage(peerId, incoming) {
      try {
        await this.engine.messageReceived(peerId, incoming);
      } catch (err) {
        this._log("failed to receive message", incoming);
      }
      if (incoming.blocks.size === 0) {
        return;
      }
      const blocks = Array.from(incoming.blocks.values());
      const wanted = blocks.filter((b) => this.wm.wantlist.contains(b.cid)).map((b) => b.cid);
      this.wm.cancelWants(wanted);
      await Promise.all(blocks.map(async (b) => {
        const wasWanted = wanted.includes(b.cid);
        await this._handleReceivedBlock(peerId, b, wasWanted);
      }));
    }
    async _handleReceivedBlock(peerId, block, wasWanted) {
      this._log("received block");
      const has = await this.blockstore.has(block.cid);
      this._updateReceiveCounters(peerId.toB58String(), block, has);
      if (!wasWanted) {
        return;
      }
      await this.put(block);
    }
    _updateReceiveCounters(peerId, block, exists) {
      this._stats.push(peerId, "blocksReceived", 1);
      this._stats.push(peerId, "dataReceived", block.data.length);
      if (exists) {
        this._stats.push(peerId, "dupBlksReceived", 1);
        this._stats.push(peerId, "dupDataReceived", block.data.length);
      }
    }
    _receiveError(err) {
      this._log.error("ReceiveError: %s", err.message);
    }
    _onPeerConnected(peerId) {
      this.wm.connected(peerId);
    }
    _onPeerDisconnected(peerId) {
      this.wm.disconnected(peerId);
      this.engine.peerDisconnected(peerId);
      this._stats.disconnected(peerId);
    }
    enableStats() {
      this._stats.enable();
    }
    disableStats() {
      this._stats.disable();
    }
    wantlistForPeer(peerId) {
      return this.engine.wantlistForPeer(peerId);
    }
    ledgerForPeer(peerId) {
      return this.engine.ledgerForPeer(peerId);
    }
    async get(cid, options = {}) {
      const fetchFromNetwork = (cid2, options2) => {
        this.wm.wantBlocks([cid2], options2);
        return this.notifications.wantBlock(cid2, options2);
      };
      let promptedNetwork = false;
      const loadOrFetchFromNetwork = async (cid2, options2) => {
        try {
          const block2 = await this.blockstore.get(cid2, options2);
          return block2;
        } catch (err) {
          if (err.code !== "ERR_NOT_FOUND") {
            throw err;
          }
          if (!promptedNetwork) {
            promptedNetwork = true;
            this.network.findAndConnect(cid2).catch((err2) => this._log.error(err2));
          }
          return fetchFromNetwork(cid2, options2);
        }
      };
      const controller = new AbortController();
      const signal = anySignal([options.signal, controller.signal]);
      const block = await Promise.race([
        this.notifications.wantBlock(cid, {
          signal
        }),
        loadOrFetchFromNetwork(cid, {
          signal
        })
      ]);
      controller.abort();
      return block;
    }
    async *getMany(cids, options = {}) {
      for await (const cid of cids) {
        yield this.get(cid, options);
      }
    }
    unwant(cids) {
      if (!Array.isArray(cids)) {
        cids = [cids];
      }
      this.wm.unwantBlocks(cids);
      cids.forEach((cid) => this.notifications.unwantBlock(cid));
    }
    cancelWants(cids) {
      if (!Array.isArray(cids)) {
        cids = [cids];
      }
      this.wm.cancelWants(cids);
    }
    async put(block) {
      await this.blockstore.put(block);
      this._sendHaveBlockNotifications(block);
    }
    async *putMany(blocks) {
      for await (const block of this.blockstore.putMany(blocks)) {
        this._sendHaveBlockNotifications(block);
        yield block;
      }
    }
    _sendHaveBlockNotifications(block) {
      this.notifications.hasBlock(block);
      this.engine.receivedBlocks([block]);
      this.network.provide(block.cid).catch((err) => {
        this._log.error("Failed to provide: %s", err.message);
      });
    }
    getWantlist() {
      return this.wm.wantlist.entries();
    }
    peers() {
      return this.engine.peers();
    }
    stat() {
      return this._stats;
    }
    start() {
      this.wm.start();
      this.network.start();
      this.engine.start();
    }
    stop() {
      this._stats.stop();
      this.wm.stop();
      this.network.stop();
      this.engine.stop();
    }
  };
  module2.exports = Bitswap;
});

// node_modules/ipfs-core/src/components/network.js
var require_network3 = __commonJS((exports2, module2) => {
  "use strict";
  var IPFSBitswap = require_src53();
  var createLibP2P = require_libp2p();
  var Multiaddr = require_src11();
  var errCode = require_err_code();
  var Network = class {
    constructor(peerId, libp2p, bitswap) {
      this.peerId = peerId;
      this.libp2p = libp2p;
      this.bitswap = bitswap;
    }
    static async start({peerId, repo, print, options}) {
      if (repo.closed) {
        await repo.open();
      }
      const config = await repo.config.getAll();
      const libp2p = createLibP2P({
        options,
        repo,
        peerId,
        multiaddrs: readAddrs(peerId, config),
        config,
        keychainConfig: void 0
      });
      if (libp2p.keychain) {
        await libp2p.loadKeychain();
      }
      await libp2p.start();
      for (const ma of libp2p.multiaddrs) {
        print(`Swarm listening on ${ma}/p2p/${peerId.toB58String()}`);
      }
      const bitswap = new IPFSBitswap(libp2p, repo.blocks, {statsEnabled: true});
      await bitswap.start();
      return new Network(peerId, libp2p, bitswap);
    }
    static async stop(network) {
      await Promise.all([
        network.bitswap.stop(),
        network.libp2p.stop()
      ]);
    }
  };
  module2.exports = Network;
  var readAddrs = (peerId, config) => {
    const peerIdStr = peerId.toB58String();
    const addrs = [];
    const swarm = config.Addresses && config.Addresses.Swarm || [];
    for (const addr of swarm) {
      let ma = Multiaddr(addr);
      if (ma.protoCodes().includes(WEBSOCKET_STAR_PROTO_CODE)) {
        throw errCode(new Error("websocket-star swarm addresses are not supported. See https://github.com/ipfs/js-ipfs/issues/2779"), "ERR_WEBSOCKET_STAR_SWARM_ADDR_NOT_SUPPORTED");
      }
      const maId = ma.getPeerId();
      if (maId && maId !== peerIdStr) {
        ma = ma.encapsulate(`/p2p/${peerIdStr}`);
      }
      addrs.push(ma);
    }
    return addrs;
  };
  var WEBSOCKET_STAR_PROTO_CODE = 479;
});

// node_modules/ipfs-core/src/components/swarm/addrs.js
var require_addrs = __commonJS((exports2, module2) => {
  "use strict";
  var withTimeoutOption = require_with_timeout_option();
  module2.exports = ({network}) => {
    async function addrs(options) {
      const peers = [];
      const {libp2p} = await network.use(options);
      for (const [peerId, peer] of libp2p.peerStore.peers.entries()) {
        peers.push({
          id: peerId,
          addrs: peer.addresses.map((mi) => mi.multiaddr)
        });
      }
      return peers;
    }
    return withTimeoutOption(addrs);
  };
});

// node_modules/ipfs-core/src/components/swarm/connect.js
var require_connect = __commonJS((exports2, module2) => {
  "use strict";
  var withTimeoutOption = require_with_timeout_option();
  module2.exports = ({network}) => {
    async function connect(addr, options) {
      const {libp2p} = await network.use(options);
      await libp2p.dial(addr, options);
    }
    return withTimeoutOption(connect);
  };
});

// node_modules/ipfs-core/src/components/swarm/disconnect.js
var require_disconnect = __commonJS((exports2, module2) => {
  "use strict";
  var withTimeoutOption = require_with_timeout_option();
  module2.exports = ({network}) => {
    async function disconnect(addr, options) {
      const {libp2p} = await network.use(options);
      await libp2p.hangUp(addr);
    }
    return withTimeoutOption(disconnect);
  };
});

// node_modules/ipfs-core/src/components/swarm/local-addrs.js
var require_local_addrs = __commonJS((exports2, module2) => {
  "use strict";
  var withTimeoutOption = require_with_timeout_option();
  module2.exports = ({network}) => {
    async function localAddrs(options) {
      const {libp2p} = await network.use(options);
      return libp2p.multiaddrs;
    }
    return withTimeoutOption(localAddrs);
  };
});

// node_modules/ipfs-core/src/components/swarm/peers.js
var require_peers = __commonJS((exports2, module2) => {
  "use strict";
  var withTimeoutOption = require_with_timeout_option();
  module2.exports = ({network}) => {
    async function peers(options = {}) {
      const {libp2p} = await network.use(options);
      const verbose = options.v || options.verbose;
      const peers2 = [];
      for (const [peerId, connections] of libp2p.connections) {
        for (const connection of connections) {
          const tupple = {
            addr: connection.remoteAddr,
            peer: peerId
          };
          if (verbose || options.direction) {
            tupple.direction = connection.stat.direction;
          }
          if (verbose) {
            tupple.muxer = connection.stat.multiplexer;
            tupple.latency = "n/a";
          }
          peers2.push(tupple);
        }
      }
      return peers2;
    }
    return withTimeoutOption(peers);
  };
});

// node_modules/ipfs-core/src/components/swarm/index.js
var require_swarm = __commonJS((exports2, module2) => {
  "use strict";
  var createAddrsAPI = require_addrs();
  var createConnectAPI = require_connect();
  var createDisconnectAPI = require_disconnect();
  var createLocalAddrsAPI = require_local_addrs();
  var createPeersAPI = require_peers();
  var SwarmAPI = class {
    constructor({network}) {
      this.addrs = createAddrsAPI({network});
      this.connect = createConnectAPI({network});
      this.disconnect = createDisconnectAPI({network});
      this.localAddrs = createLocalAddrsAPI({network});
      this.peers = createPeersAPI({network});
    }
  };
  module2.exports = SwarmAPI;
});

// node_modules/ipfs-core/src/components/gc-lock.js
var require_gc_lock = __commonJS((exports2, module2) => {
  "use strict";
  var mortice = require_lib5();
  module2.exports = ({path, repoOwner}) => mortice(path, {
    singleProcess: repoOwner !== false
  });
});

// node_modules/ipfs-core/src/components/ping.js
var require_ping3 = __commonJS((exports2, module2) => {
  "use strict";
  var PeerId = require_src9();
  var basePacket = {success: true, time: 0, text: ""};
  var withTimeoutOption = require_with_timeout_option();
  module2.exports = ({network}) => {
    async function* ping(peerId, options = {}) {
      const {libp2p} = await network.use();
      options.count = options.count || 10;
      if (!PeerId.isPeerId(peerId)) {
        peerId = PeerId.createFromCID(peerId);
      }
      const storedPeer = libp2p.peerStore.get(peerId);
      let id = storedPeer && storedPeer.id;
      if (!id) {
        yield {...basePacket, text: `Looking up peer ${peerId}`};
        const remotePeer = await libp2p.peerRouting.findPeer(peerId);
        id = remotePeer && remotePeer.id;
      }
      if (!id) {
        throw new Error("Peer was not found");
      }
      yield {...basePacket, text: `PING ${id.toB58String()}`};
      let packetCount = 0;
      let totalTime = 0;
      for (let i = 0; i < options.count; i++) {
        try {
          const time = await libp2p.ping(id);
          totalTime += time;
          packetCount++;
          yield {...basePacket, time};
        } catch (err) {
          yield {...basePacket, success: false, text: err.toString()};
        }
      }
      if (packetCount) {
        const average = totalTime / packetCount;
        yield {...basePacket, text: `Average latency: ${average}ms`};
      }
    }
    return withTimeoutOption(ping);
  };
});

// node_modules/ipfs-core/src/components/dht.js
var require_dht = __commonJS((exports2, module2) => {
  "use strict";
  var PeerId = require_src9();
  var CID = require_src7();
  var errCode = require_err_code();
  var {NotEnabledError} = require_errors3();
  var get = require_dlv_umd();
  var withTimeoutOption = require_with_timeout_option();
  module2.exports = ({network, repo}) => {
    const {get: get2, put, findProvs, findPeer, provide, query} = {
      async get(key, options = {}) {
        const {libp2p} = await use(network, options);
        return libp2p._dht.get(normalizeCID(key), options);
      },
      async *put(key, value, options) {
        const {libp2p} = await use(network, options);
        yield* libp2p._dht.put(normalizeCID(key), value);
      },
      async *findProvs(cid, options = {}) {
        const {libp2p} = await use(network, options);
        if (options.numProviders) {
          options.maxNumProviders = options.numProviders;
        }
        for await (const peer of libp2p._dht.findProviders(normalizeCID(cid), options)) {
          yield {
            id: peer.id.toB58String(),
            addrs: peer.addrs
          };
        }
      },
      async findPeer(peerId, options) {
        const {libp2p} = await use(network, options);
        if (typeof peerId === "string") {
          peerId = PeerId.createFromCID(peerId);
        }
        const peer = await libp2p._dht.findPeer(peerId);
        return {
          id: peer.id.toB58String(),
          addrs: peer.multiaddrs
        };
      },
      async *provide(cids, options = {}) {
        const {libp2p} = await use(network, options);
        cids = Array.isArray(cids) ? cids : [cids];
        for (const i in cids) {
          if (typeof cids[i] === "string") {
            try {
              cids[i] = new CID(cids[i]);
            } catch (err) {
              throw errCode(err, "ERR_INVALID_CID");
            }
          }
        }
        const hasCids = await Promise.all(cids.map((cid) => repo.blocks.has(cid)));
        const hasAll = hasCids.every((has) => has);
        if (!hasAll) {
          throw errCode(new Error("block(s) not found locally, cannot provide"), "ERR_BLOCK_NOT_FOUND");
        }
        if (options.recursive) {
          throw errCode(new Error("not implemented yet"), "ERR_NOT_IMPLEMENTED_YET");
        }
        for (const cid of cids) {
          yield libp2p._dht.provide(cid);
        }
      },
      async *query(peerId, options) {
        const {libp2p} = await use(network, options);
        if (typeof peerId === "string") {
          peerId = PeerId.createFromCID(peerId);
        }
        for await (const closerPeerId of libp2p._dht.getClosestPeers(peerId.toBytes())) {
          yield {
            id: closerPeerId.toB58String(),
            addrs: []
          };
        }
      }
    };
    return {
      get: withTimeoutOption(get2),
      put: withTimeoutOption(put),
      findProvs: withTimeoutOption(findProvs),
      findPeer: withTimeoutOption(findPeer),
      provide: withTimeoutOption(provide),
      query: withTimeoutOption(query)
    };
  };
  var parseCID = (cid) => {
    try {
      const cidStr = cid.toString().split("/").filter((part) => part && part !== "ipfs" && part !== "ipns")[0];
      return new CID(cidStr).bytes;
    } catch (error) {
      throw errCode(error, "ERR_INVALID_CID");
    }
  };
  var normalizeCID = (cid) => cid instanceof Uint8Array ? cid : parseCID(cid);
  var use = async (network, options) => {
    const net = await network.use(options);
    if (get(net.libp2p, "_config.dht.enabled", false)) {
      return net;
    } else {
      throw new NotEnabledError("dht not enabled");
    }
  };
});

// node_modules/ipfs-core/src/components/pubsub.js
var require_pubsub3 = __commonJS((exports2, module2) => {
  "use strict";
  var withTimeoutOption = require_with_timeout_option();
  var errCode = require_err_code();
  var {NotEnabledError} = require_errors3();
  var get = require_dlv_umd();
  module2.exports = ({network, config}) => {
    const isEnabled = get(config, "Pubsub.Enabled", true);
    return {
      subscribe: isEnabled ? withTimeoutOption(subscribe) : notEnabled,
      unsubscribe: isEnabled ? withTimeoutOption(unsubscribe) : notEnabled,
      publish: isEnabled ? withTimeoutOption(publish) : notEnabled,
      ls: isEnabled ? withTimeoutOption(ls) : notEnabled,
      peers: isEnabled ? withTimeoutOption(peers) : notEnabled
    };
    async function subscribe(topic, handler, options) {
      const {libp2p} = await network.use(options);
      return libp2p.pubsub.subscribe(topic, handler, options);
    }
    async function unsubscribe(topic, handler, options) {
      const {libp2p} = await network.use(options);
      libp2p.pubsub.unsubscribe(topic, handler, options);
    }
    async function publish(topic, data, options) {
      const {libp2p} = await network.use(options);
      if (!data) {
        throw errCode(new Error('argument "data" is required'), "ERR_ARG_REQUIRED");
      }
      await libp2p.pubsub.publish(topic, data);
    }
    async function ls(options) {
      const {libp2p} = await network.use(options);
      return libp2p.pubsub.getTopics();
    }
    async function peers(topic, options) {
      const {libp2p} = await network.use(options);
      return libp2p.pubsub.getSubscribers(topic);
    }
  };
  var notEnabled = async () => {
    throw new NotEnabledError("pubsub not enabled");
  };
});

// node_modules/ipfs-core/src/components/index.js
var require_components = __commonJS((exports2, module2) => {
  "use strict";
  var {mergeOptions} = require_utils7();
  var {isTest} = require_env();
  var log = require_browser4()("ipfs");
  var {DAGNode} = require_src16();
  var UnixFs = require_src17();
  var multicodec = require_src6();
  var initAssets = require_init_assets_browser();
  var {AlreadyInitializedError} = require_errors3();
  var createStartAPI = require_start();
  var createStopAPI = require_stop();
  var createDNSAPI = require_dns();
  var createIsOnlineAPI = require_is_online();
  var createResolveAPI = require_resolve();
  var PinAPI = require_pin();
  var IPNSAPI = require_ipns2();
  var NameAPI = require_name();
  var createRefsAPI = require_refs();
  var createRefsLocalAPI = require_local();
  var BitswapAPI = require_bitswap();
  var BootstrapAPI = require_bootstrap();
  var BlockAPI = require_block();
  var RootAPI = require_root();
  var createVersionAPI = require_version();
  var createIDAPI = require_id();
  var createConfigAPI = require_config2();
  var DagAPI = require_dag();
  var PinManagerAPI = require_pin_manager();
  var createPreloadAPI = require_preload();
  var createMfsPreloadAPI = require_mfs_preload();
  var createFilesAPI = require_files();
  var KeyAPI = require_key5();
  var ObjectAPI = require_object();
  var RepoAPI = require_repo();
  var StatsAPI = require_stats();
  var IPFSBlockService = require_src34();
  var createIPLD = require_ipld2();
  var Storage = require_storage();
  var Network = require_network3();
  var Service = require_service();
  var SwarmAPI = require_swarm();
  var createGCLockAPI = require_gc_lock();
  var createPingAPI = require_ping3();
  var createDHTAPI = require_dht();
  var createPubSubAPI = require_pubsub3();
  var IPFS = class {
    constructor({print, storage, options}) {
      const {peerId, repo, keychain} = storage;
      const network = Service.create(Network);
      const preload = createPreloadAPI(options.preload);
      const blockService = new IPFSBlockService(storage.repo);
      const ipld = createIPLD({blockService, print, options: options.ipld});
      const gcLock = createGCLockAPI({
        path: repo.path,
        repoOwner: options.repoOwner
      });
      const dns = createDNSAPI();
      const isOnline = createIsOnlineAPI({network});
      const ipns = new IPNSAPI(options);
      const dagReader = DagAPI.reader({ipld, preload});
      const name = new NameAPI({
        dns,
        ipns,
        dagReader,
        peerId,
        isOnline,
        keychain,
        options
      });
      const resolve = createResolveAPI({ipld, name});
      const pinManager = new PinManagerAPI({repo, dagReader});
      const pin = new PinAPI({gcLock, pinManager, dagReader});
      const block = new BlockAPI({blockService, preload, gcLock, pinManager, pin});
      const dag = new DagAPI({ipld, preload, gcLock, pin, dagReader});
      const refs = Object.assign(createRefsAPI({ipld, resolve, preload}), {
        local: createRefsLocalAPI({repo: storage.repo})
      });
      const {add, addAll, cat, get, ls} = new RootAPI({
        gcLock,
        preload,
        pin,
        block,
        ipld,
        options: options.EXPERIMENTAL
      });
      const files = createFilesAPI({
        ipld,
        block,
        blockService,
        repo,
        preload,
        options
      });
      const mfsPreload = createMfsPreloadAPI({
        files,
        preload,
        options: options.preload
      });
      this.preload = preload;
      this.name = name;
      this.ipld = ipld;
      this.ipns = ipns;
      this.pin = pin;
      this.resolve = resolve;
      this.block = block;
      this.refs = refs;
      this.start = createStartAPI({
        network,
        peerId,
        repo,
        blockService,
        preload,
        ipns,
        mfsPreload,
        print,
        keychain,
        options
      });
      this.stop = createStopAPI({
        network,
        preload,
        mfsPreload,
        blockService,
        ipns,
        repo
      });
      this.dht = createDHTAPI({network, repo});
      this.pubsub = createPubSubAPI({network, config: options.config});
      this.dns = dns;
      this.isOnline = isOnline;
      this.id = createIDAPI({network, peerId});
      this.version = createVersionAPI({repo});
      this.bitswap = new BitswapAPI({network});
      this.bootstrap = new BootstrapAPI({repo});
      this.config = createConfigAPI({repo});
      this.ping = createPingAPI({network});
      this.add = add;
      this.addAll = addAll;
      this.cat = cat;
      this.get = get;
      this.ls = ls;
      this.dag = dag;
      this.files = files;
      this.key = new KeyAPI({keychain});
      this.object = new ObjectAPI({ipld, preload, gcLock, dag});
      this.repo = new RepoAPI({gcLock, pin, repo, refs});
      this.stats = new StatsAPI({repo, network});
      this.swarm = new SwarmAPI({network});
      Object.defineProperty(this, "libp2p", {
        get() {
          const net = network.try();
          return net ? net.libp2p : void 0;
        }
      });
    }
    async init() {
      throw new AlreadyInitializedError();
    }
    static async create(options = {}) {
      options = mergeOptions(getDefaultOptions(), options);
      const print = options.silent ? log : console.log;
      const init = {
        ...mergeOptions(initOptions(options), options),
        print
      };
      const storage = await Storage.start(init);
      const config = await storage.repo.config.getAll();
      const ipfs = new IPFS({
        storage,
        print,
        options: {...options, config}
      });
      await ipfs.preload.start();
      ipfs.ipns.startOffline(storage);
      if (storage.isNew && !init.emptyRepo) {
        const cid = await addEmptyDir(ipfs);
        log("adding default assets");
        await initAssets({addAll: ipfs.addAll, print});
        log("initializing IPNS keyspace");
        await ipfs.ipns.initializeKeyspace(storage.peerId.privKey, cid.toString());
      }
      if (options.start !== false) {
        await ipfs.start();
      }
      return ipfs;
    }
  };
  module2.exports = IPFS;
  var initOptions = ({init}) => typeof init === "object" ? init : {};
  var addEmptyDir = async (ipfs) => {
    const node = new DAGNode(new UnixFs("directory").marshal());
    const cid = await ipfs.dag.put(node, {
      version: 0,
      format: multicodec.DAG_PB,
      hashAlg: multicodec.SHA2_256,
      preload: false
    });
    await ipfs.pin.add(cid);
    return cid;
  };
  var getDefaultOptions = () => ({
    start: true,
    EXPERIMENTAL: {},
    preload: {
      enabled: !isTest,
      addresses: [
        "/dns4/node0.preload.ipfs.io/https",
        "/dns4/node1.preload.ipfs.io/https",
        "/dns4/node2.preload.ipfs.io/https",
        "/dns4/node3.preload.ipfs.io/https"
      ]
    }
  });
});

// node_modules/ipfs-core/src/index.js
var require_src54 = __commonJS((exports2, module2) => {
  "use strict";
  var globSource = require_glob_source();
  var urlSource = require_url_source();
  var PeerId = require_src9();
  var crypto2 = require_src10();
  var isIPFS = require_src13();
  var multiaddr = require_src11();
  var multibase = require_src4();
  var multicodec = require_src6();
  var multihashing = require_src14();
  var multihash = multihashing.multihash;
  var CID = require_src7();
  var {create} = require_components();
  module2.exports = {
    create,
    crypto: crypto2,
    isIPFS,
    CID,
    multiaddr,
    multibase,
    multihash,
    multihashing,
    multicodec,
    PeerId,
    globSource,
    urlSource
  };
});

// src/node-globals.js
var Buffer = require_buffer().Buffer;
var process = require_browser();
var global = typeof global !== "undefined" ? global : typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {};

// node_modules/nanoid/url-alphabet/index.js
var urlAlphabet = "ModuleSymbhasOwnPr-0123456789ABCDEFGHNRVfgctiUvz_KqYTJkLxpZXIjQW";
export default require_src54();
//# sourceMappingURL=index.js.map
